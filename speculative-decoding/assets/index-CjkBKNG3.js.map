{"version":3,"file":"index-CjkBKNG3.js","sources":["../../../../src/sequence/ui.ts","../../../../node_modules/mediabunny/dist/modules/src/misc.js","../../../../node_modules/mediabunny/dist/modules/src/metadata.js","../../../../node_modules/mediabunny/dist/modules/src/codec.js","../../../../node_modules/mediabunny/dist/modules/src/muxer.js","../../../../node_modules/mediabunny/dist/modules/src/codec-data.js","../../../../node_modules/mediabunny/dist/modules/src/custom-coder.js","../../../../node_modules/mediabunny/dist/modules/src/packet.js","../../../../node_modules/mediabunny/dist/modules/src/sample.js","../../../../node_modules/mediabunny/dist/modules/src/isobmff/isobmff-misc.js","../../../../node_modules/mediabunny/dist/modules/src/isobmff/isobmff-reader.js","../../../../node_modules/mediabunny/dist/modules/src/adts/adts-reader.js","../../../../node_modules/mediabunny/dist/modules/src/reader.js","../../../../node_modules/mediabunny/dist/modules/src/subtitles.js","../../../../node_modules/mediabunny/dist/modules/src/isobmff/isobmff-boxes.js","../../../../node_modules/mediabunny/dist/modules/src/writer.js","../../../../node_modules/mediabunny/dist/modules/src/target.js","../../../../node_modules/mediabunny/dist/modules/src/isobmff/isobmff-muxer.js","../../../../node_modules/mediabunny/dist/modules/src/output-format.js","../../../../node_modules/mediabunny/dist/modules/src/encode.js","../../../../node_modules/mediabunny/dist/modules/src/media-source.js","../../../../node_modules/mediabunny/dist/modules/src/output.js","../../../../src/recording/canvas-recording.ts","../../src/colors.ts","../../src/border.ts","../../src/probability-distribution.ts","../../src/gradient-legend.ts","../../src/index.ts"],"sourcesContent":["export interface StepContent {\r\n  title: string;\r\n  description: string;\r\n}\r\n\r\nexport interface StepUIOptions {\r\n  steps: StepContent[];\r\n  onStepChange: (step: number) => void;\r\n}\r\n\r\nexport interface StepUIElements {\r\n  btnPrev: HTMLButtonElement | null;\r\n  btnNext: HTMLButtonElement | null;\r\n  counter: HTMLElement | null;\r\n  title: HTMLElement | null;\r\n  description: HTMLElement | null;\r\n}\r\n\r\nexport function findStepElements(container: HTMLElement | string): StepUIElements {\r\n  const root = typeof container === 'string' ? document.querySelector(container) : container;\r\n  if (!root) {\r\n    return { btnPrev: null, btnNext: null, counter: null, title: null, description: null };\r\n  }\r\n\r\n  return {\r\n    btnPrev: root.querySelector('.btn-prev') as HTMLButtonElement | null,\r\n    btnNext: root.querySelector('.btn-next') as HTMLButtonElement | null,\r\n    counter: root.querySelector('.step-counter'),\r\n    title: root.querySelector('.step-title'),\r\n    description: root.querySelector('.step-description'),\r\n  };\r\n}\r\n\r\nexport interface StepUIController {\r\n  setStep: (step: number) => void;\r\n  getStep: () => number;\r\n  getMaxStep: () => number;\r\n  dispose: () => void;\r\n}\r\n\r\nexport function setupStepUI(elements: StepUIElements, options: StepUIOptions): StepUIController {\r\n  const { steps, onStepChange } = options;\r\n  const maxStep = steps.length - 1;\r\n  let currentStep = 0;\r\n\r\n  const stepInfo = elements.title?.parentElement;\r\n  if (stepInfo) {\r\n    let maxHeight = 0;\r\n    for (const step of steps) {\r\n      if (elements.title) elements.title.textContent = step.title;\r\n      if (elements.description) elements.description.innerHTML = step.description;\r\n      maxHeight = Math.max(maxHeight, stepInfo.offsetHeight);\r\n    }\r\n    stepInfo.style.minHeight = `${maxHeight}px`;\r\n  }\r\n\r\n  function updateDisplay(): void {\r\n    const { btnPrev, btnNext, counter, title, description } = elements;\r\n    const content = steps[currentStep];\r\n\r\n    if (btnPrev) btnPrev.disabled = currentStep <= 0;\r\n    if (btnNext) btnNext.disabled = currentStep >= maxStep;\r\n    if (counter) counter.textContent = `Step ${currentStep + 1} of ${steps.length}`;\r\n    if (title) title.textContent = content?.title ?? '';\r\n    if (description) description.innerHTML = content?.description ?? '';\r\n  }\r\n\r\n  function goToStep(step: number): void {\r\n    const clamped = Math.max(0, Math.min(maxStep, step));\r\n    if (clamped === currentStep) return;\r\n    currentStep = clamped;\r\n    updateDisplay();\r\n    onStepChange(currentStep);\r\n  }\r\n\r\n  const handlePrev = () => goToStep(currentStep - 1);\r\n  const handleNext = () => goToStep(currentStep + 1);\r\n  const handleKeydown = (e: KeyboardEvent) => {\r\n    if (e.key === 'ArrowLeft') goToStep(currentStep - 1);\r\n    if (e.key === 'ArrowRight') goToStep(currentStep + 1);\r\n  };\r\n\r\n  elements.btnPrev?.addEventListener('click', handlePrev);\r\n  elements.btnNext?.addEventListener('click', handleNext);\r\n  document.addEventListener('keydown', handleKeydown);\r\n\r\n  updateDisplay();\r\n\r\n  return {\r\n    setStep(step: number) {\r\n      currentStep = Math.max(0, Math.min(maxStep, step));\r\n      updateDisplay();\r\n    },\r\n    getStep: () => currentStep,\r\n    getMaxStep: () => maxStep,\r\n    dispose() {\r\n      elements.btnPrev?.removeEventListener('click', handlePrev);\r\n      elements.btnNext?.removeEventListener('click', handleNext);\r\n      document.removeEventListener('keydown', handleKeydown);\r\n    },\r\n  };\r\n}\r\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport function assert(x) {\n    if (!x) {\n        throw new Error('Assertion failed.');\n    }\n}\nexport const normalizeRotation = (rotation) => {\n    const mappedRotation = (rotation % 360 + 360) % 360;\n    if (mappedRotation === 0 || mappedRotation === 90 || mappedRotation === 180 || mappedRotation === 270) {\n        return mappedRotation;\n    }\n    else {\n        throw new Error(`Invalid rotation ${rotation}.`);\n    }\n};\nexport const last = (arr) => {\n    return arr && arr[arr.length - 1];\n};\nexport const isU32 = (value) => {\n    return value >= 0 && value < 2 ** 32;\n};\nexport class Bitstream {\n    constructor(bytes) {\n        this.bytes = bytes;\n        /** Current offset in bits. */\n        this.pos = 0;\n    }\n    seekToByte(byteOffset) {\n        this.pos = 8 * byteOffset;\n    }\n    readBit() {\n        const byteIndex = Math.floor(this.pos / 8);\n        const byte = this.bytes[byteIndex] ?? 0;\n        const bitIndex = 0b111 - (this.pos & 0b111);\n        const bit = (byte & (1 << bitIndex)) >> bitIndex;\n        this.pos++;\n        return bit;\n    }\n    readBits(n) {\n        if (n === 1) {\n            return this.readBit();\n        }\n        let result = 0;\n        for (let i = 0; i < n; i++) {\n            result <<= 1;\n            result |= this.readBit();\n        }\n        return result;\n    }\n    writeBits(n, value) {\n        const end = this.pos + n;\n        for (let i = this.pos; i < end; i++) {\n            const byteIndex = Math.floor(i / 8);\n            let byte = this.bytes[byteIndex];\n            const bitIndex = 0b111 - (i & 0b111);\n            byte &= ~(1 << bitIndex);\n            byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n            this.bytes[byteIndex] = byte;\n        }\n        this.pos = end;\n    }\n    ;\n    readAlignedByte() {\n        // Ensure we're byte-aligned\n        if (this.pos % 8 !== 0) {\n            throw new Error('Bitstream is not byte-aligned.');\n        }\n        const byteIndex = this.pos / 8;\n        const byte = this.bytes[byteIndex] ?? 0;\n        this.pos += 8;\n        return byte;\n    }\n    skipBits(n) {\n        this.pos += n;\n    }\n    getBitsLeft() {\n        return this.bytes.length * 8 - this.pos;\n    }\n    clone() {\n        const clone = new Bitstream(this.bytes);\n        clone.pos = this.pos;\n        return clone;\n    }\n}\n/** Reads an exponential-Golomb universal code from a Bitstream.  */\nexport const readExpGolomb = (bitstream) => {\n    let leadingZeroBits = 0;\n    while (bitstream.readBits(1) === 0 && leadingZeroBits < 32) {\n        leadingZeroBits++;\n    }\n    if (leadingZeroBits >= 32) {\n        throw new Error('Invalid exponential-Golomb code.');\n    }\n    const result = (1 << leadingZeroBits) - 1 + bitstream.readBits(leadingZeroBits);\n    return result;\n};\n/** Reads a signed exponential-Golomb universal code from a Bitstream. */\nexport const readSignedExpGolomb = (bitstream) => {\n    const codeNum = readExpGolomb(bitstream);\n    return ((codeNum & 1) === 0)\n        ? -(codeNum >> 1)\n        : ((codeNum + 1) >> 1);\n};\nexport const writeBits = (bytes, start, end, value) => {\n    for (let i = start; i < end; i++) {\n        const byteIndex = Math.floor(i / 8);\n        let byte = bytes[byteIndex];\n        const bitIndex = 0b111 - (i & 0b111);\n        byte &= ~(1 << bitIndex);\n        byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n        bytes[byteIndex] = byte;\n    }\n};\nexport const toUint8Array = (source) => {\n    if (source.constructor === Uint8Array) { // We want a true Uint8Array, not something that extends it like Buffer\n        return source;\n    }\n    else if (ArrayBuffer.isView(source)) {\n        return new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    }\n    else {\n        return new Uint8Array(source);\n    }\n};\nexport const toDataView = (source) => {\n    if (source.constructor === DataView) {\n        return source;\n    }\n    else if (ArrayBuffer.isView(source)) {\n        return new DataView(source.buffer, source.byteOffset, source.byteLength);\n    }\n    else {\n        return new DataView(source);\n    }\n};\nexport const textDecoder = /* #__PURE__ */ new TextDecoder();\nexport const textEncoder = /* #__PURE__ */ new TextEncoder();\nexport const isIso88591Compatible = (text) => {\n    for (let i = 0; i < text.length; i++) {\n        const code = text.charCodeAt(i);\n        if (code > 255) {\n            return false;\n        }\n    }\n    return true;\n};\nconst invertObject = (object) => {\n    return Object.fromEntries(Object.entries(object).map(([key, value]) => [value, key]));\n};\n// For the color space mappings, see Rec. ITU-T H.273.\nexport const COLOR_PRIMARIES_MAP = {\n    bt709: 1, // ITU-R BT.709\n    bt470bg: 5, // ITU-R BT.470BG\n    smpte170m: 6, // ITU-R BT.601 525 - SMPTE 170M\n    bt2020: 9, // ITU-R BT.202\n    smpte432: 12, // SMPTE EG 432-1\n};\nexport const COLOR_PRIMARIES_MAP_INVERSE = /* #__PURE__ */ invertObject(COLOR_PRIMARIES_MAP);\nexport const TRANSFER_CHARACTERISTICS_MAP = {\n    'bt709': 1, // ITU-R BT.709\n    'smpte170m': 6, // SMPTE 170M\n    'linear': 8, // Linear transfer characteristics\n    'iec61966-2-1': 13, // IEC 61966-2-1\n    'pq': 16, // Rec. ITU-R BT.2100-2 perceptual quantization (PQ) system\n    'hlg': 18, // Rec. ITU-R BT.2100-2 hybrid loggamma (HLG) system\n};\nexport const TRANSFER_CHARACTERISTICS_MAP_INVERSE = /* #__PURE__ */ invertObject(TRANSFER_CHARACTERISTICS_MAP);\nexport const MATRIX_COEFFICIENTS_MAP = {\n    'rgb': 0, // Identity\n    'bt709': 1, // ITU-R BT.709\n    'bt470bg': 5, // ITU-R BT.470BG\n    'smpte170m': 6, // SMPTE 170M\n    'bt2020-ncl': 9, // ITU-R BT.2020-2 (non-constant luminance)\n};\nexport const MATRIX_COEFFICIENTS_MAP_INVERSE = /* #__PURE__ */ invertObject(MATRIX_COEFFICIENTS_MAP);\nexport const colorSpaceIsComplete = (colorSpace) => {\n    return (!!colorSpace\n        && !!colorSpace.primaries\n        && !!colorSpace.transfer\n        && !!colorSpace.matrix\n        && colorSpace.fullRange !== undefined);\n};\nexport const isAllowSharedBufferSource = (x) => {\n    return (x instanceof ArrayBuffer\n        || (typeof SharedArrayBuffer !== 'undefined' && x instanceof SharedArrayBuffer)\n        || ArrayBuffer.isView(x));\n};\nexport class AsyncMutex {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n        this.pending = 0;\n    }\n    async acquire() {\n        let resolver;\n        const nextPromise = new Promise((resolve) => {\n            let resolved = false;\n            resolver = () => {\n                if (resolved) {\n                    return;\n                }\n                resolve();\n                this.pending--;\n                resolved = true;\n            };\n        });\n        const currentPromiseAlias = this.currentPromise;\n        this.currentPromise = nextPromise;\n        this.pending++;\n        await currentPromiseAlias;\n        return resolver;\n    }\n}\nexport const bytesToHexString = (bytes) => {\n    return [...bytes].map(x => x.toString(16).padStart(2, '0')).join('');\n};\nexport const reverseBitsU32 = (x) => {\n    x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n    x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);\n    x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);\n    x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);\n    return x >>> 0; // Ensure it's treated as an unsigned 32-bit integer\n};\n/** Returns the smallest index i such that val[i] === key, or -1 if no such index exists. */\nexport const binarySearchExact = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + high) >> 1;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal === key) {\n            ans = mid;\n            high = mid - 1; // Continue searching left to find the lowest index\n        }\n        else if (midVal < key) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Returns the largest index i such that val[i] <= key, or -1 if no such index exists. */\nexport const binarySearchLessOrEqual = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + (high - low + 1) / 2) | 0;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal <= key) {\n            ans = mid;\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Assumes the array is already sorted. */\nexport const insertSorted = (arr, item, valueGetter) => {\n    const insertionIndex = binarySearchLessOrEqual(arr, valueGetter(item), valueGetter);\n    arr.splice(insertionIndex + 1, 0, item); // This even behaves correctly for the -1 case\n};\nexport const promiseWithResolvers = () => {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve: resolve, reject: reject };\n};\nexport const removeItem = (arr, item) => {\n    const index = arr.indexOf(item);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n};\nexport const findLast = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return arr[i];\n        }\n    }\n    return undefined;\n};\nexport const findLastIndex = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n};\nexport const toAsyncIterator = async function* (source) {\n    if (Symbol.iterator in source) {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.iterator]();\n    }\n    else {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.asyncIterator]();\n    }\n};\nexport const validateAnyIterable = (iterable) => {\n    if (!(Symbol.iterator in iterable) && !(Symbol.asyncIterator in iterable)) {\n        throw new TypeError('Argument must be an iterable or async iterable.');\n    }\n};\nexport const assertNever = (x) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new Error(`Unexpected value: ${x}`);\n};\nexport const getUint24 = (view, byteOffset, littleEndian) => {\n    const byte1 = view.getUint8(byteOffset);\n    const byte2 = view.getUint8(byteOffset + 1);\n    const byte3 = view.getUint8(byteOffset + 2);\n    if (littleEndian) {\n        return byte1 | (byte2 << 8) | (byte3 << 16);\n    }\n    else {\n        return (byte1 << 16) | (byte2 << 8) | byte3;\n    }\n};\nexport const getInt24 = (view, byteOffset, littleEndian) => {\n    // The left shift pushes the most significant bit into the sign bit region, and the subsequent right shift\n    // then correctly interprets the sign bit.\n    return getUint24(view, byteOffset, littleEndian) << 8 >> 8;\n};\nexport const setUint24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit unsigned range (0 to 16777215)\n    value = value >>> 0; // Convert to unsigned 32-bit\n    value = value & 0xFFFFFF; // Mask to 24 bits\n    if (littleEndian) {\n        view.setUint8(byteOffset, value & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, (value >>> 16) & 0xFF);\n    }\n    else {\n        view.setUint8(byteOffset, (value >>> 16) & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, value & 0xFF);\n    }\n};\nexport const setInt24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit signed range (-8388608 to 8388607)\n    value = clamp(value, -8388608, 8388607);\n    // Convert negative values to their 24-bit representation\n    if (value < 0) {\n        value = (value + 0x1000000) & 0xFFFFFF;\n    }\n    setUint24(view, byteOffset, value, littleEndian);\n};\nexport const setInt64 = (view, byteOffset, value, littleEndian) => {\n    if (littleEndian) {\n        view.setUint32(byteOffset + 0, value, true);\n        view.setInt32(byteOffset + 4, Math.floor(value / 2 ** 32), true);\n    }\n    else {\n        view.setInt32(byteOffset + 0, Math.floor(value / 2 ** 32), true);\n        view.setUint32(byteOffset + 4, value, true);\n    }\n};\n/**\n * Calls a function on each value spat out by an async generator. The reason for writing this manually instead of\n * using a generator function is that the generator function queues return() calls - here, we forward them immediately.\n */\nexport const mapAsyncGenerator = (generator, map) => {\n    return {\n        async next() {\n            const result = await generator.next();\n            if (result.done) {\n                return { value: undefined, done: true };\n            }\n            else {\n                return { value: map(result.value), done: false };\n            }\n        },\n        return() {\n            return generator.return();\n        },\n        throw(error) {\n            return generator.throw(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n};\nexport const clamp = (value, min, max) => {\n    return Math.max(min, Math.min(max, value));\n};\nexport const UNDETERMINED_LANGUAGE = 'und';\nexport const roundIfAlmostInteger = (value) => {\n    const rounded = Math.round(value);\n    if (Math.abs(value / rounded - 1) < 10 * Number.EPSILON) {\n        return rounded;\n    }\n    else {\n        return value;\n    }\n};\nexport const roundToMultiple = (value, multiple) => {\n    return Math.round(value / multiple) * multiple;\n};\nexport const ilog = (x) => {\n    let ret = 0;\n    while (x) {\n        ret++;\n        x >>= 1;\n    }\n    return ret;\n};\nconst ISO_639_2_REGEX = /^[a-z]{3}$/;\nexport const isIso639Dash2LanguageCode = (x) => {\n    return ISO_639_2_REGEX.test(x);\n};\n// Since the result will be truncated, add a bit of eps to compensate for floating point errors\nexport const SECOND_TO_MICROSECOND_FACTOR = 1e6 * (1 + Number.EPSILON);\n/**\n * Merges two RequestInit objects with special handling for headers.\n * Headers are merged case-insensitively, but original casing is preserved.\n * init2 headers take precedence and will override case-insensitive matches from init1.\n */\nexport const mergeRequestInit = (init1, init2) => {\n    const merged = { ...init1, ...init2 };\n    // Special handling for headers\n    if (init1.headers || init2.headers) {\n        const headers1 = init1.headers ? normalizeHeaders(init1.headers) : {};\n        const headers2 = init2.headers ? normalizeHeaders(init2.headers) : {};\n        const mergedHeaders = { ...headers1 };\n        // For each header in headers2, check if a case-insensitive match exists in mergedHeaders\n        Object.entries(headers2).forEach(([key2, value2]) => {\n            const existingKey = Object.keys(mergedHeaders).find(key1 => key1.toLowerCase() === key2.toLowerCase());\n            if (existingKey) {\n                delete mergedHeaders[existingKey];\n            }\n            mergedHeaders[key2] = value2;\n        });\n        merged.headers = mergedHeaders;\n    }\n    return merged;\n};\n/** Normalizes HeadersInit to a Record<string, string> format. */\nconst normalizeHeaders = (headers) => {\n    if (headers instanceof Headers) {\n        const result = {};\n        headers.forEach((value, key) => {\n            result[key] = value;\n        });\n        return result;\n    }\n    if (Array.isArray(headers)) {\n        const result = {};\n        headers.forEach(([key, value]) => {\n            result[key] = value;\n        });\n        return result;\n    }\n    return headers;\n};\nexport const retriedFetch = async (fetchFn, url, requestInit, getRetryDelay, shouldStop) => {\n    let attempts = 0;\n    while (true) {\n        try {\n            return await fetchFn(url, requestInit);\n        }\n        catch (error) {\n            if (shouldStop()) {\n                throw error;\n            }\n            attempts++;\n            const retryDelayInSeconds = getRetryDelay(attempts, error, url);\n            if (retryDelayInSeconds === null) {\n                throw error;\n            }\n            console.error('Retrying failed fetch. Error:', error);\n            if (!Number.isFinite(retryDelayInSeconds) || retryDelayInSeconds < 0) {\n                throw new TypeError('Retry delay must be a non-negative finite number.');\n            }\n            if (retryDelayInSeconds > 0) {\n                await new Promise(resolve => setTimeout(resolve, 1000 * retryDelayInSeconds));\n            }\n            if (shouldStop()) {\n                throw error;\n            }\n        }\n    }\n};\nexport const computeRationalApproximation = (x, maxDenominator) => {\n    // Handle negative numbers\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let prevNumerator = 0, prevDenominator = 1;\n    let currNumerator = 1, currDenominator = 0;\n    // Continued fraction algorithm\n    let remainder = x;\n    while (true) {\n        const integer = Math.floor(remainder);\n        // Calculate next convergent\n        const nextNumerator = integer * currNumerator + prevNumerator;\n        const nextDenominator = integer * currDenominator + prevDenominator;\n        if (nextDenominator > maxDenominator) {\n            return {\n                numerator: sign * currNumerator,\n                denominator: currDenominator,\n            };\n        }\n        prevNumerator = currNumerator;\n        prevDenominator = currDenominator;\n        currNumerator = nextNumerator;\n        currDenominator = nextDenominator;\n        remainder = 1 / (remainder - integer);\n        // Guard against precision issues\n        if (!isFinite(remainder)) {\n            break;\n        }\n    }\n    return {\n        numerator: sign * currNumerator,\n        denominator: currDenominator,\n    };\n};\nexport class CallSerializer {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n    }\n    call(fn) {\n        return this.currentPromise = this.currentPromise.then(fn);\n    }\n}\nlet isWebKitCache = null;\nexport const isWebKit = () => {\n    if (isWebKitCache !== null) {\n        return isWebKitCache;\n    }\n    // This even returns true for WebKit-wrapping browsers such as Chrome on iOS\n    return isWebKitCache = !!(typeof navigator !== 'undefined'\n        && (navigator.vendor?.match(/apple/i)\n            // Or, in workers:\n            || (/AppleWebKit/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent))\n            || /\\b(iPad|iPhone|iPod)\\b/.test(navigator.userAgent)));\n};\nlet isFirefoxCache = null;\nexport const isFirefox = () => {\n    if (isFirefoxCache !== null) {\n        return isFirefoxCache;\n    }\n    return isFirefoxCache = typeof navigator !== 'undefined' && navigator.userAgent?.includes('Firefox');\n};\nlet isChromiumCache = null;\nexport const isChromium = () => {\n    if (isChromiumCache !== null) {\n        return isChromiumCache;\n    }\n    return isChromiumCache = !!(typeof navigator !== 'undefined'\n        && (navigator.vendor?.includes('Google Inc') || /Chrome/.test(navigator.userAgent)));\n};\nlet chromiumVersionCache = null;\nexport const getChromiumVersion = () => {\n    if (chromiumVersionCache !== null) {\n        return chromiumVersionCache;\n    }\n    if (typeof navigator === 'undefined') {\n        return null;\n    }\n    const match = /\\bChrome\\/(\\d+)/.exec(navigator.userAgent);\n    if (!match) {\n        return null;\n    }\n    return chromiumVersionCache = Number(match[1]);\n};\n/** Acts like `??` except the condition is -1 and not null/undefined. */\nexport const coalesceIndex = (a, b) => {\n    return a !== -1 ? a : b;\n};\nexport const closedIntervalsOverlap = (startA, endA, startB, endB) => {\n    return startA <= endB && startB <= endA;\n};\nexport const keyValueIterator = function* (object) {\n    for (const key in object) {\n        const value = object[key];\n        if (value === undefined) {\n            continue;\n        }\n        yield { key, value };\n    }\n};\nexport const imageMimeTypeToExtension = (mimeType) => {\n    switch (mimeType.toLowerCase()) {\n        case 'image/jpeg':\n        case 'image/jpg':\n            return '.jpg';\n        case 'image/png':\n            return '.png';\n        case 'image/gif':\n            return '.gif';\n        case 'image/webp':\n            return '.webp';\n        case 'image/bmp':\n            return '.bmp';\n        case 'image/svg+xml':\n            return '.svg';\n        case 'image/tiff':\n            return '.tiff';\n        case 'image/avif':\n            return '.avif';\n        case 'image/x-icon':\n        case 'image/vnd.microsoft.icon':\n            return '.ico';\n        default:\n            return null;\n    }\n};\nexport const base64ToBytes = (base64) => {\n    const decoded = atob(base64);\n    const bytes = new Uint8Array(decoded.length);\n    for (let i = 0; i < decoded.length; i++) {\n        bytes[i] = decoded.charCodeAt(i);\n    }\n    return bytes;\n};\nexport const bytesToBase64 = (bytes) => {\n    let string = '';\n    for (let i = 0; i < bytes.length; i++) {\n        string += String.fromCharCode(bytes[i]);\n    }\n    return btoa(string);\n};\nexport const uint8ArraysAreEqual = (a, b) => {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n};\nexport const polyfillSymbolDispose = () => {\n    // https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html\n    // @ts-expect-error Readonly\n    Symbol.dispose ??= Symbol('Symbol.dispose');\n};\nexport const isNumber = (x) => {\n    return typeof x === 'number' && !Number.isNaN(x);\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Image data with additional metadata.\n *\n * @group Metadata tags\n * @public\n */\nexport class RichImageData {\n    /** Creates a new {@link RichImageData}. */\n    constructor(\n    /** The raw image data. */\n    data, \n    /** An RFC 6838 MIME type (e.g. image/jpeg, image/png, etc.) */\n    mimeType) {\n        this.data = data;\n        this.mimeType = mimeType;\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (typeof mimeType !== 'string') {\n            throw new TypeError('mimeType must be a string.');\n        }\n    }\n}\n/**\n * A file attached to a media file.\n *\n * @group Metadata tags\n * @public\n */\nexport class AttachedFile {\n    /** Creates a new {@link AttachedFile}. */\n    constructor(\n    /** The raw file data. */\n    data, \n    /** An RFC 6838 MIME type (e.g. image/jpeg, image/png, font/ttf, etc.) */\n    mimeType, \n    /** The name of the file. */\n    name, \n    /** A description of the file. */\n    description) {\n        this.data = data;\n        this.mimeType = mimeType;\n        this.name = name;\n        this.description = description;\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (mimeType !== undefined && typeof mimeType !== 'string') {\n            throw new TypeError('mimeType, when provided, must be a string.');\n        }\n        if (name !== undefined && typeof name !== 'string') {\n            throw new TypeError('name, when provided, must be a string.');\n        }\n        if (description !== undefined && typeof description !== 'string') {\n            throw new TypeError('description, when provided, must be a string.');\n        }\n    }\n}\n;\nexport const validateMetadataTags = (tags) => {\n    if (!tags || typeof tags !== 'object') {\n        throw new TypeError('tags must be an object.');\n    }\n    if (tags.title !== undefined && typeof tags.title !== 'string') {\n        throw new TypeError('tags.title, when provided, must be a string.');\n    }\n    if (tags.description !== undefined && typeof tags.description !== 'string') {\n        throw new TypeError('tags.description, when provided, must be a string.');\n    }\n    if (tags.artist !== undefined && typeof tags.artist !== 'string') {\n        throw new TypeError('tags.artist, when provided, must be a string.');\n    }\n    if (tags.album !== undefined && typeof tags.album !== 'string') {\n        throw new TypeError('tags.album, when provided, must be a string.');\n    }\n    if (tags.albumArtist !== undefined && typeof tags.albumArtist !== 'string') {\n        throw new TypeError('tags.albumArtist, when provided, must be a string.');\n    }\n    if (tags.trackNumber !== undefined && (!Number.isInteger(tags.trackNumber) || tags.trackNumber <= 0)) {\n        throw new TypeError('tags.trackNumber, when provided, must be a positive integer.');\n    }\n    if (tags.tracksTotal !== undefined\n        && (!Number.isInteger(tags.tracksTotal) || tags.tracksTotal <= 0)) {\n        throw new TypeError('tags.tracksTotal, when provided, must be a positive integer.');\n    }\n    if (tags.discNumber !== undefined && (!Number.isInteger(tags.discNumber) || tags.discNumber <= 0)) {\n        throw new TypeError('tags.discNumber, when provided, must be a positive integer.');\n    }\n    if (tags.discsTotal !== undefined\n        && (!Number.isInteger(tags.discsTotal) || tags.discsTotal <= 0)) {\n        throw new TypeError('tags.discsTotal, when provided, must be a positive integer.');\n    }\n    if (tags.genre !== undefined && typeof tags.genre !== 'string') {\n        throw new TypeError('tags.genre, when provided, must be a string.');\n    }\n    if (tags.date !== undefined && (!(tags.date instanceof Date) || Number.isNaN(tags.date.getTime()))) {\n        throw new TypeError('tags.date, when provided, must be a valid Date.');\n    }\n    if (tags.lyrics !== undefined && typeof tags.lyrics !== 'string') {\n        throw new TypeError('tags.lyrics, when provided, must be a string.');\n    }\n    if (tags.images !== undefined) {\n        if (!Array.isArray(tags.images)) {\n            throw new TypeError('tags.images, when provided, must be an array.');\n        }\n        for (const image of tags.images) {\n            if (!image || typeof image !== 'object') {\n                throw new TypeError('Each image in tags.images must be an object.');\n            }\n            if (!(image.data instanceof Uint8Array)) {\n                throw new TypeError('Each image.data must be a Uint8Array.');\n            }\n            if (typeof image.mimeType !== 'string') {\n                throw new TypeError('Each image.mimeType must be a string.');\n            }\n            if (!['coverFront', 'coverBack', 'unknown'].includes(image.kind)) {\n                throw new TypeError('Each image.kind must be \\'coverFront\\', \\'coverBack\\', or \\'unknown\\'.');\n            }\n        }\n    }\n    if (tags.comment !== undefined && typeof tags.comment !== 'string') {\n        throw new TypeError('tags.comment, when provided, must be a string.');\n    }\n    if (tags.raw !== undefined) {\n        if (!tags.raw || typeof tags.raw !== 'object') {\n            throw new TypeError('tags.raw, when provided, must be an object.');\n        }\n        for (const value of Object.values(tags.raw)) {\n            if (value !== null\n                && typeof value !== 'string'\n                && !(value instanceof Uint8Array)\n                && !(value instanceof RichImageData)\n                && !(value instanceof AttachedFile)) {\n                throw new TypeError('Each value in tags.raw must be a string, Uint8Array, RichImageData, AttachedFile, or null.');\n            }\n        }\n    }\n};\nexport const metadataTagsAreEmpty = (tags) => {\n    return tags.title === undefined\n        && tags.description === undefined\n        && tags.artist === undefined\n        && tags.album === undefined\n        && tags.albumArtist === undefined\n        && tags.trackNumber === undefined\n        && tags.tracksTotal === undefined\n        && tags.discNumber === undefined\n        && tags.discsTotal === undefined\n        && tags.genre === undefined\n        && tags.date === undefined\n        && tags.lyrics === undefined\n        && (!tags.images || tags.images.length === 0)\n        && tags.comment === undefined\n        && (tags.raw === undefined || Object.keys(tags.raw).length === 0);\n};\nexport const DEFAULT_TRACK_DISPOSITION = {\n    default: true,\n    forced: false,\n    original: false,\n    commentary: false,\n    hearingImpaired: false,\n    visuallyImpaired: false,\n};\nexport const validateTrackDisposition = (disposition) => {\n    if (!disposition || typeof disposition !== 'object') {\n        throw new TypeError('disposition must be an object.');\n    }\n    if (disposition.default !== undefined && typeof disposition.default !== 'boolean') {\n        throw new TypeError('disposition.default must be a boolean.');\n    }\n    if (disposition.forced !== undefined && typeof disposition.forced !== 'boolean') {\n        throw new TypeError('disposition.forced must be a boolean.');\n    }\n    if (disposition.original !== undefined && typeof disposition.original !== 'boolean') {\n        throw new TypeError('disposition.original must be a boolean.');\n    }\n    if (disposition.commentary !== undefined && typeof disposition.commentary !== 'boolean') {\n        throw new TypeError('disposition.commentary must be a boolean.');\n    }\n    if (disposition.hearingImpaired !== undefined && typeof disposition.hearingImpaired !== 'boolean') {\n        throw new TypeError('disposition.hearingImpaired must be a boolean.');\n    }\n    if (disposition.visuallyImpaired !== undefined && typeof disposition.visuallyImpaired !== 'boolean') {\n        throw new TypeError('disposition.visuallyImpaired must be a boolean.');\n    }\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream, COLOR_PRIMARIES_MAP, MATRIX_COEFFICIENTS_MAP, TRANSFER_CHARACTERISTICS_MAP, assert, bytesToHexString, isAllowSharedBufferSource, last, reverseBitsU32, toDataView, } from './misc.js';\n/**\n * List of known video codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const VIDEO_CODECS = [\n    'avc',\n    'hevc',\n    'vp9',\n    'av1',\n    'vp8',\n];\n/**\n * List of known PCM (uncompressed) audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const PCM_AUDIO_CODECS = [\n    'pcm-s16', // We don't prefix 'le' so we're compatible with the WebCodecs-registered PCM codec strings\n    'pcm-s16be',\n    'pcm-s24',\n    'pcm-s24be',\n    'pcm-s32',\n    'pcm-s32be',\n    'pcm-f32',\n    'pcm-f32be',\n    'pcm-f64',\n    'pcm-f64be',\n    'pcm-u8',\n    'pcm-s8',\n    'ulaw',\n    'alaw',\n];\n/**\n * List of known compressed audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const NON_PCM_AUDIO_CODECS = [\n    'aac',\n    'opus',\n    'mp3',\n    'vorbis',\n    'flac',\n];\n/**\n * List of known audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const AUDIO_CODECS = [\n    ...NON_PCM_AUDIO_CODECS,\n    ...PCM_AUDIO_CODECS,\n];\n/**\n * List of known subtitle codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const SUBTITLE_CODECS = [\n    'webvtt',\n]; // TODO add the rest\n// https://en.wikipedia.org/wiki/Advanced_Video_Coding\nexport const AVC_LEVEL_TABLE = [\n    { maxMacroblocks: 99, maxBitrate: 64000, maxDpbMbs: 396, level: 0x0A }, // Level 1\n    { maxMacroblocks: 396, maxBitrate: 192000, maxDpbMbs: 900, level: 0x0B }, // Level 1.1\n    { maxMacroblocks: 396, maxBitrate: 384000, maxDpbMbs: 2376, level: 0x0C }, // Level 1.2\n    { maxMacroblocks: 396, maxBitrate: 768000, maxDpbMbs: 2376, level: 0x0D }, // Level 1.3\n    { maxMacroblocks: 396, maxBitrate: 2000000, maxDpbMbs: 2376, level: 0x14 }, // Level 2\n    { maxMacroblocks: 792, maxBitrate: 4000000, maxDpbMbs: 4752, level: 0x15 }, // Level 2.1\n    { maxMacroblocks: 1620, maxBitrate: 4000000, maxDpbMbs: 8100, level: 0x16 }, // Level 2.2\n    { maxMacroblocks: 1620, maxBitrate: 10000000, maxDpbMbs: 8100, level: 0x1E }, // Level 3\n    { maxMacroblocks: 3600, maxBitrate: 14000000, maxDpbMbs: 18000, level: 0x1F }, // Level 3.1\n    { maxMacroblocks: 5120, maxBitrate: 20000000, maxDpbMbs: 20480, level: 0x20 }, // Level 3.2\n    { maxMacroblocks: 8192, maxBitrate: 20000000, maxDpbMbs: 32768, level: 0x28 }, // Level 4\n    { maxMacroblocks: 8192, maxBitrate: 50000000, maxDpbMbs: 32768, level: 0x29 }, // Level 4.1\n    { maxMacroblocks: 8704, maxBitrate: 50000000, maxDpbMbs: 34816, level: 0x2A }, // Level 4.2\n    { maxMacroblocks: 22080, maxBitrate: 135000000, maxDpbMbs: 110400, level: 0x32 }, // Level 5\n    { maxMacroblocks: 36864, maxBitrate: 240000000, maxDpbMbs: 184320, level: 0x33 }, // Level 5.1\n    { maxMacroblocks: 36864, maxBitrate: 240000000, maxDpbMbs: 184320, level: 0x34 }, // Level 5.2\n    { maxMacroblocks: 139264, maxBitrate: 240000000, maxDpbMbs: 696320, level: 0x3C }, // Level 6\n    { maxMacroblocks: 139264, maxBitrate: 480000000, maxDpbMbs: 696320, level: 0x3D }, // Level 6.1\n    { maxMacroblocks: 139264, maxBitrate: 800000000, maxDpbMbs: 696320, level: 0x3E }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding\nconst HEVC_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 128000, tier: 'L', level: 30 }, // Level 1 (Low Tier)\n    { maxPictureSize: 122880, maxBitrate: 1500000, tier: 'L', level: 60 }, // Level 2 (Low Tier)\n    { maxPictureSize: 245760, maxBitrate: 3000000, tier: 'L', level: 63 }, // Level 2.1 (Low Tier)\n    { maxPictureSize: 552960, maxBitrate: 6000000, tier: 'L', level: 90 }, // Level 3 (Low Tier)\n    { maxPictureSize: 983040, maxBitrate: 10000000, tier: 'L', level: 93 }, // Level 3.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 12000000, tier: 'L', level: 120 }, // Level 4 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 30000000, tier: 'H', level: 120 }, // Level 4 (High Tier)\n    { maxPictureSize: 2228224, maxBitrate: 20000000, tier: 'L', level: 123 }, // Level 4.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 50000000, tier: 'H', level: 123 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 25000000, tier: 'L', level: 150 }, // Level 5 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 150 }, // Level 5 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'L', level: 153 }, // Level 5.1 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 153 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'L', level: 156 }, // Level 5.2 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 156 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'L', level: 180 }, // Level 6 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 180 }, // Level 6 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 120000000, tier: 'L', level: 183 }, // Level 6.1 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 183 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'L', level: 186 }, // Level 6.2 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 186 }, // Level 6.2 (High Tier)\n];\n// https://en.wikipedia.org/wiki/VP9\nexport const VP9_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 200000, level: 10 }, // Level 1\n    { maxPictureSize: 73728, maxBitrate: 800000, level: 11 }, // Level 1.1\n    { maxPictureSize: 122880, maxBitrate: 1800000, level: 20 }, // Level 2\n    { maxPictureSize: 245760, maxBitrate: 3600000, level: 21 }, // Level 2.1\n    { maxPictureSize: 552960, maxBitrate: 7200000, level: 30 }, // Level 3\n    { maxPictureSize: 983040, maxBitrate: 12000000, level: 31 }, // Level 3.1\n    { maxPictureSize: 2228224, maxBitrate: 18000000, level: 40 }, // Level 4\n    { maxPictureSize: 2228224, maxBitrate: 30000000, level: 41 }, // Level 4.1\n    { maxPictureSize: 8912896, maxBitrate: 60000000, level: 50 }, // Level 5\n    { maxPictureSize: 8912896, maxBitrate: 120000000, level: 51 }, // Level 5.1\n    { maxPictureSize: 8912896, maxBitrate: 180000000, level: 52 }, // Level 5.2\n    { maxPictureSize: 35651584, maxBitrate: 180000000, level: 60 }, // Level 6\n    { maxPictureSize: 35651584, maxBitrate: 240000000, level: 61 }, // Level 6.1\n    { maxPictureSize: 35651584, maxBitrate: 480000000, level: 62 }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/AV1\nconst AV1_LEVEL_TABLE = [\n    { maxPictureSize: 147456, maxBitrate: 1500000, tier: 'M', level: 0 }, // Level 2.0 (Main Tier)\n    { maxPictureSize: 278784, maxBitrate: 3000000, tier: 'M', level: 1 }, // Level 2.1 (Main Tier)\n    { maxPictureSize: 665856, maxBitrate: 6000000, tier: 'M', level: 4 }, // Level 3.0 (Main Tier)\n    { maxPictureSize: 1065024, maxBitrate: 10000000, tier: 'M', level: 5 }, // Level 3.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 12000000, tier: 'M', level: 8 }, // Level 4.0 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 30000000, tier: 'H', level: 8 }, // Level 4.0 (High Tier)\n    { maxPictureSize: 2359296, maxBitrate: 20000000, tier: 'M', level: 9 }, // Level 4.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 50000000, tier: 'H', level: 9 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 30000000, tier: 'M', level: 12 }, // Level 5.0 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 12 }, // Level 5.0 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'M', level: 13 }, // Level 5.1 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 13 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'M', level: 14 }, // Level 5.2 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 14 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 15 }, // Level 5.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 15 }, // Level 5.3 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 16 }, // Level 6.0 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 16 }, // Level 6.0 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 100000000, tier: 'M', level: 17 }, // Level 6.1 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 17 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 18 }, // Level 6.2 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 18 }, // Level 6.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 19 }, // Level 6.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 19 }, // Level 6.3 (High Tier)\n];\nconst VP9_DEFAULT_SUFFIX = '.01.01.01.01.00';\nconst AV1_DEFAULT_SUFFIX = '.0.110.01.01.01.0';\nexport const buildVideoCodecString = (codec, width, height, bitrate) => {\n    if (codec === 'avc') {\n        const profileIndication = 0x64; // High Profile\n        const totalMacroblocks = Math.ceil(width / 16) * Math.ceil(height / 16);\n        // Determine the level based on the table\n        const levelInfo = AVC_LEVEL_TABLE.find(level => totalMacroblocks <= level.maxMacroblocks && bitrate <= level.maxBitrate) ?? last(AVC_LEVEL_TABLE);\n        const levelIndication = levelInfo ? levelInfo.level : 0;\n        const hexProfileIndication = profileIndication.toString(16).padStart(2, '0');\n        const hexProfileCompatibility = '00';\n        const hexLevelIndication = levelIndication.toString(16).padStart(2, '0');\n        return `avc1.${hexProfileIndication}${hexProfileCompatibility}${hexLevelIndication}`;\n    }\n    else if (codec === 'hevc') {\n        const profilePrefix = ''; // Profile space 0\n        const profileIdc = 1; // Main Profile\n        const compatibilityFlags = '6'; // Taken from the example in ISO 14496-15\n        const pictureSize = width * height;\n        const levelInfo = HEVC_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(HEVC_LEVEL_TABLE);\n        const constraintFlags = 'B0'; // Progressive source flag\n        return 'hev1.'\n            + `${profilePrefix}${profileIdc}.`\n            + `${compatibilityFlags}.`\n            + `${levelInfo.tier}${levelInfo.level}.`\n            + `${constraintFlags}`;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        const profile = '00'; // Profile 0\n        const pictureSize = width * height;\n        const levelInfo = VP9_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(VP9_LEVEL_TABLE);\n        const bitDepth = '08'; // 8-bit\n        return `vp09.${profile}.${levelInfo.level.toString().padStart(2, '0')}.${bitDepth}`;\n    }\n    else if (codec === 'av1') {\n        const profile = 0; // Main Profile, single digit\n        const pictureSize = width * height;\n        const levelInfo = AV1_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(AV1_LEVEL_TABLE);\n        const level = levelInfo.level.toString().padStart(2, '0');\n        const bitDepth = '08'; // 8-bit\n        return `av01.${profile}.${level}${levelInfo.tier}.${bitDepth}`;\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const generateVp9CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://www.webmproject.org/docs/container/#vp9-codec-feature-metadata-codecprivate\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1;\n    return [\n        1, 1, profile,\n        2, 1, level,\n        3, 1, bitDepth,\n        4, 1, chromaSubsampling,\n    ];\n};\nexport const generateAv1CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://aomediacodec.github.io/av1-isobmff/\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const marker = 1;\n    const version = 1;\n    const firstByte = (marker << 7) + version;\n    const profile = Number(parts[1]);\n    const levelAndTier = parts[2];\n    const level = Number(levelAndTier.slice(0, -1));\n    const secondByte = (profile << 5) + level;\n    const tier = levelAndTier.slice(-1) === 'H' ? 1 : 0;\n    const bitDepth = Number(parts[3]);\n    const highBitDepth = bitDepth === 8 ? 0 : 1;\n    const twelveBit = 0;\n    const monochrome = parts[4] ? Number(parts[4]) : 0;\n    const chromaSubsamplingX = parts[5] ? Number(parts[5][0]) : 1;\n    const chromaSubsamplingY = parts[5] ? Number(parts[5][1]) : 1;\n    const chromaSamplePosition = parts[5] ? Number(parts[5][2]) : 0; // CSP_UNKNOWN\n    const thirdByte = (tier << 7)\n        + (highBitDepth << 6)\n        + (twelveBit << 5)\n        + (monochrome << 4)\n        + (chromaSubsamplingX << 3)\n        + (chromaSubsamplingY << 2)\n        + chromaSamplePosition;\n    const initialPresentationDelayPresent = 0; // Should be fine\n    const fourthByte = initialPresentationDelayPresent;\n    return [firstByte, secondByte, thirdByte, fourthByte];\n};\nexport const extractVideoCodecString = (trackInfo) => {\n    const { codec, codecDescription, colorSpace, avcCodecInfo, hevcCodecInfo, vp9CodecInfo, av1CodecInfo } = trackInfo;\n    if (codec === 'avc') {\n        assert(trackInfo.avcType !== null);\n        if (avcCodecInfo) {\n            const bytes = new Uint8Array([\n                avcCodecInfo.avcProfileIndication,\n                avcCodecInfo.profileCompatibility,\n                avcCodecInfo.avcLevelIndication,\n            ]);\n            return `avc${trackInfo.avcType}.${bytesToHexString(bytes)}`;\n        }\n        if (!codecDescription || codecDescription.byteLength < 4) {\n            throw new TypeError('AVC decoder description is not provided or is not at least 4 bytes long.');\n        }\n        return `avc${trackInfo.avcType}.${bytesToHexString(codecDescription.subarray(1, 4))}`;\n    }\n    else if (codec === 'hevc') {\n        let generalProfileSpace;\n        let generalProfileIdc;\n        let compatibilityFlags;\n        let generalTierFlag;\n        let generalLevelIdc;\n        let constraintFlags;\n        if (hevcCodecInfo) {\n            generalProfileSpace = hevcCodecInfo.generalProfileSpace;\n            generalProfileIdc = hevcCodecInfo.generalProfileIdc;\n            compatibilityFlags = reverseBitsU32(hevcCodecInfo.generalProfileCompatibilityFlags);\n            generalTierFlag = hevcCodecInfo.generalTierFlag;\n            generalLevelIdc = hevcCodecInfo.generalLevelIdc;\n            constraintFlags = [...hevcCodecInfo.generalConstraintIndicatorFlags];\n        }\n        else {\n            if (!codecDescription || codecDescription.byteLength < 23) {\n                throw new TypeError('HEVC decoder description is not provided or is not at least 23 bytes long.');\n            }\n            const view = toDataView(codecDescription);\n            const profileByte = view.getUint8(1);\n            generalProfileSpace = (profileByte >> 6) & 0x03;\n            generalProfileIdc = profileByte & 0x1F;\n            compatibilityFlags = reverseBitsU32(view.getUint32(2));\n            generalTierFlag = (profileByte >> 5) & 0x01;\n            generalLevelIdc = view.getUint8(12);\n            constraintFlags = [];\n            for (let i = 0; i < 6; i++) {\n                constraintFlags.push(view.getUint8(6 + i));\n            }\n        }\n        let codecString = 'hev1.';\n        codecString += ['', 'A', 'B', 'C'][generalProfileSpace] + generalProfileIdc;\n        codecString += '.';\n        codecString += compatibilityFlags.toString(16).toUpperCase();\n        codecString += '.';\n        codecString += generalTierFlag === 0 ? 'L' : 'H';\n        codecString += generalLevelIdc;\n        while (constraintFlags.length > 0 && constraintFlags[constraintFlags.length - 1] === 0) {\n            constraintFlags.pop();\n        }\n        if (constraintFlags.length > 0) {\n            codecString += '.';\n            codecString += constraintFlags.map(x => x.toString(16).toUpperCase()).join('.');\n        }\n        return codecString;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        if (!vp9CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `vp09.00.${level.toString().padStart(2, '0')}.08`;\n        }\n        const profile = vp9CodecInfo.profile.toString().padStart(2, '0');\n        const level = vp9CodecInfo.level.toString().padStart(2, '0');\n        const bitDepth = vp9CodecInfo.bitDepth.toString().padStart(2, '0');\n        const chromaSubsampling = vp9CodecInfo.chromaSubsampling.toString().padStart(2, '0');\n        const colourPrimaries = vp9CodecInfo.colourPrimaries.toString().padStart(2, '0');\n        const transferCharacteristics = vp9CodecInfo.transferCharacteristics.toString().padStart(2, '0');\n        const matrixCoefficients = vp9CodecInfo.matrixCoefficients.toString().padStart(2, '0');\n        const videoFullRangeFlag = vp9CodecInfo.videoFullRangeFlag.toString().padStart(2, '0');\n        let string = `vp09.${profile}.${level}.${bitDepth}.${chromaSubsampling}`;\n        string += `.${colourPrimaries}.${transferCharacteristics}.${matrixCoefficients}.${videoFullRangeFlag}`;\n        if (string.endsWith(VP9_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -VP9_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    else if (codec === 'av1') {\n        if (!av1CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `av01.0.${level.toString().padStart(2, '0')}M.08`;\n        }\n        // https://aomediacodec.github.io/av1-isobmff/#codecsparam\n        const profile = av1CodecInfo.profile; // Single digit\n        const level = av1CodecInfo.level.toString().padStart(2, '0');\n        const tier = av1CodecInfo.tier ? 'H' : 'M';\n        const bitDepth = av1CodecInfo.bitDepth.toString().padStart(2, '0');\n        const monochrome = av1CodecInfo.monochrome ? '1' : '0';\n        const chromaSubsampling = 100 * av1CodecInfo.chromaSubsamplingX\n            + 10 * av1CodecInfo.chromaSubsamplingY\n            + 1 * (av1CodecInfo.chromaSubsamplingX && av1CodecInfo.chromaSubsamplingY\n                ? av1CodecInfo.chromaSamplePosition\n                : 0);\n        // The defaults are 1 (ITU-R BT.709)\n        const colorPrimaries = colorSpace?.primaries ? COLOR_PRIMARIES_MAP[colorSpace.primaries] : 1;\n        const transferCharacteristics = colorSpace?.transfer ? TRANSFER_CHARACTERISTICS_MAP[colorSpace.transfer] : 1;\n        const matrixCoefficients = colorSpace?.matrix ? MATRIX_COEFFICIENTS_MAP[colorSpace.matrix] : 1;\n        const videoFullRangeFlag = colorSpace?.fullRange ? 1 : 0;\n        let string = `av01.${profile}.${level}${tier}.${bitDepth}`;\n        string += `.${monochrome}.${chromaSubsampling.toString().padStart(3, '0')}`;\n        string += `.${colorPrimaries.toString().padStart(2, '0')}`;\n        string += `.${transferCharacteristics.toString().padStart(2, '0')}`;\n        string += `.${matrixCoefficients.toString().padStart(2, '0')}`;\n        string += `.${videoFullRangeFlag}`;\n        if (string.endsWith(AV1_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -AV1_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const buildAudioCodecString = (codec, numberOfChannels, sampleRate) => {\n    if (codec === 'aac') {\n        // If stereo or higher channels and lower sample rate, likely using HE-AAC v2 with PS\n        if (numberOfChannels >= 2 && sampleRate <= 24000) {\n            return 'mp4a.40.29'; // HE-AAC v2 (AAC LC + SBR + PS)\n        }\n        // If sample rate is low, likely using HE-AAC v1 with SBR\n        if (sampleRate <= 24000) {\n            return 'mp4a.40.5'; // HE-AAC v1 (AAC LC + SBR)\n        }\n        // Default to standard AAC-LC for higher sample rates\n        return 'mp4a.40.2'; // AAC-LC\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const extractAudioCodecString = (trackInfo) => {\n    const { codec, codecDescription, aacCodecInfo } = trackInfo;\n    if (codec === 'aac') {\n        if (!aacCodecInfo) {\n            throw new TypeError('AAC codec info must be provided.');\n        }\n        if (aacCodecInfo.isMpeg2) {\n            return 'mp4a.67';\n        }\n        else {\n            let objectType;\n            if (aacCodecInfo.objectType !== null) {\n                objectType = aacCodecInfo.objectType;\n            }\n            else {\n                const audioSpecificConfig = parseAacAudioSpecificConfig(codecDescription);\n                objectType = audioSpecificConfig.objectType;\n            }\n            return `mp4a.40.${objectType}`;\n        }\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (codec && PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const aacFrequencyTable = [\n    96000, 88200, 64000, 48000, 44100, 32000,\n    24000, 22050, 16000, 12000, 11025, 8000, 7350,\n];\nexport const aacChannelMap = [-1, 1, 2, 3, 4, 5, 6, 8];\nexport const parseAacAudioSpecificConfig = (bytes) => {\n    if (!bytes || bytes.byteLength < 2) {\n        throw new TypeError('AAC description must be at least 2 bytes long.');\n    }\n    const bitstream = new Bitstream(bytes);\n    let objectType = bitstream.readBits(5);\n    if (objectType === 31) {\n        objectType = 32 + bitstream.readBits(6);\n    }\n    const frequencyIndex = bitstream.readBits(4);\n    let sampleRate = null;\n    if (frequencyIndex === 15) {\n        sampleRate = bitstream.readBits(24);\n    }\n    else {\n        if (frequencyIndex < aacFrequencyTable.length) {\n            sampleRate = aacFrequencyTable[frequencyIndex];\n        }\n    }\n    const channelConfiguration = bitstream.readBits(4);\n    let numberOfChannels = null;\n    if (channelConfiguration >= 1 && channelConfiguration <= 7) {\n        numberOfChannels = aacChannelMap[channelConfiguration];\n    }\n    return {\n        objectType,\n        frequencyIndex,\n        sampleRate,\n        channelConfiguration,\n        numberOfChannels,\n    };\n};\nexport const buildAacAudioSpecificConfig = (config) => {\n    let frequencyIndex = aacFrequencyTable.indexOf(config.sampleRate);\n    let customSampleRate = null;\n    if (frequencyIndex === -1) {\n        frequencyIndex = 15;\n        customSampleRate = config.sampleRate;\n    }\n    const channelConfiguration = aacChannelMap.indexOf(config.numberOfChannels);\n    if (channelConfiguration === -1) {\n        throw new TypeError(`Unsupported number of channels: ${config.numberOfChannels}`);\n    }\n    let bitCount = 5 + 4 + 4;\n    if (config.objectType >= 32) {\n        bitCount += 6;\n    }\n    if (frequencyIndex === 15) {\n        bitCount += 24;\n    }\n    const byteCount = Math.ceil(bitCount / 8);\n    const bytes = new Uint8Array(byteCount);\n    const bitstream = new Bitstream(bytes);\n    if (config.objectType < 32) {\n        bitstream.writeBits(5, config.objectType);\n    }\n    else {\n        bitstream.writeBits(5, 31);\n        bitstream.writeBits(6, config.objectType - 32);\n    }\n    bitstream.writeBits(4, frequencyIndex);\n    if (frequencyIndex === 15) {\n        bitstream.writeBits(24, customSampleRate);\n    }\n    bitstream.writeBits(4, channelConfiguration);\n    return bytes;\n};\nexport const OPUS_SAMPLE_RATE = 48_000;\nconst PCM_CODEC_REGEX = /^pcm-([usf])(\\d+)+(be)?$/;\nexport const parsePcmCodec = (codec) => {\n    assert(PCM_AUDIO_CODECS.includes(codec));\n    if (codec === 'ulaw') {\n        return { dataType: 'ulaw', sampleSize: 1, littleEndian: true, silentValue: 255 };\n    }\n    else if (codec === 'alaw') {\n        return { dataType: 'alaw', sampleSize: 1, littleEndian: true, silentValue: 213 };\n    }\n    const match = PCM_CODEC_REGEX.exec(codec);\n    assert(match);\n    let dataType;\n    if (match[1] === 'u') {\n        dataType = 'unsigned';\n    }\n    else if (match[1] === 's') {\n        dataType = 'signed';\n    }\n    else {\n        dataType = 'float';\n    }\n    const sampleSize = (Number(match[2]) / 8);\n    const littleEndian = match[3] !== 'be';\n    const silentValue = codec === 'pcm-u8' ? 2 ** 7 : 0;\n    return { dataType, sampleSize, littleEndian, silentValue };\n};\nexport const inferCodecFromCodecString = (codecString) => {\n    // Video codecs\n    if (codecString.startsWith('avc1') || codecString.startsWith('avc3')) {\n        return 'avc';\n    }\n    else if (codecString.startsWith('hev1') || codecString.startsWith('hvc1')) {\n        return 'hevc';\n    }\n    else if (codecString === 'vp8') {\n        return 'vp8';\n    }\n    else if (codecString.startsWith('vp09')) {\n        return 'vp9';\n    }\n    else if (codecString.startsWith('av01')) {\n        return 'av1';\n    }\n    // Audio codecs\n    if (codecString.startsWith('mp4a.40') || codecString === 'mp4a.67') {\n        return 'aac';\n    }\n    else if (codecString === 'mp3'\n        || codecString === 'mp4a.69'\n        || codecString === 'mp4a.6B'\n        || codecString === 'mp4a.6b') {\n        return 'mp3';\n    }\n    else if (codecString === 'opus') {\n        return 'opus';\n    }\n    else if (codecString === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codecString === 'flac') {\n        return 'flac';\n    }\n    else if (codecString === 'ulaw') {\n        return 'ulaw';\n    }\n    else if (codecString === 'alaw') {\n        return 'alaw';\n    }\n    else if (PCM_CODEC_REGEX.test(codecString)) {\n        return codecString;\n    }\n    // Subtitle codecs\n    if (codecString === 'webvtt') {\n        return 'webvtt';\n    }\n    return null;\n};\nexport const getVideoEncoderConfigExtension = (codec) => {\n    if (codec === 'avc') {\n        return {\n            avc: {\n                format: 'avc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    else if (codec === 'hevc') {\n        return {\n            hevc: {\n                format: 'hevc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    return {};\n};\nexport const getAudioEncoderConfigExtension = (codec) => {\n    if (codec === 'aac') {\n        return {\n            aac: {\n                format: 'aac', // Ensure the format is not ADTS\n            },\n        };\n    }\n    else if (codec === 'opus') {\n        return {\n            opus: {\n                format: 'opus',\n            },\n        };\n    }\n    return {};\n};\nconst VALID_VIDEO_CODEC_STRING_PREFIXES = ['avc1', 'avc3', 'hev1', 'hvc1', 'vp8', 'vp09', 'av01'];\nconst AVC_CODEC_STRING_REGEX = /^(avc1|avc3)\\.[0-9a-fA-F]{6}$/;\nconst HEVC_CODEC_STRING_REGEX = /^(hev1|hvc1)\\.(?:[ABC]?\\d+)\\.[0-9a-fA-F]{1,8}\\.[LH]\\d+(?:\\.[0-9a-fA-F]{1,2}){0,6}$/;\nconst VP9_CODEC_STRING_REGEX = /^vp09(?:\\.\\d{2}){3}(?:(?:\\.\\d{2}){5})?$/;\nconst AV1_CODEC_STRING_REGEX = /^av01\\.\\d\\.\\d{2}[MH]\\.\\d{2}(?:\\.\\d\\.\\d{3}\\.\\d{2}\\.\\d{2}\\.\\d{2}\\.\\d)?$/;\nexport const validateVideoChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Video chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Video chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Video chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Video chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_VIDEO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedWidth) || metadata.decoderConfig.codedWidth <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedHeight) || metadata.decoderConfig.codedHeight <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!isAllowSharedBufferSource(metadata.decoderConfig.description)) {\n            throw new TypeError('Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.colorSpace !== undefined) {\n        const { colorSpace } = metadata.decoderConfig;\n        if (typeof colorSpace !== 'object') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace, when provided, must be an object.');\n        }\n        const primariesValues = Object.keys(COLOR_PRIMARIES_MAP);\n        if (colorSpace.primaries != null && !primariesValues.includes(colorSpace.primaries)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of`\n                + ` ${primariesValues.join(', ')}.`);\n        }\n        const transferValues = Object.keys(TRANSFER_CHARACTERISTICS_MAP);\n        if (colorSpace.transfer != null && !transferValues.includes(colorSpace.transfer)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of`\n                + ` ${transferValues.join(', ')}.`);\n        }\n        const matrixValues = Object.keys(MATRIX_COEFFICIENTS_MAP);\n        if (colorSpace.matrix != null && !matrixValues.includes(colorSpace.matrix)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of`\n                + ` ${matrixValues.join(', ')}.`);\n        }\n        if (colorSpace.fullRange != null && typeof colorSpace.fullRange !== 'boolean') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('avc1') || metadata.decoderConfig.codec.startsWith('avc3')) {\n        // AVC-specific validation\n        if (!AVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as'\n                + ' specified in Section 3.4 of RFC 6381.');\n        }\n        // `description` may or may not be set, depending on if the format is AVCC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-avc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('hev1') || metadata.decoderConfig.codec.startsWith('hvc1')) {\n        // HEVC-specific validation\n        if (!HEVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as'\n                + ' specified in Section E.3 of ISO 14496-15.');\n        }\n        // `description` may or may not be set, depending on if the format is HEVC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-hevc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp8')) {\n        // VP8-specific validation\n        if (metadata.decoderConfig.codec !== 'vp8') {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be \"vp8\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp09')) {\n        // VP9-specific validation\n        if (!VP9_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://www.webmproject.org/vp9/mp4/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('av01')) {\n        // AV1-specific validation\n        if (!AV1_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://aomediacodec.github.io/av1-isobmff/.');\n        }\n    }\n};\nconst VALID_AUDIO_CODEC_STRING_PREFIXES = ['mp4a', 'mp3', 'opus', 'vorbis', 'flac', 'ulaw', 'alaw', 'pcm'];\nexport const validateAudioChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Audio chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Audio chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Audio chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Audio chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_AUDIO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.sampleRate) || metadata.decoderConfig.sampleRate <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.numberOfChannels) || metadata.decoderConfig.numberOfChannels <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!isAllowSharedBufferSource(metadata.decoderConfig.description)) {\n            throw new TypeError('Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('mp4a')\n        // These three refer to MP3:\n        && metadata.decoderConfig.codec !== 'mp4a.69'\n        && metadata.decoderConfig.codec !== 'mp4a.6B'\n        && metadata.decoderConfig.codec !== 'mp4a.6b') {\n        // AAC-specific validation\n        const validStrings = ['mp4a.40.2', 'mp4a.40.02', 'mp4a.40.5', 'mp4a.40.05', 'mp4a.40.29', 'mp4a.67'];\n        if (!validStrings.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as'\n                + ' specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.');\n        }\n        // `description` may or may not be set, depending on if the format is AAC or ADTS, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-aac-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('mp3') || metadata.decoderConfig.codec.startsWith('mp4a')) {\n        // MP3-specific validation\n        if (metadata.decoderConfig.codec !== 'mp3'\n            && metadata.decoderConfig.codec !== 'mp4a.69'\n            && metadata.decoderConfig.codec !== 'mp4a.6B'\n            && metadata.decoderConfig.codec !== 'mp4a.6b') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be \"mp3\", \"mp4a.69\" or'\n                + ' \"mp4a.6B\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('opus')) {\n        // Opus-specific validation\n        if (metadata.decoderConfig.codec !== 'opus') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be \"opus\".');\n        }\n        if (metadata.decoderConfig.description && metadata.decoderConfig.description.byteLength < 18) {\n            // Description is optional for Opus per-spec, so we shouldn't enforce it\n            throw new TypeError('Audio chunk metadata decoder configuration description, when specified, is expected to be an'\n                + ' Identification Header as specified in Section 5.1 of RFC 7845.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vorbis')) {\n        // Vorbis-specific validation\n        if (metadata.decoderConfig.codec !== 'vorbis') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be \"vorbis\".');\n        }\n        if (!metadata.decoderConfig.description) {\n            throw new TypeError('Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('flac')) {\n        // FLAC-specific validation\n        if (metadata.decoderConfig.codec !== 'flac') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be \"flac\".');\n        }\n        const minDescriptionSize = 4 + 4 + 34; // 'fLaC' + metadata block header + STREAMINFO block\n        if (!metadata.decoderConfig.description || metadata.decoderConfig.description.byteLength < minDescriptionSize) {\n            throw new TypeError('Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('pcm')\n        || metadata.decoderConfig.codec.startsWith('ulaw')\n        || metadata.decoderConfig.codec.startsWith('alaw')) {\n        // PCM-specific validation\n        if (!PCM_AUDIO_CODECS.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM'\n                + ` codecs (${PCM_AUDIO_CODECS.join(', ')}).`);\n        }\n    }\n};\nexport const validateSubtitleMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Subtitle metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Subtitle metadata must be an object.');\n    }\n    if (!metadata.config) {\n        throw new TypeError('Subtitle metadata must include a config object.');\n    }\n    if (typeof metadata.config !== 'object') {\n        throw new TypeError('Subtitle metadata config must be an object.');\n    }\n    if (typeof metadata.config.description !== 'string') {\n        throw new TypeError('Subtitle metadata config description must be a string.');\n    }\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AsyncMutex } from './misc.js';\nexport class Muxer {\n    constructor(output) {\n        this.mutex = new AsyncMutex();\n        /**\n         * This field is used to synchronize multiple MediaStreamTracks. They use the same time coordinate system across\n         * tracks, and to ensure correct audio-video sync, we must use the same offset for all of them. The reason an offset\n         * is needed at all is because the timestamps typically don't start at zero.\n         */\n        this.firstMediaStreamTimestamp = null;\n        this.trackTimestampInfo = new WeakMap();\n        this.output = output;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onTrackClose(track) { }\n    validateAndNormalizeTimestamp(track, timestampInSeconds, isKeyPacket) {\n        timestampInSeconds += track.source._timestampOffset;\n        let timestampInfo = this.trackTimestampInfo.get(track);\n        if (!timestampInfo) {\n            if (!isKeyPacket) {\n                throw new Error('First packet must be a key packet.');\n            }\n            timestampInfo = {\n                maxTimestamp: timestampInSeconds,\n                maxTimestampBeforeLastKeyPacket: timestampInSeconds,\n            };\n            this.trackTimestampInfo.set(track, timestampInfo);\n        }\n        if (timestampInSeconds < 0) {\n            throw new Error(`Timestamps must be non-negative (got ${timestampInSeconds}s).`);\n        }\n        if (isKeyPacket) {\n            timestampInfo.maxTimestampBeforeLastKeyPacket = timestampInfo.maxTimestamp;\n        }\n        if (timestampInSeconds < timestampInfo.maxTimestampBeforeLastKeyPacket) {\n            throw new Error(`Timestamps cannot be smaller than the largest timestamp of the previous GOP (a GOP begins with a key`\n                + ` packet and ends right before the next key packet). Got ${timestampInSeconds}s, but largest`\n                + ` timestamp is ${timestampInfo.maxTimestampBeforeLastKeyPacket}s.`);\n        }\n        timestampInfo.maxTimestamp = Math.max(timestampInfo.maxTimestamp, timestampInSeconds);\n        return timestampInSeconds;\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AVC_LEVEL_TABLE, VP9_LEVEL_TABLE } from './codec.js';\nimport { assert, assertNever, base64ToBytes, Bitstream, bytesToBase64, keyValueIterator, getUint24, last, readExpGolomb, readSignedExpGolomb, textDecoder, textEncoder, toDataView, toUint8Array, getChromiumVersion, isChromium, setUint24, } from './misc.js';\n// References for AVC/HEVC code:\n// ISO 14496-15\n// Rec. ITU-T H.264\n// Rec. ITU-T H.265\n// https://stackoverflow.com/questions/24884827\nexport var AvcNalUnitType;\n(function (AvcNalUnitType) {\n    AvcNalUnitType[AvcNalUnitType[\"NON_IDR_SLICE\"] = 1] = \"NON_IDR_SLICE\";\n    AvcNalUnitType[AvcNalUnitType[\"SLICE_DPA\"] = 2] = \"SLICE_DPA\";\n    AvcNalUnitType[AvcNalUnitType[\"SLICE_DPB\"] = 3] = \"SLICE_DPB\";\n    AvcNalUnitType[AvcNalUnitType[\"SLICE_DPC\"] = 4] = \"SLICE_DPC\";\n    AvcNalUnitType[AvcNalUnitType[\"IDR\"] = 5] = \"IDR\";\n    AvcNalUnitType[AvcNalUnitType[\"SEI\"] = 6] = \"SEI\";\n    AvcNalUnitType[AvcNalUnitType[\"SPS\"] = 7] = \"SPS\";\n    AvcNalUnitType[AvcNalUnitType[\"PPS\"] = 8] = \"PPS\";\n    AvcNalUnitType[AvcNalUnitType[\"AUD\"] = 9] = \"AUD\";\n    AvcNalUnitType[AvcNalUnitType[\"SPS_EXT\"] = 13] = \"SPS_EXT\";\n})(AvcNalUnitType || (AvcNalUnitType = {}));\nexport var HevcNalUnitType;\n(function (HevcNalUnitType) {\n    HevcNalUnitType[HevcNalUnitType[\"RASL_N\"] = 8] = \"RASL_N\";\n    HevcNalUnitType[HevcNalUnitType[\"RASL_R\"] = 9] = \"RASL_R\";\n    HevcNalUnitType[HevcNalUnitType[\"BLA_W_LP\"] = 16] = \"BLA_W_LP\";\n    HevcNalUnitType[HevcNalUnitType[\"RSV_IRAP_VCL23\"] = 23] = \"RSV_IRAP_VCL23\";\n    HevcNalUnitType[HevcNalUnitType[\"VPS_NUT\"] = 32] = \"VPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"SPS_NUT\"] = 33] = \"SPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"PPS_NUT\"] = 34] = \"PPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"AUD_NUT\"] = 35] = \"AUD_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"PREFIX_SEI_NUT\"] = 39] = \"PREFIX_SEI_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"SUFFIX_SEI_NUT\"] = 40] = \"SUFFIX_SEI_NUT\";\n})(HevcNalUnitType || (HevcNalUnitType = {}));\nexport const iterateNalUnitsInAnnexB = function* (packetData) {\n    let i = 0;\n    let nalStart = -1;\n    while (i < packetData.length - 2) {\n        const zeroIndex = packetData.indexOf(0, i);\n        if (zeroIndex === -1 || zeroIndex >= packetData.length - 2) {\n            break;\n        }\n        i = zeroIndex;\n        let startCodeLength = 0;\n        // Check for 4-byte start code (0x00000001)\n        if (i + 3 < packetData.length\n            && packetData[i + 1] === 0\n            && packetData[i + 2] === 0\n            && packetData[i + 3] === 1) {\n            startCodeLength = 4;\n        }\n        else if (packetData[i + 1] === 0 && packetData[i + 2] === 1) {\n            // Check for 3-byte start code (0x000001)\n            startCodeLength = 3;\n        }\n        if (startCodeLength === 0) {\n            i++;\n            continue;\n        }\n        // If we had a previous NAL unit, yield it\n        if (nalStart !== -1 && i > nalStart) {\n            yield {\n                offset: nalStart,\n                length: i - nalStart,\n            };\n        }\n        nalStart = i + startCodeLength;\n        i = nalStart;\n    }\n    // Yield the last NAL unit if there is one\n    if (nalStart !== -1 && nalStart < packetData.length) {\n        yield {\n            offset: nalStart,\n            length: packetData.length - nalStart,\n        };\n    }\n};\nexport const iterateNalUnitsInLengthPrefixed = function* (packetData, lengthSize) {\n    let offset = 0;\n    const dataView = new DataView(packetData.buffer, packetData.byteOffset, packetData.byteLength);\n    while (offset + lengthSize <= packetData.length) {\n        let nalUnitLength;\n        if (lengthSize === 1) {\n            nalUnitLength = dataView.getUint8(offset);\n        }\n        else if (lengthSize === 2) {\n            nalUnitLength = dataView.getUint16(offset, false);\n        }\n        else if (lengthSize === 3) {\n            nalUnitLength = getUint24(dataView, offset, false);\n        }\n        else {\n            assert(lengthSize === 4);\n            nalUnitLength = dataView.getUint32(offset, false);\n        }\n        offset += lengthSize;\n        yield {\n            offset,\n            length: nalUnitLength,\n        };\n        offset += nalUnitLength;\n    }\n};\nexport const iterateAvcNalUnits = (packetData, decoderConfig) => {\n    if (decoderConfig.description) {\n        const bytes = toUint8Array(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[4] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return iterateNalUnitsInLengthPrefixed(packetData, lengthSize);\n    }\n    else {\n        return iterateNalUnitsInAnnexB(packetData);\n    }\n};\nexport const iterateAvcNalUnitsAnnexB = function* (packetData) {\n    yield* iterateNalUnitsInAnnexB(packetData);\n};\nexport const extractNalUnitTypeForAvc = (byte) => {\n    return byte & 0x1F;\n};\nconst removeEmulationPreventionBytes = (data) => {\n    const result = [];\n    const len = data.length;\n    for (let i = 0; i < len; i++) {\n        // Look for the 0x000003 pattern\n        if (i + 2 < len && data[i] === 0x00 && data[i + 1] === 0x00 && data[i + 2] === 0x03) {\n            result.push(0x00, 0x00); // Push the first two bytes\n            i += 2; // Skip the 0x03 byte\n        }\n        else {\n            result.push(data[i]);\n        }\n    }\n    return new Uint8Array(result);\n};\nconst ANNEX_B_START_CODE = new Uint8Array([0, 0, 0, 1]);\nexport const concatNalUnitsInAnnexB = (nalUnits) => {\n    const totalLength = nalUnits.reduce((a, b) => a + ANNEX_B_START_CODE.byteLength + b.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const nalUnit of nalUnits) {\n        result.set(ANNEX_B_START_CODE, offset);\n        offset += ANNEX_B_START_CODE.byteLength;\n        result.set(nalUnit, offset);\n        offset += nalUnit.byteLength;\n    }\n    return result;\n};\nexport const concatNalUnitsInLengthPrefixed = (nalUnits, lengthSize) => {\n    const totalLength = nalUnits.reduce((a, b) => a + lengthSize + b.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const nalUnit of nalUnits) {\n        const dataView = new DataView(result.buffer, result.byteOffset, result.byteLength);\n        switch (lengthSize) {\n            case 1:\n                dataView.setUint8(offset, nalUnit.byteLength);\n                break;\n            case 2:\n                dataView.setUint16(offset, nalUnit.byteLength, false);\n                break;\n            case 3:\n                setUint24(dataView, offset, nalUnit.byteLength, false);\n                break;\n            case 4:\n                dataView.setUint32(offset, nalUnit.byteLength, false);\n                break;\n        }\n        offset += lengthSize;\n        result.set(nalUnit, offset);\n        offset += nalUnit.byteLength;\n    }\n    return result;\n};\nexport const concatAvcNalUnits = (nalUnits, decoderConfig) => {\n    if (decoderConfig.description) {\n        // Stream is length-prefixed. Let's extract the size of the length prefix from the decoder config\n        const bytes = toUint8Array(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[4] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return concatNalUnitsInLengthPrefixed(nalUnits, lengthSize);\n    }\n    else {\n        // Stream is in Annex B format\n        return concatNalUnitsInAnnexB(nalUnits);\n    }\n};\n/** Builds an AvcDecoderConfigurationRecord from an AVC packet in Annex B format. */\nexport const extractAvcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const spsUnits = [];\n        const ppsUnits = [];\n        const spsExtUnits = [];\n        for (const loc of iterateAvcNalUnitsAnnexB(packetData)) {\n            const nalUnit = packetData.subarray(loc.offset, loc.offset + loc.length);\n            const type = extractNalUnitTypeForAvc(nalUnit[0]);\n            if (type === AvcNalUnitType.SPS) {\n                spsUnits.push(nalUnit);\n            }\n            else if (type === AvcNalUnitType.PPS) {\n                ppsUnits.push(nalUnit);\n            }\n            else if (type === AvcNalUnitType.SPS_EXT) {\n                spsExtUnits.push(nalUnit);\n            }\n        }\n        if (spsUnits.length === 0) {\n            return null;\n        }\n        if (ppsUnits.length === 0) {\n            return null;\n        }\n        // Let's get the first SPS for profile and level information\n        const spsData = spsUnits[0];\n        const spsInfo = parseAvcSps(spsData);\n        assert(spsInfo !== null);\n        const hasExtendedData = spsInfo.profileIdc === 100\n            || spsInfo.profileIdc === 110\n            || spsInfo.profileIdc === 122\n            || spsInfo.profileIdc === 144;\n        return {\n            configurationVersion: 1,\n            avcProfileIndication: spsInfo.profileIdc,\n            profileCompatibility: spsInfo.constraintFlags,\n            avcLevelIndication: spsInfo.levelIdc,\n            lengthSizeMinusOne: 3, // Typically 4 bytes for length field\n            sequenceParameterSets: spsUnits,\n            pictureParameterSets: ppsUnits,\n            chromaFormat: hasExtendedData ? spsInfo.chromaFormatIdc : null,\n            bitDepthLumaMinus8: hasExtendedData ? spsInfo.bitDepthLumaMinus8 : null,\n            bitDepthChromaMinus8: hasExtendedData ? spsInfo.bitDepthChromaMinus8 : null,\n            sequenceParameterSetExt: hasExtendedData ? spsExtUnits : null,\n        };\n    }\n    catch (error) {\n        console.error('Error building AVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\n/** Serializes an AvcDecoderConfigurationRecord into the format specified in Section 5.3.3.1 of ISO 14496-15. */\nexport const serializeAvcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    // Write header\n    bytes.push(record.configurationVersion);\n    bytes.push(record.avcProfileIndication);\n    bytes.push(record.profileCompatibility);\n    bytes.push(record.avcLevelIndication);\n    bytes.push(0xFC | (record.lengthSizeMinusOne & 0x03)); // Reserved bits (6) + lengthSizeMinusOne (2)\n    // Reserved bits (3) + numOfSequenceParameterSets (5)\n    bytes.push(0xE0 | (record.sequenceParameterSets.length & 0x1F));\n    // Write SPS\n    for (const sps of record.sequenceParameterSets) {\n        const length = sps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(sps[i]);\n        }\n    }\n    bytes.push(record.pictureParameterSets.length);\n    // Write PPS\n    for (const pps of record.pictureParameterSets) {\n        const length = pps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(pps[i]);\n        }\n    }\n    if (record.avcProfileIndication === 100\n        || record.avcProfileIndication === 110\n        || record.avcProfileIndication === 122\n        || record.avcProfileIndication === 144) {\n        assert(record.chromaFormat !== null);\n        assert(record.bitDepthLumaMinus8 !== null);\n        assert(record.bitDepthChromaMinus8 !== null);\n        assert(record.sequenceParameterSetExt !== null);\n        bytes.push(0xFC | (record.chromaFormat & 0x03)); // Reserved bits + chroma_format\n        bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07)); // Reserved bits + bit_depth_luma_minus8\n        bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07)); // Reserved bits + bit_depth_chroma_minus8\n        bytes.push(record.sequenceParameterSetExt.length);\n        // Write SPS Ext\n        for (const spsExt of record.sequenceParameterSetExt) {\n            const length = spsExt.byteLength;\n            bytes.push(length >> 8); // High byte\n            bytes.push(length & 0xFF); // Low byte\n            for (let i = 0; i < length; i++) {\n                bytes.push(spsExt[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\n/** Deserializes an AvcDecoderConfigurationRecord from the format specified in Section 5.3.3.1 of ISO 14496-15. */\nexport const deserializeAvcDecoderConfigurationRecord = (data) => {\n    try {\n        const view = toDataView(data);\n        let offset = 0;\n        // Read header\n        const configurationVersion = view.getUint8(offset++);\n        const avcProfileIndication = view.getUint8(offset++);\n        const profileCompatibility = view.getUint8(offset++);\n        const avcLevelIndication = view.getUint8(offset++);\n        const lengthSizeMinusOne = view.getUint8(offset++) & 0x03;\n        const numOfSequenceParameterSets = view.getUint8(offset++) & 0x1F;\n        // Read SPS\n        const sequenceParameterSets = [];\n        for (let i = 0; i < numOfSequenceParameterSets; i++) {\n            const length = view.getUint16(offset, false);\n            offset += 2;\n            sequenceParameterSets.push(data.subarray(offset, offset + length));\n            offset += length;\n        }\n        const numOfPictureParameterSets = view.getUint8(offset++);\n        // Read PPS\n        const pictureParameterSets = [];\n        for (let i = 0; i < numOfPictureParameterSets; i++) {\n            const length = view.getUint16(offset, false);\n            offset += 2;\n            pictureParameterSets.push(data.subarray(offset, offset + length));\n            offset += length;\n        }\n        const record = {\n            configurationVersion,\n            avcProfileIndication,\n            profileCompatibility,\n            avcLevelIndication,\n            lengthSizeMinusOne,\n            sequenceParameterSets,\n            pictureParameterSets,\n            chromaFormat: null,\n            bitDepthLumaMinus8: null,\n            bitDepthChromaMinus8: null,\n            sequenceParameterSetExt: null,\n        };\n        // Check if there are extended profile fields\n        if ((avcProfileIndication === 100\n            || avcProfileIndication === 110\n            || avcProfileIndication === 122\n            || avcProfileIndication === 144)\n            && offset + 4 <= data.length) {\n            const chromaFormat = view.getUint8(offset++) & 0x03;\n            const bitDepthLumaMinus8 = view.getUint8(offset++) & 0x07;\n            const bitDepthChromaMinus8 = view.getUint8(offset++) & 0x07;\n            const numOfSequenceParameterSetExt = view.getUint8(offset++);\n            record.chromaFormat = chromaFormat;\n            record.bitDepthLumaMinus8 = bitDepthLumaMinus8;\n            record.bitDepthChromaMinus8 = bitDepthChromaMinus8;\n            // Read SPS Ext\n            const sequenceParameterSetExt = [];\n            for (let i = 0; i < numOfSequenceParameterSetExt; i++) {\n                const length = view.getUint16(offset, false);\n                offset += 2;\n                sequenceParameterSetExt.push(data.subarray(offset, offset + length));\n                offset += length;\n            }\n            record.sequenceParameterSetExt = sequenceParameterSetExt;\n        }\n        return record;\n    }\n    catch (error) {\n        console.error('Error deserializing AVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\n/** Parses an AVC SPS (Sequence Parameter Set) to extract basic information. */\nexport const parseAvcSps = (sps) => {\n    try {\n        const bitstream = new Bitstream(removeEmulationPreventionBytes(sps));\n        bitstream.skipBits(1); // forbidden_zero_bit\n        bitstream.skipBits(2); // nal_ref_idc\n        const nalUnitType = bitstream.readBits(5);\n        if (nalUnitType !== 7) { // SPS NAL unit type is 7\n            return null;\n        }\n        const profileIdc = bitstream.readAlignedByte();\n        const constraintFlags = bitstream.readAlignedByte();\n        const levelIdc = bitstream.readAlignedByte();\n        readExpGolomb(bitstream); // seq_parameter_set_id\n        // \"When chroma_format_idc is not present, it shall be inferred to be equal to 1 (4:2:0 chroma format).\"\n        let chromaFormatIdc = 1;\n        // \"When bit_depth_luma_minus8 is not present, it shall be inferred to be equal to 0.\"\"\n        let bitDepthLumaMinus8 = 0;\n        // \"When bit_depth_chroma_minus8 is not present, it shall be inferred to be equal to 0.\"\n        let bitDepthChromaMinus8 = 0;\n        // \"When separate_colour_plane_flag is not present, it shall be inferred to be equal to 0.\"\n        let separateColourPlaneFlag = 0;\n        // Handle high profile chroma_format_idc\n        if (profileIdc === 100\n            || profileIdc === 110\n            || profileIdc === 122\n            || profileIdc === 244\n            || profileIdc === 44\n            || profileIdc === 83\n            || profileIdc === 86\n            || profileIdc === 118\n            || profileIdc === 128) {\n            chromaFormatIdc = readExpGolomb(bitstream);\n            if (chromaFormatIdc === 3) {\n                separateColourPlaneFlag = bitstream.readBits(1);\n            }\n            bitDepthLumaMinus8 = readExpGolomb(bitstream);\n            bitDepthChromaMinus8 = readExpGolomb(bitstream);\n            bitstream.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n            const seqScalingMatrixPresentFlag = bitstream.readBits(1);\n            if (seqScalingMatrixPresentFlag) {\n                for (let i = 0; i < (chromaFormatIdc !== 3 ? 8 : 12); i++) {\n                    const seqScalingListPresentFlag = bitstream.readBits(1);\n                    if (seqScalingListPresentFlag) {\n                        const sizeOfScalingList = i < 6 ? 16 : 64;\n                        let lastScale = 8;\n                        let nextScale = 8;\n                        for (let j = 0; j < sizeOfScalingList; j++) {\n                            if (nextScale !== 0) {\n                                const deltaScale = readSignedExpGolomb(bitstream);\n                                nextScale = (lastScale + deltaScale + 256) % 256;\n                            }\n                            lastScale = nextScale === 0 ? lastScale : nextScale;\n                        }\n                    }\n                }\n            }\n        }\n        readExpGolomb(bitstream); // log2_max_frame_num_minus4\n        const picOrderCntType = readExpGolomb(bitstream);\n        if (picOrderCntType === 0) {\n            readExpGolomb(bitstream); // log2_max_pic_order_cnt_lsb_minus4\n        }\n        else if (picOrderCntType === 1) {\n            bitstream.skipBits(1); // delta_pic_order_always_zero_flag\n            readSignedExpGolomb(bitstream); // offset_for_non_ref_pic\n            readSignedExpGolomb(bitstream); // offset_for_top_to_bottom_field\n            const numRefFramesInPicOrderCntCycle = readExpGolomb(bitstream);\n            for (let i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n                readSignedExpGolomb(bitstream); // offset_for_ref_frame[i]\n            }\n        }\n        readExpGolomb(bitstream); // max_num_ref_frames\n        bitstream.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n        const picWidthInMbsMinus1 = readExpGolomb(bitstream);\n        const picHeightInMapUnitsMinus1 = readExpGolomb(bitstream);\n        const codedWidth = 16 * (picWidthInMbsMinus1 + 1);\n        const codedHeight = 16 * (picHeightInMapUnitsMinus1 + 1);\n        let displayWidth = codedWidth;\n        let displayHeight = codedHeight;\n        const frameMbsOnlyFlag = bitstream.readBits(1);\n        if (!frameMbsOnlyFlag) {\n            bitstream.skipBits(1); // mb_adaptive_frame_field_flag\n        }\n        bitstream.skipBits(1); // direct_8x8_inference_flag\n        const frameCroppingFlag = bitstream.readBits(1);\n        if (frameCroppingFlag) {\n            const frameCropLeftOffset = readExpGolomb(bitstream);\n            const frameCropRightOffset = readExpGolomb(bitstream);\n            const frameCropTopOffset = readExpGolomb(bitstream);\n            const frameCropBottomOffset = readExpGolomb(bitstream);\n            let cropUnitX;\n            let cropUnitY;\n            const chromaArrayType = separateColourPlaneFlag === 0 ? chromaFormatIdc : 0;\n            if (chromaArrayType === 0) {\n                // \"If ChromaArrayType is equal to 0, CropUnitX and CropUnitY are derived as:\"\n                cropUnitX = 1;\n                cropUnitY = 2 - frameMbsOnlyFlag;\n            }\n            else {\n                // \"Otherwise (ChromaArrayType is equal to 1, 2, or 3), CropUnitX and CropUnitY are derived as:\"\n                const subWidthC = chromaFormatIdc === 3 ? 1 : 2;\n                const subHeightC = chromaFormatIdc === 1 ? 2 : 1;\n                cropUnitX = subWidthC;\n                cropUnitY = subHeightC * (2 - frameMbsOnlyFlag);\n            }\n            displayWidth -= (cropUnitX * (frameCropLeftOffset + frameCropRightOffset));\n            displayHeight -= (cropUnitY * (frameCropTopOffset + frameCropBottomOffset));\n        }\n        // 2 = unspecified\n        let colourPrimaries = 2;\n        let transferCharacteristics = 2;\n        let matrixCoefficients = 2;\n        let fullRangeFlag = 0;\n        let numReorderFrames = null;\n        let maxDecFrameBuffering = null;\n        const vuiParametersPresentFlag = bitstream.readBits(1);\n        if (vuiParametersPresentFlag) {\n            const aspectRatioInfoPresentFlag = bitstream.readBits(1);\n            if (aspectRatioInfoPresentFlag) {\n                const aspectRatioIdc = bitstream.readBits(8);\n                if (aspectRatioIdc === 255) { // Extended_SAR\n                    bitstream.skipBits(16); // sar_width\n                    bitstream.skipBits(16); // sar_height\n                }\n            }\n            const overscanInfoPresentFlag = bitstream.readBits(1);\n            if (overscanInfoPresentFlag) {\n                bitstream.skipBits(1); // overscan_appropriate_flag\n            }\n            const videoSignalTypePresentFlag = bitstream.readBits(1);\n            if (videoSignalTypePresentFlag) {\n                bitstream.skipBits(3); // video_format\n                fullRangeFlag = bitstream.readBits(1);\n                const colourDescriptionPresentFlag = bitstream.readBits(1);\n                if (colourDescriptionPresentFlag) {\n                    colourPrimaries = bitstream.readBits(8);\n                    transferCharacteristics = bitstream.readBits(8);\n                    matrixCoefficients = bitstream.readBits(8);\n                }\n            }\n            const chromaLocInfoPresentFlag = bitstream.readBits(1);\n            if (chromaLocInfoPresentFlag) {\n                readExpGolomb(bitstream); // chroma_sample_loc_type_top_field\n                readExpGolomb(bitstream); // chroma_sample_loc_type_bottom_field\n            }\n            const timingInfoPresentFlag = bitstream.readBits(1);\n            if (timingInfoPresentFlag) {\n                bitstream.skipBits(32); // num_units_in_tick\n                bitstream.skipBits(32); // time_scale\n                bitstream.skipBits(1); // fixed_frame_rate_flag\n            }\n            const nalHrdParametersPresentFlag = bitstream.readBits(1);\n            if (nalHrdParametersPresentFlag) {\n                skipAvcHrdParameters(bitstream);\n            }\n            const vclHrdParametersPresentFlag = bitstream.readBits(1);\n            if (vclHrdParametersPresentFlag) {\n                skipAvcHrdParameters(bitstream);\n            }\n            if (nalHrdParametersPresentFlag || vclHrdParametersPresentFlag) {\n                bitstream.skipBits(1); // low_delay_hrd_flag\n            }\n            bitstream.skipBits(1); // pic_struct_present_flag\n            const bitstreamRestrictionFlag = bitstream.readBits(1);\n            if (bitstreamRestrictionFlag) {\n                bitstream.skipBits(1); // motion_vectors_over_pic_boundaries_flag\n                readExpGolomb(bitstream); // max_bytes_per_pic_denom\n                readExpGolomb(bitstream); // max_bits_per_mb_denom\n                readExpGolomb(bitstream); // log2_max_mv_length_horizontal\n                readExpGolomb(bitstream); // log2_max_mv_length_vertical\n                numReorderFrames = readExpGolomb(bitstream);\n                maxDecFrameBuffering = readExpGolomb(bitstream);\n            }\n        }\n        if (numReorderFrames === null) {\n            assert(maxDecFrameBuffering === null);\n            const constraintSet3Flag = constraintFlags & 0b00010000;\n            if ((profileIdc === 44 || profileIdc === 86 || profileIdc === 100\n                || profileIdc === 110 || profileIdc === 122 || profileIdc === 244) && constraintSet3Flag) {\n                // \"If profile_idc is equal to 44, 86, 100, 110, 122, or 244 and constraint_set3_flag is equal to 1, the\n                // value of num_reorder_frames shall be inferred to be equal to 0.\"\n                numReorderFrames = 0;\n                maxDecFrameBuffering = 0;\n            }\n            else {\n                const picWidthInMbs = picWidthInMbsMinus1 + 1;\n                const picHeightInMapUnits = picHeightInMapUnitsMinus1 + 1;\n                const frameHeightInMbs = (2 - frameMbsOnlyFlag) * picHeightInMapUnits;\n                const levelInfo = AVC_LEVEL_TABLE.find(x => x.level >= levelIdc) ?? last(AVC_LEVEL_TABLE);\n                // \"MaxDpbFrames is equal to\n                // Min( MaxDpbMbs / ( picWidthInMbs * frameHeightInMbs ), 16 ) and MaxDpbMbs is given in Table A-1.\"\n                const maxDpbFrames = Math.min(Math.floor(levelInfo.maxDpbMbs / (picWidthInMbs * frameHeightInMbs)), 16);\n                // \"Otherwise, [...] the value of num_reorder_frames shall be inferred to be equal to MaxDpbFrames.\"\n                numReorderFrames = maxDpbFrames;\n                maxDecFrameBuffering = maxDpbFrames;\n            }\n        }\n        assert(maxDecFrameBuffering !== null);\n        return {\n            profileIdc,\n            constraintFlags,\n            levelIdc,\n            frameMbsOnlyFlag,\n            chromaFormatIdc,\n            bitDepthLumaMinus8,\n            bitDepthChromaMinus8,\n            codedWidth,\n            codedHeight,\n            displayWidth,\n            displayHeight,\n            colourPrimaries,\n            matrixCoefficients,\n            transferCharacteristics,\n            fullRangeFlag,\n            numReorderFrames,\n            maxDecFrameBuffering,\n        };\n    }\n    catch (error) {\n        console.error('Error parsing AVC SPS:', error);\n        return null;\n    }\n};\nconst skipAvcHrdParameters = (bitstream) => {\n    const cpb_cnt_minus1 = readExpGolomb(bitstream);\n    bitstream.skipBits(4); // bit_rate_scale\n    bitstream.skipBits(4); // cpb_size_scale\n    for (let i = 0; i <= cpb_cnt_minus1; i++) {\n        readExpGolomb(bitstream); // bit_rate_value_minus1[i]\n        readExpGolomb(bitstream); // cpb_size_value_minus1[i]\n        bitstream.skipBits(1); // cbr_flag[i]\n    }\n    bitstream.skipBits(5); // initial_cpb_removal_delay_length_minus1\n    bitstream.skipBits(5); // cpb_removal_delay_length_minus1\n    bitstream.skipBits(5); // dpb_output_delay_length_minus1\n    bitstream.skipBits(5); // time_offset_length\n};\nexport const iterateHevcNalUnits = (packetData, decoderConfig) => {\n    if (decoderConfig.description) {\n        const bytes = toUint8Array(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[21] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return iterateNalUnitsInLengthPrefixed(packetData, lengthSize);\n    }\n    else {\n        return iterateNalUnitsInAnnexB(packetData);\n    }\n};\nexport const iterateHevcNalUnitsAnnexB = function* (packetData) {\n    yield* iterateNalUnitsInAnnexB(packetData);\n};\nexport const extractNalUnitTypeForHevc = (byte) => {\n    return (byte >> 1) & 0x3F;\n};\n/** Parses an HEVC SPS (Sequence Parameter Set) to extract video information. */\nexport const parseHevcSps = (sps) => {\n    try {\n        const bitstream = new Bitstream(removeEmulationPreventionBytes(sps));\n        bitstream.skipBits(16); // NAL header\n        bitstream.readBits(4); // sps_video_parameter_set_id\n        const spsMaxSubLayersMinus1 = bitstream.readBits(3);\n        const spsTemporalIdNestingFlag = bitstream.readBits(1);\n        const { general_profile_space, general_tier_flag, general_profile_idc, general_profile_compatibility_flags, general_constraint_indicator_flags, general_level_idc, } = parseProfileTierLevel(bitstream, spsMaxSubLayersMinus1);\n        readExpGolomb(bitstream); // sps_seq_parameter_set_id\n        const chromaFormatIdc = readExpGolomb(bitstream);\n        let separateColourPlaneFlag = 0;\n        if (chromaFormatIdc === 3) {\n            separateColourPlaneFlag = bitstream.readBits(1);\n        }\n        const picWidthInLumaSamples = readExpGolomb(bitstream);\n        const picHeightInLumaSamples = readExpGolomb(bitstream);\n        let displayWidth = picWidthInLumaSamples;\n        let displayHeight = picHeightInLumaSamples;\n        if (bitstream.readBits(1)) { // conformance_window_flag\n            const confWinLeftOffset = readExpGolomb(bitstream);\n            const confWinRightOffset = readExpGolomb(bitstream);\n            const confWinTopOffset = readExpGolomb(bitstream);\n            const confWinBottomOffset = readExpGolomb(bitstream);\n            // SubWidthC and SubHeightC depend on chroma_format_idc and separate_colour_plane_flag\n            let subWidthC = 1;\n            let subHeightC = 1;\n            const chromaArrayType = separateColourPlaneFlag === 0 ? chromaFormatIdc : 0;\n            if (chromaArrayType === 1) {\n                subWidthC = 2;\n                subHeightC = 2;\n            }\n            else if (chromaArrayType === 2) {\n                subWidthC = 2;\n                subHeightC = 1;\n            }\n            displayWidth -= (confWinLeftOffset + confWinRightOffset) * subWidthC;\n            displayHeight -= (confWinTopOffset + confWinBottomOffset) * subHeightC;\n        }\n        const bitDepthLumaMinus8 = readExpGolomb(bitstream);\n        const bitDepthChromaMinus8 = readExpGolomb(bitstream);\n        readExpGolomb(bitstream); // log2_max_pic_order_cnt_lsb_minus4\n        const spsSubLayerOrderingInfoPresentFlag = bitstream.readBits(1);\n        const startI = spsSubLayerOrderingInfoPresentFlag ? 0 : spsMaxSubLayersMinus1;\n        let spsMaxNumReorderPics = 0;\n        for (let i = startI; i <= spsMaxSubLayersMinus1; i++) {\n            readExpGolomb(bitstream); // sps_max_dec_pic_buffering_minus1[i]\n            spsMaxNumReorderPics = readExpGolomb(bitstream); // sps_max_num_reorder_pics[i]\n            readExpGolomb(bitstream); // sps_max_latency_increase_plus1[i]\n        }\n        readExpGolomb(bitstream); // log2_min_luma_coding_block_size_minus3\n        readExpGolomb(bitstream); // log2_diff_max_min_luma_coding_block_size\n        readExpGolomb(bitstream); // log2_min_luma_transform_block_size_minus2\n        readExpGolomb(bitstream); // log2_diff_max_min_luma_transform_block_size\n        readExpGolomb(bitstream); // max_transform_hierarchy_depth_inter\n        readExpGolomb(bitstream); // max_transform_hierarchy_depth_intra\n        if (bitstream.readBits(1)) { // scaling_list_enabled_flag\n            if (bitstream.readBits(1)) {\n                skipScalingListData(bitstream);\n            }\n        }\n        bitstream.skipBits(1); // amp_enabled_flag\n        bitstream.skipBits(1); // sample_adaptive_offset_enabled_flag\n        if (bitstream.readBits(1)) { // pcm_enabled_flag\n            bitstream.skipBits(4); // pcm_sample_bit_depth_luma_minus1\n            bitstream.skipBits(4); // pcm_sample_bit_depth_chroma_minus1\n            readExpGolomb(bitstream); // log2_min_pcm_luma_coding_block_size_minus3\n            readExpGolomb(bitstream); // log2_diff_max_min_pcm_luma_coding_block_size\n            bitstream.skipBits(1); // pcm_loop_filter_disabled_flag\n        }\n        const numShortTermRefPicSets = readExpGolomb(bitstream);\n        skipAllStRefPicSets(bitstream, numShortTermRefPicSets);\n        if (bitstream.readBits(1)) { // long_term_ref_pics_present_flag\n            const numLongTermRefPicsSps = readExpGolomb(bitstream);\n            for (let i = 0; i < numLongTermRefPicsSps; i++) {\n                readExpGolomb(bitstream); // lt_ref_pic_poc_lsb_sps[i]\n                bitstream.skipBits(1); // used_by_curr_pic_lt_sps_flag[i]\n            }\n        }\n        bitstream.skipBits(1); // sps_temporal_mvp_enabled_flag\n        bitstream.skipBits(1); // strong_intra_smoothing_enabled_flag\n        let colourPrimaries = 2;\n        let transferCharacteristics = 2;\n        let matrixCoefficients = 2;\n        let fullRangeFlag = 0;\n        let minSpatialSegmentationIdc = 0;\n        if (bitstream.readBits(1)) { // vui_parameters_present_flag\n            const vui = parseHevcVui(bitstream, spsMaxSubLayersMinus1);\n            colourPrimaries = vui.colourPrimaries;\n            transferCharacteristics = vui.transferCharacteristics;\n            matrixCoefficients = vui.matrixCoefficients;\n            fullRangeFlag = vui.fullRangeFlag;\n            minSpatialSegmentationIdc = vui.minSpatialSegmentationIdc;\n        }\n        return {\n            displayWidth,\n            displayHeight,\n            colourPrimaries,\n            transferCharacteristics,\n            matrixCoefficients,\n            fullRangeFlag,\n            maxDecFrameBuffering: spsMaxNumReorderPics + 1,\n            spsMaxSubLayersMinus1,\n            spsTemporalIdNestingFlag,\n            generalProfileSpace: general_profile_space,\n            generalTierFlag: general_tier_flag,\n            generalProfileIdc: general_profile_idc,\n            generalProfileCompatibilityFlags: general_profile_compatibility_flags,\n            generalConstraintIndicatorFlags: general_constraint_indicator_flags,\n            generalLevelIdc: general_level_idc,\n            chromaFormatIdc,\n            bitDepthLumaMinus8,\n            bitDepthChromaMinus8,\n            minSpatialSegmentationIdc,\n        };\n    }\n    catch (error) {\n        console.error('Error parsing HEVC SPS:', error);\n        return null;\n    }\n};\n/** Builds a HevcDecoderConfigurationRecord from an HEVC packet in Annex B format. */\nexport const extractHevcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const vpsUnits = [];\n        const spsUnits = [];\n        const ppsUnits = [];\n        const seiUnits = [];\n        for (const loc of iterateHevcNalUnitsAnnexB(packetData)) {\n            const nalUnit = packetData.subarray(loc.offset, loc.offset + loc.length);\n            const type = extractNalUnitTypeForHevc(nalUnit[0]);\n            if (type === HevcNalUnitType.VPS_NUT) {\n                vpsUnits.push(nalUnit);\n            }\n            else if (type === HevcNalUnitType.SPS_NUT) {\n                spsUnits.push(nalUnit);\n            }\n            else if (type === HevcNalUnitType.PPS_NUT) {\n                ppsUnits.push(nalUnit);\n            }\n            else if (type === HevcNalUnitType.PREFIX_SEI_NUT || type === HevcNalUnitType.SUFFIX_SEI_NUT) {\n                seiUnits.push(nalUnit);\n            }\n        }\n        if (spsUnits.length === 0 || ppsUnits.length === 0)\n            return null;\n        const spsInfo = parseHevcSps(spsUnits[0]);\n        if (!spsInfo)\n            return null;\n        // Parse PPS for parallelismType\n        let parallelismType = 0;\n        if (ppsUnits.length > 0) {\n            const pps = ppsUnits[0];\n            const ppsBitstream = new Bitstream(removeEmulationPreventionBytes(pps));\n            ppsBitstream.skipBits(16); // NAL header\n            readExpGolomb(ppsBitstream); // pps_pic_parameter_set_id\n            readExpGolomb(ppsBitstream); // pps_seq_parameter_set_id\n            ppsBitstream.skipBits(1); // dependent_slice_segments_enabled_flag\n            ppsBitstream.skipBits(1); // output_flag_present_flag\n            ppsBitstream.skipBits(3); // num_extra_slice_header_bits\n            ppsBitstream.skipBits(1); // sign_data_hiding_enabled_flag\n            ppsBitstream.skipBits(1); // cabac_init_present_flag\n            readExpGolomb(ppsBitstream); // num_ref_idx_l0_default_active_minus1\n            readExpGolomb(ppsBitstream); // num_ref_idx_l1_default_active_minus1\n            readSignedExpGolomb(ppsBitstream); // init_qp_minus26\n            ppsBitstream.skipBits(1); // constrained_intra_pred_flag\n            ppsBitstream.skipBits(1); // transform_skip_enabled_flag\n            if (ppsBitstream.readBits(1)) { // cu_qp_delta_enabled_flag\n                readExpGolomb(ppsBitstream); // diff_cu_qp_delta_depth\n            }\n            readSignedExpGolomb(ppsBitstream); // pps_cb_qp_offset\n            readSignedExpGolomb(ppsBitstream); // pps_cr_qp_offset\n            ppsBitstream.skipBits(1); // pps_slice_chroma_qp_offsets_present_flag\n            ppsBitstream.skipBits(1); // weighted_pred_flag\n            ppsBitstream.skipBits(1); // weighted_bipred_flag\n            ppsBitstream.skipBits(1); // transquant_bypass_enabled_flag\n            const tiles_enabled_flag = ppsBitstream.readBits(1);\n            const entropy_coding_sync_enabled_flag = ppsBitstream.readBits(1);\n            if (!tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 0;\n            else if (tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 2;\n            else if (!tiles_enabled_flag && entropy_coding_sync_enabled_flag)\n                parallelismType = 3;\n            else\n                parallelismType = 0;\n        }\n        const arrays = [\n            ...(vpsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.VPS_NUT,\n                        nalUnits: vpsUnits,\n                    },\n                ]\n                : []),\n            ...(spsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.SPS_NUT,\n                        nalUnits: spsUnits,\n                    },\n                ]\n                : []),\n            ...(ppsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.PPS_NUT,\n                        nalUnits: ppsUnits,\n                    },\n                ]\n                : []),\n            ...(seiUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: extractNalUnitTypeForHevc(seiUnits[0][0]),\n                        nalUnits: seiUnits,\n                    },\n                ]\n                : []),\n        ];\n        const record = {\n            configurationVersion: 1,\n            generalProfileSpace: spsInfo.generalProfileSpace,\n            generalTierFlag: spsInfo.generalTierFlag,\n            generalProfileIdc: spsInfo.generalProfileIdc,\n            generalProfileCompatibilityFlags: spsInfo.generalProfileCompatibilityFlags,\n            generalConstraintIndicatorFlags: spsInfo.generalConstraintIndicatorFlags,\n            generalLevelIdc: spsInfo.generalLevelIdc,\n            minSpatialSegmentationIdc: spsInfo.minSpatialSegmentationIdc,\n            parallelismType,\n            chromaFormatIdc: spsInfo.chromaFormatIdc,\n            bitDepthLumaMinus8: spsInfo.bitDepthLumaMinus8,\n            bitDepthChromaMinus8: spsInfo.bitDepthChromaMinus8,\n            avgFrameRate: 0,\n            constantFrameRate: 0,\n            numTemporalLayers: spsInfo.spsMaxSubLayersMinus1 + 1,\n            temporalIdNested: spsInfo.spsTemporalIdNestingFlag,\n            lengthSizeMinusOne: 3,\n            arrays,\n        };\n        return record;\n    }\n    catch (error) {\n        console.error('Error building HEVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\nconst parseProfileTierLevel = (bitstream, maxNumSubLayersMinus1) => {\n    const general_profile_space = bitstream.readBits(2);\n    const general_tier_flag = bitstream.readBits(1);\n    const general_profile_idc = bitstream.readBits(5);\n    let general_profile_compatibility_flags = 0;\n    for (let i = 0; i < 32; i++) {\n        general_profile_compatibility_flags = (general_profile_compatibility_flags << 1) | bitstream.readBits(1);\n    }\n    const general_constraint_indicator_flags = new Uint8Array(6);\n    for (let i = 0; i < 6; i++) {\n        general_constraint_indicator_flags[i] = bitstream.readBits(8);\n    }\n    const general_level_idc = bitstream.readBits(8);\n    const sub_layer_profile_present_flag = [];\n    const sub_layer_level_present_flag = [];\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        sub_layer_profile_present_flag.push(bitstream.readBits(1));\n        sub_layer_level_present_flag.push(bitstream.readBits(1));\n    }\n    if (maxNumSubLayersMinus1 > 0) {\n        for (let i = maxNumSubLayersMinus1; i < 8; i++) {\n            bitstream.skipBits(2); // reserved_zero_2bits\n        }\n    }\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        if (sub_layer_profile_present_flag[i])\n            bitstream.skipBits(88);\n        if (sub_layer_level_present_flag[i])\n            bitstream.skipBits(8);\n    }\n    return {\n        general_profile_space,\n        general_tier_flag,\n        general_profile_idc,\n        general_profile_compatibility_flags,\n        general_constraint_indicator_flags,\n        general_level_idc,\n    };\n};\nconst skipScalingListData = (bitstream) => {\n    for (let sizeId = 0; sizeId < 4; sizeId++) {\n        for (let matrixId = 0; matrixId < (sizeId === 3 ? 2 : 6); matrixId++) {\n            const scaling_list_pred_mode_flag = bitstream.readBits(1);\n            if (!scaling_list_pred_mode_flag) {\n                readExpGolomb(bitstream); // scaling_list_pred_matrix_id_delta\n            }\n            else {\n                const coefNum = Math.min(64, 1 << (4 + (sizeId << 1)));\n                if (sizeId > 1) {\n                    readSignedExpGolomb(bitstream); // scaling_list_dc_coef_minus8\n                }\n                for (let i = 0; i < coefNum; i++) {\n                    readSignedExpGolomb(bitstream); // scaling_list_delta_coef\n                }\n            }\n        }\n    }\n};\nconst skipAllStRefPicSets = (bitstream, num_short_term_ref_pic_sets) => {\n    const NumDeltaPocs = [];\n    for (let stRpsIdx = 0; stRpsIdx < num_short_term_ref_pic_sets; stRpsIdx++) {\n        NumDeltaPocs[stRpsIdx] = skipStRefPicSet(bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs);\n    }\n};\nconst skipStRefPicSet = (bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs) => {\n    let NumDeltaPocsThis = 0;\n    let inter_ref_pic_set_prediction_flag = 0;\n    let RefRpsIdx = 0;\n    if (stRpsIdx !== 0) {\n        inter_ref_pic_set_prediction_flag = bitstream.readBits(1);\n    }\n    if (inter_ref_pic_set_prediction_flag) {\n        if (stRpsIdx === num_short_term_ref_pic_sets) {\n            const delta_idx_minus1 = readExpGolomb(bitstream);\n            RefRpsIdx = stRpsIdx - (delta_idx_minus1 + 1);\n        }\n        else {\n            RefRpsIdx = stRpsIdx - 1;\n        }\n        bitstream.readBits(1); // delta_rps_sign\n        readExpGolomb(bitstream); // abs_delta_rps_minus1\n        // The number of iterations is NumDeltaPocs[RefRpsIdx] + 1\n        const numDelta = NumDeltaPocs[RefRpsIdx] ?? 0;\n        for (let j = 0; j <= numDelta; j++) {\n            const used_by_curr_pic_flag = bitstream.readBits(1);\n            if (!used_by_curr_pic_flag) {\n                bitstream.readBits(1); // use_delta_flag\n            }\n        }\n        NumDeltaPocsThis = NumDeltaPocs[RefRpsIdx];\n    }\n    else {\n        const num_negative_pics = readExpGolomb(bitstream);\n        const num_positive_pics = readExpGolomb(bitstream);\n        for (let i = 0; i < num_negative_pics; i++) {\n            readExpGolomb(bitstream); // delta_poc_s0_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s0_flag[i]\n        }\n        for (let i = 0; i < num_positive_pics; i++) {\n            readExpGolomb(bitstream); // delta_poc_s1_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s1_flag[i]\n        }\n        NumDeltaPocsThis = num_negative_pics + num_positive_pics;\n    }\n    return NumDeltaPocsThis;\n};\nconst parseHevcVui = (bitstream, sps_max_sub_layers_minus1) => {\n    // Defaults: 2 = unspecified\n    let colourPrimaries = 2;\n    let transferCharacteristics = 2;\n    let matrixCoefficients = 2;\n    let fullRangeFlag = 0;\n    let minSpatialSegmentationIdc = 0;\n    if (bitstream.readBits(1)) { // aspect_ratio_info_present_flag\n        const aspect_ratio_idc = bitstream.readBits(8);\n        if (aspect_ratio_idc === 255) {\n            bitstream.readBits(16); // sar_width\n            bitstream.readBits(16); // sar_height\n        }\n    }\n    if (bitstream.readBits(1)) { // overscan_info_present_flag\n        bitstream.readBits(1); // overscan_appropriate_flag\n    }\n    if (bitstream.readBits(1)) { // video_signal_type_present_flag\n        bitstream.readBits(3); // video_format\n        fullRangeFlag = bitstream.readBits(1);\n        if (bitstream.readBits(1)) { // colour_description_present_flag\n            colourPrimaries = bitstream.readBits(8);\n            transferCharacteristics = bitstream.readBits(8);\n            matrixCoefficients = bitstream.readBits(8);\n        }\n    }\n    if (bitstream.readBits(1)) { // chroma_loc_info_present_flag\n        readExpGolomb(bitstream); // chroma_sample_loc_type_top_field\n        readExpGolomb(bitstream); // chroma_sample_loc_type_bottom_field\n    }\n    bitstream.readBits(1); // neutral_chroma_indication_flag\n    bitstream.readBits(1); // field_seq_flag\n    bitstream.readBits(1); // frame_field_info_present_flag\n    if (bitstream.readBits(1)) { // default_display_window_flag\n        readExpGolomb(bitstream); // def_disp_win_left_offset\n        readExpGolomb(bitstream); // def_disp_win_right_offset\n        readExpGolomb(bitstream); // def_disp_win_top_offset\n        readExpGolomb(bitstream); // def_disp_win_bottom_offset\n    }\n    if (bitstream.readBits(1)) { // vui_timing_info_present_flag\n        bitstream.readBits(32); // vui_num_units_in_tick\n        bitstream.readBits(32); // vui_time_scale\n        if (bitstream.readBits(1)) { // vui_poc_proportional_to_timing_flag\n            readExpGolomb(bitstream); // vui_num_ticks_poc_diff_one_minus1\n        }\n        if (bitstream.readBits(1)) {\n            skipHevcHrdParameters(bitstream, true, sps_max_sub_layers_minus1);\n        }\n    }\n    if (bitstream.readBits(1)) { // bitstream_restriction_flag\n        bitstream.readBits(1); // tiles_fixed_structure_flag\n        bitstream.readBits(1); // motion_vectors_over_pic_boundaries_flag\n        bitstream.readBits(1); // restricted_ref_pic_lists_flag\n        minSpatialSegmentationIdc = readExpGolomb(bitstream);\n        readExpGolomb(bitstream); // max_bytes_per_pic_denom\n        readExpGolomb(bitstream); // max_bits_per_min_cu_denom\n        readExpGolomb(bitstream); // log2_max_mv_length_horizontal\n        readExpGolomb(bitstream); // log2_max_mv_length_vertical\n    }\n    return {\n        colourPrimaries,\n        transferCharacteristics,\n        matrixCoefficients,\n        fullRangeFlag,\n        minSpatialSegmentationIdc,\n    };\n};\nconst skipHevcHrdParameters = (bitstream, commonInfPresentFlag, maxNumSubLayersMinus1) => {\n    let nal_hrd_parameters_present_flag = false;\n    let vcl_hrd_parameters_present_flag = false;\n    let sub_pic_hrd_params_present_flag = false;\n    if (commonInfPresentFlag) {\n        nal_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        vcl_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n            sub_pic_hrd_params_present_flag = bitstream.readBits(1) === 1;\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(8); // tick_divisor_minus2\n                bitstream.readBits(5); // du_cpb_removal_delay_increment_length_minus1\n                bitstream.readBits(1); // sub_pic_cpb_params_in_pic_timing_sei_flag\n                bitstream.readBits(5); // dpb_output_delay_du_length_minus1\n            }\n            bitstream.readBits(4); // bit_rate_scale\n            bitstream.readBits(4); // cpb_size_scale\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(4); // cpb_size_du_scale\n            }\n            bitstream.readBits(5); // initial_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // au_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // dpb_output_delay_length_minus1\n        }\n    }\n    for (let i = 0; i <= maxNumSubLayersMinus1; i++) {\n        const fixed_pic_rate_general_flag = bitstream.readBits(1) === 1;\n        let fixed_pic_rate_within_cvs_flag = true; // Default assumption if general is true\n        if (!fixed_pic_rate_general_flag) {\n            fixed_pic_rate_within_cvs_flag = bitstream.readBits(1) === 1;\n        }\n        let low_delay_hrd_flag = false; // Default assumption\n        if (fixed_pic_rate_within_cvs_flag) {\n            readExpGolomb(bitstream); // elemental_duration_in_tc_minus1[i]\n        }\n        else {\n            low_delay_hrd_flag = bitstream.readBits(1) === 1;\n        }\n        let CpbCnt = 1; // Default if low_delay is true\n        if (!low_delay_hrd_flag) {\n            const cpb_cnt_minus1 = readExpGolomb(bitstream); // cpb_cnt_minus1[i]\n            CpbCnt = cpb_cnt_minus1 + 1;\n        }\n        if (nal_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n        if (vcl_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n    }\n};\nconst skipSubLayerHrdParameters = (bitstream, CpbCnt, sub_pic_hrd_params_present_flag) => {\n    for (let i = 0; i < CpbCnt; i++) {\n        readExpGolomb(bitstream); // bit_rate_value_minus1[i]\n        readExpGolomb(bitstream); // cpb_size_value_minus1[i]\n        if (sub_pic_hrd_params_present_flag) {\n            readExpGolomb(bitstream); // cpb_size_du_value_minus1[i]\n            readExpGolomb(bitstream); // bit_rate_du_value_minus1[i]\n        }\n        bitstream.readBits(1); // cbr_flag[i]\n    }\n};\n/** Serializes an HevcDecoderConfigurationRecord into the format specified in Section 8.3.3.1 of ISO 14496-15. */\nexport const serializeHevcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    bytes.push(record.configurationVersion);\n    bytes.push(((record.generalProfileSpace & 0x3) << 6)\n        | ((record.generalTierFlag & 0x1) << 5)\n        | (record.generalProfileIdc & 0x1F));\n    bytes.push((record.generalProfileCompatibilityFlags >>> 24) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 16) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 8) & 0xFF);\n    bytes.push(record.generalProfileCompatibilityFlags & 0xFF);\n    bytes.push(...record.generalConstraintIndicatorFlags);\n    bytes.push(record.generalLevelIdc & 0xFF);\n    bytes.push(0xF0 | ((record.minSpatialSegmentationIdc >> 8) & 0x0F)); // Reserved + high nibble\n    bytes.push(record.minSpatialSegmentationIdc & 0xFF); // Low byte\n    bytes.push(0xFC | (record.parallelismType & 0x03));\n    bytes.push(0xFC | (record.chromaFormatIdc & 0x03));\n    bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07));\n    bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07));\n    bytes.push((record.avgFrameRate >> 8) & 0xFF); // High byte\n    bytes.push(record.avgFrameRate & 0xFF); // Low byte\n    bytes.push(((record.constantFrameRate & 0x03) << 6)\n        | ((record.numTemporalLayers & 0x07) << 3)\n        | ((record.temporalIdNested & 0x01) << 2)\n        | (record.lengthSizeMinusOne & 0x03));\n    bytes.push(record.arrays.length & 0xFF);\n    for (const arr of record.arrays) {\n        bytes.push(((arr.arrayCompleteness & 0x01) << 7)\n            | (0 << 6)\n            | (arr.nalUnitType & 0x3F));\n        bytes.push((arr.nalUnits.length >> 8) & 0xFF); // High byte\n        bytes.push(arr.nalUnits.length & 0xFF); // Low byte\n        for (const nal of arr.nalUnits) {\n            bytes.push((nal.length >> 8) & 0xFF); // High byte\n            bytes.push(nal.length & 0xFF); // Low byte\n            for (let i = 0; i < nal.length; i++) {\n                bytes.push(nal[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\n/** Deserializes an HevcDecoderConfigurationRecord from the format specified in Section 8.3.3.1 of ISO 14496-15. */\nexport const deserializeHevcDecoderConfigurationRecord = (data) => {\n    try {\n        const view = toDataView(data);\n        let offset = 0;\n        const configurationVersion = view.getUint8(offset++);\n        const byte1 = view.getUint8(offset++);\n        const generalProfileSpace = (byte1 >> 6) & 0x3;\n        const generalTierFlag = (byte1 >> 5) & 0x1;\n        const generalProfileIdc = byte1 & 0x1F;\n        const generalProfileCompatibilityFlags = view.getUint32(offset, false);\n        offset += 4;\n        const generalConstraintIndicatorFlags = data.subarray(offset, offset + 6);\n        offset += 6;\n        const generalLevelIdc = view.getUint8(offset++);\n        const minSpatialSegmentationIdc = ((view.getUint8(offset++) & 0x0F) << 8) | view.getUint8(offset++);\n        const parallelismType = view.getUint8(offset++) & 0x03;\n        const chromaFormatIdc = view.getUint8(offset++) & 0x03;\n        const bitDepthLumaMinus8 = view.getUint8(offset++) & 0x07;\n        const bitDepthChromaMinus8 = view.getUint8(offset++) & 0x07;\n        const avgFrameRate = view.getUint16(offset, false);\n        offset += 2;\n        const byte21 = view.getUint8(offset++);\n        const constantFrameRate = (byte21 >> 6) & 0x03;\n        const numTemporalLayers = (byte21 >> 3) & 0x07;\n        const temporalIdNested = (byte21 >> 2) & 0x01;\n        const lengthSizeMinusOne = byte21 & 0x03;\n        const numOfArrays = view.getUint8(offset++);\n        const arrays = [];\n        for (let i = 0; i < numOfArrays; i++) {\n            const arrByte = view.getUint8(offset++);\n            const arrayCompleteness = (arrByte >> 7) & 0x01;\n            const nalUnitType = arrByte & 0x3F;\n            const numNalus = view.getUint16(offset, false);\n            offset += 2;\n            const nalUnits = [];\n            for (let j = 0; j < numNalus; j++) {\n                const nalUnitLength = view.getUint16(offset, false);\n                offset += 2;\n                nalUnits.push(data.subarray(offset, offset + nalUnitLength));\n                offset += nalUnitLength;\n            }\n            arrays.push({\n                arrayCompleteness,\n                nalUnitType,\n                nalUnits,\n            });\n        }\n        return {\n            configurationVersion,\n            generalProfileSpace,\n            generalTierFlag,\n            generalProfileIdc,\n            generalProfileCompatibilityFlags,\n            generalConstraintIndicatorFlags,\n            generalLevelIdc,\n            minSpatialSegmentationIdc,\n            parallelismType,\n            chromaFormatIdc,\n            bitDepthLumaMinus8,\n            bitDepthChromaMinus8,\n            avgFrameRate,\n            constantFrameRate,\n            numTemporalLayers,\n            temporalIdNested,\n            lengthSizeMinusOne,\n            arrays,\n        };\n    }\n    catch (error) {\n        console.error('Error deserializing HEVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\nexport const extractVp9CodecInfoFromPacket = (packet) => {\n    // eslint-disable-next-line @stylistic/max-len\n    // https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.7-20170222-draft.pdf\n    // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf\n    const bitstream = new Bitstream(packet);\n    // Frame marker (0b10)\n    const frameMarker = bitstream.readBits(2);\n    if (frameMarker !== 2) {\n        return null;\n    }\n    // Profile\n    const profileLowBit = bitstream.readBits(1);\n    const profileHighBit = bitstream.readBits(1);\n    const profile = (profileHighBit << 1) + profileLowBit;\n    // Skip reserved bit for profile 3\n    if (profile === 3) {\n        bitstream.skipBits(1);\n    }\n    // show_existing_frame\n    const showExistingFrame = bitstream.readBits(1);\n    if (showExistingFrame === 1) {\n        return null;\n    }\n    // frame_type (0 = key frame)\n    const frameType = bitstream.readBits(1);\n    if (frameType !== 0) {\n        return null;\n    }\n    // Skip show_frame and error_resilient_mode\n    bitstream.skipBits(2);\n    // Sync code (0x498342)\n    const syncCode = bitstream.readBits(24);\n    if (syncCode !== 0x498342) {\n        return null;\n    }\n    // Color config\n    let bitDepth = 8;\n    if (profile >= 2) {\n        const tenOrTwelveBit = bitstream.readBits(1);\n        bitDepth = tenOrTwelveBit ? 12 : 10;\n    }\n    // Color space\n    const colorSpace = bitstream.readBits(3);\n    let chromaSubsampling = 0;\n    let videoFullRangeFlag = 0;\n    if (colorSpace !== 7) { // 7 is CS_RGB\n        const colorRange = bitstream.readBits(1);\n        videoFullRangeFlag = colorRange;\n        if (profile === 1 || profile === 3) {\n            const subsamplingX = bitstream.readBits(1);\n            const subsamplingY = bitstream.readBits(1);\n            // 0 = 4:2:0 vertical\n            // 1 = 4:2:0 colocated\n            // 2 = 4:2:2\n            // 3 = 4:4:4\n            chromaSubsampling = !subsamplingX && !subsamplingY\n                ? 3 // 0,0 = 4:4:4\n                : subsamplingX && !subsamplingY\n                    ? 2 // 1,0 = 4:2:2\n                    : 1; // 1,1 = 4:2:0 colocated (default)\n            // Skip reserved bit\n            bitstream.skipBits(1);\n        }\n        else {\n            // For profile 0 and 2, always 4:2:0\n            chromaSubsampling = 1; // Using colocated as default\n        }\n    }\n    else {\n        // RGB is always 4:4:4\n        chromaSubsampling = 3;\n        videoFullRangeFlag = 1;\n    }\n    // Parse frame size\n    const widthMinusOne = bitstream.readBits(16);\n    const heightMinusOne = bitstream.readBits(16);\n    const width = widthMinusOne + 1;\n    const height = heightMinusOne + 1;\n    // Calculate level based on dimensions\n    const pictureSize = width * height;\n    let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n    for (const entry of VP9_LEVEL_TABLE) {\n        if (pictureSize <= entry.maxPictureSize) {\n            level = entry.level;\n            break;\n        }\n    }\n    // Map color_space to standard values\n    const matrixCoefficients = colorSpace === 7\n        ? 0\n        : colorSpace === 2\n            ? 1\n            : colorSpace === 1\n                ? 6\n                : 2;\n    const colourPrimaries = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    const transferCharacteristics = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    return {\n        profile,\n        level,\n        bitDepth,\n        chromaSubsampling,\n        videoFullRangeFlag,\n        colourPrimaries,\n        transferCharacteristics,\n        matrixCoefficients,\n    };\n};\n/** Iterates over all OBUs in an AV1 packet bistream. */\nexport const iterateAv1PacketObus = function* (packet) {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    const bitstream = new Bitstream(packet);\n    const readLeb128 = () => {\n        let value = 0;\n        for (let i = 0; i < 8; i++) {\n            const byte = bitstream.readAlignedByte();\n            value |= ((byte & 0x7f) << (i * 7));\n            if (!(byte & 0x80)) {\n                break;\n            }\n            // Spec requirement\n            if (i === 7 && (byte & 0x80)) {\n                return null;\n            }\n        }\n        // Spec requirement\n        if (value >= 2 ** 32 - 1) {\n            return null;\n        }\n        return value;\n    };\n    while (bitstream.getBitsLeft() >= 8) {\n        // Parse OBU header\n        bitstream.skipBits(1);\n        const obuType = bitstream.readBits(4);\n        const obuExtension = bitstream.readBits(1);\n        const obuHasSizeField = bitstream.readBits(1);\n        bitstream.skipBits(1);\n        // Skip extension header if present\n        if (obuExtension) {\n            bitstream.skipBits(8);\n        }\n        // Read OBU size if present\n        let obuSize;\n        if (obuHasSizeField) {\n            const obuSizeValue = readLeb128();\n            if (obuSizeValue === null)\n                return; // It was invalid\n            obuSize = obuSizeValue;\n        }\n        else {\n            // Calculate remaining bits and convert to bytes, rounding down\n            obuSize = Math.floor(bitstream.getBitsLeft() / 8);\n        }\n        assert(bitstream.pos % 8 === 0);\n        yield {\n            type: obuType,\n            data: packet.subarray(bitstream.pos / 8, bitstream.pos / 8 + obuSize),\n        };\n        // Move to next OBU\n        bitstream.skipBits(obuSize * 8);\n    }\n};\n/**\n * When AV1 codec information is not provided by the container, we can still try to extract the information by digging\n * into the AV1 bitstream.\n */\nexport const extractAv1CodecInfoFromPacket = (packet) => {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    for (const { type, data } of iterateAv1PacketObus(packet)) {\n        if (type !== 1) {\n            continue; // 1 == OBU_SEQUENCE_HEADER\n        }\n        const bitstream = new Bitstream(data);\n        // Read sequence header fields\n        const seqProfile = bitstream.readBits(3);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const stillPicture = bitstream.readBits(1);\n        const reducedStillPictureHeader = bitstream.readBits(1);\n        let seqLevel = 0;\n        let seqTier = 0;\n        let bufferDelayLengthMinus1 = 0;\n        if (reducedStillPictureHeader) {\n            seqLevel = bitstream.readBits(5);\n        }\n        else {\n            // Parse timing_info_present_flag\n            const timingInfoPresentFlag = bitstream.readBits(1);\n            if (timingInfoPresentFlag) {\n                // Skip timing info (num_units_in_display_tick, time_scale, equal_picture_interval)\n                bitstream.skipBits(32); // num_units_in_display_tick\n                bitstream.skipBits(32); // time_scale\n                const equalPictureInterval = bitstream.readBits(1);\n                if (equalPictureInterval) {\n                    // Skip num_ticks_per_picture_minus_1 (uvlc)\n                    // Since this is variable length, we'd need to implement uvlc reading\n                    // For now, we'll return null as this is rare\n                    return null;\n                }\n            }\n            // Parse decoder_model_info_present_flag\n            const decoderModelInfoPresentFlag = bitstream.readBits(1);\n            if (decoderModelInfoPresentFlag) {\n                // Store buffer_delay_length_minus_1 instead of just skipping\n                bufferDelayLengthMinus1 = bitstream.readBits(5);\n                bitstream.skipBits(32); // num_units_in_decoding_tick\n                bitstream.skipBits(5); // buffer_removal_time_length_minus_1\n                bitstream.skipBits(5); // frame_presentation_time_length_minus_1\n            }\n            // Parse operating_points_cnt_minus_1\n            const operatingPointsCntMinus1 = bitstream.readBits(5);\n            // For each operating point\n            for (let i = 0; i <= operatingPointsCntMinus1; i++) {\n                // operating_point_idc[i]\n                bitstream.skipBits(12);\n                // seq_level_idx[i]\n                const seqLevelIdx = bitstream.readBits(5);\n                if (i === 0) {\n                    seqLevel = seqLevelIdx;\n                }\n                if (seqLevelIdx > 7) {\n                    // seq_tier[i]\n                    const seqTierTemp = bitstream.readBits(1);\n                    if (i === 0) {\n                        seqTier = seqTierTemp;\n                    }\n                }\n                if (decoderModelInfoPresentFlag) {\n                    // decoder_model_present_for_this_op[i]\n                    const decoderModelPresentForThisOp = bitstream.readBits(1);\n                    if (decoderModelPresentForThisOp) {\n                        const n = bufferDelayLengthMinus1 + 1;\n                        bitstream.skipBits(n); // decoder_buffer_delay[op]\n                        bitstream.skipBits(n); // encoder_buffer_delay[op]\n                        bitstream.skipBits(1); // low_delay_mode_flag[op]\n                    }\n                }\n                // initial_display_delay_present_flag\n                const initialDisplayDelayPresentFlag = bitstream.readBits(1);\n                if (initialDisplayDelayPresentFlag) {\n                    // initial_display_delay_minus_1[i]\n                    bitstream.skipBits(4);\n                }\n            }\n        }\n        // Frame size\n        const frameWidthBitsMinus1 = bitstream.readBits(4);\n        const frameHeightBitsMinus1 = bitstream.readBits(4);\n        const n1 = frameWidthBitsMinus1 + 1;\n        bitstream.skipBits(n1); // max_frame_width_minus_1\n        const n2 = frameHeightBitsMinus1 + 1;\n        bitstream.skipBits(n2); // max_frame_height_minus_1\n        // Frame IDs\n        let frameIdNumbersPresentFlag = 0;\n        if (reducedStillPictureHeader) {\n            frameIdNumbersPresentFlag = 0;\n        }\n        else {\n            frameIdNumbersPresentFlag = bitstream.readBits(1);\n        }\n        if (frameIdNumbersPresentFlag) {\n            bitstream.skipBits(4); // delta_frame_id_length_minus_2\n            bitstream.skipBits(3); // additional_frame_id_length_minus_1\n        }\n        bitstream.skipBits(1); // use_128x128_superblock\n        bitstream.skipBits(1); // enable_filter_intra\n        bitstream.skipBits(1); // enable_intra_edge_filter\n        if (!reducedStillPictureHeader) {\n            bitstream.skipBits(1); // enable_interintra_compound\n            bitstream.skipBits(1); // enable_masked_compound\n            bitstream.skipBits(1); // enable_warped_motion\n            bitstream.skipBits(1); // enable_dual_filter\n            const enableOrderHint = bitstream.readBits(1);\n            if (enableOrderHint) {\n                bitstream.skipBits(1); // enable_jnt_comp\n                bitstream.skipBits(1); // enable_ref_frame_mvs\n            }\n            const seqChooseScreenContentTools = bitstream.readBits(1);\n            let seqForceScreenContentTools = 0;\n            if (seqChooseScreenContentTools) {\n                seqForceScreenContentTools = 2; // SELECT_SCREEN_CONTENT_TOOLS\n            }\n            else {\n                seqForceScreenContentTools = bitstream.readBits(1);\n            }\n            if (seqForceScreenContentTools > 0) {\n                const seqChooseIntegerMv = bitstream.readBits(1);\n                if (!seqChooseIntegerMv) {\n                    bitstream.skipBits(1); // seq_force_integer_mv\n                }\n            }\n            if (enableOrderHint) {\n                bitstream.skipBits(3); // order_hint_bits_minus_1\n            }\n        }\n        bitstream.skipBits(1); // enable_superres\n        bitstream.skipBits(1); // enable_cdef\n        bitstream.skipBits(1); // enable_restoration\n        // color_config()\n        const highBitdepth = bitstream.readBits(1);\n        let bitDepth = 8;\n        if (seqProfile === 2 && highBitdepth) {\n            const twelveBit = bitstream.readBits(1);\n            bitDepth = twelveBit ? 12 : 10;\n        }\n        else if (seqProfile <= 2) {\n            bitDepth = highBitdepth ? 10 : 8;\n        }\n        let monochrome = 0;\n        if (seqProfile !== 1) {\n            monochrome = bitstream.readBits(1);\n        }\n        let chromaSubsamplingX = 1;\n        let chromaSubsamplingY = 1;\n        let chromaSamplePosition = 0;\n        if (!monochrome) {\n            if (seqProfile === 0) {\n                chromaSubsamplingX = 1;\n                chromaSubsamplingY = 1;\n            }\n            else if (seqProfile === 1) {\n                chromaSubsamplingX = 0;\n                chromaSubsamplingY = 0;\n            }\n            else {\n                if (bitDepth === 12) {\n                    chromaSubsamplingX = bitstream.readBits(1);\n                    if (chromaSubsamplingX) {\n                        chromaSubsamplingY = bitstream.readBits(1);\n                    }\n                }\n            }\n            if (chromaSubsamplingX && chromaSubsamplingY) {\n                chromaSamplePosition = bitstream.readBits(2);\n            }\n        }\n        return {\n            profile: seqProfile,\n            level: seqLevel,\n            tier: seqTier,\n            bitDepth,\n            monochrome,\n            chromaSubsamplingX,\n            chromaSubsamplingY,\n            chromaSamplePosition,\n        };\n    }\n    return null;\n};\nexport const parseOpusIdentificationHeader = (bytes) => {\n    const view = toDataView(bytes);\n    const outputChannelCount = view.getUint8(9);\n    const preSkip = view.getUint16(10, true);\n    const inputSampleRate = view.getUint32(12, true);\n    const outputGain = view.getInt16(16, true);\n    const channelMappingFamily = view.getUint8(18);\n    let channelMappingTable = null;\n    if (channelMappingFamily) {\n        channelMappingTable = bytes.subarray(19, 19 + 2 + outputChannelCount);\n    }\n    return {\n        outputChannelCount,\n        preSkip,\n        inputSampleRate,\n        outputGain,\n        channelMappingFamily,\n        channelMappingTable,\n    };\n};\n// From https://datatracker.ietf.org/doc/html/rfc6716, in 48 kHz samples\nconst OPUS_FRAME_DURATION_TABLE = [\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960,\n    480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n];\nexport const parseOpusTocByte = (packet) => {\n    const config = packet[0] >> 3;\n    return {\n        durationInSamples: OPUS_FRAME_DURATION_TABLE[config],\n    };\n};\n// Based on vorbis_parser.c from FFmpeg.\nexport const parseModesFromVorbisSetupPacket = (setupHeader) => {\n    // Verify that this is a Setup header.\n    if (setupHeader.length < 7) {\n        throw new Error('Setup header is too short.');\n    }\n    if (setupHeader[0] !== 5) {\n        throw new Error('Wrong packet type in Setup header.');\n    }\n    const signature = String.fromCharCode(...setupHeader.slice(1, 7));\n    if (signature !== 'vorbis') {\n        throw new Error('Invalid packet signature in Setup header.');\n    }\n    // Reverse the entire buffer.\n    const bufSize = setupHeader.length;\n    const revBuffer = new Uint8Array(bufSize);\n    for (let i = 0; i < bufSize; i++) {\n        revBuffer[i] = setupHeader[bufSize - 1 - i];\n    }\n    // Initialize a Bitstream on the reversed buffer.\n    const bitstream = new Bitstream(revBuffer);\n    // --- Find the framing bit.\n    // In FFmpeg code, we scan until get_bits1() returns 1.\n    let gotFramingBit = 0;\n    while (bitstream.getBitsLeft() > 97) {\n        if (bitstream.readBits(1) === 1) {\n            gotFramingBit = bitstream.pos;\n            break;\n        }\n    }\n    if (gotFramingBit === 0) {\n        throw new Error('Invalid Setup header: framing bit not found.');\n    }\n    // --- Search backwards for a valid mode header.\n    // We try to guess the number of modes by reading a fixed pattern.\n    let modeCount = 0;\n    let gotModeHeader = false;\n    let lastModeCount = 0;\n    while (bitstream.getBitsLeft() >= 97) {\n        const tempPos = bitstream.pos;\n        const a = bitstream.readBits(8);\n        const b = bitstream.readBits(16);\n        const c = bitstream.readBits(16);\n        // If a > 63 or b or c nonzero, assume weve gone too far.\n        if (a > 63 || b !== 0 || c !== 0) {\n            bitstream.pos = tempPos;\n            break;\n        }\n        bitstream.skipBits(1);\n        modeCount++;\n        if (modeCount > 64) {\n            break;\n        }\n        const bsClone = bitstream.clone();\n        const candidate = bsClone.readBits(6) + 1;\n        if (candidate === modeCount) {\n            gotModeHeader = true;\n            lastModeCount = modeCount;\n        }\n    }\n    if (!gotModeHeader) {\n        throw new Error('Invalid Setup header: mode header not found.');\n    }\n    if (lastModeCount > 63) {\n        throw new Error(`Unsupported mode count: ${lastModeCount}.`);\n    }\n    const finalModeCount = lastModeCount;\n    // --- Reinitialize the bitstream.\n    bitstream.pos = 0;\n    // Skip the bits up to the found framing bit.\n    bitstream.skipBits(gotFramingBit);\n    // --- Now read, for each mode (in reverse order), 40 bits then one bit.\n    // That one bit is the mode blockflag.\n    const modeBlockflags = Array(finalModeCount).fill(0);\n    for (let i = finalModeCount - 1; i >= 0; i--) {\n        bitstream.skipBits(40);\n        modeBlockflags[i] = bitstream.readBits(1);\n    }\n    return { modeBlockflags };\n};\n/** Determines a packet's type (key or delta) by digging into the packet bitstream. */\nexport const determineVideoPacketType = (codec, decoderConfig, packetData) => {\n    switch (codec) {\n        case 'avc':\n            {\n                for (const loc of iterateAvcNalUnits(packetData, decoderConfig)) {\n                    const nalTypeByte = packetData[loc.offset];\n                    const type = extractNalUnitTypeForAvc(nalTypeByte);\n                    if (type >= AvcNalUnitType.NON_IDR_SLICE && type <= AvcNalUnitType.SLICE_DPC) {\n                        return 'delta';\n                    }\n                    if (type === AvcNalUnitType.IDR) {\n                        return 'key';\n                    }\n                    // In addition to IDR, Recovery Point SEI also counts as a valid H.264 keyframe by current consensus.\n                    // See https://github.com/w3c/webcodecs/issues/650 for the relevant discussion. WebKit and Firefox have\n                    // always supported them, but Chromium hasn't, therefore the (admittedly dirty) version check.\n                    if (type === AvcNalUnitType.SEI && (!isChromium() || getChromiumVersion() >= 144)) {\n                        const nalUnit = packetData.subarray(loc.offset, loc.offset + loc.length);\n                        const bytes = removeEmulationPreventionBytes(nalUnit);\n                        let pos = 1; // Skip NALU header\n                        // sei_rbsp()\n                        do {\n                            // sei_message()\n                            let payloadType = 0;\n                            while (true) {\n                                const nextByte = bytes[pos++];\n                                if (nextByte === undefined)\n                                    break;\n                                payloadType += nextByte;\n                                if (nextByte < 255) {\n                                    break;\n                                }\n                            }\n                            let payloadSize = 0;\n                            while (true) {\n                                const nextByte = bytes[pos++];\n                                if (nextByte === undefined)\n                                    break;\n                                payloadSize += nextByte;\n                                if (nextByte < 255) {\n                                    break;\n                                }\n                            }\n                            // sei_payload()\n                            const PAYLOAD_TYPE_RECOVERY_POINT = 6;\n                            if (payloadType === PAYLOAD_TYPE_RECOVERY_POINT) {\n                                const bitstream = new Bitstream(bytes);\n                                bitstream.pos = 8 * pos;\n                                const recoveryFrameCount = readExpGolomb(bitstream);\n                                const exactMatchFlag = bitstream.readBits(1);\n                                if (recoveryFrameCount === 0 && exactMatchFlag === 1) {\n                                    // https://github.com/w3c/webcodecs/pull/910\n                                    // \"recovery_frame_cnt == 0 and exact_match_flag=1 in the SEI recovery payload\"\n                                    return 'key';\n                                }\n                            }\n                            pos += payloadSize;\n                        } while (pos < bytes.length - 1);\n                    }\n                }\n                return 'delta';\n            }\n            ;\n        case 'hevc':\n            {\n                for (const loc of iterateHevcNalUnits(packetData, decoderConfig)) {\n                    const type = extractNalUnitTypeForHevc(packetData[loc.offset]);\n                    if (type < HevcNalUnitType.BLA_W_LP) {\n                        return 'delta';\n                    }\n                    if (type <= HevcNalUnitType.RSV_IRAP_VCL23) {\n                        return 'key';\n                    }\n                }\n                return 'delta';\n            }\n            ;\n        case 'vp8':\n            {\n                // VP8, once again, by far the easiest to deal with.\n                const frameType = packetData[0] & 0b1;\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'vp9':\n            {\n                const bitstream = new Bitstream(packetData);\n                if (bitstream.readBits(2) !== 2) {\n                    return null;\n                }\n                ;\n                const profileLowBit = bitstream.readBits(1);\n                const profileHighBit = bitstream.readBits(1);\n                const profile = (profileHighBit << 1) + profileLowBit;\n                // Skip reserved bit for profile 3\n                if (profile === 3) {\n                    bitstream.skipBits(1);\n                }\n                const showExistingFrame = bitstream.readBits(1);\n                if (showExistingFrame) {\n                    return null;\n                }\n                const frameType = bitstream.readBits(1);\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'av1':\n            {\n                let reducedStillPictureHeader = false;\n                for (const { type, data } of iterateAv1PacketObus(packetData)) {\n                    if (type === 1) { // OBU_SEQUENCE_HEADER\n                        const bitstream = new Bitstream(data);\n                        bitstream.skipBits(4);\n                        reducedStillPictureHeader = !!bitstream.readBits(1);\n                    }\n                    else if (type === 3 // OBU_FRAME_HEADER\n                        || type === 6 // OBU_FRAME\n                        || type === 7 // OBU_REDUNDANT_FRAME_HEADER\n                    ) {\n                        if (reducedStillPictureHeader) {\n                            return 'key';\n                        }\n                        const bitstream = new Bitstream(data);\n                        const showExistingFrame = bitstream.readBits(1);\n                        if (showExistingFrame) {\n                            return null;\n                        }\n                        const frameType = bitstream.readBits(2);\n                        return frameType === 0 ? 'key' : 'delta';\n                    }\n                }\n                return null;\n            }\n            ;\n        default:\n            {\n                assertNever(codec);\n                assert(false);\n            }\n            ;\n    }\n};\nexport var FlacBlockType;\n(function (FlacBlockType) {\n    FlacBlockType[FlacBlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n    FlacBlockType[FlacBlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n    FlacBlockType[FlacBlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(FlacBlockType || (FlacBlockType = {}));\nexport const readVorbisComments = (bytes, metadataTags) => {\n    // https://datatracker.ietf.org/doc/html/rfc7845#section-5.2\n    const commentView = toDataView(bytes);\n    let commentPos = 0;\n    const vendorStringLength = commentView.getUint32(commentPos, true);\n    commentPos += 4;\n    const vendorString = textDecoder.decode(bytes.subarray(commentPos, commentPos + vendorStringLength));\n    commentPos += vendorStringLength;\n    if (vendorStringLength > 0) {\n        // Expose the vendor string in the raw metadata\n        metadataTags.raw ??= {};\n        metadataTags.raw['vendor'] ??= vendorString;\n    }\n    const listLength = commentView.getUint32(commentPos, true);\n    commentPos += 4;\n    // Loop over all metadata tags\n    for (let i = 0; i < listLength; i++) {\n        const stringLength = commentView.getUint32(commentPos, true);\n        commentPos += 4;\n        const string = textDecoder.decode(bytes.subarray(commentPos, commentPos + stringLength));\n        commentPos += stringLength;\n        const separatorIndex = string.indexOf('=');\n        if (separatorIndex === -1) {\n            continue;\n        }\n        const key = string.slice(0, separatorIndex).toUpperCase();\n        const value = string.slice(separatorIndex + 1);\n        metadataTags.raw ??= {};\n        metadataTags.raw[key] ??= value;\n        switch (key) {\n            case 'TITLE':\n                {\n                    metadataTags.title ??= value;\n                }\n                ;\n                break;\n            case 'DESCRIPTION':\n                {\n                    metadataTags.description ??= value;\n                }\n                ;\n                break;\n            case 'ARTIST':\n                {\n                    metadataTags.artist ??= value;\n                }\n                ;\n                break;\n            case 'ALBUM':\n                {\n                    metadataTags.album ??= value;\n                }\n                ;\n                break;\n            case 'ALBUMARTIST':\n                {\n                    metadataTags.albumArtist ??= value;\n                }\n                ;\n                break;\n            case 'COMMENT':\n                {\n                    metadataTags.comment ??= value;\n                }\n                ;\n                break;\n            case 'LYRICS':\n                {\n                    metadataTags.lyrics ??= value;\n                }\n                ;\n                break;\n            case 'TRACKNUMBER':\n                {\n                    const parts = value.split('/');\n                    const trackNum = Number.parseInt(parts[0], 10);\n                    const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(trackNum) && trackNum > 0) {\n                        metadataTags.trackNumber ??= trackNum;\n                    }\n                    if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                        metadataTags.tracksTotal ??= tracksTotal;\n                    }\n                }\n                ;\n                break;\n            case 'TRACKTOTAL':\n                {\n                    const tracksTotal = Number.parseInt(value, 10);\n                    if (Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                        metadataTags.tracksTotal ??= tracksTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DISCNUMBER':\n                {\n                    const parts = value.split('/');\n                    const discNum = Number.parseInt(parts[0], 10);\n                    const discsTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(discNum) && discNum > 0) {\n                        metadataTags.discNumber ??= discNum;\n                    }\n                    if (discsTotal && Number.isInteger(discsTotal) && discsTotal > 0) {\n                        metadataTags.discsTotal ??= discsTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DISCTOTAL':\n                {\n                    const discsTotal = Number.parseInt(value, 10);\n                    if (Number.isInteger(discsTotal) && discsTotal > 0) {\n                        metadataTags.discsTotal ??= discsTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DATE':\n                {\n                    const date = new Date(value);\n                    if (!Number.isNaN(date.getTime())) {\n                        metadataTags.date ??= date;\n                    }\n                }\n                ;\n                break;\n            case 'GENRE':\n                {\n                    metadataTags.genre ??= value;\n                }\n                ;\n                break;\n            case 'METADATA_BLOCK_PICTURE':\n                {\n                    // https://datatracker.ietf.org/doc/rfc9639/ Section 8.8\n                    const decoded = base64ToBytes(value);\n                    const view = toDataView(decoded);\n                    const pictureType = view.getUint32(0, false);\n                    const mediaTypeLength = view.getUint32(4, false);\n                    const mediaType = String.fromCharCode(...decoded.subarray(8, 8 + mediaTypeLength)); // ASCII\n                    const descriptionLength = view.getUint32(8 + mediaTypeLength, false);\n                    const description = textDecoder.decode(decoded.subarray(12 + mediaTypeLength, 12 + mediaTypeLength + descriptionLength));\n                    const dataLength = view.getUint32(mediaTypeLength + descriptionLength + 28);\n                    const data = decoded.subarray(mediaTypeLength + descriptionLength + 32, mediaTypeLength + descriptionLength + 32 + dataLength);\n                    metadataTags.images ??= [];\n                    metadataTags.images.push({\n                        data,\n                        mimeType: mediaType,\n                        kind: pictureType === 3 ? 'coverFront' : pictureType === 4 ? 'coverBack' : 'unknown',\n                        name: undefined,\n                        description: description || undefined,\n                    });\n                }\n                ;\n                break;\n        }\n    }\n};\nexport const createVorbisComments = (headerBytes, tags, writeImages) => {\n    // https://datatracker.ietf.org/doc/html/rfc7845#section-5.2\n    const commentHeaderParts = [\n        headerBytes,\n    ];\n    const vendorString = 'Mediabunny';\n    const encodedVendorString = textEncoder.encode(vendorString);\n    let currentBuffer = new Uint8Array(4 + encodedVendorString.length);\n    let currentView = new DataView(currentBuffer.buffer);\n    currentView.setUint32(0, encodedVendorString.length, true);\n    currentBuffer.set(encodedVendorString, 4);\n    commentHeaderParts.push(currentBuffer);\n    const writtenTags = new Set();\n    const addCommentTag = (key, value) => {\n        const joined = `${key}=${value}`;\n        const encoded = textEncoder.encode(joined);\n        currentBuffer = new Uint8Array(4 + encoded.length);\n        currentView = new DataView(currentBuffer.buffer);\n        currentView.setUint32(0, encoded.length, true);\n        currentBuffer.set(encoded, 4);\n        commentHeaderParts.push(currentBuffer);\n        writtenTags.add(key);\n    };\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    addCommentTag('TITLE', value);\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    addCommentTag('DESCRIPTION', value);\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    addCommentTag('ARTIST', value);\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    addCommentTag('ALBUM', value);\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    addCommentTag('ALBUMARTIST', value);\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    addCommentTag('GENRE', value);\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    const rawVersion = tags.raw?.['DATE'] ?? tags.raw?.['date'];\n                    if (rawVersion && typeof rawVersion === 'string') {\n                        addCommentTag('DATE', rawVersion);\n                    }\n                    else {\n                        addCommentTag('DATE', value.toISOString().slice(0, 10));\n                    }\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    addCommentTag('COMMENT', value);\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    addCommentTag('LYRICS', value);\n                }\n                ;\n                break;\n            case 'trackNumber':\n                {\n                    addCommentTag('TRACKNUMBER', value.toString());\n                }\n                ;\n                break;\n            case 'tracksTotal':\n                {\n                    addCommentTag('TRACKTOTAL', value.toString());\n                }\n                ;\n                break;\n            case 'discNumber':\n                {\n                    addCommentTag('DISCNUMBER', value.toString());\n                }\n                ;\n                break;\n            case 'discsTotal':\n                {\n                    addCommentTag('DISCTOTAL', value.toString());\n                }\n                ;\n                break;\n            case 'images':\n                {\n                    // For example, in .flac, we put the pictures in a different section,\n                    // not in the Vorbis comment header.\n                    if (!writeImages) {\n                        break;\n                    }\n                    for (const image of value) {\n                        // https://datatracker.ietf.org/doc/rfc9639/ Section 8.8\n                        const pictureType = image.kind === 'coverFront' ? 3 : image.kind === 'coverBack' ? 4 : 0;\n                        const encodedMediaType = new Uint8Array(image.mimeType.length);\n                        for (let i = 0; i < image.mimeType.length; i++) {\n                            encodedMediaType[i] = image.mimeType.charCodeAt(i);\n                        }\n                        const encodedDescription = textEncoder.encode(image.description ?? '');\n                        const buffer = new Uint8Array(4 // Picture type\n                            + 4 // MIME type length\n                            + encodedMediaType.length // MIME type\n                            + 4 // Description length\n                            + encodedDescription.length // Description\n                            + 16 // Width, height, color depth, number of colors\n                            + 4 // Picture data length\n                            + image.data.length);\n                        const view = toDataView(buffer);\n                        view.setUint32(0, pictureType, false);\n                        view.setUint32(4, encodedMediaType.length, false);\n                        buffer.set(encodedMediaType, 8);\n                        view.setUint32(8 + encodedMediaType.length, encodedDescription.length, false);\n                        buffer.set(encodedDescription, 12 + encodedMediaType.length);\n                        // Skip a bunch of fields (width, height, color depth, number of colors)\n                        view.setUint32(28 + encodedMediaType.length + encodedDescription.length, image.data.length, false);\n                        buffer.set(image.data, 32 + encodedMediaType.length + encodedDescription.length);\n                        const encoded = bytesToBase64(buffer);\n                        addCommentTag('METADATA_BLOCK_PICTURE', encoded);\n                    }\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key] ?? tags.raw[key.toLowerCase()];\n            if (key === 'vendor' || value == null || writtenTags.has(key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                addCommentTag(key, value);\n            }\n        }\n    }\n    const listLengthBuffer = new Uint8Array(4);\n    toDataView(listLengthBuffer).setUint32(0, writtenTags.size, true);\n    commentHeaderParts.splice(2, 0, listLengthBuffer); // Insert after the header and vendor section\n    // Merge all comment header parts into a single buffer\n    const commentHeaderLength = commentHeaderParts.reduce((a, b) => a + b.length, 0);\n    const commentHeader = new Uint8Array(commentHeaderLength);\n    let pos = 0;\n    for (const part of commentHeaderParts) {\n        commentHeader.set(part, pos);\n        pos += part.length;\n    }\n    return commentHeader;\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Base class for custom video decoders. To add your own custom video decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using {@link registerDecoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomVideoDecoder {\n    /** Returns true if and only if the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio decoders. To add your own custom audio decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using {@link registerDecoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomAudioDecoder {\n    /** Returns true if and only if the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom video encoders. To add your own custom video encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using {@link registerEncoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomVideoEncoder {\n    /** Returns true if and only if the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio encoders. To add your own custom audio encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using {@link registerEncoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomAudioEncoder {\n    /** Returns true if and only if the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\nexport const customVideoDecoders = [];\nexport const customAudioDecoders = [];\nexport const customVideoEncoders = [];\nexport const customAudioEncoders = [];\n/**\n * Registers a custom video or audio decoder. Registered decoders will automatically be used for decoding whenever\n * possible.\n * @group Custom coders\n * @public\n */\nexport const registerDecoder = (decoder) => {\n    if (decoder.prototype instanceof CustomVideoDecoder) {\n        const casted = decoder;\n        if (customVideoDecoders.includes(casted)) {\n            console.warn('Video decoder already registered.');\n            return;\n        }\n        customVideoDecoders.push(casted);\n    }\n    else if (decoder.prototype instanceof CustomAudioDecoder) {\n        const casted = decoder;\n        if (customAudioDecoders.includes(casted)) {\n            console.warn('Audio decoder already registered.');\n            return;\n        }\n        customAudioDecoders.push(casted);\n    }\n    else {\n        throw new TypeError('Decoder must be a CustomVideoDecoder or CustomAudioDecoder.');\n    }\n};\n/**\n * Registers a custom video or audio encoder. Registered encoders will automatically be used for encoding whenever\n * possible.\n * @group Custom coders\n * @public\n */\nexport const registerEncoder = (encoder) => {\n    if (encoder.prototype instanceof CustomVideoEncoder) {\n        const casted = encoder;\n        if (customVideoEncoders.includes(casted)) {\n            console.warn('Video encoder already registered.');\n            return;\n        }\n        customVideoEncoders.push(casted);\n    }\n    else if (encoder.prototype instanceof CustomAudioEncoder) {\n        const casted = encoder;\n        if (customAudioEncoders.includes(casted)) {\n            console.warn('Audio encoder already registered.');\n            return;\n        }\n        customAudioEncoders.push(casted);\n    }\n    else {\n        throw new TypeError('Encoder must be a CustomVideoEncoder or CustomAudioEncoder.');\n    }\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { SECOND_TO_MICROSECOND_FACTOR } from './misc.js';\nexport const PLACEHOLDER_DATA = /* #__PURE__ */ new Uint8Array(0);\n/**\n * Represents an encoded chunk of media. Mainly used as an expressive wrapper around WebCodecs API's\n * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) and\n * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk), but can also be used\n * standalone.\n * @group Packets\n * @public\n */\nexport class EncodedPacket {\n    /** Creates a new {@link EncodedPacket} from raw bytes and timing information. */\n    constructor(\n    /** The encoded data of this packet. */\n    data, \n    /** The type of this packet. */\n    type, \n    /**\n     * The presentation timestamp of this packet in seconds. May be negative. Samples with negative end timestamps\n     * should not be presented.\n     */\n    timestamp, \n    /** The duration of this packet in seconds. */\n    duration, \n    /**\n     * The sequence number indicates the decode order of the packets. Packet A  must be decoded before packet B if A\n     * has a lower sequence number than B. If two packets have the same sequence number, they are the same packet.\n     * Otherwise, sequence numbers are arbitrary and are not guaranteed to have any meaning besides their relative\n     * ordering. Negative sequence numbers mean the sequence number is undefined.\n     */\n    sequenceNumber = -1, byteLength, sideData) {\n        this.data = data;\n        this.type = type;\n        this.timestamp = timestamp;\n        this.duration = duration;\n        this.sequenceNumber = sequenceNumber;\n        if (data === PLACEHOLDER_DATA && byteLength === undefined) {\n            throw new Error('Internal error: byteLength must be explicitly provided when constructing metadata-only packets.');\n        }\n        if (byteLength === undefined) {\n            byteLength = data.byteLength;\n        }\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (type !== 'key' && type !== 'delta') {\n            throw new TypeError('type must be either \"key\" or \"delta\".');\n        }\n        if (!Number.isFinite(timestamp)) {\n            throw new TypeError('timestamp must be a number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        if (!Number.isFinite(sequenceNumber)) {\n            throw new TypeError('sequenceNumber must be a number.');\n        }\n        if (!Number.isInteger(byteLength) || byteLength < 0) {\n            throw new TypeError('byteLength must be a non-negative integer.');\n        }\n        if (sideData !== undefined && (typeof sideData !== 'object' || !sideData)) {\n            throw new TypeError('sideData, when provided, must be an object.');\n        }\n        if (sideData?.alpha !== undefined && !(sideData.alpha instanceof Uint8Array)) {\n            throw new TypeError('sideData.alpha, when provided, must be a Uint8Array.');\n        }\n        if (sideData?.alphaByteLength !== undefined\n            && (!Number.isInteger(sideData.alphaByteLength) || sideData.alphaByteLength < 0)) {\n            throw new TypeError('sideData.alphaByteLength, when provided, must be a non-negative integer.');\n        }\n        this.byteLength = byteLength;\n        this.sideData = sideData ?? {};\n        if (this.sideData.alpha && this.sideData.alphaByteLength === undefined) {\n            this.sideData.alphaByteLength = this.sideData.alpha.byteLength;\n        }\n    }\n    /**\n     * If this packet is a metadata-only packet. Metadata-only packets don't contain their packet data. They are the\n     * result of retrieving packets with {@link PacketRetrievalOptions.metadataOnly} set to `true`.\n     */\n    get isMetadataOnly() {\n        return this.data === PLACEHOLDER_DATA;\n    }\n    /** The timestamp of this packet in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of this packet in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /** Converts this packet to an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) for use with the\n     * WebCodecs API. */\n    toEncodedVideoChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to a video chunk.');\n        }\n        if (typeof EncodedVideoChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedVideoChunk.');\n        }\n        return new EncodedVideoChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /**\n     * Converts this packet to an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) for use with the\n     * WebCodecs API, using the alpha side data instead of the color data. Throws if no alpha side data is defined.\n     */\n    alphaToEncodedVideoChunk(type = this.type) {\n        if (!this.sideData.alpha) {\n            throw new TypeError('This packet does not contain alpha side data.');\n        }\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to a video chunk.');\n        }\n        if (typeof EncodedVideoChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedVideoChunk.');\n        }\n        return new EncodedVideoChunk({\n            data: this.sideData.alpha,\n            type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /** Converts this packet to an\n     * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk) for use with the\n     * WebCodecs API. */\n    toEncodedAudioChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to an audio chunk.');\n        }\n        if (typeof EncodedAudioChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedAudioChunk.');\n        }\n        return new EncodedAudioChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /**\n     * Creates an {@link EncodedPacket} from an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) or\n     * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk). This method is useful\n     * for converting chunks from the WebCodecs API to `EncodedPacket` instances.\n     */\n    static fromEncodedChunk(chunk, sideData) {\n        if (!(chunk instanceof EncodedVideoChunk || chunk instanceof EncodedAudioChunk)) {\n            throw new TypeError('chunk must be an EncodedVideoChunk or EncodedAudioChunk.');\n        }\n        const data = new Uint8Array(chunk.byteLength);\n        chunk.copyTo(data);\n        return new EncodedPacket(data, chunk.type, chunk.timestamp / 1e6, (chunk.duration ?? 0) / 1e6, undefined, undefined, sideData);\n    }\n    /** Clones this packet while optionally modifying the new packet's data. */\n    clone(options) {\n        if (options !== undefined && (typeof options !== 'object' || options === null)) {\n            throw new TypeError('options, when provided, must be an object.');\n        }\n        if (options?.data !== undefined && !(options.data instanceof Uint8Array)) {\n            throw new TypeError('options.data, when provided, must be a Uint8Array.');\n        }\n        if (options?.type !== undefined && options.type !== 'key' && options.type !== 'delta') {\n            throw new TypeError('options.type, when provided, must be either \"key\" or \"delta\".');\n        }\n        if (options?.timestamp !== undefined && !Number.isFinite(options.timestamp)) {\n            throw new TypeError('options.timestamp, when provided, must be a number.');\n        }\n        if (options?.duration !== undefined && !Number.isFinite(options.duration)) {\n            throw new TypeError('options.duration, when provided, must be a number.');\n        }\n        if (options?.sequenceNumber !== undefined && !Number.isFinite(options.sequenceNumber)) {\n            throw new TypeError('options.sequenceNumber, when provided, must be a number.');\n        }\n        if (options?.sideData !== undefined && (typeof options.sideData !== 'object' || options.sideData === null)) {\n            throw new TypeError('options.sideData, when provided, must be an object.');\n        }\n        return new EncodedPacket(options?.data ?? this.data, options?.type ?? this.type, options?.timestamp ?? this.timestamp, options?.duration ?? this.duration, options?.sequenceNumber ?? this.sequenceNumber, this.byteLength, options?.sideData ?? this.sideData);\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert, clamp, isAllowSharedBufferSource, SECOND_TO_MICROSECOND_FACTOR, toDataView, toUint8Array, isFirefox, polyfillSymbolDispose, assertNever, isWebKit, } from './misc.js';\npolyfillSymbolDispose();\n// Let's manually handle logging the garbage collection errors that are typically logged by the browser. This way, they\n// also kick for audio samples (which is normally not the case), making sure any incorrect code is quickly caught.\nlet lastVideoGcErrorLog = -Infinity;\nlet lastAudioGcErrorLog = -Infinity;\nlet finalizationRegistry = null;\nif (typeof FinalizationRegistry !== 'undefined') {\n    finalizationRegistry = new FinalizationRegistry((value) => {\n        const now = Date.now();\n        if (value.type === 'video') {\n            if (now - lastVideoGcErrorLog >= 1000) {\n                // This error is annoying but oh so important\n                console.error(`A VideoSample was garbage collected without first being closed. For proper resource management,`\n                    + ` make sure to call close() on all your VideoSamples as soon as you're done using them.`);\n                lastVideoGcErrorLog = now;\n            }\n            if (typeof VideoFrame !== 'undefined' && value.data instanceof VideoFrame) {\n                value.data.close(); // Prevent the browser error since we're logging our own\n            }\n        }\n        else {\n            if (now - lastAudioGcErrorLog >= 1000) {\n                console.error(`An AudioSample was garbage collected without first being closed. For proper resource management,`\n                    + ` make sure to call close() on all your AudioSamples as soon as you're done using them.`);\n                lastAudioGcErrorLog = now;\n            }\n            if (typeof AudioData !== 'undefined' && value.data instanceof AudioData) {\n                value.data.close();\n            }\n        }\n    });\n}\n/**\n * The list of {@link VideoSample} pixel formats.\n * @group Samples\n * @public\n */\nexport const VIDEO_SAMPLE_PIXEL_FORMATS = [\n    // 4:2:0 Y, U, V\n    'I420',\n    'I420P10',\n    'I420P12',\n    // 4:2:0 Y, U, V, A\n    'I420A',\n    'I420AP10',\n    'I420AP12',\n    // 4:2:2 Y, U, V\n    'I422',\n    'I422P10',\n    'I422P12',\n    // 4:2:2 Y, U, V, A\n    'I422A',\n    'I422AP10',\n    'I422AP12',\n    // 4:4:4 Y, U, V\n    'I444',\n    'I444P10',\n    'I444P12',\n    // 4:4:4 Y, U, V, A\n    'I444A',\n    'I444AP10',\n    'I444AP12',\n    // 4:2:0 Y, UV\n    'NV12',\n    // 4:4:4 RGBA\n    'RGBA',\n    // 4:4:4 RGBX (opaque)\n    'RGBX',\n    // 4:4:4 BGRA\n    'BGRA',\n    // 4:4:4 BGRX (opaque)\n    'BGRX',\n];\nconst VIDEO_SAMPLE_PIXEL_FORMATS_SET = new Set(VIDEO_SAMPLE_PIXEL_FORMATS);\n/**\n * Represents a raw, unencoded video sample (frame). Mainly used as an expressive wrapper around WebCodecs API's\n * [`VideoFrame`](https://developer.mozilla.org/en-US/docs/Web/API/VideoFrame), but can also be used standalone.\n * @group Samples\n * @public\n */\nexport class VideoSample {\n    /** The width of the frame in pixels after rotation. */\n    get displayWidth() {\n        return this.rotation % 180 === 0 ? this.codedWidth : this.codedHeight;\n    }\n    /** The height of the frame in pixels after rotation. */\n    get displayHeight() {\n        return this.rotation % 180 === 0 ? this.codedHeight : this.codedWidth;\n    }\n    /** The presentation timestamp of the frame in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the frame in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /**\n     * Whether this sample uses a pixel format that can hold transparency data. Note that this doesn't necessarily mean\n     * that the sample is transparent.\n     */\n    get hasAlpha() {\n        return this.format && this.format.includes('A');\n    }\n    constructor(data, init) {\n        /** @internal */\n        this._closed = false;\n        if (data instanceof ArrayBuffer\n            || (typeof SharedArrayBuffer !== 'undefined' && data instanceof SharedArrayBuffer)\n            || ArrayBuffer.isView(data)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (init.format === undefined || !VIDEO_SAMPLE_PIXEL_FORMATS_SET.has(init.format)) {\n                throw new TypeError('init.format must be one of: ' + VIDEO_SAMPLE_PIXEL_FORMATS.join(', '));\n            }\n            if (!Number.isInteger(init.codedWidth) || init.codedWidth <= 0) {\n                throw new TypeError('init.codedWidth must be a positive integer.');\n            }\n            if (!Number.isInteger(init.codedHeight) || init.codedHeight <= 0) {\n                throw new TypeError('init.codedHeight must be a positive integer.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = toUint8Array(data).slice(); // Copy it\n            this._layout = init.layout ?? createDefaultPlaneLayout(init.format, init.codedWidth, init.codedHeight);\n            this.format = init.format;\n            this.codedWidth = init.codedWidth;\n            this.codedHeight = init.codedHeight;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoSampleColorSpace(init.colorSpace);\n        }\n        else if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n            if (init?.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (init?.timestamp !== undefined && !Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp, when provided, must be a number.');\n            }\n            if (init?.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = data;\n            this._layout = null;\n            this.format = data.format;\n            // Copying the display dimensions here, assuming no innate VideoFrame rotation\n            this.codedWidth = data.displayWidth;\n            this.codedHeight = data.displayHeight;\n            // The VideoFrame's rotation is ignored here. It's still a new field, and I'm not sure of any application\n            // where the browser makes use of it. If a case gets found, I'll add it.\n            this.rotation = init?.rotation ?? 0;\n            this.timestamp = init?.timestamp ?? data.timestamp / 1e6;\n            this.duration = init?.duration ?? (data.duration ?? 0) / 1e6;\n            this.colorSpace = new VideoSampleColorSpace(data.colorSpace);\n        }\n        else if ((typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement)\n            || (typeof SVGImageElement !== 'undefined' && data instanceof SVGImageElement)\n            || (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap)\n            || (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement)\n            || (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement)\n            || (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            if (typeof VideoFrame !== 'undefined') {\n                return new VideoSample(new VideoFrame(data, {\n                    timestamp: Math.trunc(init.timestamp * SECOND_TO_MICROSECOND_FACTOR),\n                    // Drag 0 to undefined\n                    duration: Math.trunc((init.duration ?? 0) * SECOND_TO_MICROSECOND_FACTOR) || undefined,\n                }), init);\n            }\n            let width = 0;\n            let height = 0;\n            // Determine the dimensions of the thing\n            if ('naturalWidth' in data) {\n                width = data.naturalWidth;\n                height = data.naturalHeight;\n            }\n            else if ('videoWidth' in data) {\n                width = data.videoWidth;\n                height = data.videoHeight;\n            }\n            else if ('width' in data) {\n                width = Number(data.width);\n                height = Number(data.height);\n            }\n            if (!width || !height) {\n                throw new TypeError('Could not determine dimensions.');\n            }\n            const canvas = new OffscreenCanvas(width, height);\n            const context = canvas.getContext('2d', {\n                alpha: isFirefox(), // Firefox has VideoFrame glitches with opaque canvases\n                willReadFrequently: true,\n            });\n            assert(context);\n            // Draw it to a canvas\n            context.drawImage(data, 0, 0);\n            this._data = canvas;\n            this._layout = null;\n            this.format = 'RGBX';\n            this.codedWidth = width;\n            this.codedHeight = height;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoSampleColorSpace({\n                matrix: 'rgb',\n                primaries: 'bt709',\n                transfer: 'iec61966-2-1',\n                fullRange: true,\n            });\n        }\n        else {\n            throw new TypeError('Invalid data type: Must be a BufferSource or CanvasImageSource.');\n        }\n        finalizationRegistry?.register(this, { type: 'video', data: this._data }, this);\n    }\n    /** Clones this video sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoSample(this._data.clone(), {\n                timestamp: this.timestamp,\n                duration: this.duration,\n                rotation: this.rotation,\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            assert(this._layout);\n            return new VideoSample(this._data, {\n                format: this.format,\n                layout: this._layout,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n        else {\n            return new VideoSample(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n    }\n    /**\n     * Closes this video sample, releasing held resources. Video samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        finalizationRegistry?.unregister(this);\n        if (isVideoFrame(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = null; // GC that shit\n        }\n        this._closed = true;\n    }\n    /**\n     * Returns the number of bytes required to hold this video sample's pixel data. Throws if `format` is `null`.\n     */\n    allocationSize(options = {}) {\n        validateVideoFrameCopyToOptions(options);\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        if (this.format === null) {\n            // https://github.com/Vanilagy/mediabunny/issues/267\n            // https://github.com/w3c/webcodecs/issues/920\n            throw new Error('Cannot get allocation size when format is null. Sorry!');\n        }\n        assert(this._data !== null);\n        if (!isVideoFrame(this._data)) {\n            if (options.colorSpace\n                || (options.format && options.format !== this.format)\n                || options.layout\n                || options.rect) {\n                // Temporarily convert to VideoFrame to get it done\n                // TODO: Compute this directly without needing to go through VideoFrame\n                const videoFrame = this.toVideoFrame();\n                const size = videoFrame.allocationSize(options);\n                videoFrame.close();\n                return size;\n            }\n        }\n        if (isVideoFrame(this._data)) {\n            return this._data.allocationSize(options);\n        }\n        else if (this._data instanceof Uint8Array) {\n            return this._data.byteLength;\n        }\n        else {\n            return this.codedWidth * this.codedHeight * 4; // RGBX\n        }\n    }\n    /**\n     * Copies this video sample's pixel data to an ArrayBuffer or ArrayBufferView. Throws if `format` is `null`.\n     * @returns The byte layout of the planes of the copied data.\n     */\n    async copyTo(destination, options = {}) {\n        if (!isAllowSharedBufferSource(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        validateVideoFrameCopyToOptions(options);\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        if (this.format === null) {\n            throw new Error('Cannot copy video sample data when format is null. Sorry!');\n        }\n        assert(this._data !== null);\n        if (!isVideoFrame(this._data)) {\n            if (options.colorSpace\n                || (options.format && options.format !== this.format)\n                || options.layout\n                || options.rect) {\n                // Temporarily convert to VideoFrame to get it done\n                // TODO: Do this directly without needing to go through VideoFrame\n                const videoFrame = this.toVideoFrame();\n                const layout = await videoFrame.copyTo(destination, options);\n                videoFrame.close();\n                return layout;\n            }\n        }\n        if (isVideoFrame(this._data)) {\n            return this._data.copyTo(destination, options);\n        }\n        else if (this._data instanceof Uint8Array) {\n            assert(this._layout);\n            const dest = toUint8Array(destination);\n            dest.set(this._data);\n            return this._layout;\n        }\n        else {\n            const canvas = this._data;\n            const context = canvas.getContext('2d');\n            assert(context);\n            const imageData = context.getImageData(0, 0, this.codedWidth, this.codedHeight);\n            const dest = toUint8Array(destination);\n            dest.set(imageData.data);\n            return [{\n                    offset: 0,\n                    stride: 4 * this.codedWidth,\n                }];\n        }\n    }\n    /**\n     * Converts this video sample to a VideoFrame for use with the WebCodecs API. The VideoFrame returned by this\n     * method *must* be closed separately from this video sample.\n     */\n    toVideoFrame() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined, // Drag 0 duration to undefined, glitches some codecs\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            return new VideoFrame(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined,\n                colorSpace: this.colorSpace,\n            });\n        }\n        else {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined,\n            });\n        }\n    }\n    draw(context, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n        let sx = 0;\n        let sy = 0;\n        let sWidth = this.displayWidth;\n        let sHeight = this.displayHeight;\n        let dx = 0;\n        let dy = 0;\n        let dWidth = this.displayWidth;\n        let dHeight = this.displayHeight;\n        if (arg5 !== undefined) {\n            sx = arg1;\n            sy = arg2;\n            sWidth = arg3;\n            sHeight = arg4;\n            dx = arg5;\n            dy = arg6;\n            if (arg7 !== undefined) {\n                dWidth = arg7;\n                dHeight = arg8;\n            }\n            else {\n                dWidth = sWidth;\n                dHeight = sHeight;\n            }\n        }\n        else {\n            dx = arg1;\n            dy = arg2;\n            if (arg3 !== undefined) {\n                dWidth = arg3;\n                dHeight = arg4;\n            }\n        }\n        if (!((typeof CanvasRenderingContext2D !== 'undefined' && context instanceof CanvasRenderingContext2D)\n            || (typeof OffscreenCanvasRenderingContext2D !== 'undefined'\n                && context instanceof OffscreenCanvasRenderingContext2D))) {\n            throw new TypeError('context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.');\n        }\n        if (!Number.isFinite(sx)) {\n            throw new TypeError('sx must be a number.');\n        }\n        if (!Number.isFinite(sy)) {\n            throw new TypeError('sy must be a number.');\n        }\n        if (!Number.isFinite(sWidth) || sWidth < 0) {\n            throw new TypeError('sWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(sHeight) || sHeight < 0) {\n            throw new TypeError('sHeight must be a non-negative number.');\n        }\n        if (!Number.isFinite(dx)) {\n            throw new TypeError('dx must be a number.');\n        }\n        if (!Number.isFinite(dy)) {\n            throw new TypeError('dy must be a number.');\n        }\n        if (!Number.isFinite(dWidth) || dWidth < 0) {\n            throw new TypeError('dWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(dHeight) || dHeight < 0) {\n            throw new TypeError('dHeight must be a non-negative number.');\n        }\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        ({ sx, sy, sWidth, sHeight } = this._rotateSourceRegion(sx, sy, sWidth, sHeight, this.rotation));\n        const source = this.toCanvasImageSource();\n        context.save();\n        const centerX = dx + dWidth / 2;\n        const centerY = dy + dHeight / 2;\n        context.translate(centerX, centerY);\n        context.rotate(this.rotation * Math.PI / 180);\n        const aspectRatioChange = this.rotation % 180 === 0 ? 1 : dWidth / dHeight;\n        // Scale to compensate for aspect ratio changes when rotated\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.drawImage(source, sx, sy, sWidth, sHeight, -dWidth / 2, -dHeight / 2, dWidth, dHeight);\n        context.restore();\n    }\n    /**\n     * Draws the sample in the middle of the canvas corresponding to the context with the specified fit behavior.\n     */\n    drawWithFit(context, options) {\n        if (!((typeof CanvasRenderingContext2D !== 'undefined' && context instanceof CanvasRenderingContext2D)\n            || (typeof OffscreenCanvasRenderingContext2D !== 'undefined'\n                && context instanceof OffscreenCanvasRenderingContext2D))) {\n            throw new TypeError('context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!['fill', 'contain', 'cover'].includes(options.fit)) {\n            throw new TypeError('options.fit must be \\'fill\\', \\'contain\\', or \\'cover\\'.');\n        }\n        if (options.rotation !== undefined && ![0, 90, 180, 270].includes(options.rotation)) {\n            throw new TypeError('options.rotation, when provided, must be 0, 90, 180, or 270.');\n        }\n        if (options.crop !== undefined) {\n            validateCropRectangle(options.crop, 'options.');\n        }\n        const canvasWidth = context.canvas.width;\n        const canvasHeight = context.canvas.height;\n        const rotation = options.rotation ?? this.rotation;\n        const [rotatedWidth, rotatedHeight] = rotation % 180 === 0\n            ? [this.codedWidth, this.codedHeight]\n            : [this.codedHeight, this.codedWidth];\n        if (options.crop) {\n            clampCropRectangle(options.crop, rotatedWidth, rotatedHeight);\n        }\n        // These variables specify where the final sample will be drawn on the canvas\n        let dx;\n        let dy;\n        let newWidth;\n        let newHeight;\n        const { sx, sy, sWidth, sHeight } = this._rotateSourceRegion(options.crop?.left ?? 0, options.crop?.top ?? 0, options.crop?.width ?? rotatedWidth, options.crop?.height ?? rotatedHeight, rotation);\n        if (options.fit === 'fill') {\n            dx = 0;\n            dy = 0;\n            newWidth = canvasWidth;\n            newHeight = canvasHeight;\n        }\n        else {\n            const [sampleWidth, sampleHeight] = options.crop\n                ? [options.crop.width, options.crop.height]\n                : [rotatedWidth, rotatedHeight];\n            const scale = options.fit === 'contain'\n                ? Math.min(canvasWidth / sampleWidth, canvasHeight / sampleHeight)\n                : Math.max(canvasWidth / sampleWidth, canvasHeight / sampleHeight);\n            newWidth = sampleWidth * scale;\n            newHeight = sampleHeight * scale;\n            dx = (canvasWidth - newWidth) / 2;\n            dy = (canvasHeight - newHeight) / 2;\n        }\n        context.save();\n        const aspectRatioChange = rotation % 180 === 0 ? 1 : newWidth / newHeight;\n        context.translate(canvasWidth / 2, canvasHeight / 2);\n        context.rotate(rotation * Math.PI / 180);\n        // This aspect ratio compensation is done so that we can draw the sample with the intended dimensions and\n        // don't need to think about how those dimensions change after the rotation\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.translate(-canvasWidth / 2, -canvasHeight / 2);\n        // Important that we don't use .draw() here since that would take rotation into account, but we wanna handle it\n        // ourselves here\n        context.drawImage(this.toCanvasImageSource(), sx, sy, sWidth, sHeight, dx, dy, newWidth, newHeight);\n        context.restore();\n    }\n    /** @internal */\n    _rotateSourceRegion(sx, sy, sWidth, sHeight, rotation) {\n        // The provided sx,sy,sWidth,sHeight refer to the final rotated image, but that's not actually how the image is\n        // stored. Therefore, we must map these back onto the original, pre-rotation image.\n        if (rotation === 90) {\n            [sx, sy, sWidth, sHeight] = [\n                sy,\n                this.codedHeight - sx - sWidth,\n                sHeight,\n                sWidth,\n            ];\n        }\n        else if (rotation === 180) {\n            [sx, sy] = [\n                this.codedWidth - sx - sWidth,\n                this.codedHeight - sy - sHeight,\n            ];\n        }\n        else if (rotation === 270) {\n            [sx, sy, sWidth, sHeight] = [\n                this.codedWidth - sy - sHeight,\n                sx,\n                sHeight,\n                sWidth,\n            ];\n        }\n        return { sx, sy, sWidth, sHeight };\n    }\n    /**\n     * Converts this video sample to a\n     * [`CanvasImageSource`](https://udn.realityripple.com/docs/Web/API/CanvasImageSource) for drawing to a canvas.\n     *\n     * You must use the value returned by this method immediately, as any VideoFrame created internally will\n     * automatically be closed in the next microtask.\n     */\n    toCanvasImageSource() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (this._data instanceof Uint8Array) {\n            // Requires VideoFrame to be defined\n            const videoFrame = this.toVideoFrame();\n            queueMicrotask(() => videoFrame.close()); // Let's automatically close the frame in the next microtask\n            return videoFrame;\n        }\n        else {\n            return this._data;\n        }\n    }\n    /** Sets the rotation metadata of this video sample. */\n    setRotation(newRotation) {\n        if (![0, 90, 180, 270].includes(newRotation)) {\n            throw new TypeError('newRotation must be 0, 90, 180, or 270.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.rotation = newRotation;\n    }\n    /** Sets the presentation timestamp of this video sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** Sets the duration of this video sample, in seconds. */\n    setDuration(newDuration) {\n        if (!Number.isFinite(newDuration) || newDuration < 0) {\n            throw new TypeError('newDuration must be a non-negative number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.duration = newDuration;\n    }\n    /** Calls `.close()`. */\n    [Symbol.dispose]() {\n        this.close();\n    }\n}\n/**\n * Describes the color space of a {@link VideoSample}. Corresponds to the WebCodecs API's VideoColorSpace.\n * @group Samples\n * @public\n */\nexport class VideoSampleColorSpace {\n    /** Creates a new VideoSampleColorSpace. */\n    constructor(init) {\n        this.primaries = init?.primaries ?? null;\n        this.transfer = init?.transfer ?? null;\n        this.matrix = init?.matrix ?? null;\n        this.fullRange = init?.fullRange ?? null;\n    }\n    /** Serializes the color space to a JSON object. */\n    toJSON() {\n        return {\n            primaries: this.primaries,\n            transfer: this.transfer,\n            matrix: this.matrix,\n            fullRange: this.fullRange,\n        };\n    }\n}\nconst isVideoFrame = (x) => {\n    return typeof VideoFrame !== 'undefined' && x instanceof VideoFrame;\n};\nexport const clampCropRectangle = (crop, outerWidth, outerHeight) => {\n    crop.left = Math.min(crop.left, outerWidth);\n    crop.top = Math.min(crop.top, outerHeight);\n    crop.width = Math.min(crop.width, outerWidth - crop.left);\n    crop.height = Math.min(crop.height, outerHeight - crop.top);\n    assert(crop.width >= 0);\n    assert(crop.height >= 0);\n};\nexport const validateCropRectangle = (crop, prefix) => {\n    if (!crop || typeof crop !== 'object') {\n        throw new TypeError(prefix + 'crop, when provided, must be an object.');\n    }\n    if (!Number.isInteger(crop.left) || crop.left < 0) {\n        throw new TypeError(prefix + 'crop.left must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.top) || crop.top < 0) {\n        throw new TypeError(prefix + 'crop.top must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.width) || crop.width < 0) {\n        throw new TypeError(prefix + 'crop.width must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.height) || crop.height < 0) {\n        throw new TypeError(prefix + 'crop.height must be a non-negative integer.');\n    }\n};\nconst validateVideoFrameCopyToOptions = (options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('options must be an object.');\n    }\n    if (options.colorSpace !== undefined && !['display-p3', 'srgb'].includes(options.colorSpace)) {\n        throw new TypeError('options.colorSpace, when provided, must be \\'display-p3\\' or \\'srgb\\'.');\n    }\n    if (options.format !== undefined && typeof options.format !== 'string') {\n        throw new TypeError('options.format, when provided, must be a string.');\n    }\n    if (options.layout !== undefined) {\n        if (!Array.isArray(options.layout)) {\n            throw new TypeError('options.layout, when provided, must be an array.');\n        }\n        for (const plane of options.layout) {\n            if (!plane || typeof plane !== 'object') {\n                throw new TypeError('Each entry in options.layout must be an object.');\n            }\n            if (!Number.isInteger(plane.offset) || plane.offset < 0) {\n                throw new TypeError('plane.offset must be a non-negative integer.');\n            }\n            if (!Number.isInteger(plane.stride) || plane.stride < 0) {\n                throw new TypeError('plane.stride must be a non-negative integer.');\n            }\n        }\n    }\n    if (options.rect !== undefined) {\n        if (!options.rect || typeof options.rect !== 'object') {\n            throw new TypeError('options.rect, when provided, must be an object.');\n        }\n        if (options.rect.x !== undefined && (!Number.isInteger(options.rect.x) || options.rect.x < 0)) {\n            throw new TypeError('options.rect.x, when provided, must be a non-negative integer.');\n        }\n        if (options.rect.y !== undefined && (!Number.isInteger(options.rect.y) || options.rect.y < 0)) {\n            throw new TypeError('options.rect.y, when provided, must be a non-negative integer.');\n        }\n        if (options.rect.width !== undefined && (!Number.isInteger(options.rect.width) || options.rect.width < 0)) {\n            throw new TypeError('options.rect.width, when provided, must be a non-negative integer.');\n        }\n        if (options.rect.height !== undefined && (!Number.isInteger(options.rect.height) || options.rect.height < 0)) {\n            throw new TypeError('options.rect.height, when provided, must be a non-negative integer.');\n        }\n    }\n};\n/** Implements logic from WebCodecs  9.4.6 \"Compute Layout and Allocation Size\" */\nconst createDefaultPlaneLayout = (format, codedWidth, codedHeight) => {\n    const planes = getPlaneConfigs(format);\n    const layouts = [];\n    let currentOffset = 0;\n    for (const plane of planes) {\n        // Per  9.8, dimensions are usually \"rounded up to the nearest integer\".\n        const planeWidth = Math.ceil(codedWidth / plane.widthDivisor);\n        const planeHeight = Math.ceil(codedHeight / plane.heightDivisor);\n        const stride = planeWidth * plane.sampleBytes;\n        // Tight packing\n        const planeSize = stride * planeHeight;\n        layouts.push({\n            offset: currentOffset,\n            stride: stride,\n        });\n        currentOffset += planeSize;\n    }\n    return layouts;\n};\n/** Helper to retrieve plane configurations based on WebCodecs  9.8 Pixel Format definitions. */\nconst getPlaneConfigs = (format) => {\n    // Helper for standard YUV planes\n    const yuv = (yBytes, uvBytes, subX, subY, hasAlpha) => {\n        const configs = [\n            { sampleBytes: yBytes, widthDivisor: 1, heightDivisor: 1 },\n            { sampleBytes: uvBytes, widthDivisor: subX, heightDivisor: subY },\n            { sampleBytes: uvBytes, widthDivisor: subX, heightDivisor: subY },\n        ];\n        if (hasAlpha) {\n            // Match luma dimensions\n            configs.push({ sampleBytes: yBytes, widthDivisor: 1, heightDivisor: 1 });\n        }\n        return configs;\n    };\n    switch (format) {\n        case 'I420':\n            return yuv(1, 1, 2, 2, false);\n        case 'I420P10':\n        case 'I420P12':\n            return yuv(2, 2, 2, 2, false);\n        case 'I420A':\n            return yuv(1, 1, 2, 2, true);\n        case 'I420AP10':\n        case 'I420AP12':\n            return yuv(2, 2, 2, 2, true);\n        case 'I422':\n            return yuv(1, 1, 2, 1, false);\n        case 'I422P10':\n        case 'I422P12':\n            return yuv(2, 2, 2, 1, false);\n        case 'I422A':\n            return yuv(1, 1, 2, 1, true);\n        case 'I422AP10':\n        case 'I422AP12':\n            return yuv(2, 2, 2, 1, true);\n        case 'I444':\n            return yuv(1, 1, 1, 1, false);\n        case 'I444P10':\n        case 'I444P12':\n            return yuv(2, 2, 1, 1, false);\n        case 'I444A':\n            return yuv(1, 1, 1, 1, true);\n        case 'I444AP10':\n        case 'I444AP12':\n            return yuv(2, 2, 1, 1, true);\n        case 'NV12':\n            return [\n                { sampleBytes: 1, widthDivisor: 1, heightDivisor: 1 },\n                { sampleBytes: 2, widthDivisor: 2, heightDivisor: 2 }, // Interleaved U and V\n            ];\n        case 'RGBA':\n        case 'RGBX':\n        case 'BGRA':\n        case 'BGRX':\n            return [\n                { sampleBytes: 4, widthDivisor: 1, heightDivisor: 1 },\n            ];\n        default:\n            assertNever(format);\n            assert(false);\n    }\n};\nconst AUDIO_SAMPLE_FORMATS = new Set(['f32', 'f32-planar', 's16', 's16-planar', 's32', 's32-planar', 'u8', 'u8-planar']);\n/**\n * Represents a raw, unencoded audio sample. Mainly used as an expressive wrapper around WebCodecs API's\n * [`AudioData`](https://developer.mozilla.org/en-US/docs/Web/API/AudioData), but can also be used standalone.\n * @group Samples\n * @public\n */\nexport class AudioSample {\n    /** The presentation timestamp of the sample in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the sample in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /**\n     * Creates a new {@link AudioSample}, either from an existing\n     * [`AudioData`](https://developer.mozilla.org/en-US/docs/Web/API/AudioData) or from raw bytes specified in\n     * {@link AudioSampleInit}.\n     */\n    constructor(init) {\n        /** @internal */\n        this._closed = false;\n        if (isAudioData(init)) {\n            if (init.format === null) {\n                throw new TypeError('AudioData with null format is not supported.');\n            }\n            this._data = init;\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = init.numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp / 1e6;\n            this.duration = init.numberOfFrames / init.sampleRate;\n        }\n        else {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('Invalid AudioDataInit: must be an object.');\n            }\n            if (!AUDIO_SAMPLE_FORMATS.has(init.format)) {\n                throw new TypeError('Invalid AudioDataInit: invalid format.');\n            }\n            if (!Number.isFinite(init.sampleRate) || init.sampleRate <= 0) {\n                throw new TypeError('Invalid AudioDataInit: sampleRate must be > 0.');\n            }\n            if (!Number.isInteger(init.numberOfChannels) || init.numberOfChannels === 0) {\n                throw new TypeError('Invalid AudioDataInit: numberOfChannels must be an integer > 0.');\n            }\n            if (!Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            const numberOfFrames = init.data.byteLength / (getBytesPerSample(init.format) * init.numberOfChannels);\n            if (!Number.isInteger(numberOfFrames)) {\n                throw new TypeError('Invalid AudioDataInit: data size is not a multiple of frame size.');\n            }\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp;\n            this.duration = numberOfFrames / init.sampleRate;\n            let dataBuffer;\n            if (init.data instanceof ArrayBuffer) {\n                dataBuffer = new Uint8Array(init.data);\n            }\n            else if (ArrayBuffer.isView(init.data)) {\n                dataBuffer = new Uint8Array(init.data.buffer, init.data.byteOffset, init.data.byteLength);\n            }\n            else {\n                throw new TypeError('Invalid AudioDataInit: data is not a BufferSource.');\n            }\n            const expectedSize = this.numberOfFrames * this.numberOfChannels * getBytesPerSample(this.format);\n            if (dataBuffer.byteLength < expectedSize) {\n                throw new TypeError('Invalid AudioDataInit: insufficient data size.');\n            }\n            this._data = dataBuffer;\n        }\n        finalizationRegistry?.register(this, { type: 'audio', data: this._data }, this);\n    }\n    /** Returns the number of bytes required to hold the audio sample's data as specified by the given options. */\n    allocationSize(options) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const destFormat = options.format ?? this.format;\n        const frameOffset = options.frameOffset ?? 0;\n        if (frameOffset >= this.numberOfFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = options.frameCount !== undefined ? options.frameCount : (this.numberOfFrames - frameOffset);\n        if (copyFrameCount > (this.numberOfFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const bytesPerSample = getBytesPerSample(destFormat);\n        const isPlanar = formatIsPlanar(destFormat);\n        if (isPlanar && options.planeIndex >= this.numberOfChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!isPlanar && options.planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const elementCount = isPlanar ? copyFrameCount : copyFrameCount * this.numberOfChannels;\n        return elementCount * bytesPerSample;\n    }\n    /** Copies the audio sample's data to an ArrayBuffer or ArrayBufferView as specified by the given options. */\n    copyTo(destination, options) {\n        if (!isAllowSharedBufferSource(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const { planeIndex, format, frameCount: optFrameCount, frameOffset: optFrameOffset } = options;\n        const srcFormat = this.format;\n        const destFormat = format ?? this.format;\n        if (!destFormat)\n            throw new Error('Destination format not determined');\n        const numFrames = this.numberOfFrames;\n        const numChannels = this.numberOfChannels;\n        const frameOffset = optFrameOffset ?? 0;\n        if (frameOffset >= numFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = optFrameCount !== undefined ? optFrameCount : (numFrames - frameOffset);\n        if (copyFrameCount > (numFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const destBytesPerSample = getBytesPerSample(destFormat);\n        const destIsPlanar = formatIsPlanar(destFormat);\n        if (destIsPlanar && planeIndex >= numChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!destIsPlanar && planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const destElementCount = destIsPlanar ? copyFrameCount : copyFrameCount * numChannels;\n        const requiredSize = destElementCount * destBytesPerSample;\n        if (destination.byteLength < requiredSize) {\n            throw new RangeError('Destination buffer is too small');\n        }\n        const destView = toDataView(destination);\n        const writeFn = getWriteFunction(destFormat);\n        if (isAudioData(this._data)) {\n            if (isWebKit() && numChannels > 2 && destFormat !== srcFormat) {\n                // WebKit bug workaround\n                doAudioDataCopyToWebKitWorkaround(this._data, destView, srcFormat, destFormat, numChannels, planeIndex, frameOffset, copyFrameCount);\n            }\n            else {\n                // Per spec, only f32-planar conversion must be supported, but in practice, all browsers support all\n                // destination formats, so let's just delegate here:\n                this._data.copyTo(destination, {\n                    planeIndex,\n                    frameOffset,\n                    frameCount: copyFrameCount,\n                    format: destFormat,\n                });\n            }\n        }\n        else {\n            const uint8Data = this._data;\n            const srcView = toDataView(uint8Data);\n            const readFn = getReadFunction(srcFormat);\n            const srcBytesPerSample = getBytesPerSample(srcFormat);\n            const srcIsPlanar = formatIsPlanar(srcFormat);\n            for (let i = 0; i < copyFrameCount; i++) {\n                if (destIsPlanar) {\n                    const destOffset = i * destBytesPerSample;\n                    let srcOffset;\n                    if (srcIsPlanar) {\n                        srcOffset = (planeIndex * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                    }\n                    else {\n                        srcOffset = (((i + frameOffset) * numChannels) + planeIndex) * srcBytesPerSample;\n                    }\n                    const normalized = readFn(srcView, srcOffset);\n                    writeFn(destView, destOffset, normalized);\n                }\n                else {\n                    for (let ch = 0; ch < numChannels; ch++) {\n                        const destIndex = i * numChannels + ch;\n                        const destOffset = destIndex * destBytesPerSample;\n                        let srcOffset;\n                        if (srcIsPlanar) {\n                            srcOffset = (ch * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                        }\n                        else {\n                            srcOffset = (((i + frameOffset) * numChannels) + ch) * srcBytesPerSample;\n                        }\n                        const normalized = readFn(srcView, srcOffset);\n                        writeFn(destView, destOffset, normalized);\n                    }\n                }\n            }\n        }\n    }\n    /** Clones this audio sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            const sample = new AudioSample(this._data.clone());\n            sample.setTimestamp(this.timestamp); // Make sure the timestamp is precise (beyond microsecond accuracy)\n            return sample;\n        }\n        else {\n            return new AudioSample({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.timestamp,\n                data: this._data,\n            });\n        }\n    }\n    /**\n     * Closes this audio sample, releasing held resources. Audio samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        finalizationRegistry?.unregister(this);\n        if (isAudioData(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = new Uint8Array(0);\n        }\n        this._closed = true;\n    }\n    /**\n     * Converts this audio sample to an AudioData for use with the WebCodecs API. The AudioData returned by this\n     * method *must* be closed separately from this audio sample.\n     */\n    toAudioData() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            if (this._data.timestamp === this.microsecondTimestamp) {\n                // Timestamp matches, let's just return the data (but cloned)\n                return this._data.clone();\n            }\n            else {\n                // It's impossible to simply change an AudioData's timestamp, so we'll need to create a new one\n                if (formatIsPlanar(this.format)) {\n                    const size = this.allocationSize({ planeIndex: 0, format: this.format });\n                    const data = new ArrayBuffer(size * this.numberOfChannels);\n                    // We gotta read out each plane individually\n                    for (let i = 0; i < this.numberOfChannels; i++) {\n                        this.copyTo(new Uint8Array(data, i * size, size), { planeIndex: i, format: this.format });\n                    }\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n                else {\n                    const data = new ArrayBuffer(this.allocationSize({ planeIndex: 0, format: this.format }));\n                    this.copyTo(data, { planeIndex: 0, format: this.format });\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n            }\n        }\n        else {\n            return new AudioData({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.microsecondTimestamp,\n                data: this._data.buffer instanceof ArrayBuffer\n                    ? this._data.buffer\n                    : this._data.slice(), // In the case of SharedArrayBuffer, convert to ArrayBuffer\n            });\n        }\n    }\n    /** Convert this audio sample to an AudioBuffer for use with the Web Audio API. */\n    toAudioBuffer() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const audioBuffer = new AudioBuffer({\n            numberOfChannels: this.numberOfChannels,\n            length: this.numberOfFrames,\n            sampleRate: this.sampleRate,\n        });\n        const dataBytes = new Float32Array(this.allocationSize({ planeIndex: 0, format: 'f32-planar' }) / 4);\n        for (let i = 0; i < this.numberOfChannels; i++) {\n            this.copyTo(dataBytes, { planeIndex: i, format: 'f32-planar' });\n            audioBuffer.copyToChannel(dataBytes, i);\n        }\n        return audioBuffer;\n    }\n    /** Sets the presentation timestamp of this audio sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** Calls `.close()`. */\n    [Symbol.dispose]() {\n        this.close();\n    }\n    /** @internal */\n    static *_fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            yield new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n    }\n    /**\n     * Creates AudioSamples from an AudioBuffer, starting at the given timestamp in seconds. Typically creates exactly\n     * one sample, but may create multiple if the AudioBuffer is exceedingly large.\n     */\n    static fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        const result = [];\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            const audioSample = new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            result.push(audioSample);\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n        return result;\n    }\n}\nconst getBytesPerSample = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return 1;\n        case 's16':\n        case 's16-planar':\n            return 2;\n        case 's32':\n        case 's32-planar':\n            return 4;\n        case 'f32':\n        case 'f32-planar':\n            return 4;\n        default:\n            throw new Error('Unknown AudioSampleFormat');\n    }\n};\nconst formatIsPlanar = (format) => {\n    switch (format) {\n        case 'u8-planar':\n        case 's16-planar':\n        case 's32-planar':\n        case 'f32-planar':\n            return true;\n        default:\n            return false;\n    }\n};\nconst getReadFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset) => (view.getUint8(offset) - 128) / 128;\n        case 's16':\n        case 's16-planar':\n            return (view, offset) => view.getInt16(offset, true) / 32768;\n        case 's32':\n        case 's32-planar':\n            return (view, offset) => view.getInt32(offset, true) / 2147483648;\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset) => view.getFloat32(offset, true);\n    }\n};\nconst getWriteFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset, value) => view.setUint8(offset, clamp((value + 1) * 127.5, 0, 255));\n        case 's16':\n        case 's16-planar':\n            return (view, offset, value) => view.setInt16(offset, clamp(Math.round(value * 32767), -32768, 32767), true);\n        case 's32':\n        case 's32-planar':\n            return (view, offset, value) => view.setInt32(offset, clamp(Math.round(value * 2147483647), -2147483648, 2147483647), true);\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset, value) => view.setFloat32(offset, value, true);\n    }\n};\nconst isAudioData = (x) => {\n    return typeof AudioData !== 'undefined' && x instanceof AudioData;\n};\n/**\n * WebKit has a bug where calling AudioData.copyTo with a format different from the source format\n * crashes the tab when there are more than 2 channels. This function works around that by always\n * copying with the source format and then manually converting to the destination format.\n *\n * See https://bugs.webkit.org/show_bug.cgi?id=302521.\n */\nconst doAudioDataCopyToWebKitWorkaround = (audioData, destView, srcFormat, destFormat, numChannels, planeIndex, frameOffset, copyFrameCount) => {\n    const readFn = getReadFunction(srcFormat);\n    const writeFn = getWriteFunction(destFormat);\n    const srcBytesPerSample = getBytesPerSample(srcFormat);\n    const destBytesPerSample = getBytesPerSample(destFormat);\n    const srcIsPlanar = formatIsPlanar(srcFormat);\n    const destIsPlanar = formatIsPlanar(destFormat);\n    if (destIsPlanar) {\n        if (srcIsPlanar) {\n            // src planar -> dest planar: copy single plane and convert\n            const data = new ArrayBuffer(copyFrameCount * srcBytesPerSample);\n            const dataView = toDataView(data);\n            audioData.copyTo(data, {\n                planeIndex,\n                frameOffset,\n                frameCount: copyFrameCount,\n                format: srcFormat,\n            });\n            for (let i = 0; i < copyFrameCount; i++) {\n                const srcOffset = i * srcBytesPerSample;\n                const destOffset = i * destBytesPerSample;\n                const sample = readFn(dataView, srcOffset);\n                writeFn(destView, destOffset, sample);\n            }\n        }\n        else {\n            // src interleaved -> dest planar: copy all interleaved data, extract one channel\n            const data = new ArrayBuffer(copyFrameCount * numChannels * srcBytesPerSample);\n            const dataView = toDataView(data);\n            audioData.copyTo(data, {\n                planeIndex: 0,\n                frameOffset,\n                frameCount: copyFrameCount,\n                format: srcFormat,\n            });\n            for (let i = 0; i < copyFrameCount; i++) {\n                const srcOffset = (i * numChannels + planeIndex) * srcBytesPerSample;\n                const destOffset = i * destBytesPerSample;\n                const sample = readFn(dataView, srcOffset);\n                writeFn(destView, destOffset, sample);\n            }\n        }\n    }\n    else {\n        if (srcIsPlanar) {\n            // src planar -> dest interleaved: copy each plane and interleave\n            const planeSize = copyFrameCount * srcBytesPerSample;\n            const data = new ArrayBuffer(planeSize);\n            const dataView = toDataView(data);\n            for (let ch = 0; ch < numChannels; ch++) {\n                audioData.copyTo(data, {\n                    planeIndex: ch,\n                    frameOffset,\n                    frameCount: copyFrameCount,\n                    format: srcFormat,\n                });\n                for (let i = 0; i < copyFrameCount; i++) {\n                    const srcOffset = i * srcBytesPerSample;\n                    const destOffset = (i * numChannels + ch) * destBytesPerSample;\n                    const sample = readFn(dataView, srcOffset);\n                    writeFn(destView, destOffset, sample);\n                }\n            }\n        }\n        else {\n            // src interleaved -> dest interleaved: copy all and convert\n            const data = new ArrayBuffer(copyFrameCount * numChannels * srcBytesPerSample);\n            const dataView = toDataView(data);\n            audioData.copyTo(data, {\n                planeIndex: 0,\n                frameOffset,\n                frameCount: copyFrameCount,\n                format: srcFormat,\n            });\n            for (let i = 0; i < copyFrameCount; i++) {\n                for (let ch = 0; ch < numChannels; ch++) {\n                    const idx = i * numChannels + ch;\n                    const srcOffset = idx * srcBytesPerSample;\n                    const destOffset = idx * destBytesPerSample;\n                    const sample = readFn(dataView, srcOffset);\n                    writeFn(destView, destOffset, sample);\n                }\n            }\n        }\n    }\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const buildIsobmffMimeType = (info) => {\n    const base = info.hasVideo\n        ? 'video/'\n        : info.hasAudio\n            ? 'audio/'\n            : 'application/';\n    let string = base + (info.isQuickTime ? 'quicktime' : 'mp4');\n    if (info.codecStrings.length > 0) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings)];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { RichImageData } from '../metadata.js';\nimport { textDecoder } from '../misc.js';\nimport { readAscii, readBytes, readI32Be, readU16Be, readU32Be, readU64Be, readU8 } from '../reader.js';\nexport const MIN_BOX_HEADER_SIZE = 8;\nexport const MAX_BOX_HEADER_SIZE = 16;\nexport const readBoxHeader = (slice) => {\n    let totalSize = readU32Be(slice);\n    const name = readAscii(slice, 4);\n    let headerSize = 8;\n    const hasLargeSize = totalSize === 1;\n    if (hasLargeSize) {\n        totalSize = readU64Be(slice);\n        headerSize = 16;\n    }\n    const contentSize = totalSize - headerSize;\n    if (contentSize < 0) {\n        return null; // Hardly a box is it\n    }\n    return { name, totalSize, headerSize, contentSize };\n};\nexport const readFixed_16_16 = (slice) => {\n    return readI32Be(slice) / 0x10000;\n};\nexport const readFixed_2_30 = (slice) => {\n    return readI32Be(slice) / 0x40000000;\n};\nexport const readIsomVariableInteger = (slice) => {\n    let result = 0;\n    for (let i = 0; i < 4; i++) {\n        result <<= 7;\n        const nextByte = readU8(slice);\n        result |= nextByte & 0x7f;\n        if ((nextByte & 0x80) === 0) {\n            break;\n        }\n    }\n    return result;\n};\nexport const readMetadataStringShort = (slice) => {\n    let stringLength = readU16Be(slice);\n    slice.skip(2); // Language\n    stringLength = Math.min(stringLength, slice.remainingLength);\n    return textDecoder.decode(readBytes(slice, stringLength));\n};\nexport const readDataBox = (slice) => {\n    const header = readBoxHeader(slice);\n    if (!header || header.name !== 'data') {\n        return null;\n    }\n    if (slice.remainingLength < 8) {\n        // Box is too small\n        return null;\n    }\n    const typeIndicator = readU32Be(slice);\n    slice.skip(4); // Locale indicator\n    const data = readBytes(slice, header.contentSize - 8);\n    switch (typeIndicator) {\n        case 1: return textDecoder.decode(data); // UTF-8\n        case 2: return new TextDecoder('utf-16be').decode(data); // UTF-16-BE\n        case 13: return new RichImageData(data, 'image/jpeg');\n        case 14: return new RichImageData(data, 'image/png');\n        case 27: return new RichImageData(data, 'image/bmp');\n        default: return data;\n    }\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream } from '../misc.js';\nimport { readBytes } from '../reader.js';\nexport const MIN_ADTS_FRAME_HEADER_SIZE = 7;\nexport const MAX_ADTS_FRAME_HEADER_SIZE = 9;\nexport const readAdtsFrameHeader = (slice) => {\n    // https://wiki.multimedia.cx/index.php/ADTS (last visited: 2025/08/17)\n    const startPos = slice.filePos;\n    const bytes = readBytes(slice, 9); // 9 with CRC, 7 without CRC\n    const bitstream = new Bitstream(bytes);\n    const syncword = bitstream.readBits(12);\n    if (syncword !== 0b1111_11111111) {\n        return null;\n    }\n    bitstream.skipBits(1); // MPEG version\n    const layer = bitstream.readBits(2);\n    if (layer !== 0) {\n        return null;\n    }\n    const protectionAbsence = bitstream.readBits(1);\n    const objectType = bitstream.readBits(2) + 1;\n    const samplingFrequencyIndex = bitstream.readBits(4);\n    if (samplingFrequencyIndex === 15) {\n        return null;\n    }\n    bitstream.skipBits(1); // Private bit\n    const channelConfiguration = bitstream.readBits(3);\n    if (channelConfiguration === 0) {\n        throw new Error('ADTS frames with channel configuration 0 are not supported.');\n    }\n    bitstream.skipBits(1); // Originality\n    bitstream.skipBits(1); // Home\n    bitstream.skipBits(1); // Copyright ID bit\n    bitstream.skipBits(1); // Copyright ID start\n    const frameLength = bitstream.readBits(13);\n    bitstream.skipBits(11); // Buffer fullness\n    const numberOfAacFrames = bitstream.readBits(2) + 1;\n    if (numberOfAacFrames !== 1) {\n        throw new Error('ADTS frames with more than one AAC frame are not supported.');\n    }\n    let crcCheck = null;\n    if (protectionAbsence === 1) { // No CRC\n        slice.filePos -= 2;\n    }\n    else { // CRC\n        crcCheck = bitstream.readBits(16);\n    }\n    return {\n        objectType,\n        samplingFrequencyIndex,\n        channelConfiguration,\n        frameLength,\n        numberOfAacFrames,\n        crcCheck,\n        startPos,\n    };\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { InputDisposedError } from './input.js';\nimport { assert, clamp, getUint24, toDataView } from './misc.js';\nexport class Reader {\n    constructor(source) {\n        this.source = source;\n    }\n    requestSlice(start, length) {\n        if (this.source._disposed) {\n            throw new InputDisposedError();\n        }\n        if (start < 0) {\n            return null;\n        }\n        if (this.fileSize !== null && start + length > this.fileSize) {\n            return null;\n        }\n        const end = start + length;\n        const result = this.source._read(start, end);\n        if (result instanceof Promise) {\n            return result.then((x) => {\n                if (!x) {\n                    return null;\n                }\n                return new FileSlice(x.bytes, x.view, x.offset, start, end);\n            });\n        }\n        else {\n            if (!result) {\n                return null;\n            }\n            return new FileSlice(result.bytes, result.view, result.offset, start, end);\n        }\n    }\n    requestSliceRange(start, minLength, maxLength) {\n        if (this.source._disposed) {\n            throw new InputDisposedError();\n        }\n        if (start < 0) {\n            return null;\n        }\n        if (this.fileSize !== null) {\n            return this.requestSlice(start, clamp(this.fileSize - start, minLength, maxLength));\n        }\n        else {\n            const promisedAttempt = this.requestSlice(start, maxLength);\n            const handleAttempt = (attempt) => {\n                if (attempt) {\n                    return attempt;\n                }\n                const handleFileSize = (fileSize) => {\n                    assert(fileSize !== null); // The slice couldn't fit, meaning we must know the file size now\n                    return this.requestSlice(start, clamp(fileSize - start, minLength, maxLength));\n                };\n                const promisedFileSize = this.source._retrieveSize();\n                if (promisedFileSize instanceof Promise) {\n                    return promisedFileSize.then(handleFileSize);\n                }\n                else {\n                    return handleFileSize(promisedFileSize);\n                }\n            };\n            if (promisedAttempt instanceof Promise) {\n                return promisedAttempt.then(handleAttempt);\n            }\n            else {\n                return handleAttempt(promisedAttempt);\n            }\n        }\n    }\n}\nexport class FileSlice {\n    constructor(\n    /** The underlying bytes backing this slice. Avoid using this directly and prefer reader functions instead. */\n    bytes, \n    /** A view into the bytes backing this slice. Avoid using this directly and prefer reader functions instead. */\n    view, \n    /** The offset in \"file bytes\" at which `bytes` begins in the file. */\n    offset, \n    /** The offset in \"file bytes\" where this slice begins. */\n    start, \n    /** The offset in \"file bytes\" where this slice ends (exclusive). */\n    end) {\n        this.bytes = bytes;\n        this.view = view;\n        this.offset = offset;\n        this.start = start;\n        this.end = end;\n        this.bufferPos = start - offset;\n    }\n    static tempFromBytes(bytes) {\n        return new FileSlice(bytes, toDataView(bytes), 0, 0, bytes.length);\n    }\n    get length() {\n        return this.end - this.start;\n    }\n    get filePos() {\n        return this.offset + this.bufferPos;\n    }\n    set filePos(value) {\n        this.bufferPos = value - this.offset;\n    }\n    /** The number of bytes left from the current pos to the end of the slice. */\n    get remainingLength() {\n        return Math.max(this.end - this.filePos, 0);\n    }\n    skip(byteCount) {\n        this.bufferPos += byteCount;\n    }\n    /** Creates a new subslice of this slice whose byte range must be contained within this slice. */\n    slice(filePos, length = this.end - filePos) {\n        if (filePos < this.start || filePos + length > this.end) {\n            throw new RangeError('Slicing outside of original slice.');\n        }\n        return new FileSlice(this.bytes, this.view, this.offset, filePos, filePos + length);\n    }\n}\nconst checkIsInRange = (slice, bytesToRead) => {\n    if (slice.filePos < slice.start || slice.filePos + bytesToRead > slice.end) {\n        throw new RangeError(`Tried reading [${slice.filePos}, ${slice.filePos + bytesToRead}), but slice is`\n            + ` [${slice.start}, ${slice.end}). This is likely an internal error, please report it alongside the file`\n            + ` that caused it.`);\n    }\n};\nexport const readBytes = (slice, length) => {\n    checkIsInRange(slice, length);\n    const bytes = slice.bytes.subarray(slice.bufferPos, slice.bufferPos + length);\n    slice.bufferPos += length;\n    return bytes;\n};\nexport const readU8 = (slice) => {\n    checkIsInRange(slice, 1);\n    return slice.view.getUint8(slice.bufferPos++);\n};\nexport const readU16 = (slice, littleEndian) => {\n    checkIsInRange(slice, 2);\n    const value = slice.view.getUint16(slice.bufferPos, littleEndian);\n    slice.bufferPos += 2;\n    return value;\n};\nexport const readU16Be = (slice) => {\n    checkIsInRange(slice, 2);\n    const value = slice.view.getUint16(slice.bufferPos, false);\n    slice.bufferPos += 2;\n    return value;\n};\nexport const readU24Be = (slice) => {\n    checkIsInRange(slice, 3);\n    const value = getUint24(slice.view, slice.bufferPos, false);\n    slice.bufferPos += 3;\n    return value;\n};\nexport const readI16Be = (slice) => {\n    checkIsInRange(slice, 2);\n    const value = slice.view.getInt16(slice.bufferPos, false);\n    slice.bufferPos += 2;\n    return value;\n};\nexport const readU32 = (slice, littleEndian) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getUint32(slice.bufferPos, littleEndian);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readU32Be = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getUint32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readU32Le = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getUint32(slice.bufferPos, true);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readI32Be = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getInt32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readI32Le = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getInt32(slice.bufferPos, true);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readU64 = (slice, littleEndian) => {\n    let low;\n    let high;\n    if (littleEndian) {\n        low = readU32(slice, true);\n        high = readU32(slice, true);\n    }\n    else {\n        high = readU32(slice, false);\n        low = readU32(slice, false);\n    }\n    return high * 0x100000000 + low;\n};\nexport const readU64Be = (slice) => {\n    const high = readU32Be(slice);\n    const low = readU32Be(slice);\n    return high * 0x100000000 + low;\n};\nexport const readI64Be = (slice) => {\n    const high = readI32Be(slice);\n    const low = readU32Be(slice);\n    return high * 0x100000000 + low;\n};\nexport const readI64Le = (slice) => {\n    const low = readU32Le(slice);\n    const high = readI32Le(slice);\n    return high * 0x100000000 + low;\n};\nexport const readF32Be = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getFloat32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readF64Be = (slice) => {\n    checkIsInRange(slice, 8);\n    const value = slice.view.getFloat64(slice.bufferPos, false);\n    slice.bufferPos += 8;\n    return value;\n};\nexport const readAscii = (slice, length) => {\n    checkIsInRange(slice, length);\n    let str = '';\n    for (let i = 0; i < length; i++) {\n        str += String.fromCharCode(slice.bytes[slice.bufferPos++]);\n    }\n    return str;\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst cueBlockHeaderRegex = /(?:(.+?)\\n)?((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})\\s+-->\\s+((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})/g;\nconst preambleStartRegex = /^WEBVTT(.|\\n)*?\\n{2}/;\nexport const inlineTimestampRegex = /<(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})>/g;\nexport class SubtitleParser {\n    constructor(options) {\n        this.preambleText = null;\n        this.preambleEmitted = false;\n        this.options = options;\n    }\n    parse(text) {\n        text = text.replaceAll('\\r\\n', '\\n').replaceAll('\\r', '\\n');\n        cueBlockHeaderRegex.lastIndex = 0;\n        let match;\n        if (!this.preambleText) {\n            if (!preambleStartRegex.test(text)) {\n                throw new Error('WebVTT preamble incorrect.');\n            }\n            match = cueBlockHeaderRegex.exec(text);\n            const preamble = text.slice(0, match?.index ?? text.length).trimEnd();\n            if (!preamble) {\n                throw new Error('No WebVTT preamble provided.');\n            }\n            this.preambleText = preamble;\n            if (match) {\n                text = text.slice(match.index);\n                cueBlockHeaderRegex.lastIndex = 0;\n            }\n        }\n        while ((match = cueBlockHeaderRegex.exec(text))) {\n            const notes = text.slice(0, match.index);\n            const cueIdentifier = match[1];\n            const matchEnd = match.index + match[0].length;\n            const bodyStart = text.indexOf('\\n', matchEnd) + 1;\n            const cueSettings = text.slice(matchEnd, bodyStart).trim();\n            let bodyEnd = text.indexOf('\\n\\n', matchEnd);\n            if (bodyEnd === -1)\n                bodyEnd = text.length;\n            const startTime = parseSubtitleTimestamp(match[2]);\n            const endTime = parseSubtitleTimestamp(match[3]);\n            const duration = endTime - startTime;\n            const body = text.slice(bodyStart, bodyEnd).trim();\n            text = text.slice(bodyEnd).trimStart();\n            cueBlockHeaderRegex.lastIndex = 0;\n            const cue = {\n                timestamp: startTime / 1000,\n                duration: duration / 1000,\n                text: body,\n                identifier: cueIdentifier,\n                settings: cueSettings,\n                notes,\n            };\n            const meta = {};\n            if (!this.preambleEmitted) {\n                meta.config = {\n                    description: this.preambleText,\n                };\n                this.preambleEmitted = true;\n            }\n            this.options.output(cue, meta);\n        }\n    }\n}\nconst timestampRegex = /(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})/;\nexport const parseSubtitleTimestamp = (string) => {\n    const match = timestampRegex.exec(string);\n    if (!match)\n        throw new Error('Expected match.');\n    return 60 * 60 * 1000 * Number(match[1] || '0')\n        + 60 * 1000 * Number(match[2])\n        + 1000 * Number(match[3])\n        + Number(match[4]);\n};\nexport const formatSubtitleTimestamp = (timestamp) => {\n    const hours = Math.floor(timestamp / (60 * 60 * 1000));\n    const minutes = Math.floor((timestamp % (60 * 60 * 1000)) / (60 * 1000));\n    const seconds = Math.floor((timestamp % (60 * 1000)) / 1000);\n    const milliseconds = timestamp % 1000;\n    return hours.toString().padStart(2, '0') + ':'\n        + minutes.toString().padStart(2, '0') + ':'\n        + seconds.toString().padStart(2, '0') + '.'\n        + milliseconds.toString().padStart(3, '0');\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { toUint8Array, assert, isU32, last, textEncoder, COLOR_PRIMARIES_MAP, TRANSFER_CHARACTERISTICS_MAP, MATRIX_COEFFICIENTS_MAP, colorSpaceIsComplete, UNDETERMINED_LANGUAGE, assertNever, keyValueIterator, } from '../misc.js';\nimport { generateAv1CodecConfigurationFromCodecString, parsePcmCodec, PCM_AUDIO_CODECS, } from '../codec.js';\nimport { formatSubtitleTimestamp } from '../subtitles.js';\nimport { getTrackMetadata, GLOBAL_TIMESCALE, intoTimescale, } from './isobmff-muxer.js';\nimport { parseOpusIdentificationHeader } from '../codec-data.js';\nimport { RichImageData } from '../metadata.js';\nexport class IsobmffBoxWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n        /**\n         * Stores the position from the start of the file to where boxes elements have been written. This is used to\n         * rewrite/edit elements that were already added before, and to measure sizes of things.\n         */\n        this.offsets = new WeakMap();\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeU64(value) {\n        this.helperView.setUint32(0, Math.floor(value / 2 ** 32), false);\n        this.helperView.setUint32(4, value, false);\n        this.writer.write(this.helper.subarray(0, 8));\n    }\n    writeAscii(text) {\n        for (let i = 0; i < text.length; i++) {\n            this.helperView.setUint8(i % 8, text.charCodeAt(i));\n            if (i % 8 === 7)\n                this.writer.write(this.helper);\n        }\n        if (text.length % 8 !== 0) {\n            this.writer.write(this.helper.subarray(0, text.length % 8));\n        }\n    }\n    writeBox(box) {\n        this.offsets.set(box, this.writer.getPos());\n        if (box.contents && !box.children) {\n            this.writeBoxHeader(box, box.size ?? box.contents.byteLength + 8);\n            this.writer.write(box.contents);\n        }\n        else {\n            const startPos = this.writer.getPos();\n            this.writeBoxHeader(box, 0);\n            if (box.contents)\n                this.writer.write(box.contents);\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        this.writeBox(child);\n            const endPos = this.writer.getPos();\n            const size = box.size ?? endPos - startPos;\n            this.writer.seek(startPos);\n            this.writeBoxHeader(box, size);\n            this.writer.seek(endPos);\n        }\n    }\n    writeBoxHeader(box, size) {\n        this.writeU32(box.largeSize ? 1 : size);\n        this.writeAscii(box.type);\n        if (box.largeSize)\n            this.writeU64(size);\n    }\n    measureBoxHeader(box) {\n        return 8 + (box.largeSize ? 8 : 0);\n    }\n    patchBox(box) {\n        const boxOffset = this.offsets.get(box);\n        assert(boxOffset !== undefined);\n        const endPos = this.writer.getPos();\n        this.writer.seek(boxOffset);\n        this.writeBox(box);\n        this.writer.seek(endPos);\n    }\n    measureBox(box) {\n        if (box.contents && !box.children) {\n            const headerSize = this.measureBoxHeader(box);\n            return headerSize + box.contents.byteLength;\n        }\n        else {\n            let result = this.measureBoxHeader(box);\n            if (box.contents)\n                result += box.contents.byteLength;\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        result += this.measureBox(child);\n            return result;\n        }\n    }\n}\nconst bytes = /* #__PURE__ */ new Uint8Array(8);\nconst view = /* #__PURE__ */ new DataView(bytes.buffer);\nconst u8 = (value) => {\n    return [(value % 0x100 + 0x100) % 0x100];\n};\nconst u16 = (value) => {\n    view.setUint16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst i16 = (value) => {\n    view.setInt16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst u24 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[1], bytes[2], bytes[3]];\n};\nconst u32 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst i32 = (value) => {\n    view.setInt32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst u64 = (value) => {\n    view.setUint32(0, Math.floor(value / 2 ** 32), false);\n    view.setUint32(4, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]];\n};\nconst fixed_8_8 = (value) => {\n    view.setInt16(0, 2 ** 8 * value, false);\n    return [bytes[0], bytes[1]];\n};\nconst fixed_16_16 = (value) => {\n    view.setInt32(0, 2 ** 16 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst fixed_2_30 = (value) => {\n    view.setInt32(0, 2 ** 30 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst variableUnsignedInt = (value, byteLength) => {\n    const bytes = [];\n    let remaining = value;\n    do {\n        let byte = remaining & 0x7f;\n        remaining >>= 7;\n        // If this isn't the first byte we're adding (meaning there will be more bytes after it\n        // when we reverse the array), set the continuation bit\n        if (bytes.length > 0) {\n            byte |= 0x80;\n        }\n        bytes.push(byte);\n        if (byteLength !== undefined) {\n            byteLength--;\n        }\n    } while (remaining > 0 || byteLength);\n    // Reverse the array since we built it backwards\n    return bytes.reverse();\n};\nconst ascii = (text, nullTerminated = false) => {\n    const bytes = Array(text.length).fill(null).map((_, i) => text.charCodeAt(i));\n    if (nullTerminated)\n        bytes.push(0x00);\n    return bytes;\n};\nconst lastPresentedSample = (samples) => {\n    let result = null;\n    for (const sample of samples) {\n        if (!result || sample.timestamp > result.timestamp) {\n            result = sample;\n        }\n    }\n    return result;\n};\nconst rotationMatrix = (rotationInDegrees) => {\n    const theta = rotationInDegrees * (Math.PI / 180);\n    const cosTheta = Math.round(Math.cos(theta));\n    const sinTheta = Math.round(Math.sin(theta));\n    // Matrices are post-multiplied in ISOBMFF, meaning this is the transpose of your typical rotation matrix\n    return [\n        cosTheta, sinTheta, 0,\n        -sinTheta, cosTheta, 0,\n        0, 0, 1,\n    ];\n};\nconst IDENTITY_MATRIX = /* #__PURE__ */ rotationMatrix(0);\nconst matrixToBytes = (matrix) => {\n    return [\n        fixed_16_16(matrix[0]), fixed_16_16(matrix[1]), fixed_2_30(matrix[2]),\n        fixed_16_16(matrix[3]), fixed_16_16(matrix[4]), fixed_2_30(matrix[5]),\n        fixed_16_16(matrix[6]), fixed_16_16(matrix[7]), fixed_2_30(matrix[8]),\n    ];\n};\nexport const box = (type, contents, children) => ({\n    type,\n    contents: contents && new Uint8Array(contents.flat(10)),\n    children,\n});\n/** A FullBox always starts with a version byte, followed by three flag bytes. */\nexport const fullBox = (type, version, flags, contents, children) => box(type, [u8(version), u24(flags), contents ?? []], children);\n/**\n * File Type Compatibility Box: Allows the reader to determine whether this is a type of file that the\n * reader understands.\n */\nexport const ftyp = (details) => {\n    // You can find the full logic for this at\n    // https://github.com/FFmpeg/FFmpeg/blob/de2fb43e785773738c660cdafb9309b1ef1bc80d/libavformat/movenc.c#L5518\n    // Obviously, this lib only needs a small subset of that logic.\n    const minorVersion = 0x200;\n    if (details.isQuickTime) {\n        return box('ftyp', [\n            ascii('qt  '), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('qt  '),\n        ]);\n    }\n    if (details.fragmented) {\n        return box('ftyp', [\n            ascii('iso5'), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('iso5'),\n            ascii('iso6'),\n            ascii('mp41'),\n        ]);\n    }\n    return box('ftyp', [\n        ascii('isom'), // Major brand\n        u32(minorVersion), // Minor version\n        // Compatible brands\n        ascii('isom'),\n        details.holdsAvc ? ascii('avc1') : [],\n        ascii('mp41'),\n    ]);\n};\n/** Movie Sample Data Box. Contains the actual frames/samples of the media. */\nexport const mdat = (reserveLargeSize) => ({ type: 'mdat', largeSize: reserveLargeSize });\n/** Free Space Box: A box that designates unused space in the movie data file. */\nexport const free = (size) => ({ type: 'free', size });\n/**\n * Movie Box: Used to specify the information that defines a movie - that is, the information that allows\n * an application to interpret the sample data that is stored elsewhere.\n */\nexport const moov = (muxer) => box('moov', undefined, [\n    mvhd(muxer.creationTime, muxer.trackDatas),\n    ...muxer.trackDatas.map(x => trak(x, muxer.creationTime)),\n    muxer.isFragmented ? mvex(muxer.trackDatas) : null,\n    udta(muxer),\n]);\n/** Movie Header Box: Used to specify the characteristics of the entire movie, such as timescale and duration. */\nexport const mvhd = (creationTime, trackDatas) => {\n    const duration = intoTimescale(Math.max(0, ...trackDatas\n        .filter(x => x.samples.length > 0)\n        .map((x) => {\n        const lastSample = lastPresentedSample(x.samples);\n        return lastSample.timestamp + lastSample.duration;\n    })), GLOBAL_TIMESCALE);\n    const nextTrackId = Math.max(0, ...trackDatas.map(x => x.track.id)) + 1;\n    // Conditionally use u64 if u32 isn't enough\n    const needsU64 = !isU32(creationTime) || !isU32(duration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    return fullBox('mvhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(GLOBAL_TIMESCALE), // Timescale\n        u32OrU64(duration), // Duration\n        fixed_16_16(1), // Preferred rate\n        fixed_8_8(1), // Preferred volume\n        Array(10).fill(0), // Reserved\n        matrixToBytes(IDENTITY_MATRIX), // Matrix\n        Array(24).fill(0), // Pre-defined\n        u32(nextTrackId), // Next track ID\n    ]);\n};\n/**\n * Track Box: Defines a single track of a movie. A movie may consist of one or more tracks. Each track is\n * independent of the other tracks in the movie and carries its own temporal and spatial information. Each Track Box\n * contains its associated Media Box.\n */\nexport const trak = (trackData, creationTime) => {\n    const trackMetadata = getTrackMetadata(trackData);\n    return box('trak', undefined, [\n        tkhd(trackData, creationTime),\n        mdia(trackData, creationTime),\n        trackMetadata.name !== undefined\n            ? box('udta', undefined, [\n                box('name', [\n                    ...textEncoder.encode(trackMetadata.name),\n                ]),\n            ])\n            : null,\n    ]);\n};\n/** Track Header Box: Specifies the characteristics of a single track within a movie. */\nexport const tkhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const durationInGlobalTimescale = intoTimescale(lastSample ? lastSample.timestamp + lastSample.duration : 0, GLOBAL_TIMESCALE);\n    const needsU64 = !isU32(creationTime) || !isU32(durationInGlobalTimescale);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    let matrix;\n    if (trackData.type === 'video') {\n        const rotation = trackData.track.metadata.rotation;\n        matrix = rotationMatrix(rotation ?? 0);\n    }\n    else {\n        matrix = IDENTITY_MATRIX;\n    }\n    let flags = 0x2; // Track in movie\n    if (trackData.track.metadata.disposition?.default !== false) {\n        flags |= 0x1; // Track enabled\n    }\n    return fullBox('tkhd', +needsU64, flags, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.track.id), // Track ID\n        u32(0), // Reserved\n        u32OrU64(durationInGlobalTimescale), // Duration\n        Array(8).fill(0), // Reserved\n        u16(0), // Layer\n        u16(trackData.track.id), // Alternate group\n        fixed_8_8(trackData.type === 'audio' ? 1 : 0), // Volume\n        u16(0), // Reserved\n        matrixToBytes(matrix), // Matrix\n        fixed_16_16(trackData.type === 'video' ? trackData.info.width : 0), // Track width\n        fixed_16_16(trackData.type === 'video' ? trackData.info.height : 0), // Track height\n    ]);\n};\n/** Media Box: Describes and define a track's media type and sample data. */\nexport const mdia = (trackData, creationTime) => box('mdia', undefined, [\n    mdhd(trackData, creationTime),\n    hdlr(true, TRACK_TYPE_TO_COMPONENT_SUBTYPE[trackData.type], TRACK_TYPE_TO_HANDLER_NAME[trackData.type]),\n    minf(trackData),\n]);\n/** Media Header Box: Specifies the characteristics of a media, including timescale and duration. */\nexport const mdhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const localDuration = intoTimescale(lastSample ? lastSample.timestamp + lastSample.duration : 0, trackData.timescale);\n    const needsU64 = !isU32(creationTime) || !isU32(localDuration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    return fullBox('mdhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.timescale), // Timescale\n        u32OrU64(localDuration), // Duration\n        u16(getLanguageCodeInt(trackData.track.metadata.languageCode ?? UNDETERMINED_LANGUAGE)), // Language\n        u16(0), // Quality\n    ]);\n};\nconst TRACK_TYPE_TO_COMPONENT_SUBTYPE = {\n    video: 'vide',\n    audio: 'soun',\n    subtitle: 'text',\n};\nconst TRACK_TYPE_TO_HANDLER_NAME = {\n    video: 'MediabunnyVideoHandler',\n    audio: 'MediabunnySoundHandler',\n    subtitle: 'MediabunnyTextHandler',\n};\n/** Handler Reference Box. */\nexport const hdlr = (hasComponentType, handlerType, name, manufacturer = '\\0\\0\\0\\0') => fullBox('hdlr', 0, 0, [\n    hasComponentType ? ascii('mhlr') : u32(0), // Component type\n    ascii(handlerType), // Component subtype\n    ascii(manufacturer), // Component manufacturer\n    u32(0), // Component flags\n    u32(0), // Component flags mask\n    ascii(name, true), // Component name\n]);\n/**\n * Media Information Box: Stores handler-specific information for a track's media data. The media handler uses this\n * information to map from media time to media data and to process the media data.\n */\nexport const minf = (trackData) => box('minf', undefined, [\n    TRACK_TYPE_TO_HEADER_BOX[trackData.type](),\n    dinf(),\n    stbl(trackData),\n]);\n/** Video Media Information Header Box: Defines specific color and graphics mode information. */\nexport const vmhd = () => fullBox('vmhd', 0, 1, [\n    u16(0), // Graphics mode\n    u16(0), // Opcolor R\n    u16(0), // Opcolor G\n    u16(0), // Opcolor B\n]);\n/** Sound Media Information Header Box: Stores the sound media's control information, such as balance. */\nexport const smhd = () => fullBox('smhd', 0, 0, [\n    u16(0), // Balance\n    u16(0), // Reserved\n]);\n/** Null Media Header Box. */\nexport const nmhd = () => fullBox('nmhd', 0, 0);\nconst TRACK_TYPE_TO_HEADER_BOX = {\n    video: vmhd,\n    audio: smhd,\n    subtitle: nmhd,\n};\n/**\n * Data Information Box: Contains information specifying the data handler component that provides access to the\n * media data. The data handler component uses the Data Information Box to interpret the media's data.\n */\nexport const dinf = () => box('dinf', undefined, [\n    dref(),\n]);\n/**\n * Data Reference Box: Contains tabular data that instructs the data handler component how to access the media's data.\n */\nexport const dref = () => fullBox('dref', 0, 0, [\n    u32(1), // Entry count\n], [\n    url(),\n]);\nexport const url = () => fullBox('url ', 0, 1); // Self-reference flag enabled\n/**\n * Sample Table Box: Contains information for converting from media time to sample number to sample location. This box\n * also indicates how to interpret the sample (for example, whether to decompress the video data and, if so, how).\n */\nexport const stbl = (trackData) => {\n    const needsCtts = trackData.compositionTimeOffsetTable.length > 1\n        || trackData.compositionTimeOffsetTable.some(x => x.sampleCompositionTimeOffset !== 0);\n    return box('stbl', undefined, [\n        stsd(trackData),\n        stts(trackData),\n        needsCtts ? ctts(trackData) : null,\n        needsCtts ? cslg(trackData) : null,\n        stsc(trackData),\n        stsz(trackData),\n        stco(trackData),\n        stss(trackData),\n    ]);\n};\n/**\n * Sample Description Box: Stores information that allows you to decode samples in the media. The data stored in the\n * sample description varies, depending on the media type.\n */\nexport const stsd = (trackData) => {\n    let sampleDescription;\n    if (trackData.type === 'video') {\n        sampleDescription = videoSampleDescription(videoCodecToBoxName(trackData.track.source._codec, trackData.info.decoderConfig.codec), trackData);\n    }\n    else if (trackData.type === 'audio') {\n        const boxName = audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime);\n        assert(boxName);\n        sampleDescription = soundSampleDescription(boxName, trackData);\n    }\n    else if (trackData.type === 'subtitle') {\n        sampleDescription = subtitleSampleDescription(SUBTITLE_CODEC_TO_BOX_NAME[trackData.track.source._codec], trackData);\n    }\n    assert(sampleDescription);\n    return fullBox('stsd', 0, 0, [\n        u32(1), // Entry count\n    ], [\n        sampleDescription,\n    ]);\n};\n/** Video Sample Description Box: Contains information that defines how to interpret video media data. */\nexport const videoSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n    u16(0), // Pre-defined\n    u16(0), // Reserved\n    Array(12).fill(0), // Pre-defined\n    u16(trackData.info.width), // Width\n    u16(trackData.info.height), // Height\n    u32(0x00480000), // Horizontal resolution\n    u32(0x00480000), // Vertical resolution\n    u32(0), // Reserved\n    u16(1), // Frame count\n    Array(32).fill(0), // Compressor name\n    u16(0x0018), // Depth\n    i16(0xffff), // Pre-defined\n], [\n    VIDEO_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n    colorSpaceIsComplete(trackData.info.decoderConfig.colorSpace) ? colr(trackData) : null,\n]);\n/** Colour Information Box: Specifies the color space of the video. */\nexport const colr = (trackData) => box('colr', [\n    ascii('nclx'), // Colour type\n    u16(COLOR_PRIMARIES_MAP[trackData.info.decoderConfig.colorSpace.primaries]), // Colour primaries\n    u16(TRANSFER_CHARACTERISTICS_MAP[trackData.info.decoderConfig.colorSpace.transfer]), // Transfer characteristics\n    u16(MATRIX_COEFFICIENTS_MAP[trackData.info.decoderConfig.colorSpace.matrix]), // Matrix coefficients\n    u8((trackData.info.decoderConfig.colorSpace.fullRange ? 1 : 0) << 7), // Full range flag\n]);\n/** AVC Configuration Box: Provides additional information to the decoder. */\nexport const avcC = (trackData) => trackData.info.decoderConfig && box('avcC', [\n    // For AVC, description is an AVCDecoderConfigurationRecord, so nothing else to do here\n    ...toUint8Array(trackData.info.decoderConfig.description),\n]);\n/** HEVC Configuration Box: Provides additional information to the decoder. */\nexport const hvcC = (trackData) => trackData.info.decoderConfig && box('hvcC', [\n    // For HEVC, description is an HEVCDecoderConfigurationRecord, so nothing else to do here\n    ...toUint8Array(trackData.info.decoderConfig.description),\n]);\n/** VP Configuration Box: Provides additional information to the decoder. */\nexport const vpcC = (trackData) => {\n    // Reference: https://www.webmproject.org/vp9/mp4/\n    if (!trackData.info.decoderConfig) {\n        return null;\n    }\n    const decoderConfig = trackData.info.decoderConfig;\n    const parts = decoderConfig.codec.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1; // 4:2:0 colocated with luma (0,0)\n    const videoFullRangeFlag = parts[8] ? Number(parts[8]) : Number(decoderConfig.colorSpace?.fullRange ?? 0);\n    const thirdByte = (bitDepth << 4) + (chromaSubsampling << 1) + videoFullRangeFlag;\n    const colourPrimaries = parts[5]\n        ? Number(parts[5])\n        : decoderConfig.colorSpace?.primaries\n            ? COLOR_PRIMARIES_MAP[decoderConfig.colorSpace.primaries]\n            : 2; // Default to undetermined\n    const transferCharacteristics = parts[6]\n        ? Number(parts[6])\n        : decoderConfig.colorSpace?.transfer\n            ? TRANSFER_CHARACTERISTICS_MAP[decoderConfig.colorSpace.transfer]\n            : 2;\n    const matrixCoefficients = parts[7]\n        ? Number(parts[7])\n        : decoderConfig.colorSpace?.matrix\n            ? MATRIX_COEFFICIENTS_MAP[decoderConfig.colorSpace.matrix]\n            : 2;\n    return fullBox('vpcC', 1, 0, [\n        u8(profile), // Profile\n        u8(level), // Level\n        u8(thirdByte), // Bit depth, chroma subsampling, full range\n        u8(colourPrimaries), // Colour primaries\n        u8(transferCharacteristics), // Transfer characteristics\n        u8(matrixCoefficients), // Matrix coefficients\n        u16(0), // Codec initialization data size\n    ]);\n};\n/** AV1 Configuration Box: Provides additional information to the decoder. */\nexport const av1C = (trackData) => {\n    return box('av1C', generateAv1CodecConfigurationFromCodecString(trackData.info.decoderConfig.codec));\n};\n/** Sound Sample Description Box: Contains information that defines how to interpret sound media data. */\nexport const soundSampleDescription = (compressionType, trackData) => {\n    let version = 0;\n    let contents;\n    let sampleSizeInBits = 16;\n    if (PCM_AUDIO_CODECS.includes(trackData.track.source._codec)) {\n        const codec = trackData.track.source._codec;\n        const { sampleSize } = parsePcmCodec(codec);\n        sampleSizeInBits = 8 * sampleSize;\n        if (sampleSizeInBits > 16) {\n            version = 1;\n        }\n    }\n    if (version === 0) {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(sampleSizeInBits), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n        ];\n    }\n    else {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(Math.min(sampleSizeInBits, 16)), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n            u32(1), // Samples per packet (must be 1 for uncompressed formats)\n            u32(sampleSizeInBits / 8), // Bytes per packet\n            u32(trackData.info.numberOfChannels * sampleSizeInBits / 8), // Bytes per frame\n            u32(2), // Bytes per sample (constant in FFmpeg)\n        ];\n    }\n    return box(compressionType, contents, [\n        audioCodecToConfigurationBox(trackData.track.source._codec, trackData.muxer.isQuickTime)?.(trackData) ?? null,\n    ]);\n};\n/** MPEG-4 Elementary Stream Descriptor Box. */\nexport const esds = (trackData) => {\n    // We build up the bytes in a layered way which reflects the nested structure\n    let objectTypeIndication;\n    switch (trackData.track.source._codec) {\n        case 'aac':\n            {\n                objectTypeIndication = 0x40;\n            }\n            ;\n            break;\n        case 'mp3':\n            {\n                objectTypeIndication = 0x6b;\n            }\n            ;\n            break;\n        case 'vorbis':\n            {\n                objectTypeIndication = 0xdd;\n            }\n            ;\n            break;\n        default: throw new Error(`Unhandled audio codec: ${trackData.track.source._codec}`);\n    }\n    let bytes = [\n        ...u8(objectTypeIndication), // Object type indication\n        ...u8(0x15), // stream type(6bits)=5 audio, flags(2bits)=1\n        ...u24(0), // 24bit buffer size\n        ...u32(0), // max bitrate\n        ...u32(0), // avg bitrate\n    ];\n    if (trackData.info.decoderConfig.description) {\n        const description = toUint8Array(trackData.info.decoderConfig.description);\n        // Add the decoder description to the end\n        bytes = [\n            ...bytes,\n            ...u8(0x05), // TAG(5) = DecoderSpecificInfo\n            ...variableUnsignedInt(description.byteLength),\n            ...description,\n        ];\n    }\n    bytes = [\n        ...u16(1), // ES_ID = 1\n        ...u8(0x00), // flags etc = 0\n        ...u8(0x04), // TAG(4) = ES Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n        ...u8(0x06), // TAG(6)\n        ...u8(0x01), // length\n        ...u8(0x02), // data\n    ];\n    bytes = [\n        ...u8(0x03), // TAG(3) = Object Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n    ];\n    return fullBox('esds', 0, 0, bytes);\n};\nexport const wave = (trackData) => {\n    return box('wave', undefined, [\n        frma(trackData),\n        enda(trackData),\n        box('\\x00\\x00\\x00\\x00'), // NULL tag at the end\n    ]);\n};\nexport const frma = (trackData) => {\n    return box('frma', [\n        ascii(audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime)),\n    ]);\n};\n// This box specifies PCM endianness\nexport const enda = (trackData) => {\n    const { littleEndian } = parsePcmCodec(trackData.track.source._codec);\n    return box('enda', [\n        u16(+littleEndian),\n    ]);\n};\n/** Opus Specific Box. */\nexport const dOps = (trackData) => {\n    let outputChannelCount = trackData.info.numberOfChannels;\n    // Default PreSkip, should be at least 80 milliseconds worth of playback, measured in 48000 Hz samples\n    let preSkip = 3840;\n    let inputSampleRate = trackData.info.sampleRate;\n    let outputGain = 0;\n    let channelMappingFamily = 0;\n    let channelMappingTable = new Uint8Array(0);\n    // Read preskip and from codec private data from the encoder\n    // https://www.rfc-editor.org/rfc/rfc7845#section-5\n    const description = trackData.info.decoderConfig?.description;\n    if (description) {\n        assert(description.byteLength >= 18);\n        const bytes = toUint8Array(description);\n        const header = parseOpusIdentificationHeader(bytes);\n        outputChannelCount = header.outputChannelCount;\n        preSkip = header.preSkip;\n        inputSampleRate = header.inputSampleRate;\n        outputGain = header.outputGain;\n        channelMappingFamily = header.channelMappingFamily;\n        if (header.channelMappingTable) {\n            channelMappingTable = header.channelMappingTable;\n        }\n    }\n    // https://www.opus-codec.org/docs/opus_in_isobmff.html\n    return box('dOps', [\n        u8(0), // Version\n        u8(outputChannelCount), // OutputChannelCount\n        u16(preSkip), // PreSkip\n        u32(inputSampleRate), // InputSampleRate\n        i16(outputGain), // OutputGain\n        u8(channelMappingFamily), // ChannelMappingFamily\n        ...channelMappingTable,\n    ]);\n};\n/** FLAC specific box. */\nexport const dfLa = (trackData) => {\n    const description = trackData.info.decoderConfig?.description;\n    assert(description);\n    const bytes = toUint8Array(description);\n    return fullBox('dfLa', 0, 0, [\n        ...bytes.subarray(4),\n    ]);\n};\n/** PCM Configuration Box, ISO/IEC 23003-5. */\nconst pcmC = (trackData) => {\n    const { littleEndian, sampleSize } = parsePcmCodec(trackData.track.source._codec);\n    const formatFlags = +littleEndian;\n    return fullBox('pcmC', 0, 0, [\n        u8(formatFlags),\n        u8(8 * sampleSize),\n    ]);\n};\nexport const subtitleSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n], [\n    SUBTITLE_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n]);\nexport const vttC = (trackData) => box('vttC', [\n    ...textEncoder.encode(trackData.info.config.description),\n]);\nexport const txtC = (textConfig) => fullBox('txtC', 0, 0, [\n    ...textConfig, 0, // Text config (null-terminated)\n]);\n/**\n * Time-To-Sample Box: Stores duration information for a media's samples, providing a mapping from a time in a media\n * to the corresponding data sample. The table is compact, meaning that consecutive samples with the same time delta\n * will be grouped.\n */\nexport const stts = (trackData) => {\n    return fullBox('stts', 0, 0, [\n        u32(trackData.timeToSampleTable.length), // Number of entries\n        trackData.timeToSampleTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            u32(x.sampleDelta), // Sample duration\n        ]),\n    ]);\n};\n/** Sync Sample Box: Identifies the key frames in the media, marking the random access points within a stream. */\nexport const stss = (trackData) => {\n    if (trackData.samples.every(x => x.type === 'key'))\n        return null; // No stss box -> every frame is a key frame\n    const keySamples = [...trackData.samples.entries()].filter(([, sample]) => sample.type === 'key');\n    return fullBox('stss', 0, 0, [\n        u32(keySamples.length), // Number of entries\n        keySamples.map(([index]) => u32(index + 1)), // Sync sample table\n    ]);\n};\n/**\n * Sample-To-Chunk Box: As samples are added to a media, they are collected into chunks that allow optimized data\n * access. A chunk contains one or more samples. Chunks in a media may have different sizes, and the samples within a\n * chunk may have different sizes. The Sample-To-Chunk Box stores chunk information for the samples in a media, stored\n * in a compactly-coded fashion.\n */\nexport const stsc = (trackData) => {\n    return fullBox('stsc', 0, 0, [\n        u32(trackData.compactlyCodedChunkTable.length), // Number of entries\n        trackData.compactlyCodedChunkTable.map(x => [\n            u32(x.firstChunk), // First chunk\n            u32(x.samplesPerChunk), // Samples per chunk\n            u32(1), // Sample description index\n        ]),\n    ]);\n};\n/** Sample Size Box: Specifies the byte size of each sample in the media. */\nexport const stsz = (trackData) => {\n    if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n        const { sampleSize } = parsePcmCodec(trackData.track.source._codec);\n        // With PCM, every sample has the same size\n        return fullBox('stsz', 0, 0, [\n            u32(sampleSize * trackData.info.numberOfChannels), // Sample size\n            u32(trackData.samples.reduce((acc, x) => acc + intoTimescale(x.duration, trackData.timescale), 0)),\n        ]);\n    }\n    return fullBox('stsz', 0, 0, [\n        u32(0), // Sample size (0 means non-constant size)\n        u32(trackData.samples.length), // Number of entries\n        trackData.samples.map(x => u32(x.size)), // Sample size table\n    ]);\n};\n/** Chunk Offset Box: Identifies the location of each chunk of data in the media's data stream, relative to the file. */\nexport const stco = (trackData) => {\n    if (trackData.finalizedChunks.length > 0 && last(trackData.finalizedChunks).offset >= 2 ** 32) {\n        // If the file is large, use the co64 box\n        return fullBox('co64', 0, 0, [\n            u32(trackData.finalizedChunks.length), // Number of entries\n            trackData.finalizedChunks.map(x => u64(x.offset)), // Chunk offset table\n        ]);\n    }\n    return fullBox('stco', 0, 0, [\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(x => u32(x.offset)), // Chunk offset table\n    ]);\n};\n/**\n * Composition Time to Sample Box: Stores composition time offset information (PTS-DTS) for a\n * media's samples. The table is compact, meaning that consecutive samples with the same time\n * composition time offset will be grouped.\n */\nexport const ctts = (trackData) => {\n    return fullBox('ctts', 1, 0, [\n        u32(trackData.compositionTimeOffsetTable.length), // Number of entries\n        trackData.compositionTimeOffsetTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            i32(x.sampleCompositionTimeOffset), // Sample offset\n        ]),\n    ]);\n};\n/**\n * Composition to Decode Box: Stores information about the composition and display times of the media samples.\n */\nexport const cslg = (trackData) => {\n    let leastDecodeToDisplayDelta = Infinity;\n    let greatestDecodeToDisplayDelta = -Infinity;\n    let compositionStartTime = Infinity;\n    let compositionEndTime = -Infinity;\n    assert(trackData.compositionTimeOffsetTable.length > 0);\n    assert(trackData.samples.length > 0);\n    for (let i = 0; i < trackData.compositionTimeOffsetTable.length; i++) {\n        const entry = trackData.compositionTimeOffsetTable[i];\n        leastDecodeToDisplayDelta = Math.min(leastDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n        greatestDecodeToDisplayDelta = Math.max(greatestDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n    }\n    for (let i = 0; i < trackData.samples.length; i++) {\n        const sample = trackData.samples[i];\n        compositionStartTime = Math.min(compositionStartTime, intoTimescale(sample.timestamp, trackData.timescale));\n        compositionEndTime = Math.max(compositionEndTime, intoTimescale(sample.timestamp + sample.duration, trackData.timescale));\n    }\n    const compositionToDtsShift = Math.max(-leastDecodeToDisplayDelta, 0);\n    if (compositionEndTime >= 2 ** 31) {\n        // For very large files, the composition end time can't be represented in i32, so let's just scrap the box in\n        // that case. QuickTime fails to read the file if there's a cslg box with version 1, so that's sadly not an\n        // option.\n        return null;\n    }\n    return fullBox('cslg', 0, 0, [\n        i32(compositionToDtsShift), // Composition to DTS shift\n        i32(leastDecodeToDisplayDelta), // Least decode to display delta\n        i32(greatestDecodeToDisplayDelta), // Greatest decode to display delta\n        i32(compositionStartTime), // Composition start time\n        i32(compositionEndTime), // Composition end time\n    ]);\n};\n/**\n * Movie Extends Box: This box signals to readers that the file is fragmented. Contains a single Track Extends Box\n * for each track in the movie.\n */\nexport const mvex = (trackDatas) => {\n    return box('mvex', undefined, trackDatas.map(trex));\n};\n/** Track Extends Box: Contains the default values used by the movie fragments. */\nexport const trex = (trackData) => {\n    return fullBox('trex', 0, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(1), // Default sample description index\n        u32(0), // Default sample duration\n        u32(0), // Default sample size\n        u32(0), // Default sample flags\n    ]);\n};\n/**\n * Movie Fragment Box: The movie fragments extend the presentation in time. They provide the information that would\n * previously have been\tin the Movie Box.\n */\nexport const moof = (sequenceNumber, trackDatas) => {\n    return box('moof', undefined, [\n        mfhd(sequenceNumber),\n        ...trackDatas.map(traf),\n    ]);\n};\n/** Movie Fragment Header Box: Contains a sequence number as a safety check. */\nexport const mfhd = (sequenceNumber) => {\n    return fullBox('mfhd', 0, 0, [\n        u32(sequenceNumber), // Sequence number\n    ]);\n};\nconst fragmentSampleFlags = (sample) => {\n    let byte1 = 0;\n    let byte2 = 0;\n    const byte3 = 0;\n    const byte4 = 0;\n    const sampleIsDifferenceSample = sample.type === 'delta';\n    byte2 |= +sampleIsDifferenceSample;\n    if (sampleIsDifferenceSample) {\n        byte1 |= 1; // There is redundant coding in this sample\n    }\n    else {\n        byte1 |= 2; // There is no redundant coding in this sample\n    }\n    // Note that there are a lot of other flags to potentially set here, but most are irrelevant / non-necessary\n    return byte1 << 24 | byte2 << 16 | byte3 << 8 | byte4;\n};\n/** Track Fragment Box */\nexport const traf = (trackData) => {\n    return box('traf', undefined, [\n        tfhd(trackData),\n        tfdt(trackData),\n        trun(trackData),\n    ]);\n};\n/** Track Fragment Header Box: Provides a reference to the extended track, and flags. */\nexport const tfhd = (trackData) => {\n    assert(trackData.currentChunk);\n    let tfFlags = 0;\n    tfFlags |= 0x00008; // Default sample duration present\n    tfFlags |= 0x00010; // Default sample size present\n    tfFlags |= 0x00020; // Default sample flags present\n    tfFlags |= 0x20000; // Default base is moof\n    // Prefer the second sample over the first one, as the first one is a sync sample and therefore the \"odd one out\"\n    const referenceSample = trackData.currentChunk.samples[1] ?? trackData.currentChunk.samples[0];\n    const referenceSampleInfo = {\n        duration: referenceSample.timescaleUnitsToNextSample,\n        size: referenceSample.size,\n        flags: fragmentSampleFlags(referenceSample),\n    };\n    return fullBox('tfhd', 0, tfFlags, [\n        u32(trackData.track.id), // Track ID\n        u32(referenceSampleInfo.duration), // Default sample duration\n        u32(referenceSampleInfo.size), // Default sample size\n        u32(referenceSampleInfo.flags), // Default sample flags\n    ]);\n};\n/**\n * Track Fragment Decode Time Box: Provides the absolute decode time of the first sample of the fragment. This is\n * useful for performing random access on the media file.\n */\nexport const tfdt = (trackData) => {\n    assert(trackData.currentChunk);\n    return fullBox('tfdt', 1, 0, [\n        u64(intoTimescale(trackData.currentChunk.startTimestamp, trackData.timescale)), // Base Media Decode Time\n    ]);\n};\n/** Track Run Box: Specifies a run of contiguous samples for a given track. */\nexport const trun = (trackData) => {\n    assert(trackData.currentChunk);\n    const allSampleDurations = trackData.currentChunk.samples.map(x => x.timescaleUnitsToNextSample);\n    const allSampleSizes = trackData.currentChunk.samples.map(x => x.size);\n    const allSampleFlags = trackData.currentChunk.samples.map(fragmentSampleFlags);\n    const allSampleCompositionTimeOffsets = trackData.currentChunk.samples\n        .map(x => intoTimescale(x.timestamp - x.decodeTimestamp, trackData.timescale));\n    const uniqueSampleDurations = new Set(allSampleDurations);\n    const uniqueSampleSizes = new Set(allSampleSizes);\n    const uniqueSampleFlags = new Set(allSampleFlags);\n    const uniqueSampleCompositionTimeOffsets = new Set(allSampleCompositionTimeOffsets);\n    const firstSampleFlagsPresent = uniqueSampleFlags.size === 2 && allSampleFlags[0] !== allSampleFlags[1];\n    const sampleDurationPresent = uniqueSampleDurations.size > 1;\n    const sampleSizePresent = uniqueSampleSizes.size > 1;\n    const sampleFlagsPresent = !firstSampleFlagsPresent && uniqueSampleFlags.size > 1;\n    const sampleCompositionTimeOffsetsPresent = uniqueSampleCompositionTimeOffsets.size > 1 || [...uniqueSampleCompositionTimeOffsets].some(x => x !== 0);\n    let flags = 0;\n    flags |= 0x0001; // Data offset present\n    flags |= 0x0004 * +firstSampleFlagsPresent; // First sample flags present\n    flags |= 0x0100 * +sampleDurationPresent; // Sample duration present\n    flags |= 0x0200 * +sampleSizePresent; // Sample size present\n    flags |= 0x0400 * +sampleFlagsPresent; // Sample flags present\n    flags |= 0x0800 * +sampleCompositionTimeOffsetsPresent; // Sample composition time offsets present\n    return fullBox('trun', 1, flags, [\n        u32(trackData.currentChunk.samples.length), // Sample count\n        u32(trackData.currentChunk.offset - trackData.currentChunk.moofOffset || 0), // Data offset\n        firstSampleFlagsPresent ? u32(allSampleFlags[0]) : [],\n        trackData.currentChunk.samples.map((_, i) => [\n            sampleDurationPresent ? u32(allSampleDurations[i]) : [], // Sample duration\n            sampleSizePresent ? u32(allSampleSizes[i]) : [], // Sample size\n            sampleFlagsPresent ? u32(allSampleFlags[i]) : [], // Sample flags\n            // Sample composition time offsets\n            sampleCompositionTimeOffsetsPresent ? i32(allSampleCompositionTimeOffsets[i]) : [],\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Box: For each track, provides pointers to sync samples within the file\n * for random access.\n */\nexport const mfra = (trackDatas) => {\n    return box('mfra', undefined, [\n        ...trackDatas.map(tfra),\n        mfro(),\n    ]);\n};\n/** Track Fragment Random Access Box: Provides pointers to sync samples within the file for random access. */\nexport const tfra = (trackData, trackIndex) => {\n    const version = 1; // Using this version allows us to use 64-bit time and offset values\n    return fullBox('tfra', version, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(0b111111), // This specifies that traf number, trun number and sample number are 32-bit ints\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(chunk => [\n            u64(intoTimescale(chunk.samples[0].timestamp, trackData.timescale)), // Time (in presentation time)\n            u64(chunk.moofOffset), // moof offset\n            u32(trackIndex + 1), // traf number\n            u32(1), // trun number\n            u32(1), // Sample number\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Offset Box: Provides the size of the enclosing mfra box. This box can be used by readers\n * to quickly locate the mfra box by searching from the end of the file.\n */\nexport const mfro = () => {\n    return fullBox('mfro', 0, 0, [\n        // This value needs to be overwritten manually from the outside, where the actual size of the enclosing mfra box\n        // is known\n        u32(0), // Size\n    ]);\n};\n/** VTT Empty Cue Box */\nexport const vtte = () => box('vtte');\n/** VTT Cue Box */\nexport const vttc = (payload, timestamp, identifier, settings, sourceId) => box('vttc', undefined, [\n    sourceId !== null ? box('vsid', [i32(sourceId)]) : null,\n    identifier !== null ? box('iden', [...textEncoder.encode(identifier)]) : null,\n    timestamp !== null ? box('ctim', [...textEncoder.encode(formatSubtitleTimestamp(timestamp))]) : null,\n    settings !== null ? box('sttg', [...textEncoder.encode(settings)]) : null,\n    box('payl', [...textEncoder.encode(payload)]),\n]);\n/** VTT Additional Text Box */\nexport const vtta = (notes) => box('vtta', [...textEncoder.encode(notes)]);\n/** User Data Box */\nconst udta = (muxer) => {\n    const boxes = [];\n    const metadataFormat = muxer.format._options.metadataFormat ?? 'auto';\n    const metadataTags = muxer.output._metadataTags;\n    // Depending on the format, metadata tags are written differently\n    if (metadataFormat === 'mdir' || (metadataFormat === 'auto' && !muxer.isQuickTime)) {\n        const metaBox = metaMdir(metadataTags);\n        if (metaBox)\n            boxes.push(metaBox);\n    }\n    else if (metadataFormat === 'mdta') {\n        const metaBox = metaMdta(metadataTags);\n        if (metaBox)\n            boxes.push(metaBox);\n    }\n    else if (metadataFormat === 'udta' || (metadataFormat === 'auto' && muxer.isQuickTime)) {\n        addQuickTimeMetadataTagBoxes(boxes, muxer.output._metadataTags);\n    }\n    if (boxes.length === 0) {\n        return null;\n    }\n    return box('udta', undefined, boxes);\n};\nconst addQuickTimeMetadataTagBoxes = (boxes, tags) => {\n    // https://exiftool.org/TagNames/QuickTime.html (QuickTime UserData Tags)\n    // For QuickTime files, metadata tags are dumped into the udta box\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    boxes.push(metadataTagStringBoxShort('nam', value));\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    boxes.push(metadataTagStringBoxShort('des', value));\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    boxes.push(metadataTagStringBoxShort('ART', value));\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    boxes.push(metadataTagStringBoxShort('alb', value));\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    boxes.push(metadataTagStringBoxShort('albr', value));\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    boxes.push(metadataTagStringBoxShort('gen', value));\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    boxes.push(metadataTagStringBoxShort('day', value.toISOString().slice(0, 10)));\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    boxes.push(metadataTagStringBoxShort('cmt', value));\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    boxes.push(metadataTagStringBoxShort('lyr', value));\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            case 'discNumber':\n            case 'discsTotal':\n            case 'trackNumber':\n            case 'tracksTotal':\n            case 'images':\n                {\n                    // Not written for QuickTime (common Apple L)\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key];\n            if (value == null || key.length !== 4 || boxes.some(x => x.type === key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                boxes.push(metadataTagStringBoxShort(key, value));\n            }\n            else if (value instanceof Uint8Array) {\n                boxes.push(box(key, Array.from(value)));\n            }\n        }\n    }\n};\nconst metadataTagStringBoxShort = (name, value) => {\n    const encoded = textEncoder.encode(value);\n    return box(name, [\n        u16(encoded.length),\n        u16(getLanguageCodeInt('und')),\n        Array.from(encoded),\n    ]);\n};\nconst DATA_BOX_MIME_TYPE_MAP = {\n    'image/jpeg': 13,\n    'image/png': 14,\n    'image/bmp': 27,\n};\n/**\n * Generates key-value metadata for inclusion in the \"meta\" box.\n */\nconst generateMetadataPairs = (tags, isMdta) => {\n    const pairs = [];\n    // https://exiftool.org/TagNames/QuickTime.html (QuickTime ItemList Tags)\n    // This is the metadata format used for MP4 files\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    pairs.push({ key: isMdta ? 'title' : 'nam', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    pairs.push({ key: isMdta ? 'description' : 'des', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    pairs.push({ key: isMdta ? 'artist' : 'ART', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    pairs.push({ key: isMdta ? 'album' : 'alb', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    pairs.push({ key: isMdta ? 'album_artist' : 'aART', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    pairs.push({ key: isMdta ? 'comment' : 'cmt', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    pairs.push({ key: isMdta ? 'genre' : 'gen', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    pairs.push({ key: isMdta ? 'lyrics' : 'lyr', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    pairs.push({\n                        key: isMdta ? 'date' : 'day',\n                        value: dataStringBoxLong(value.toISOString().slice(0, 10)),\n                    });\n                }\n                ;\n                break;\n            case 'images':\n                {\n                    for (const image of value) {\n                        if (image.kind !== 'coverFront') {\n                            continue;\n                        }\n                        pairs.push({ key: 'covr', value: box('data', [\n                                u32(DATA_BOX_MIME_TYPE_MAP[image.mimeType] ?? 0), // Type indicator\n                                u32(0), // Locale indicator\n                                Array.from(image.data), // Kinda slow, hopefully temp\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'trackNumber':\n                {\n                    if (isMdta) {\n                        const string = tags.tracksTotal !== undefined\n                            ? `${value}/${tags.tracksTotal}`\n                            : value.toString();\n                        pairs.push({ key: 'track', value: dataStringBoxLong(string) });\n                    }\n                    else {\n                        pairs.push({ key: 'trkn', value: box('data', [\n                                u32(0), // 8 bytes empty\n                                u32(0),\n                                u16(0), // Empty\n                                u16(value),\n                                u16(tags.tracksTotal ?? 0),\n                                u16(0), // Empty\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'discNumber':\n                {\n                    if (!isMdta) {\n                        // Only written for mdir\n                        pairs.push({ key: 'disc', value: box('data', [\n                                u32(0), // 8 bytes empty\n                                u32(0),\n                                u16(0), // Empty\n                                u16(value),\n                                u16(tags.discsTotal ?? 0),\n                                u16(0), // Empty\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'tracksTotal':\n            case 'discsTotal':\n                {\n                    // These are included with 'trackNumber' and 'discNumber' respectively\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key];\n            if (value == null || (!isMdta && key.length !== 4) || pairs.some(x => x.key === key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                pairs.push({ key, value: dataStringBoxLong(value) });\n            }\n            else if (value instanceof Uint8Array) {\n                pairs.push({ key, value: box('data', [\n                        u32(0), // Type indicator\n                        u32(0), // Locale indicator\n                        Array.from(value),\n                    ]) });\n            }\n            else if (value instanceof RichImageData) {\n                pairs.push({ key, value: box('data', [\n                        u32(DATA_BOX_MIME_TYPE_MAP[value.mimeType] ?? 0), // Type indicator\n                        u32(0), // Locale indicator\n                        Array.from(value.data), // Kinda slow, hopefully temp\n                    ]) });\n            }\n        }\n    }\n    return pairs;\n};\n/** Metadata Box (mdir format) */\nconst metaMdir = (tags) => {\n    const pairs = generateMetadataPairs(tags, false);\n    if (pairs.length === 0) {\n        return null;\n    }\n    // fullBox format\n    return fullBox('meta', 0, 0, undefined, [\n        hdlr(false, 'mdir', '', 'appl'), // mdir handler\n        box('ilst', undefined, pairs.map(pair => box(pair.key, undefined, [pair.value]))), // Item list without keys box\n    ]);\n};\n/** Metadata Box (mdta format with keys box) */\nconst metaMdta = (tags) => {\n    const pairs = generateMetadataPairs(tags, true);\n    if (pairs.length === 0) {\n        return null;\n    }\n    // box without version and flags\n    return box('meta', undefined, [\n        hdlr(false, 'mdta', ''), // mdta handler\n        fullBox('keys', 0, 0, [\n            u32(pairs.length),\n        ], pairs.map(pair => box('mdta', [\n            ...textEncoder.encode(pair.key),\n        ]))),\n        box('ilst', undefined, pairs.map((pair, i) => {\n            const boxName = String.fromCharCode(...u32(i + 1));\n            return box(boxName, undefined, [pair.value]);\n        })),\n    ]);\n};\nconst dataStringBoxLong = (value) => {\n    return box('data', [\n        u32(1), // Type indicator (UTF-8)\n        u32(0), // Locale indicator\n        ...textEncoder.encode(value),\n    ]);\n};\nconst videoCodecToBoxName = (codec, fullCodecString) => {\n    switch (codec) {\n        case 'avc': return fullCodecString.startsWith('avc3') ? 'avc3' : 'avc1';\n        case 'hevc': return 'hvc1';\n        case 'vp8': return 'vp08';\n        case 'vp9': return 'vp09';\n        case 'av1': return 'av01';\n    }\n};\nconst VIDEO_CODEC_TO_CONFIGURATION_BOX = {\n    avc: avcC,\n    hevc: hvcC,\n    vp8: vpcC,\n    vp9: vpcC,\n    av1: av1C,\n};\nconst audioCodecToBoxName = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return 'mp4a';\n        case 'mp3': return 'mp4a';\n        case 'opus': return 'Opus';\n        case 'vorbis': return 'mp4a';\n        case 'flac': return 'fLaC';\n        case 'ulaw': return 'ulaw';\n        case 'alaw': return 'alaw';\n        case 'pcm-u8': return 'raw ';\n        case 'pcm-s8': return 'sowt';\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s16': return 'sowt';\n            case 'pcm-s16be': return 'twos';\n            case 'pcm-s24': return 'in24';\n            case 'pcm-s24be': return 'in24';\n            case 'pcm-s32': return 'in32';\n            case 'pcm-s32be': return 'in32';\n            case 'pcm-f32': return 'fl32';\n            case 'pcm-f32be': return 'fl32';\n            case 'pcm-f64': return 'fl64';\n            case 'pcm-f64be': return 'fl64';\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return 'ipcm';\n            case 'pcm-s16be': return 'ipcm';\n            case 'pcm-s24': return 'ipcm';\n            case 'pcm-s24be': return 'ipcm';\n            case 'pcm-s32': return 'ipcm';\n            case 'pcm-s32be': return 'ipcm';\n            case 'pcm-f32': return 'fpcm';\n            case 'pcm-f32be': return 'fpcm';\n            case 'pcm-f64': return 'fpcm';\n            case 'pcm-f64be': return 'fpcm';\n        }\n    }\n};\nconst audioCodecToConfigurationBox = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return esds;\n        case 'mp3': return esds;\n        case 'opus': return dOps;\n        case 'vorbis': return esds;\n        case 'flac': return dfLa;\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s24': return wave;\n            case 'pcm-s24be': return wave;\n            case 'pcm-s32': return wave;\n            case 'pcm-s32be': return wave;\n            case 'pcm-f32': return wave;\n            case 'pcm-f32be': return wave;\n            case 'pcm-f64': return wave;\n            case 'pcm-f64be': return wave;\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return pcmC;\n            case 'pcm-s16be': return pcmC;\n            case 'pcm-s24': return pcmC;\n            case 'pcm-s24be': return pcmC;\n            case 'pcm-s32': return pcmC;\n            case 'pcm-s32be': return pcmC;\n            case 'pcm-f32': return pcmC;\n            case 'pcm-f32be': return pcmC;\n            case 'pcm-f64': return pcmC;\n            case 'pcm-f64be': return pcmC;\n        }\n    }\n    return null;\n};\nconst SUBTITLE_CODEC_TO_BOX_NAME = {\n    webvtt: 'wvtt',\n};\nconst SUBTITLE_CODEC_TO_CONFIGURATION_BOX = {\n    webvtt: vttC,\n};\nconst getLanguageCodeInt = (code) => {\n    assert(code.length === 3);\n    ;\n    let language = 0;\n    for (let i = 0; i < 3; i++) {\n        language <<= 5;\n        language += code.charCodeAt(i) - 0x60;\n    }\n    return language;\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert } from './misc.js';\nexport class Writer {\n    constructor() {\n        /** Setting this to true will cause the writer to ensure data is written in a strictly monotonic, streamable way. */\n        this.ensureMonotonicity = false;\n        this.trackedWrites = null;\n        this.trackedStart = -1;\n        this.trackedEnd = -1;\n    }\n    start() { }\n    maybeTrackWrites(data) {\n        if (!this.trackedWrites) {\n            return;\n        }\n        // Handle negative relative write positions\n        let pos = this.getPos();\n        if (pos < this.trackedStart) {\n            if (pos + data.byteLength <= this.trackedStart) {\n                return;\n            }\n            data = data.subarray(this.trackedStart - pos);\n            pos = 0;\n        }\n        const neededSize = pos + data.byteLength - this.trackedStart;\n        let newLength = this.trackedWrites.byteLength;\n        while (newLength < neededSize) {\n            newLength *= 2;\n        }\n        // Check if we need to resize the buffer\n        if (newLength !== this.trackedWrites.byteLength) {\n            const copy = new Uint8Array(newLength);\n            copy.set(this.trackedWrites, 0);\n            this.trackedWrites = copy;\n        }\n        this.trackedWrites.set(data, pos - this.trackedStart);\n        this.trackedEnd = Math.max(this.trackedEnd, pos + data.byteLength);\n    }\n    startTrackingWrites() {\n        this.trackedWrites = new Uint8Array(2 ** 10);\n        this.trackedStart = this.getPos();\n        this.trackedEnd = this.trackedStart;\n    }\n    stopTrackingWrites() {\n        if (!this.trackedWrites) {\n            throw new Error('Internal error: Can\\'t get tracked writes since nothing was tracked.');\n        }\n        const slice = this.trackedWrites.subarray(0, this.trackedEnd - this.trackedStart);\n        const result = {\n            data: slice,\n            start: this.trackedStart,\n            end: this.trackedEnd,\n        };\n        this.trackedWrites = null;\n        return result;\n    }\n}\nconst ARRAY_BUFFER_INITIAL_SIZE = 2 ** 16;\nconst ARRAY_BUFFER_MAX_SIZE = 2 ** 32;\nexport class BufferTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.maxPos = 0;\n        this.target = target;\n        this.supportsResize = 'resize' in new ArrayBuffer(0);\n        if (this.supportsResize) {\n            try {\n                // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE, { maxByteLength: ARRAY_BUFFER_MAX_SIZE });\n            }\n            catch {\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n                this.supportsResize = false;\n            }\n        }\n        else {\n            this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n        }\n        this.bytes = new Uint8Array(this.buffer);\n    }\n    ensureSize(size) {\n        let newLength = this.buffer.byteLength;\n        while (newLength < size)\n            newLength *= 2;\n        if (newLength === this.buffer.byteLength)\n            return;\n        if (newLength > ARRAY_BUFFER_MAX_SIZE) {\n            throw new Error(`ArrayBuffer exceeded maximum size of ${ARRAY_BUFFER_MAX_SIZE} bytes. Please consider using another`\n                + ` target.`);\n        }\n        if (this.supportsResize) {\n            // Use resize if it exists\n            // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            this.buffer.resize(newLength);\n            // The Uint8Array scales automatically\n        }\n        else {\n            const newBuffer = new ArrayBuffer(newLength);\n            const newBytes = new Uint8Array(newBuffer);\n            newBytes.set(this.bytes, 0);\n            this.buffer = newBuffer;\n            this.bytes = newBytes;\n        }\n    }\n    write(data) {\n        this.maybeTrackWrites(data);\n        this.ensureSize(this.pos + data.byteLength);\n        this.bytes.set(data, this.pos);\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n        this.maxPos = Math.max(this.maxPos, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() { }\n    async finalize() {\n        this.ensureSize(this.pos);\n        this.target.buffer = this.buffer.slice(0, Math.max(this.maxPos, this.pos));\n    }\n    async close() { }\n    getSlice(start, end) {\n        return this.bytes.slice(start, end);\n    }\n}\nconst DEFAULT_CHUNK_SIZE = 2 ** 24;\nconst MAX_CHUNKS_AT_ONCE = 2;\n/**\n * Writes to a StreamTarget every time it is flushed, sending out all of the new data written since the\n * last flush. This is useful for streaming applications, like piping the output to disk. When using the chunked mode,\n * data will first be accumulated in larger chunks, and then the entire chunk will be flushed out at once when ready.\n */\nexport class StreamTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.sections = [];\n        this.lastWriteEnd = 0;\n        this.lastFlushEnd = 0;\n        this.writer = null;\n        /**\n         * The data is divided up into fixed-size chunks, whose contents are first filled in RAM and then flushed out.\n         * A chunk is flushed if all of its contents have been written.\n         */\n        this.chunks = [];\n        this.target = target;\n        this.chunked = target._options.chunked ?? false;\n        this.chunkSize = target._options.chunkSize ?? DEFAULT_CHUNK_SIZE;\n    }\n    start() {\n        this.writer = this.target._writable.getWriter();\n    }\n    write(data) {\n        if (this.pos > this.lastWriteEnd) {\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        this.maybeTrackWrites(data);\n        this.sections.push({\n            data: data.slice(),\n            start: this.pos,\n        });\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n        this.lastWriteEnd = Math.max(this.lastWriteEnd, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() {\n        if (this.pos > this.lastWriteEnd) {\n            // There's a \"void\" between the last written byte and the next byte we're about to write. Let's pad that\n            // void with zeroes explicitly.\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        assert(this.writer);\n        if (this.sections.length === 0)\n            return;\n        const chunks = [];\n        const sorted = [...this.sections].sort((a, b) => a.start - b.start);\n        chunks.push({\n            start: sorted[0].start,\n            size: sorted[0].data.byteLength,\n        });\n        // Figure out how many contiguous chunks we have\n        for (let i = 1; i < sorted.length; i++) {\n            const lastChunk = chunks[chunks.length - 1];\n            const section = sorted[i];\n            if (section.start <= lastChunk.start + lastChunk.size) {\n                lastChunk.size = Math.max(lastChunk.size, section.start + section.data.byteLength - lastChunk.start);\n            }\n            else {\n                chunks.push({\n                    start: section.start,\n                    size: section.data.byteLength,\n                });\n            }\n        }\n        for (const chunk of chunks) {\n            chunk.data = new Uint8Array(chunk.size);\n            // Make sure to write the data in the correct order for correct overwriting\n            for (const section of this.sections) {\n                // Check if the section is in the chunk\n                if (chunk.start <= section.start && section.start < chunk.start + chunk.size) {\n                    chunk.data.set(section.data, section.start - chunk.start);\n                }\n            }\n            if (this.writer.desiredSize !== null && this.writer.desiredSize <= 0) {\n                await this.writer.ready; // Allow the writer to apply backpressure\n            }\n            if (this.chunked) {\n                // Let's first gather the data into bigger chunks before writing it\n                this.writeDataIntoChunks(chunk.data, chunk.start);\n                this.tryToFlushChunks();\n            }\n            else {\n                if (this.ensureMonotonicity && chunk.start !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                // Write out the data immediately\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data,\n                    position: chunk.start,\n                });\n                this.lastFlushEnd = chunk.start + chunk.data.byteLength;\n            }\n        }\n        this.sections.length = 0;\n    }\n    writeDataIntoChunks(data, position) {\n        // First, find the chunk to write the data into, or create one if none exists\n        let chunkIndex = this.chunks.findIndex(x => x.start <= position && position < x.start + this.chunkSize);\n        if (chunkIndex === -1)\n            chunkIndex = this.createChunk(position);\n        const chunk = this.chunks[chunkIndex];\n        // Figure out how much to write to the chunk, and then write to the chunk\n        const relativePosition = position - chunk.start;\n        const toWrite = data.subarray(0, Math.min(this.chunkSize - relativePosition, data.byteLength));\n        chunk.data.set(toWrite, relativePosition);\n        // Create a section describing the region of data that was just written to\n        const section = {\n            start: relativePosition,\n            end: relativePosition + toWrite.byteLength,\n        };\n        this.insertSectionIntoChunk(chunk, section);\n        // Queue chunk for flushing to target if it has been fully written to\n        if (chunk.written[0].start === 0 && chunk.written[0].end === this.chunkSize) {\n            chunk.shouldFlush = true;\n        }\n        // Make sure we don't hold too many chunks in memory at once to keep memory usage down\n        if (this.chunks.length > MAX_CHUNKS_AT_ONCE) {\n            // Flush all but the last chunk\n            for (let i = 0; i < this.chunks.length - 1; i++) {\n                this.chunks[i].shouldFlush = true;\n            }\n            this.tryToFlushChunks();\n        }\n        // If the data didn't fit in one chunk, recurse with the remaining data\n        if (toWrite.byteLength < data.byteLength) {\n            this.writeDataIntoChunks(data.subarray(toWrite.byteLength), position + toWrite.byteLength);\n        }\n    }\n    insertSectionIntoChunk(chunk, section) {\n        let low = 0;\n        let high = chunk.written.length - 1;\n        let index = -1;\n        // Do a binary search to find the last section with a start not larger than `section`'s start\n        while (low <= high) {\n            const mid = Math.floor(low + (high - low + 1) / 2);\n            if (chunk.written[mid].start <= section.start) {\n                low = mid + 1;\n                index = mid;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        // Insert the new section\n        chunk.written.splice(index + 1, 0, section);\n        if (index === -1 || chunk.written[index].end < section.start)\n            index++;\n        // Merge overlapping sections\n        while (index < chunk.written.length - 1 && chunk.written[index].end >= chunk.written[index + 1].start) {\n            chunk.written[index].end = Math.max(chunk.written[index].end, chunk.written[index + 1].end);\n            chunk.written.splice(index + 1, 1);\n        }\n    }\n    createChunk(includesPosition) {\n        const start = Math.floor(includesPosition / this.chunkSize) * this.chunkSize;\n        const chunk = {\n            start,\n            data: new Uint8Array(this.chunkSize),\n            written: [],\n            shouldFlush: false,\n        };\n        this.chunks.push(chunk);\n        this.chunks.sort((a, b) => a.start - b.start);\n        return this.chunks.indexOf(chunk);\n    }\n    tryToFlushChunks(force = false) {\n        assert(this.writer);\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            if (!chunk.shouldFlush && !force)\n                continue;\n            for (const section of chunk.written) {\n                const position = chunk.start + section.start;\n                if (this.ensureMonotonicity && position !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data.subarray(section.start, section.end),\n                    position,\n                });\n                this.lastFlushEnd = chunk.start + section.end;\n            }\n            this.chunks.splice(i--, 1);\n        }\n    }\n    finalize() {\n        if (this.chunked) {\n            this.tryToFlushChunks(true);\n        }\n        assert(this.writer);\n        return this.writer.close();\n    }\n    async close() {\n        return this.writer?.close();\n    }\n}\nexport class NullTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.target = target;\n        this.pos = 0;\n    }\n    write(data) {\n        this.maybeTrackWrites(data);\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n    }\n    getPos() {\n        return this.pos;\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    async flush() { }\n    async finalize() { }\n    async close() { }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { BufferTargetWriter, NullTargetWriter, StreamTargetWriter } from './writer.js';\nimport * as nodeAlias from './node.js';\nimport { assert } from './misc.js';\nconst node = typeof nodeAlias !== 'undefined'\n    ? nodeAlias // Aliasing it prevents some bundler warnings\n    : undefined;\n/**\n * Base class for targets, specifying where output files are written.\n * @group Output targets\n * @public\n */\nexport class Target {\n    constructor() {\n        /** @internal */\n        this._output = null;\n        /**\n         * Called each time data is written to the target. Will be called with the byte range into which data was written.\n         *\n         * Use this callback to track the size of the output file as it grows. But be warned, this function is chatty and\n         * gets called *extremely* often.\n         */\n        this.onwrite = null;\n    }\n}\n/**\n * A target that writes data directly into an ArrayBuffer in memory. Great for performance, but not suitable for very\n * large files. The buffer will be available once the output has been finalized.\n * @group Output targets\n * @public\n */\nexport class BufferTarget extends Target {\n    constructor() {\n        super(...arguments);\n        /** Stores the final output buffer. Until the output is finalized, this will be `null`. */\n        this.buffer = null;\n    }\n    /** @internal */\n    _createWriter() {\n        return new BufferTargetWriter(this);\n    }\n}\n/**\n * This target writes data to a [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream),\n * making it a general-purpose target for writing data anywhere. It is also compatible with\n * [`FileSystemWritableFileStream`](https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream) for\n * use with the [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_API). The\n * `WritableStream` can also apply backpressure, which will propagate to the output and throttle the encoders.\n * @group Output targets\n * @public\n */\nexport class StreamTarget extends Target {\n    /** Creates a new {@link StreamTarget} which writes to the specified `writable`. */\n    constructor(writable, options = {}) {\n        super();\n        if (!(writable instanceof WritableStream)) {\n            throw new TypeError('StreamTarget requires a WritableStream instance.');\n        }\n        if (options != null && typeof options !== 'object') {\n            throw new TypeError('StreamTarget options, when provided, must be an object.');\n        }\n        if (options.chunked !== undefined && typeof options.chunked !== 'boolean') {\n            throw new TypeError('options.chunked, when provided, must be a boolean.');\n        }\n        if (options.chunkSize !== undefined && (!Number.isInteger(options.chunkSize) || options.chunkSize < 1024)) {\n            throw new TypeError('options.chunkSize, when provided, must be an integer and not smaller than 1024.');\n        }\n        this._writable = writable;\n        this._options = options;\n    }\n    /** @internal */\n    _createWriter() {\n        return new StreamTargetWriter(this);\n    }\n}\n/**\n * A target that writes to a file at the specified path. Intended for server-side usage in Node, Bun, or Deno.\n *\n * Writing is chunked by default. The internally held file handle will be closed when `.finalize()` or `.cancel()` are\n * called on the corresponding {@link Output}.\n * @group Output targets\n * @public\n */\nexport class FilePathTarget extends Target {\n    /** Creates a new {@link FilePathTarget} that writes to the file at the specified file path. */\n    constructor(filePath, options = {}) {\n        if (typeof filePath !== 'string') {\n            throw new TypeError('filePath must be a string.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        super();\n        /** @internal */\n        this._fileHandle = null;\n        // Let's back this target with a StreamTarget, makes the implementation very simple\n        const writable = new WritableStream({\n            start: async () => {\n                this._fileHandle = await node.fs.open(filePath, 'w');\n            },\n            write: async (chunk) => {\n                assert(this._fileHandle);\n                await this._fileHandle.write(chunk.data, 0, chunk.data.byteLength, chunk.position);\n            },\n            close: async () => {\n                if (this._fileHandle) {\n                    await this._fileHandle.close();\n                    this._fileHandle = null;\n                }\n            },\n        });\n        this._streamTarget = new StreamTarget(writable, {\n            chunked: true,\n            ...options,\n        });\n        this._streamTarget._output = this._output;\n    }\n    /** @internal */\n    _createWriter() {\n        return this._streamTarget._createWriter();\n    }\n}\n/**\n * This target just discards all incoming data. It is useful for when you need an {@link Output} but extract data from\n * it differently, for example through format-specific callbacks (`onMoof`, `onMdat`, ...) or encoder events.\n * @group Output targets\n * @public\n */\nexport class NullTarget extends Target {\n    /** @internal */\n    _createWriter() {\n        return new NullTargetWriter(this);\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { free, ftyp, IsobmffBoxWriter, mdat, mfra, moof, moov, vtta, vttc, vtte } from './isobmff-boxes.js';\nimport { Muxer } from '../muxer.js';\nimport { BufferTargetWriter } from '../writer.js';\nimport { assert, computeRationalApproximation, last, promiseWithResolvers } from '../misc.js';\nimport { MovOutputFormat } from '../output-format.js';\nimport { inlineTimestampRegex } from '../subtitles.js';\nimport { aacChannelMap, aacFrequencyTable, buildAacAudioSpecificConfig, parsePcmCodec, PCM_AUDIO_CODECS, validateAudioChunkMetadata, validateSubtitleMetadata, validateVideoChunkMetadata, } from '../codec.js';\nimport { MAX_ADTS_FRAME_HEADER_SIZE, MIN_ADTS_FRAME_HEADER_SIZE, readAdtsFrameHeader } from '../adts/adts-reader.js';\nimport { FileSlice } from '../reader.js';\nimport { BufferTarget } from '../target.js';\nimport { concatNalUnitsInLengthPrefixed, extractAvcDecoderConfigurationRecord, extractHevcDecoderConfigurationRecord, iterateNalUnitsInAnnexB, serializeAvcDecoderConfigurationRecord, serializeHevcDecoderConfigurationRecord, } from '../codec-data.js';\nimport { buildIsobmffMimeType } from './isobmff-misc.js';\nimport { MAX_BOX_HEADER_SIZE, MIN_BOX_HEADER_SIZE } from './isobmff-reader.js';\nexport const GLOBAL_TIMESCALE = 1000;\nconst TIMESTAMP_OFFSET = 2_082_844_800; // Seconds between Jan 1 1904 and Jan 1 1970\nexport const getTrackMetadata = (trackData) => {\n    const metadata = {};\n    const track = trackData.track;\n    if (track.metadata.name !== undefined) {\n        metadata.name = track.metadata.name;\n    }\n    return metadata;\n};\nexport const intoTimescale = (timeInSeconds, timescale, round = true) => {\n    const value = timeInSeconds * timescale;\n    return round ? Math.round(value) : value;\n};\nexport class IsobmffMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.auxTarget = new BufferTarget();\n        this.auxWriter = this.auxTarget._createWriter();\n        this.auxBoxWriter = new IsobmffBoxWriter(this.auxWriter);\n        this.mdat = null;\n        this.ftypSize = null;\n        this.trackDatas = [];\n        this.allTracksKnown = promiseWithResolvers();\n        this.creationTime = Math.floor(Date.now() / 1000) + TIMESTAMP_OFFSET;\n        this.finalizedChunks = [];\n        this.nextFragmentNumber = 1;\n        // Only relevant for fragmented files, to make sure new fragments start with the highest timestamp seen so far\n        this.maxWrittenTimestamp = -Infinity;\n        this.format = format;\n        this.writer = output._writer;\n        this.boxWriter = new IsobmffBoxWriter(this.writer);\n        this.isQuickTime = format instanceof MovOutputFormat;\n        // If the fastStart option isn't defined, enable in-memory fast start if the target is an ArrayBuffer, as the\n        // memory usage remains identical\n        const fastStartDefault = this.writer instanceof BufferTargetWriter ? 'in-memory' : false;\n        this.fastStart = format._options.fastStart ?? fastStartDefault;\n        this.isFragmented = this.fastStart === 'fragmented';\n        if (this.fastStart === 'in-memory' || this.isFragmented) {\n            this.writer.ensureMonotonicity = true;\n        }\n        this.minimumFragmentDuration = format._options.minimumFragmentDuration ?? 1;\n    }\n    async start() {\n        const release = await this.mutex.acquire();\n        const holdsAvc = this.output._tracks.some(x => x.type === 'video' && x.source._codec === 'avc');\n        // Write the header\n        {\n            if (this.format._options.onFtyp) {\n                this.writer.startTrackingWrites();\n            }\n            this.boxWriter.writeBox(ftyp({\n                isQuickTime: this.isQuickTime,\n                holdsAvc: holdsAvc,\n                fragmented: this.isFragmented,\n            }));\n            if (this.format._options.onFtyp) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onFtyp(data, start);\n            }\n        }\n        this.ftypSize = this.writer.getPos();\n        if (this.fastStart === 'in-memory') {\n            // We're write at finalization\n        }\n        else if (this.fastStart === 'reserve') {\n            // Validate that all tracks have set maximumPacketCount\n            for (const track of this.output._tracks) {\n                if (track.metadata.maximumPacketCount === undefined) {\n                    throw new Error('All tracks must specify maximumPacketCount in their metadata when using'\n                        + ' fastStart: \\'reserve\\'.');\n                }\n            }\n            // We'll start writing once we know all tracks\n        }\n        else if (this.isFragmented) {\n            // We write the moov box once we write out the first fragment to make sure we get the decoder configs\n        }\n        else {\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat = mdat(true); // Reserve large size by default, can refine this when finalizing.\n            this.boxWriter.writeBox(this.mdat);\n        }\n        await this.writer.flush();\n        release();\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        const codecStrings = this.trackDatas.map((trackData) => {\n            if (trackData.type === 'video') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else if (trackData.type === 'audio') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else {\n                const map = {\n                    webvtt: 'wvtt',\n                };\n                return map[trackData.track.source._codec];\n            }\n        });\n        return buildIsobmffMimeType({\n            isQuickTime: this.isQuickTime,\n            hasVideo: this.trackDatas.some(x => x.type === 'video'),\n            hasAudio: this.trackDatas.some(x => x.type === 'audio'),\n            codecStrings,\n        });\n    }\n    getVideoTrackData(track, packet, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateVideoChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const decoderConfig = { ...meta.decoderConfig };\n        assert(decoderConfig.codedWidth !== undefined);\n        assert(decoderConfig.codedHeight !== undefined);\n        let requiresAnnexBTransformation = false;\n        if (track.source._codec === 'avc' && !decoderConfig.description) {\n            // ISOBMFF can only hold AVC in the AVCC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = extractAvcDecoderConfigurationRecord(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are'\n                    + ' in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or'\n                    + ' provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in AVCC format.');\n            }\n            decoderConfig.description = serializeAvcDecoderConfigurationRecord(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        else if (track.source._codec === 'hevc' && !decoderConfig.description) {\n            // ISOBMFF can only hold HEVC in the HEVC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = extractHevcDecoderConfigurationRecord(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets'\n                    + ' are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or'\n                    + ' provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in HEVC format.');\n            }\n            decoderConfig.description = serializeHevcDecoderConfigurationRecord(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        // The frame rate set by the user may not be an integer. Since timescale is an integer, we'll approximate the\n        // frame time (inverse of frame rate) with a rational number, then use that approximation's denominator\n        // as the timescale.\n        const timescale = computeRationalApproximation(1 / (track.metadata.frameRate ?? 57600), 1e6).denominator;\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'video',\n            info: {\n                width: decoderConfig.codedWidth,\n                height: decoderConfig.codedHeight,\n                decoderConfig: decoderConfig,\n                requiresAnnexBTransformation,\n            },\n            timescale,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getAudioTrackData(track, packet, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const decoderConfig = { ...meta.decoderConfig };\n        let requiresAdtsStripping = false;\n        if (track.source._codec === 'aac' && !decoderConfig.description) {\n            // ISOBMFF can only hold AAC in raw format, not ADTS, but the missing description indicates ADTS.\n            // Parse the first packet to extract the AudioSpecificConfig.\n            const adtsFrame = readAdtsFrameHeader(FileSlice.tempFromBytes(packet.data));\n            if (!adtsFrame) {\n                throw new Error('Couldn\\'t parse ADTS header from the AAC packet. Make sure the packets are in ADTS format'\n                    + ' (as specified in ISO 13818-7) when not providing a description, or provide a description'\n                    + ' (must be an AudioSpecificConfig as specified in ISO 14496-3) and ensure the packets'\n                    + ' are raw AAC data.');\n            }\n            const sampleRate = aacFrequencyTable[adtsFrame.samplingFrequencyIndex];\n            const numberOfChannels = aacChannelMap[adtsFrame.channelConfiguration];\n            if (sampleRate === undefined || numberOfChannels === undefined) {\n                throw new Error('Invalid ADTS frame header.');\n            }\n            decoderConfig.description = buildAacAudioSpecificConfig({\n                objectType: adtsFrame.objectType,\n                sampleRate,\n                numberOfChannels,\n            });\n            requiresAdtsStripping = true;\n        }\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'audio',\n            info: {\n                numberOfChannels: meta.decoderConfig.numberOfChannels,\n                sampleRate: meta.decoderConfig.sampleRate,\n                decoderConfig,\n                requiresPcmTransformation: !this.isFragmented\n                    && PCM_AUDIO_CODECS.includes(track.source._codec),\n                requiresAdtsStripping,\n            },\n            timescale: meta.decoderConfig.sampleRate,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getSubtitleTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateSubtitleMetadata(meta);\n        assert(meta);\n        assert(meta.config);\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'subtitle',\n            info: {\n                config: meta.config,\n            },\n            timescale: 1000, // Reasonable\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n            lastCueEndTimestamp: 0,\n            cueQueue: [],\n            nextSourceId: 0,\n            cueToSourceId: new WeakMap(),\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    async addEncodedVideoPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getVideoTrackData(track, packet, meta);\n            let packetData = packet.data;\n            if (trackData.info.requiresAnnexBTransformation) {\n                const nalUnits = [...iterateNalUnitsInAnnexB(packetData)]\n                    .map(loc => packetData.subarray(loc.offset, loc.offset + loc.length));\n                if (nalUnits.length === 0) {\n                    // It's not valid Annex B data\n                    throw new Error('Failed to transform packet data. Make sure all packets are provided in Annex B format, as'\n                        + ' specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.');\n                }\n                // We don't strip things like SPS or PPS NALUs here, mainly because they can also appear in the middle\n                // of a stream and potentially modify the parameters of it. So, let's just leave them in to be sure.\n                packetData = concatNalUnitsInLengthPrefixed(nalUnits, 4);\n            }\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packetData, timestamp, packet.duration, packet.type);\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getAudioTrackData(track, packet, meta);\n            let packetData = packet.data;\n            if (trackData.info.requiresAdtsStripping) {\n                const adtsFrame = readAdtsFrameHeader(FileSlice.tempFromBytes(packetData));\n                if (!adtsFrame) {\n                    throw new Error('Expected ADTS frame, didn\\'t get one.');\n                }\n                const headerLength = adtsFrame.crcCheck === null\n                    ? MIN_ADTS_FRAME_HEADER_SIZE\n                    : MAX_ADTS_FRAME_HEADER_SIZE;\n                packetData = packetData.subarray(headerLength);\n            }\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packetData, timestamp, packet.duration, packet.type);\n            if (trackData.info.requiresPcmTransformation) {\n                await this.maybePadWithSilence(trackData, timestamp);\n            }\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async maybePadWithSilence(trackData, untilTimestamp) {\n        // The PCM transformation assumes that all samples are contiguous. This is not something that is enforced, so\n        // we need to pad the \"holes\" in between samples (and before the first sample) with additional\n        // \"silence samples\".\n        const lastSample = last(trackData.samples);\n        const lastEndTimestamp = lastSample\n            ? lastSample.timestamp + lastSample.duration\n            : 0;\n        const delta = untilTimestamp - lastEndTimestamp;\n        const deltaInTimescale = intoTimescale(delta, trackData.timescale);\n        if (deltaInTimescale > 0) {\n            const { sampleSize, silentValue } = parsePcmCodec(trackData.info.decoderConfig.codec);\n            const samplesNeeded = deltaInTimescale * trackData.info.numberOfChannels;\n            const data = new Uint8Array(sampleSize * samplesNeeded).fill(silentValue);\n            const paddingSample = this.createSampleForTrack(trackData, new Uint8Array(data.buffer), lastEndTimestamp, delta, 'key');\n            await this.registerSample(trackData, paddingSample);\n        }\n    }\n    async addSubtitleCue(track, cue, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getSubtitleTrackData(track, meta);\n            this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);\n            if (track.source._codec === 'webvtt') {\n                trackData.cueQueue.push(cue);\n                await this.processWebVTTCues(trackData, cue.timestamp);\n            }\n            else {\n                // TODO\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    async processWebVTTCues(trackData, until) {\n        // WebVTT cues need to undergo special processing as empty sections need to be padded out with samples, and\n        // overlapping samples require special logic. The algorithm produces the format specified in ISO 14496-30.\n        while (trackData.cueQueue.length > 0) {\n            const timestamps = new Set([]);\n            for (const cue of trackData.cueQueue) {\n                assert(cue.timestamp <= until);\n                assert(trackData.lastCueEndTimestamp <= cue.timestamp + cue.duration);\n                timestamps.add(Math.max(cue.timestamp, trackData.lastCueEndTimestamp)); // Start timestamp\n                timestamps.add(cue.timestamp + cue.duration); // End timestamp\n            }\n            const sortedTimestamps = [...timestamps].sort((a, b) => a - b);\n            // These are the timestamps of the next sample we'll create:\n            const sampleStart = sortedTimestamps[0];\n            const sampleEnd = sortedTimestamps[1] ?? sampleStart;\n            if (until < sampleEnd) {\n                break;\n            }\n            // We may need to pad out empty space with an vtte box\n            if (trackData.lastCueEndTimestamp < sampleStart) {\n                this.auxWriter.seek(0);\n                const box = vtte();\n                this.auxBoxWriter.writeBox(box);\n                const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n                const sample = this.createSampleForTrack(trackData, body, trackData.lastCueEndTimestamp, sampleStart - trackData.lastCueEndTimestamp, 'key');\n                await this.registerSample(trackData, sample);\n                trackData.lastCueEndTimestamp = sampleStart;\n            }\n            this.auxWriter.seek(0);\n            for (let i = 0; i < trackData.cueQueue.length; i++) {\n                const cue = trackData.cueQueue[i];\n                if (cue.timestamp >= sampleEnd) {\n                    break;\n                }\n                inlineTimestampRegex.lastIndex = 0;\n                const containsTimestamp = inlineTimestampRegex.test(cue.text);\n                const endTimestamp = cue.timestamp + cue.duration;\n                let sourceId = trackData.cueToSourceId.get(cue);\n                if (sourceId === undefined && sampleEnd < endTimestamp) {\n                    // We know this cue will appear in more than one sample, therefore we need to mark it with a\n                    // unique ID\n                    sourceId = trackData.nextSourceId++;\n                    trackData.cueToSourceId.set(cue, sourceId);\n                }\n                if (cue.notes) {\n                    // Any notes/comments are included in a special vtta box\n                    const box = vtta(cue.notes);\n                    this.auxBoxWriter.writeBox(box);\n                }\n                const box = vttc(cue.text, containsTimestamp ? sampleStart : null, cue.identifier ?? null, cue.settings ?? null, sourceId ?? null);\n                this.auxBoxWriter.writeBox(box);\n                if (endTimestamp === sampleEnd) {\n                    // The cue won't appear in any future sample, so we're done with it\n                    trackData.cueQueue.splice(i--, 1);\n                }\n            }\n            const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n            const sample = this.createSampleForTrack(trackData, body, sampleStart, sampleEnd - sampleStart, 'key');\n            await this.registerSample(trackData, sample);\n            trackData.lastCueEndTimestamp = sampleEnd;\n        }\n    }\n    createSampleForTrack(trackData, data, timestamp, duration, type) {\n        const sample = {\n            timestamp,\n            decodeTimestamp: timestamp, // This may be refined later\n            duration,\n            data,\n            size: data.byteLength,\n            type,\n            timescaleUnitsToNextSample: intoTimescale(duration, trackData.timescale), // Will be refined\n        };\n        return sample;\n    }\n    processTimestamps(trackData, nextSample) {\n        if (trackData.timestampProcessingQueue.length === 0) {\n            return;\n        }\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            let totalDuration = 0;\n            // Compute the total duration in the track timescale (which is equal to the amount of PCM audio samples)\n            // and simply say that's how many new samples there are.\n            for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n                const sample = trackData.timestampProcessingQueue[i];\n                const duration = intoTimescale(sample.duration, trackData.timescale);\n                totalDuration += duration;\n            }\n            if (trackData.timeToSampleTable.length === 0) {\n                trackData.timeToSampleTable.push({\n                    sampleCount: totalDuration,\n                    sampleDelta: 1,\n                });\n            }\n            else {\n                const lastEntry = last(trackData.timeToSampleTable);\n                lastEntry.sampleCount += totalDuration;\n            }\n            trackData.timestampProcessingQueue.length = 0;\n            return;\n        }\n        const sortedTimestamps = trackData.timestampProcessingQueue.map(x => x.timestamp).sort((a, b) => a - b);\n        for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n            const sample = trackData.timestampProcessingQueue[i];\n            // Since the user only supplies presentation time, but these may be out of order, we reverse-engineer from\n            // that a sensible decode timestamp. The notion of a decode timestamp doesn't really make sense\n            // (presentation timestamp & decode order are all you need), but it is a concept in ISOBMFF so we need to\n            // model it.\n            sample.decodeTimestamp = sortedTimestamps[i];\n            if (!this.isFragmented && trackData.lastTimescaleUnits === null) {\n                // In non-fragmented files, the first decode timestamp is always zero. If the first presentation\n                // timestamp isn't zero, we'll simply use the composition time offset to achieve it.\n                sample.decodeTimestamp = 0;\n            }\n            const sampleCompositionTimeOffset = intoTimescale(sample.timestamp - sample.decodeTimestamp, trackData.timescale);\n            const durationInTimescale = intoTimescale(sample.duration, trackData.timescale);\n            if (trackData.lastTimescaleUnits !== null) {\n                assert(trackData.lastSample);\n                const timescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n                assert(delta >= 0);\n                trackData.lastTimescaleUnits += delta;\n                trackData.lastSample.timescaleUnitsToNextSample = delta;\n                if (!this.isFragmented) {\n                    let lastTableEntry = last(trackData.timeToSampleTable);\n                    assert(lastTableEntry);\n                    if (lastTableEntry.sampleCount === 1) {\n                        lastTableEntry.sampleDelta = delta;\n                        const entryBefore = trackData.timeToSampleTable[trackData.timeToSampleTable.length - 2];\n                        if (entryBefore && entryBefore.sampleDelta === delta) {\n                            // If the delta is the same as the previous one, merge the two entries\n                            entryBefore.sampleCount++;\n                            trackData.timeToSampleTable.pop();\n                            lastTableEntry = entryBefore;\n                        }\n                    }\n                    else if (lastTableEntry.sampleDelta !== delta) {\n                        // The delta has changed, so we need a new entry to reach the current sample\n                        lastTableEntry.sampleCount--;\n                        trackData.timeToSampleTable.push(lastTableEntry = {\n                            sampleCount: 1,\n                            sampleDelta: delta,\n                        });\n                    }\n                    if (lastTableEntry.sampleDelta === durationInTimescale) {\n                        // The sample's duration matches the delta, so we can increment the count\n                        lastTableEntry.sampleCount++;\n                    }\n                    else {\n                        // Add a new entry in order to maintain the last sample's true duration\n                        trackData.timeToSampleTable.push({\n                            sampleCount: 1,\n                            sampleDelta: durationInTimescale,\n                        });\n                    }\n                    const lastCompositionTimeOffsetTableEntry = last(trackData.compositionTimeOffsetTable);\n                    assert(lastCompositionTimeOffsetTableEntry);\n                    if (lastCompositionTimeOffsetTableEntry.sampleCompositionTimeOffset === sampleCompositionTimeOffset) {\n                        // Simply increment the count\n                        lastCompositionTimeOffsetTableEntry.sampleCount++;\n                    }\n                    else {\n                        // The composition time offset has changed, so create a new entry with the new composition time\n                        // offset\n                        trackData.compositionTimeOffsetTable.push({\n                            sampleCount: 1,\n                            sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                        });\n                    }\n                }\n            }\n            else {\n                // Decode timestamp of the first sample\n                trackData.lastTimescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                if (!this.isFragmented) {\n                    trackData.timeToSampleTable.push({\n                        sampleCount: 1,\n                        sampleDelta: durationInTimescale,\n                    });\n                    trackData.compositionTimeOffsetTable.push({\n                        sampleCount: 1,\n                        sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                    });\n                }\n            }\n            trackData.lastSample = sample;\n        }\n        trackData.timestampProcessingQueue.length = 0;\n        assert(trackData.lastSample);\n        assert(trackData.lastTimescaleUnits !== null);\n        if (nextSample !== undefined && trackData.lastSample.timescaleUnitsToNextSample === 0) {\n            assert(nextSample.type === 'key');\n            // Given the next sample, we can make a guess about the duration of the last sample. This avoids having\n            // the last sample's duration in each fragment be \"0\" for fragmented files. The guess we make here is\n            // actually correct most of the time, since typically, no delta frame with a lower timestamp follows the key\n            // frame (although it can happen).\n            const timescaleUnits = intoTimescale(nextSample.timestamp, trackData.timescale, false);\n            const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n            trackData.lastSample.timescaleUnitsToNextSample = delta;\n        }\n    }\n    async registerSample(trackData, sample) {\n        if (sample.type === 'key') {\n            this.processTimestamps(trackData, sample);\n        }\n        trackData.timestampProcessingQueue.push(sample);\n        if (this.isFragmented) {\n            trackData.sampleQueue.push(sample);\n            await this.interleaveSamples();\n        }\n        else if (this.fastStart === 'reserve') {\n            await this.registerSampleFastStartReserve(trackData, sample);\n        }\n        else {\n            await this.addSampleToTrack(trackData, sample);\n        }\n    }\n    async addSampleToTrack(trackData, sample) {\n        if (!this.isFragmented) {\n            trackData.samples.push(sample);\n            if (this.fastStart === 'reserve') {\n                const maximumPacketCount = trackData.track.metadata.maximumPacketCount;\n                assert(maximumPacketCount !== undefined);\n                if (trackData.samples.length > maximumPacketCount) {\n                    throw new Error(`Track #${trackData.track.id} has already reached the maximum packet count`\n                        + ` (${maximumPacketCount}). Either add less packets or increase the maximum packet count.`);\n                }\n            }\n        }\n        let beginNewChunk = false;\n        if (!trackData.currentChunk) {\n            beginNewChunk = true;\n        }\n        else {\n            // Timestamp don't need to be monotonic (think B-frames), so we may need to update the start timestamp of\n            // the chunk\n            trackData.currentChunk.startTimestamp = Math.min(trackData.currentChunk.startTimestamp, sample.timestamp);\n            const currentChunkDuration = sample.timestamp - trackData.currentChunk.startTimestamp;\n            if (this.isFragmented) {\n                // We can only finalize this fragment (and begin a new one) if we know that each track will be able to\n                // start the new one with a key frame.\n                const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData) => {\n                    if (trackData === otherTrackData) {\n                        return sample.type === 'key';\n                    }\n                    const firstQueuedSample = otherTrackData.sampleQueue[0];\n                    if (firstQueuedSample) {\n                        return firstQueuedSample.type === 'key';\n                    }\n                    return otherTrackData.track.source._closed;\n                });\n                if (currentChunkDuration >= this.minimumFragmentDuration\n                    && keyFrameQueuedEverywhere\n                    && sample.timestamp > this.maxWrittenTimestamp) {\n                    beginNewChunk = true;\n                    await this.finalizeFragment();\n                }\n            }\n            else {\n                beginNewChunk = currentChunkDuration >= 0.5; // Chunk is long enough, we need a new one\n            }\n        }\n        if (beginNewChunk) {\n            if (trackData.currentChunk) {\n                await this.finalizeCurrentChunk(trackData);\n            }\n            trackData.currentChunk = {\n                startTimestamp: sample.timestamp,\n                samples: [],\n                offset: null,\n                moofOffset: null,\n            };\n        }\n        assert(trackData.currentChunk);\n        trackData.currentChunk.samples.push(sample);\n        if (this.isFragmented) {\n            this.maxWrittenTimestamp = Math.max(this.maxWrittenTimestamp, sample.timestamp);\n        }\n    }\n    async finalizeCurrentChunk(trackData) {\n        assert(!this.isFragmented);\n        if (!trackData.currentChunk)\n            return;\n        trackData.finalizedChunks.push(trackData.currentChunk);\n        this.finalizedChunks.push(trackData.currentChunk);\n        let sampleCount = trackData.currentChunk.samples.length;\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            sampleCount = trackData.currentChunk.samples\n                .reduce((acc, sample) => acc + intoTimescale(sample.duration, trackData.timescale), 0);\n        }\n        if (trackData.compactlyCodedChunkTable.length === 0\n            || last(trackData.compactlyCodedChunkTable).samplesPerChunk !== sampleCount) {\n            trackData.compactlyCodedChunkTable.push({\n                firstChunk: trackData.finalizedChunks.length, // 1-indexed\n                samplesPerChunk: sampleCount,\n            });\n        }\n        if (this.fastStart === 'in-memory') {\n            trackData.currentChunk.offset = 0; // We'll compute the proper offset when finalizing\n            return;\n        }\n        // Write out the data\n        trackData.currentChunk.offset = this.writer.getPos();\n        for (const sample of trackData.currentChunk.samples) {\n            assert(sample.data);\n            this.writer.write(sample.data);\n            sample.data = null; // Can be GC'd\n        }\n        await this.writer.flush();\n    }\n    async interleaveSamples(isFinalCall = false) {\n        assert(this.isFragmented);\n        if (!isFinalCall && !this.allTracksAreKnown()) {\n            return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall && trackData.sampleQueue.length === 0 && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.sampleQueue.length > 0 && trackData.sampleQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.sampleQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const sample = trackWithMinTimestamp.sampleQueue.shift();\n            await this.addSampleToTrack(trackWithMinTimestamp, sample);\n        }\n    }\n    async finalizeFragment(flushWriter = true) {\n        assert(this.isFragmented);\n        const fragmentNumber = this.nextFragmentNumber++;\n        if (fragmentNumber === 1) {\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            // Write the moov box now that we have all decoder configs\n            const movieBox = moov(this);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        // Not all tracks need to be present in every fragment\n        const tracksInFragment = this.trackDatas.filter(x => x.currentChunk);\n        // Create an initial moof box and measure it; we need this to know where the following mdat box will begin\n        const moofBox = moof(fragmentNumber, tracksInFragment);\n        const moofOffset = this.writer.getPos();\n        const mdatStartPos = moofOffset + this.boxWriter.measureBox(moofBox);\n        let currentPos = mdatStartPos + MIN_BOX_HEADER_SIZE;\n        let fragmentStartTimestamp = Infinity;\n        for (const trackData of tracksInFragment) {\n            trackData.currentChunk.offset = currentPos;\n            trackData.currentChunk.moofOffset = moofOffset;\n            for (const sample of trackData.currentChunk.samples) {\n                currentPos += sample.size;\n            }\n            fragmentStartTimestamp = Math.min(fragmentStartTimestamp, trackData.currentChunk.startTimestamp);\n        }\n        const mdatSize = currentPos - mdatStartPos;\n        const needsLargeMdatSize = mdatSize >= 2 ** 32;\n        if (needsLargeMdatSize) {\n            // Shift all offsets by 8. Previously, all chunks were shifted assuming the large box size, but due to what\n            // I suspect is a bug in WebKit, it failed in Safari (when livestreaming with MSE, not for static playback).\n            for (const trackData of tracksInFragment) {\n                trackData.currentChunk.offset += MAX_BOX_HEADER_SIZE - MIN_BOX_HEADER_SIZE;\n            }\n        }\n        if (this.format._options.onMoof) {\n            this.writer.startTrackingWrites();\n        }\n        const newMoofBox = moof(fragmentNumber, tracksInFragment);\n        this.boxWriter.writeBox(newMoofBox);\n        if (this.format._options.onMoof) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMoof(data, start, fragmentStartTimestamp);\n        }\n        assert(this.writer.getPos() === mdatStartPos);\n        if (this.format._options.onMdat) {\n            this.writer.startTrackingWrites();\n        }\n        const mdatBox = mdat(needsLargeMdatSize);\n        mdatBox.size = mdatSize;\n        this.boxWriter.writeBox(mdatBox);\n        this.writer.seek(mdatStartPos + (needsLargeMdatSize ? MAX_BOX_HEADER_SIZE : MIN_BOX_HEADER_SIZE));\n        // Write sample data\n        for (const trackData of tracksInFragment) {\n            for (const sample of trackData.currentChunk.samples) {\n                this.writer.write(sample.data);\n                sample.data = null; // Can be GC'd\n            }\n        }\n        if (this.format._options.onMdat) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMdat(data, start);\n        }\n        for (const trackData of tracksInFragment) {\n            trackData.finalizedChunks.push(trackData.currentChunk);\n            this.finalizedChunks.push(trackData.currentChunk);\n            trackData.currentChunk = null;\n        }\n        if (flushWriter) {\n            await this.writer.flush();\n        }\n    }\n    async registerSampleFastStartReserve(trackData, sample) {\n        if (this.allTracksAreKnown()) {\n            if (!this.mdat) {\n                // We finally know all tracks, let's reserve space for the moov box\n                const moovBox = moov(this);\n                const moovSize = this.boxWriter.measureBox(moovBox);\n                const reservedSize = moovSize\n                    + this.computeSampleTableSizeUpperBound()\n                    + 4096; // Just a little extra headroom\n                assert(this.ftypSize !== null);\n                this.writer.seek(this.ftypSize + reservedSize);\n                if (this.format._options.onMdat) {\n                    this.writer.startTrackingWrites();\n                }\n                this.mdat = mdat(true);\n                this.boxWriter.writeBox(this.mdat);\n                // Now write everything that was queued\n                for (const trackData of this.trackDatas) {\n                    for (const sample of trackData.sampleQueue) {\n                        await this.addSampleToTrack(trackData, sample);\n                    }\n                    trackData.sampleQueue.length = 0;\n                }\n            }\n            await this.addSampleToTrack(trackData, sample);\n        }\n        else {\n            // Queue it for when we know all tracks\n            trackData.sampleQueue.push(sample);\n        }\n    }\n    computeSampleTableSizeUpperBound() {\n        assert(this.fastStart === 'reserve');\n        let upperBound = 0;\n        for (const trackData of this.trackDatas) {\n            const n = trackData.track.metadata.maximumPacketCount;\n            assert(n !== undefined); // We validated this earlier\n            // Given the max allowed packet count, compute the space they'll take up in the Sample Table Box, assuming\n            // the worst case for each individual box:\n            // stts box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4) * Math.ceil(2 / 3 * n);\n            // stss box - 1 entry per sample\n            upperBound += 4 * n;\n            // ctts box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4) * Math.ceil(2 / 3 * n);\n            // stsc box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4 + 4) * Math.ceil(2 / 3 * n);\n            // stsz box - 1 entry per sample\n            upperBound += 4 * n;\n            // co64 box - we assume 1 sample per chunk and 64-bit chunk offsets (co64 instead of stco)\n            upperBound += 8 * n;\n        }\n        return upperBound;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose(track) {\n        const release = await this.mutex.acquire();\n        if (track.type === 'subtitle' && track.source._codec === 'webvtt') {\n            const trackData = this.trackDatas.find(x => x.track === track);\n            if (trackData) {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        if (this.isFragmented) {\n            // Since a track is now closed, we may be able to write out chunks that were previously waiting\n            await this.interleaveSamples();\n        }\n        release();\n    }\n    /** Finalizes the file, making it ready for use. Must be called after all video and audio chunks have been added. */\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        for (const trackData of this.trackDatas) {\n            if (trackData.type === 'subtitle' && trackData.track.source._codec === 'webvtt') {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.isFragmented) {\n            await this.interleaveSamples(true);\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n            }\n            await this.finalizeFragment(false); // Don't flush the last fragment as we will flush it with the mfra box\n        }\n        else {\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n                await this.finalizeCurrentChunk(trackData);\n            }\n        }\n        if (this.fastStart === 'in-memory') {\n            this.mdat = mdat(false);\n            let mdatSize;\n            // We know how many chunks there are, but computing the chunk positions requires an iterative approach:\n            // In order to know where the first chunk should go, we first need to know the size of the moov box. But we\n            // cannot write a proper moov box without first knowing all chunk positions. So, we generate a tentative\n            // moov box with placeholder values (0) for the chunk offsets to be able to compute its size. If it then\n            // turns out that appending all chunks exceeds 4 GiB, we need to repeat this process, now with the co64 box\n            // being used in the moov box instead, which will make it larger. After that, we definitely know the final\n            // size of the moov box and can compute the proper chunk positions.\n            for (let i = 0; i < 2; i++) {\n                const movieBox = moov(this);\n                const movieBoxSize = this.boxWriter.measureBox(movieBox);\n                mdatSize = this.boxWriter.measureBox(this.mdat);\n                let currentChunkPos = this.writer.getPos() + movieBoxSize + mdatSize;\n                for (const chunk of this.finalizedChunks) {\n                    chunk.offset = currentChunkPos;\n                    for (const { data } of chunk.samples) {\n                        assert(data);\n                        currentChunkPos += data.byteLength;\n                        mdatSize += data.byteLength;\n                    }\n                }\n                if (currentChunkPos < 2 ** 32)\n                    break;\n                if (mdatSize >= 2 ** 32)\n                    this.mdat.largeSize = true;\n            }\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            const movieBox = moov(this);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat.size = mdatSize;\n            this.boxWriter.writeBox(this.mdat);\n            for (const chunk of this.finalizedChunks) {\n                for (const sample of chunk.samples) {\n                    assert(sample.data);\n                    this.writer.write(sample.data);\n                    sample.data = null;\n                }\n            }\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n        }\n        else if (this.isFragmented) {\n            // Append the mfra box to the end of the file for better random access\n            const startPos = this.writer.getPos();\n            const mfraBox = mfra(this.trackDatas);\n            this.boxWriter.writeBox(mfraBox);\n            // Patch the 'size' field of the mfro box at the end of the mfra box now that we know its actual size\n            const mfraBoxSize = this.writer.getPos() - startPos;\n            this.writer.seek(this.writer.getPos() - 4);\n            this.boxWriter.writeU32(mfraBoxSize);\n        }\n        else {\n            assert(this.mdat);\n            const mdatPos = this.boxWriter.offsets.get(this.mdat);\n            assert(mdatPos !== undefined);\n            const mdatSize = this.writer.getPos() - mdatPos;\n            this.mdat.size = mdatSize;\n            this.mdat.largeSize = mdatSize >= 2 ** 32; // Only use the large size if we need it\n            this.boxWriter.patchBox(this.mdat);\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n            const movieBox = moov(this);\n            if (this.fastStart === 'reserve') {\n                assert(this.ftypSize !== null);\n                this.writer.seek(this.ftypSize);\n                if (this.format._options.onMoov) {\n                    this.writer.startTrackingWrites();\n                }\n                this.boxWriter.writeBox(movieBox);\n                // Fill the remaining space with a free box. If there are less than 8 bytes left, sucks I guess\n                const remainingSpace = this.boxWriter.offsets.get(this.mdat) - this.writer.getPos();\n                this.boxWriter.writeBox(free(remainingSpace));\n            }\n            else {\n                if (this.format._options.onMoov) {\n                    this.writer.startTrackingWrites();\n                }\n                this.boxWriter.writeBox(movieBox);\n            }\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        release();\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AdtsMuxer } from './adts/adts-muxer.js';\nimport { AUDIO_CODECS, NON_PCM_AUDIO_CODECS, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { FlacMuxer } from './flac/flac-muxer.js';\nimport { IsobmffMuxer } from './isobmff/isobmff-muxer.js';\nimport { MatroskaMuxer } from './matroska/matroska-muxer.js';\nimport { Mp3Muxer } from './mp3/mp3-muxer.js';\nimport { OggMuxer } from './ogg/ogg-muxer.js';\nimport { MpegTsMuxer } from './mpeg-ts/mpeg-ts-muxer.js';\nimport { WaveMuxer } from './wave/wave-muxer.js';\n/**\n * Base class representing an output media file format.\n * @group Output formats\n * @public\n */\nexport class OutputFormat {\n    /** Returns a list of video codecs that this output format can contain. */\n    getSupportedVideoCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => VIDEO_CODECS.includes(codec));\n    }\n    /** Returns a list of audio codecs that this output format can contain. */\n    getSupportedAudioCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => AUDIO_CODECS.includes(codec));\n    }\n    /** Returns a list of subtitle codecs that this output format can contain. */\n    getSupportedSubtitleCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => SUBTITLE_CODECS.includes(codec));\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _codecUnsupportedHint(codec) {\n        return '';\n    }\n}\n/**\n * Format representing files compatible with the ISO base media file format (ISOBMFF), like MP4 or MOV files.\n * @group Output formats\n * @public\n */\nexport class IsobmffOutputFormat extends OutputFormat {\n    /** Internal constructor. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.fastStart !== undefined\n            && ![false, 'in-memory', 'reserve', 'fragmented'].includes(options.fastStart)) {\n            throw new TypeError('options.fastStart, when provided, must be false, \\'in-memory\\', \\'reserve\\', or \\'fragmented\\'.');\n        }\n        if (options.minimumFragmentDuration !== undefined\n            && (!Number.isFinite(options.minimumFragmentDuration) || options.minimumFragmentDuration < 0)) {\n            throw new TypeError('options.minimumFragmentDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onFtyp !== undefined && typeof options.onFtyp !== 'function') {\n            throw new TypeError('options.onFtyp, when provided, must be a function.');\n        }\n        if (options.onMoov !== undefined && typeof options.onMoov !== 'function') {\n            throw new TypeError('options.onMoov, when provided, must be a function.');\n        }\n        if (options.onMdat !== undefined && typeof options.onMdat !== 'function') {\n            throw new TypeError('options.onMdat, when provided, must be a function.');\n        }\n        if (options.onMoof !== undefined && typeof options.onMoof !== 'function') {\n            throw new TypeError('options.onMoof, when provided, must be a function.');\n        }\n        if (options.metadataFormat !== undefined\n            && !['mdir', 'mdta', 'udta', 'auto'].includes(options.metadataFormat)) {\n            throw new TypeError('options.metadataFormat, when provided, must be either \\'auto\\', \\'mdir\\', \\'mdta\\', or \\'udta\\'.');\n        }\n        super();\n        this._options = options;\n    }\n    getSupportedTrackCounts() {\n        const max = 2 ** 32 - 1; // Have fun reaching this one\n        return {\n            video: { min: 0, max },\n            audio: { min: 0, max },\n            subtitle: { min: 0, max },\n            total: { min: 1, max },\n        };\n    }\n    get supportsVideoRotationMetadata() {\n        return true;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new IsobmffMuxer(output, this);\n    }\n}\n/**\n * MPEG-4 Part 14 (MP4) file format. Supports most codecs.\n * @group Output formats\n * @public\n */\nexport class Mp4OutputFormat extends IsobmffOutputFormat {\n    /** Creates a new {@link Mp4OutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    /** @internal */\n    get _name() {\n        return 'MP4';\n    }\n    get fileExtension() {\n        return '.mp4';\n    }\n    get mimeType() {\n        return 'video/mp4';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...NON_PCM_AUDIO_CODECS,\n            // These are supported via ISO/IEC 23003-5\n            'pcm-s16',\n            'pcm-s16be',\n            'pcm-s24',\n            'pcm-s24be',\n            'pcm-s32',\n            'pcm-s32be',\n            'pcm-f32',\n            'pcm-f32be',\n            'pcm-f64',\n            'pcm-f64be',\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MovOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MOV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * QuickTime File Format (QTFF), often called MOV. Supports all video and audio codecs, but not subtitle codecs.\n * @group Output formats\n * @public\n */\nexport class MovOutputFormat extends IsobmffOutputFormat {\n    /** Creates a new {@link MovOutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    /** @internal */\n    get _name() {\n        return 'MOV';\n    }\n    get fileExtension() {\n        return '.mov';\n    }\n    get mimeType() {\n        return 'video/quicktime';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...AUDIO_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new Mp4OutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MP4 will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * Matroska file format.\n *\n * Supports writing transparent video. For a video track to be marked as transparent, the first packet added must\n * contain alpha side data.\n *\n * @group Output formats\n * @public\n */\nexport class MkvOutputFormat extends OutputFormat {\n    /** Creates a new {@link MkvOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.appendOnly !== undefined && typeof options.appendOnly !== 'boolean') {\n            throw new TypeError('options.appendOnly, when provided, must be a boolean.');\n        }\n        if (options.minimumClusterDuration !== undefined\n            && (!Number.isFinite(options.minimumClusterDuration) || options.minimumClusterDuration < 0)) {\n            throw new TypeError('options.minimumClusterDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onEbmlHeader !== undefined && typeof options.onEbmlHeader !== 'function') {\n            throw new TypeError('options.onEbmlHeader, when provided, must be a function.');\n        }\n        if (options.onSegmentHeader !== undefined && typeof options.onSegmentHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        if (options.onCluster !== undefined && typeof options.onCluster !== 'function') {\n            throw new TypeError('options.onCluster, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new MatroskaMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Matroska';\n    }\n    getSupportedTrackCounts() {\n        const max = 127;\n        return {\n            video: { min: 0, max },\n            audio: { min: 0, max },\n            subtitle: { min: 0, max },\n            total: { min: 1, max },\n        };\n    }\n    get fileExtension() {\n        return '.mkv';\n    }\n    get mimeType() {\n        return 'video/x-matroska';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...NON_PCM_AUDIO_CODECS,\n            ...PCM_AUDIO_CODECS.filter(codec => !['pcm-s8', 'pcm-f32be', 'pcm-f64be', 'ulaw', 'alaw'].includes(codec)),\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        // While it technically does support it with ProjectionPoseRoll, many players appear to ignore this value\n        return false;\n    }\n}\n/**\n * WebM file format, based on Matroska.\n *\n * Supports writing transparent video. For a video track to be marked as transparent, the first packet added must\n * contain alpha side data.\n *\n * @group Output formats\n * @public\n */\nexport class WebMOutputFormat extends MkvOutputFormat {\n    /** Creates a new {@link WebMOutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS.filter(codec => ['vp8', 'vp9', 'av1'].includes(codec)),\n            ...AUDIO_CODECS.filter(codec => ['opus', 'vorbis'].includes(codec)),\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    get _name() {\n        return 'WebM';\n    }\n    get fileExtension() {\n        return '.webm';\n    }\n    get mimeType() {\n        return 'video/webm';\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MkvOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MKV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * MP3 file format.\n * @group Output formats\n * @public\n */\nexport class Mp3OutputFormat extends OutputFormat {\n    /** Creates a new {@link Mp3OutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.xingHeader !== undefined && typeof options.xingHeader !== 'boolean') {\n            throw new TypeError('options.xingHeader, when provided, must be a boolean.');\n        }\n        if (options.onXingFrame !== undefined && typeof options.onXingFrame !== 'function') {\n            throw new TypeError('options.onXingFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new Mp3Muxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'MP3';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.mp3';\n    }\n    get mimeType() {\n        return 'audio/mpeg';\n    }\n    getSupportedCodecs() {\n        return ['mp3'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * WAVE file format, based on RIFF.\n * @group Output formats\n * @public\n */\nexport class WavOutputFormat extends OutputFormat {\n    /** Creates a new {@link WavOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.large !== undefined && typeof options.large !== 'boolean') {\n            throw new TypeError('options.large, when provided, must be a boolean.');\n        }\n        if (options.metadataFormat !== undefined && !['info', 'id3'].includes(options.metadataFormat)) {\n            throw new TypeError('options.metadataFormat, when provided, must be either \\'info\\' or \\'id3\\'.');\n        }\n        if (options.onHeader !== undefined && typeof options.onHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new WaveMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'WAVE';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.wav';\n    }\n    get mimeType() {\n        return 'audio/wav';\n    }\n    getSupportedCodecs() {\n        return [\n            ...PCM_AUDIO_CODECS.filter(codec => ['pcm-s16', 'pcm-s24', 'pcm-s32', 'pcm-f32', 'pcm-u8', 'ulaw', 'alaw'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * Ogg file format.\n * @group Output formats\n * @public\n */\nexport class OggOutputFormat extends OutputFormat {\n    /** Creates a new {@link OggOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.maximumPageDuration !== undefined\n            && (!Number.isFinite(options.maximumPageDuration) || options.maximumPageDuration <= 0)) {\n            throw new TypeError('options.maximumPageDuration, when provided, must be a positive number.');\n        }\n        if (options.onPage !== undefined && typeof options.onPage !== 'function') {\n            throw new TypeError('options.onPage, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new OggMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Ogg';\n    }\n    getSupportedTrackCounts() {\n        const max = 2 ** 32; // Have fun reaching this one\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 0, max },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max },\n        };\n    }\n    get fileExtension() {\n        return '.ogg';\n    }\n    get mimeType() {\n        return 'application/ogg';\n    }\n    getSupportedCodecs() {\n        return [\n            ...AUDIO_CODECS.filter(codec => ['vorbis', 'opus'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * ADTS file format.\n * @group Output formats\n * @public\n */\nexport class AdtsOutputFormat extends OutputFormat {\n    /** Creates a new {@link AdtsOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onFrame !== undefined && typeof options.onFrame !== 'function') {\n            throw new TypeError('options.onFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new AdtsMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'ADTS';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.aac';\n    }\n    get mimeType() {\n        return 'audio/aac';\n    }\n    getSupportedCodecs() {\n        return ['aac'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * FLAC file format.\n * @group Output formats\n * @public\n */\nexport class FlacOutputFormat extends OutputFormat {\n    /** Creates a new {@link FlacOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new FlacMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'FLAC';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.flac';\n    }\n    get mimeType() {\n        return 'audio/flac';\n    }\n    getSupportedCodecs() {\n        return ['flac'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * MPEG Transport Stream file format.\n * @group Output formats\n * @public\n */\nexport class MpegTsOutputFormat extends OutputFormat {\n    /** Creates a new {@link MpegTsOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onPacket !== undefined && typeof options.onPacket !== 'function') {\n            throw new TypeError('options.onPacket, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new MpegTsMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'MPEG-TS';\n    }\n    getSupportedTrackCounts() {\n        const maxVideo = 16; // Stream IDs 0xE0-0xEF\n        const maxAudio = 32;\n        const maxTotal = maxVideo + maxAudio;\n        return {\n            video: { min: 0, max: maxVideo },\n            audio: { min: 0, max: maxAudio },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: maxTotal },\n        };\n    }\n    get fileExtension() {\n        return '.ts';\n    }\n    get mimeType() {\n        return 'video/MP2T';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS.filter(codec => ['avc', 'hevc'].includes(codec)),\n            ...AUDIO_CODECS.filter(codec => ['aac', 'mp3'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AUDIO_CODECS, buildAudioCodecString, buildVideoCodecString, getAudioEncoderConfigExtension, getVideoEncoderConfigExtension, inferCodecFromCodecString, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { customAudioEncoders, customVideoEncoders } from './custom-coder.js';\nimport { isFirefox } from './misc.js';\nexport const validateVideoEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!VIDEO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid video codec '${config.codec}'. Must be one of: ${VIDEO_CODECS.join(', ')}.`);\n    }\n    if (!(config.bitrate instanceof Quality) && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate must be a positive integer or a quality.');\n    }\n    if (config.keyFrameInterval !== undefined\n        && (!Number.isFinite(config.keyFrameInterval) || config.keyFrameInterval < 0)) {\n        throw new TypeError('config.keyFrameInterval, when provided, must be a non-negative number.');\n    }\n    if (config.sizeChangeBehavior !== undefined\n        && !['deny', 'passThrough', 'fill', 'contain', 'cover'].includes(config.sizeChangeBehavior)) {\n        throw new TypeError('config.sizeChangeBehavior, when provided, must be \\'deny\\', \\'passThrough\\', \\'fill\\', \\'contain\\''\n            + ' or \\'cover\\'.');\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n    validateVideoEncodingAdditionalOptions(config.codec, config);\n};\nexport const validateVideoEncodingAdditionalOptions = (codec, options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('Encoding options must be an object.');\n    }\n    if (options.alpha !== undefined && !['discard', 'keep'].includes(options.alpha)) {\n        throw new TypeError('options.alpha, when provided, must be \\'discard\\' or \\'keep\\'.');\n    }\n    if (options.bitrateMode !== undefined && !['constant', 'variable'].includes(options.bitrateMode)) {\n        throw new TypeError('bitrateMode, when provided, must be \\'constant\\' or \\'variable\\'.');\n    }\n    if (options.latencyMode !== undefined && !['quality', 'realtime'].includes(options.latencyMode)) {\n        throw new TypeError('latencyMode, when provided, must be \\'quality\\' or \\'realtime\\'.');\n    }\n    if (options.fullCodecString !== undefined && typeof options.fullCodecString !== 'string') {\n        throw new TypeError('fullCodecString, when provided, must be a string.');\n    }\n    if (options.fullCodecString !== undefined && inferCodecFromCodecString(options.fullCodecString) !== codec) {\n        throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${codec}).`);\n    }\n    if (options.hardwareAcceleration !== undefined\n        && !['no-preference', 'prefer-hardware', 'prefer-software'].includes(options.hardwareAcceleration)) {\n        throw new TypeError('hardwareAcceleration, when provided, must be \\'no-preference\\', \\'prefer-hardware\\' or'\n            + ' \\'prefer-software\\'.');\n    }\n    if (options.scalabilityMode !== undefined && typeof options.scalabilityMode !== 'string') {\n        throw new TypeError('scalabilityMode, when provided, must be a string.');\n    }\n    if (options.contentHint !== undefined && typeof options.contentHint !== 'string') {\n        throw new TypeError('contentHint, when provided, must be a string.');\n    }\n};\nexport const buildVideoEncoderConfig = (options) => {\n    const resolvedBitrate = options.bitrate instanceof Quality\n        ? options.bitrate._toVideoBitrate(options.codec, options.width, options.height)\n        : options.bitrate;\n    return {\n        codec: options.fullCodecString ?? buildVideoCodecString(options.codec, options.width, options.height, resolvedBitrate),\n        width: options.width,\n        height: options.height,\n        bitrate: resolvedBitrate,\n        bitrateMode: options.bitrateMode,\n        alpha: options.alpha ?? 'discard',\n        framerate: options.framerate,\n        latencyMode: options.latencyMode,\n        hardwareAcceleration: options.hardwareAcceleration,\n        scalabilityMode: options.scalabilityMode,\n        contentHint: options.contentHint,\n        ...getVideoEncoderConfigExtension(options.codec),\n    };\n};\nexport const validateAudioEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!AUDIO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid audio codec '${config.codec}'. Must be one of: ${AUDIO_CODECS.join(', ')}.`);\n    }\n    if (config.bitrate === undefined\n        && (!PCM_AUDIO_CODECS.includes(config.codec) || config.codec === 'flac')) {\n        throw new TypeError('config.bitrate must be provided for compressed audio codecs.');\n    }\n    if (config.bitrate !== undefined\n        && !(config.bitrate instanceof Quality)\n        && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate, when provided, must be a positive integer or a quality.');\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n    validateAudioEncodingAdditionalOptions(config.codec, config);\n};\nexport const validateAudioEncodingAdditionalOptions = (codec, options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('Encoding options must be an object.');\n    }\n    if (options.bitrateMode !== undefined && !['constant', 'variable'].includes(options.bitrateMode)) {\n        throw new TypeError('bitrateMode, when provided, must be \\'constant\\' or \\'variable\\'.');\n    }\n    if (options.fullCodecString !== undefined && typeof options.fullCodecString !== 'string') {\n        throw new TypeError('fullCodecString, when provided, must be a string.');\n    }\n    if (options.fullCodecString !== undefined && inferCodecFromCodecString(options.fullCodecString) !== codec) {\n        throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${codec}).`);\n    }\n};\nexport const buildAudioEncoderConfig = (options) => {\n    const resolvedBitrate = options.bitrate instanceof Quality\n        ? options.bitrate._toAudioBitrate(options.codec)\n        : options.bitrate;\n    return {\n        codec: options.fullCodecString ?? buildAudioCodecString(options.codec, options.numberOfChannels, options.sampleRate),\n        numberOfChannels: options.numberOfChannels,\n        sampleRate: options.sampleRate,\n        bitrate: resolvedBitrate,\n        bitrateMode: options.bitrateMode,\n        ...getAudioEncoderConfigExtension(options.codec),\n    };\n};\n/**\n * Represents a subjective media quality level.\n * @group Encoding\n * @public\n */\nexport class Quality {\n    /** @internal */\n    constructor(factor) {\n        this._factor = factor;\n    }\n    /** @internal */\n    _toVideoBitrate(codec, width, height) {\n        const pixels = width * height;\n        const codecEfficiencyFactors = {\n            avc: 1.0, // H.264/AVC (baseline)\n            hevc: 0.6, // H.265/HEVC (~40% more efficient than AVC)\n            vp9: 0.6, // Similar to HEVC\n            av1: 0.4, // ~60% more efficient than AVC\n            vp8: 1.2, // Slightly less efficient than AVC\n        };\n        const referencePixels = 1920 * 1080;\n        const referenceBitrate = 3000000;\n        const scaleFactor = Math.pow(pixels / referencePixels, 0.95); // Slight non-linear scaling\n        const baseBitrate = referenceBitrate * scaleFactor;\n        const codecAdjustedBitrate = baseBitrate * codecEfficiencyFactors[codec];\n        const finalBitrate = codecAdjustedBitrate * this._factor;\n        return Math.ceil(finalBitrate / 1000) * 1000;\n    }\n    /** @internal */\n    _toAudioBitrate(codec) {\n        if (PCM_AUDIO_CODECS.includes(codec) || codec === 'flac') {\n            return undefined;\n        }\n        const baseRates = {\n            aac: 128000, // 128kbps base for AAC\n            opus: 64000, // 64kbps base for Opus\n            mp3: 160000, // 160kbps base for MP3\n            vorbis: 64000, // 64kbps base for Vorbis\n        };\n        const baseBitrate = baseRates[codec];\n        if (!baseBitrate) {\n            throw new Error(`Unhandled codec: ${codec}`);\n        }\n        let finalBitrate = baseBitrate * this._factor;\n        if (codec === 'aac') {\n            // AAC only works with specific bitrates, let's find the closest\n            const validRates = [96000, 128000, 160000, 192000];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        else if (codec === 'opus' || codec === 'vorbis') {\n            finalBitrate = Math.max(6000, finalBitrate);\n        }\n        else if (codec === 'mp3') {\n            const validRates = [\n                8000, 16000, 24000, 32000, 40000, 48000, 64000, 80000,\n                96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000,\n            ];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        return Math.round(finalBitrate / 1000) * 1000;\n    }\n}\n/**\n * Represents a very low media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_VERY_LOW = /* #__PURE__ */ new Quality(0.3);\n/**\n * Represents a low media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_LOW = /* #__PURE__ */ new Quality(0.6);\n/**\n * Represents a medium media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_MEDIUM = /* #__PURE__ */ new Quality(1);\n/**\n * Represents a high media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_HIGH = /* #__PURE__ */ new Quality(2);\n/**\n * Represents a very high media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_VERY_HIGH = /* #__PURE__ */ new Quality(4);\n/**\n * Checks if the browser is able to encode the given codec.\n * @group Encoding\n * @public\n */\nexport const canEncode = (codec) => {\n    if (VIDEO_CODECS.includes(codec)) {\n        return canEncodeVideo(codec);\n    }\n    else if (AUDIO_CODECS.includes(codec)) {\n        return canEncodeAudio(codec);\n    }\n    else if (SUBTITLE_CODECS.includes(codec)) {\n        return canEncodeSubtitles(codec);\n    }\n    throw new TypeError(`Unknown codec '${codec}'.`);\n};\n/**\n * Checks if the browser is able to encode the given video codec with the given parameters.\n * @group Encoding\n * @public\n */\nexport const canEncodeVideo = async (codec, options = {}) => {\n    const { width = 1280, height = 720, bitrate = 1e6, ...restOptions } = options;\n    if (!VIDEO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(width) || width <= 0) {\n        throw new TypeError('width must be a positive integer.');\n    }\n    if (!Number.isInteger(height) || height <= 0) {\n        throw new TypeError('height must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer or a quality.');\n    }\n    validateVideoEncodingAdditionalOptions(codec, restOptions);\n    let encoderConfig = null;\n    if (customVideoEncoders.length > 0) {\n        encoderConfig ??= buildVideoEncoderConfig({\n            codec,\n            width,\n            height,\n            bitrate,\n            framerate: undefined,\n            ...restOptions,\n        });\n        if (customVideoEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (typeof VideoEncoder === 'undefined') {\n        return false;\n    }\n    const hasOddDimension = width % 2 === 1 || height % 2 === 1;\n    if (hasOddDimension\n        && (codec === 'avc' || codec === 'hevc')) {\n        // Disallow odd dimensions for certain codecs\n        return false;\n    }\n    encoderConfig ??= buildVideoEncoderConfig({\n        codec,\n        width,\n        height,\n        bitrate,\n        framerate: undefined,\n        ...restOptions,\n        alpha: 'discard', // Since we handle alpha ourselves\n    });\n    const support = await VideoEncoder.isConfigSupported(encoderConfig);\n    if (!support.supported) {\n        return false;\n    }\n    if (isFirefox()) {\n        // isConfigSupported on Firefox appears to unreliably indicate if encoding will actually succeed. Therefore, we\n        // just try encoding a frame to see if it actually works.\n        // https://github.com/Vanilagy/mediabunny/issues/222\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n        return new Promise(async (resolve) => {\n            try {\n                const encoder = new VideoEncoder({\n                    output: () => { },\n                    error: () => resolve(false),\n                });\n                encoder.configure(encoderConfig);\n                const frameData = new Uint8Array(width * height * 4);\n                const frame = new VideoFrame(frameData, {\n                    format: 'RGBA',\n                    codedWidth: width,\n                    codedHeight: height,\n                    timestamp: 0,\n                });\n                encoder.encode(frame);\n                frame.close();\n                await encoder.flush();\n                resolve(true);\n            }\n            catch {\n                resolve(false);\n            }\n        });\n    }\n    else {\n        return true;\n    }\n};\n/**\n * Checks if the browser is able to encode the given audio codec with the given parameters.\n * @group Encoding\n * @public\n */\nexport const canEncodeAudio = async (codec, options = {}) => {\n    const { numberOfChannels = 2, sampleRate = 48000, bitrate = 128e3, ...restOptions } = options;\n    if (!AUDIO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(numberOfChannels) || numberOfChannels <= 0) {\n        throw new TypeError('numberOfChannels must be a positive integer.');\n    }\n    if (!Number.isInteger(sampleRate) || sampleRate <= 0) {\n        throw new TypeError('sampleRate must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer.');\n    }\n    validateAudioEncodingAdditionalOptions(codec, restOptions);\n    let encoderConfig = null;\n    if (customAudioEncoders.length > 0) {\n        encoderConfig ??= buildAudioEncoderConfig({\n            codec,\n            numberOfChannels,\n            sampleRate,\n            bitrate,\n            ...restOptions,\n        });\n        if (customAudioEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (PCM_AUDIO_CODECS.includes(codec)) {\n        return true; // Because we encode these ourselves\n    }\n    if (typeof AudioEncoder === 'undefined') {\n        return false;\n    }\n    encoderConfig ??= buildAudioEncoderConfig({\n        codec,\n        numberOfChannels,\n        sampleRate,\n        bitrate,\n        ...restOptions,\n    });\n    const support = await AudioEncoder.isConfigSupported(encoderConfig);\n    return support.supported === true;\n};\n/**\n * Checks if the browser is able to encode the given subtitle codec.\n * @group Encoding\n * @public\n */\nexport const canEncodeSubtitles = async (codec) => {\n    if (!SUBTITLE_CODECS.includes(codec)) {\n        return false;\n    }\n    return true;\n};\n/**\n * Returns the list of all media codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableCodecs = async () => {\n    const [videoCodecs, audioCodecs, subtitleCodecs] = await Promise.all([\n        getEncodableVideoCodecs(),\n        getEncodableAudioCodecs(),\n        getEncodableSubtitleCodecs(),\n    ]);\n    return [...videoCodecs, ...audioCodecs, ...subtitleCodecs];\n};\n/**\n * Returns the list of all video codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableVideoCodecs = async (checkedCodecs = VIDEO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeVideo(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all audio codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableAudioCodecs = async (checkedCodecs = AUDIO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeAudio(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all subtitle codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableSubtitleCodecs = async (checkedCodecs = SUBTITLE_CODECS) => {\n    const bools = await Promise.all(checkedCodecs.map(canEncodeSubtitles));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the first video codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableVideoCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeVideo(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first audio codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableAudioCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeAudio(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first subtitle codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableSubtitleCodec = async (checkedCodecs) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeSubtitles(codec)) {\n            return codec;\n        }\n    }\n    return null;\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AUDIO_CODECS, buildAacAudioSpecificConfig, parseAacAudioSpecificConfig, parsePcmCodec, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { assert, assertNever, CallSerializer, clamp, isFirefox, last, promiseWithResolvers, setInt24, setUint24, toUint8Array, } from './misc.js';\nimport { SubtitleParser } from './subtitles.js';\nimport { toAlaw, toUlaw } from './pcm.js';\nimport { customVideoEncoders, customAudioEncoders, } from './custom-coder.js';\nimport { EncodedPacket } from './packet.js';\nimport { AudioSample, VideoSample } from './sample.js';\nimport { buildAudioEncoderConfig, buildVideoEncoderConfig, validateAudioEncodingConfig, validateVideoEncodingConfig, } from './encode.js';\n/**\n * Base class for media sources. Media sources are used to add media samples to an output file.\n * @group Media sources\n * @public\n */\nexport class MediaSource {\n    constructor() {\n        /** @internal */\n        this._connectedTrack = null;\n        /** @internal */\n        this._closingPromise = null;\n        /** @internal */\n        this._closed = false;\n        /**\n         * @internal\n         * A time offset in seconds that is added to all timestamps generated by this source.\n         */\n        this._timestampOffset = 0;\n    }\n    /** @internal */\n    _ensureValidAdd() {\n        if (!this._connectedTrack) {\n            throw new Error('Source is not connected to an output track.');\n        }\n        if (this._connectedTrack.output.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._connectedTrack.output.state === 'finalizing' || this._connectedTrack.output.state === 'finalized') {\n            throw new Error('Output has been finalized.');\n        }\n        if (this._connectedTrack.output.state === 'pending') {\n            throw new Error('Output has not started.');\n        }\n        if (this._closed) {\n            throw new Error('Source is closed.');\n        }\n    }\n    /** @internal */\n    async _start() { }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async _flushAndClose(forceClose) { }\n    /**\n     * Closes this source. This prevents future samples from being added and signals to the output file that no further\n     * samples will come in for this track. Calling `.close()` is optional but recommended after adding the\n     * last sample - for improved performance and reduced memory usage.\n     */\n    close() {\n        if (this._closingPromise) {\n            return;\n        }\n        const connectedTrack = this._connectedTrack;\n        if (!connectedTrack) {\n            throw new Error('Cannot call close without connecting the source to an output track.');\n        }\n        if (connectedTrack.output.state === 'pending') {\n            throw new Error('Cannot call close before output has been started.');\n        }\n        this._closingPromise = (async () => {\n            await this._flushAndClose(false);\n            this._closed = true;\n            if (connectedTrack.output.state === 'finalizing' || connectedTrack.output.state === 'finalized') {\n                return;\n            }\n            connectedTrack.output._muxer.onTrackClose(connectedTrack);\n        })();\n    }\n    /** @internal */\n    async _flushOrWaitForOngoingClose(forceClose) {\n        return this._closingPromise ??= (async () => {\n            await this._flushAndClose(forceClose);\n            this._closed = true;\n        })();\n    }\n}\n/**\n * Base class for video sources - sources for video tracks.\n * @group Media sources\n * @public\n */\nexport class VideoSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!VIDEO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid video codec '${codec}'. Must be one of: ${VIDEO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic video source; can be used to directly pipe encoded packets into the output file.\n * @group Media sources\n * @public\n */\nexport class EncodedVideoPacketSource extends VideoSource {\n    /** Creates a new {@link EncodedVideoPacketSource} whose packets are encoded using `codec`. */\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output video track. Packets must be added in *decode order*, while a packet's\n     * timestamp must be its *presentation timestamp*. B-frames are handled automatically.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack, packet, meta);\n    }\n}\nclass VideoEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastMultipleOfKeyFrameInterval = -1;\n        this.codedWidth = null;\n        this.codedHeight = null;\n        this.resizeCanvas = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new CallSerializer();\n        this.customEncoderQueueSize = 0;\n        // Alpha stuff\n        this.alphaEncoder = null;\n        this.splitter = null;\n        this.splitterCreationFailed = false;\n        this.alphaFrameQueue = [];\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.error = null;\n        this.errorNeedsNewStack = true;\n    }\n    async add(videoSample, shouldClose, encodeOptions) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure video sample size remains constant\n            if (this.codedWidth !== null && this.codedHeight !== null) {\n                if (videoSample.codedWidth !== this.codedWidth || videoSample.codedHeight !== this.codedHeight) {\n                    const sizeChangeBehavior = this.encodingConfig.sizeChangeBehavior ?? 'deny';\n                    if (sizeChangeBehavior === 'passThrough') {\n                        // Do nada\n                    }\n                    else if (sizeChangeBehavior === 'deny') {\n                        throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight},`\n                            + ` got ${videoSample.codedWidth}x${videoSample.codedHeight}. To allow the sample size to`\n                            + ` change over time, set \\`sizeChangeBehavior\\` to a value other than 'strict' in the`\n                            + ` encoding options.`);\n                    }\n                    else {\n                        let canvasIsNew = false;\n                        if (!this.resizeCanvas) {\n                            if (typeof document !== 'undefined') {\n                                // Prefer an HTMLCanvasElement\n                                this.resizeCanvas = document.createElement('canvas');\n                                this.resizeCanvas.width = this.codedWidth;\n                                this.resizeCanvas.height = this.codedHeight;\n                            }\n                            else {\n                                this.resizeCanvas = new OffscreenCanvas(this.codedWidth, this.codedHeight);\n                            }\n                            canvasIsNew = true;\n                        }\n                        const context = this.resizeCanvas.getContext('2d', {\n                            alpha: isFirefox(), // Firefox has VideoFrame glitches with opaque canvases\n                        });\n                        assert(context);\n                        if (!canvasIsNew) {\n                            if (isFirefox()) {\n                                context.fillStyle = 'black';\n                                context.fillRect(0, 0, this.codedWidth, this.codedHeight);\n                            }\n                            else {\n                                context.clearRect(0, 0, this.codedWidth, this.codedHeight);\n                            }\n                        }\n                        videoSample.drawWithFit(context, { fit: sizeChangeBehavior });\n                        if (shouldClose) {\n                            videoSample.close();\n                        }\n                        videoSample = new VideoSample(this.resizeCanvas, {\n                            timestamp: videoSample.timestamp,\n                            duration: videoSample.duration,\n                            rotation: videoSample.rotation,\n                        });\n                        shouldClose = true;\n                    }\n                }\n            }\n            else {\n                this.codedWidth = videoSample.codedWidth;\n                this.codedHeight = videoSample.codedHeight;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    this.ensureEncoder(videoSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            assert(this.encoderInitialized);\n            const keyFrameInterval = this.encodingConfig.keyFrameInterval ?? 5;\n            const multipleOfKeyFrameInterval = Math.floor(videoSample.timestamp / keyFrameInterval);\n            // Ensure a key frame every keyFrameInterval seconds. It is important that all video tracks follow the same\n            // \"key frame\" rhythm, because aligned key frames are required to start new fragments in ISOBMFF or clusters\n            // in Matroska (or at least desirable).\n            const finalEncodeOptions = {\n                ...encodeOptions,\n                keyFrame: encodeOptions?.keyFrame\n                    || keyFrameInterval === 0\n                    || multipleOfKeyFrameInterval !== this.lastMultipleOfKeyFrameInterval,\n            };\n            this.lastMultipleOfKeyFrameInterval = multipleOfKeyFrameInterval;\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = videoSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample, finalEncodeOptions))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.error ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `videoSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n            }\n            else {\n                assert(this.encoder);\n                const videoFrame = videoSample.toVideoFrame();\n                if (!this.alphaEncoder) {\n                    // No alpha encoder, simple case\n                    this.encoder.encode(videoFrame, finalEncodeOptions);\n                    videoFrame.close();\n                }\n                else {\n                    // We're expected to encode alpha as well\n                    const frameDefinitelyHasNoAlpha = !!videoFrame.format && !videoFrame.format.includes('A');\n                    if (frameDefinitelyHasNoAlpha || this.splitterCreationFailed) {\n                        this.alphaFrameQueue.push(null);\n                        this.encoder.encode(videoFrame, finalEncodeOptions);\n                        videoFrame.close();\n                    }\n                    else {\n                        const width = videoFrame.displayWidth;\n                        const height = videoFrame.displayHeight;\n                        if (!this.splitter) {\n                            try {\n                                this.splitter = new ColorAlphaSplitter(width, height);\n                            }\n                            catch (error) {\n                                console.error('Due to an error, only color data will be encoded.', error);\n                                this.splitterCreationFailed = true;\n                                this.alphaFrameQueue.push(null);\n                                this.encoder.encode(videoFrame, finalEncodeOptions);\n                                videoFrame.close();\n                            }\n                        }\n                        if (this.splitter) {\n                            const colorFrame = this.splitter.extractColor(videoFrame);\n                            const alphaFrame = this.splitter.extractAlpha(videoFrame);\n                            this.alphaFrameQueue.push(alphaFrame);\n                            this.encoder.encode(colorFrame, finalEncodeOptions);\n                            colorFrame.close();\n                            videoFrame.close();\n                        }\n                    }\n                }\n                if (shouldClose) {\n                    videoSample.close();\n                }\n                // We need to do this after sending the frame to the encoder as the frame otherwise might be closed\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n            }\n            await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                videoSample.close();\n            }\n        }\n    }\n    ensureEncoder(videoSample) {\n        const encoderError = new Error();\n        this.ensureEncoderPromise = (async () => {\n            const encoderConfig = buildVideoEncoderConfig({\n                width: videoSample.codedWidth,\n                height: videoSample.codedHeight,\n                ...this.encodingConfig,\n                framerate: this.source._connectedTrack?.metadata.frameRate,\n            });\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = customVideoEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class \"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                await this.customEncoder.init();\n            }\n            else {\n                if (typeof VideoEncoder === 'undefined') {\n                    throw new Error('VideoEncoder is not supported by this browser.');\n                }\n                encoderConfig.alpha = 'discard'; // Since we handle alpha ourselves\n                if (this.encodingConfig.alpha === 'keep') {\n                    // Encoding alpha requires using two parallel encoders, so we need to make sure they stay in sync\n                    // and that neither of them drops frames. Setting latencyMode to 'quality' achieves this, because\n                    // \"User Agents MUST not drop frames to achieve the target bitrate and/or framerate.\"\n                    encoderConfig.latencyMode = 'quality';\n                }\n                const hasOddDimension = encoderConfig.width % 2 === 1 || encoderConfig.height % 2 === 1;\n                if (hasOddDimension\n                    && (this.encodingConfig.codec === 'avc' || this.encodingConfig.codec === 'hevc')) {\n                    // Throw a special error for this case as it gets hit often\n                    throw new Error(`The dimensions ${encoderConfig.width}x${encoderConfig.height} are not supported for codec`\n                        + ` '${this.encodingConfig.codec}'; both width and height must be even numbers. Make sure to`\n                        + ` round your dimensions to the nearest even number.`);\n                }\n                const support = await VideoEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.width}x${encoderConfig.height}, hardware acceleration:`\n                        + ` ${encoderConfig.hardwareAcceleration ?? 'no-preference'}) is not supported by this browser.`\n                        + ` Consider using another codec or changing your video parameters.`);\n                }\n                /** Queue of color chunks waiting for their alpha counterpart. */\n                const colorChunkQueue = [];\n                /** Each value is the number of encoded alpha chunks at which a null alpha chunk should be added. */\n                const nullAlphaChunkQueue = [];\n                let encodedAlphaChunkCount = 0;\n                let alphaEncoderQueue = 0;\n                const addPacket = (colorChunk, alphaChunk, meta) => {\n                    const sideData = {};\n                    if (alphaChunk) {\n                        const alphaData = new Uint8Array(alphaChunk.byteLength);\n                        alphaChunk.copyTo(alphaData);\n                        sideData.alpha = alphaData;\n                    }\n                    const packet = EncodedPacket.fromEncodedChunk(colorChunk, sideData);\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                this.encoder = new VideoEncoder({\n                    output: (chunk, meta) => {\n                        if (!this.alphaEncoder) {\n                            // We're done\n                            addPacket(chunk, null, meta);\n                            return;\n                        }\n                        const alphaFrame = this.alphaFrameQueue.shift();\n                        assert(alphaFrame !== undefined);\n                        if (alphaFrame) {\n                            this.alphaEncoder.encode(alphaFrame, {\n                                // Crucial: The alpha frame is forced to be a key frame whenever the color frame\n                                // also is. Without this, playback can glitch and even crash in some browsers.\n                                // This is the reason why the two encoders are wired in series and not in parallel.\n                                keyFrame: chunk.type === 'key',\n                            });\n                            alphaEncoderQueue++;\n                            alphaFrame.close();\n                            colorChunkQueue.push({ chunk, meta });\n                        }\n                        else {\n                            // There was no alpha component for this frame\n                            if (alphaEncoderQueue === 0) {\n                                // No pending alpha encodes either, so we're done\n                                addPacket(chunk, null, meta);\n                            }\n                            else {\n                                // There are still alpha encodes pending, so we can't add the packet immediately since\n                                // we'd end up with out-of-order packets. Instead, let's queue a null alpha chunk to be\n                                // added in the future, after the current encoder workload has completed:\n                                nullAlphaChunkQueue.push(encodedAlphaChunkCount + alphaEncoderQueue);\n                                colorChunkQueue.push({ chunk, meta });\n                            }\n                        }\n                    },\n                    error: (error) => {\n                        error.stack = encoderError.stack; // Provide a more useful stack trace\n                        this.error ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n                if (this.encodingConfig.alpha === 'keep') {\n                    // We need to encode alpha as well, which we do with a separate encoder\n                    this.alphaEncoder = new VideoEncoder({\n                        // We ignore the alpha chunk's metadata\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        output: (chunk, meta) => {\n                            alphaEncoderQueue--;\n                            // There has to be a color chunk because the encoders are wired in series\n                            const colorChunk = colorChunkQueue.shift();\n                            assert(colorChunk !== undefined);\n                            addPacket(colorChunk.chunk, chunk, colorChunk.meta);\n                            // See if there are any null alpha chunks queued up\n                            encodedAlphaChunkCount++;\n                            while (nullAlphaChunkQueue.length > 0\n                                && nullAlphaChunkQueue[0] === encodedAlphaChunkCount) {\n                                nullAlphaChunkQueue.shift();\n                                const colorChunk = colorChunkQueue.shift();\n                                assert(colorChunk !== undefined);\n                                addPacket(colorChunk.chunk, null, colorChunk.meta);\n                            }\n                        },\n                        error: (error) => {\n                            error.stack = encoderError.stack; // Provide a more useful stack trace\n                            this.error ??= error;\n                        },\n                    });\n                    this.alphaEncoder.configure(encoderConfig);\n                }\n            }\n            assert(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    async flushAndClose(forceClose) {\n        if (!forceClose)\n            this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                // These are wired in series, therefore they must also be flushed in series\n                await this.encoder.flush();\n                await this.alphaEncoder?.flush();\n            }\n            if (this.encoder.state !== 'closed') {\n                this.encoder.close();\n            }\n            if (this.alphaEncoder && this.alphaEncoder.state !== 'closed') {\n                this.alphaEncoder.close();\n            }\n            this.alphaFrameQueue.forEach(x => x?.close());\n            this.splitter?.close();\n        }\n        if (!forceClose)\n            this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else {\n            // Because the color and alpha encoders are wired in series, there's no need to also include the alpha\n            // encoder's queue size here\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.error) {\n            if (this.errorNeedsNewStack) {\n                this.error.stack = new Error().stack; // Provide an even more useful stack trace\n            }\n            throw this.error;\n        }\n    }\n}\n/** Utility class for splitting a composite frame into separate color and alpha components. */\nclass ColorAlphaSplitter {\n    constructor(initialWidth, initialHeight) {\n        this.lastFrame = null;\n        if (typeof OffscreenCanvas !== 'undefined') {\n            this.canvas = new OffscreenCanvas(initialWidth, initialHeight);\n        }\n        else {\n            this.canvas = document.createElement('canvas');\n            this.canvas.width = initialWidth;\n            this.canvas.height = initialHeight;\n        }\n        const gl = this.canvas.getContext('webgl2', {\n            alpha: true, // Needed due to the YUV thing we do for alpha\n        }); // Casting because of some TypeScript weirdness\n        if (!gl) {\n            throw new Error('Couldn\\'t acquire WebGL 2 context.');\n        }\n        this.gl = gl;\n        this.colorProgram = this.createColorProgram();\n        this.alphaProgram = this.createAlphaProgram();\n        this.vao = this.createVAO();\n        this.sourceTexture = this.createTexture();\n        this.alphaResolutionLocation = this.gl.getUniformLocation(this.alphaProgram, 'u_resolution');\n        this.gl.useProgram(this.colorProgram);\n        this.gl.uniform1i(this.gl.getUniformLocation(this.colorProgram, 'u_sourceTexture'), 0);\n        this.gl.useProgram(this.alphaProgram);\n        this.gl.uniform1i(this.gl.getUniformLocation(this.alphaProgram, 'u_sourceTexture'), 0);\n    }\n    createVertexShader() {\n        return this.createShader(this.gl.VERTEX_SHADER, `#version 300 es\n\t\t\tin vec2 a_position;\n\t\t\tin vec2 a_texCoord;\n\t\t\tout vec2 v_texCoord;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = vec4(a_position, 0.0, 1.0);\n\t\t\t\tv_texCoord = a_texCoord;\n\t\t\t}\n\t\t`);\n    }\n    createColorProgram() {\n        const vertexShader = this.createVertexShader();\n        // This shader is simple, simply copy the color information while setting alpha to 1\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, `#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_sourceTexture;\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tvec4 source = texture(u_sourceTexture, v_texCoord);\n\t\t\t\tfragColor = vec4(source.rgb, 1.0);\n\t\t\t}\n\t\t`);\n        const program = this.gl.createProgram();\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n        return program;\n    }\n    createAlphaProgram() {\n        const vertexShader = this.createVertexShader();\n        // This shader's more complex. The main reason is that this shader writes data in I420 (yuv420) pixel format\n        // instead of regular RGBA. In other words, we use the shader to write out I420 data into an RGBA canvas, which\n        // we then later read out with JavaScript. The reason being that browsers weirdly encode canvases and mess up\n        // the color spaces, and the only way to have full control over the color space is by outputting YUV data\n        // directly (avoiding the RGB conversion). Doing this conversion in JS is painfully slow, so let's utlize the\n        // GPU since we're already calling it anyway.\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, `#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_sourceTexture;\n\t\t\tuniform vec2 u_resolution; // The width and height of the canvas\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\n\t\t\t// This function determines the value for a single byte in the YUV stream\n\t\t\tfloat getByteValue(float byteOffset) {\n\t\t\t\tfloat width = u_resolution.x;\n\t\t\t\tfloat height = u_resolution.y;\n\n\t\t\t\tfloat yPlaneSize = width * height;\n\n\t\t\t\tif (byteOffset < yPlaneSize) {\n\t\t\t\t\t// This byte is in the luma plane. Find the corresponding pixel coordinates to sample from\n\t\t\t\t\tfloat y = floor(byteOffset / width);\n\t\t\t\t\tfloat x = mod(byteOffset, width);\n\t\t\t\t\t\n\t\t\t\t\t// Add 0.5 to sample the center of the texel\n\t\t\t\t\tvec2 sampleCoord = (vec2(x, y) + 0.5) / u_resolution;\n\t\t\t\t\t\n\t\t\t\t\t// The luma value is the alpha from the source texture\n\t\t\t\t\treturn texture(u_sourceTexture, sampleCoord).a;\n\t\t\t\t} else {\n\t\t\t\t\t// Write a fixed value for chroma and beyond\n\t\t\t\t\treturn 128.0 / 255.0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\t// Each fragment writes 4 bytes (R, G, B, A)\n\t\t\t\tfloat pixelIndex = floor(gl_FragCoord.y) * u_resolution.x + floor(gl_FragCoord.x);\n\t\t\t\tfloat baseByteOffset = pixelIndex * 4.0;\n\n\t\t\t\tvec4 result;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tfloat currentByteOffset = baseByteOffset + float(i);\n\t\t\t\t\tresult[i] = getByteValue(currentByteOffset);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfragColor = result;\n\t\t\t}\n\t\t`);\n        const program = this.gl.createProgram();\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n        return program;\n    }\n    createShader(type, source) {\n        const shader = this.gl.createShader(type);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));\n        }\n        return shader;\n    }\n    createVAO() {\n        const vao = this.gl.createVertexArray();\n        this.gl.bindVertexArray(vao);\n        const vertices = new Float32Array([\n            -1, -1, 0, 1,\n            1, -1, 1, 1,\n            -1, 1, 0, 0,\n            1, 1, 1, 0,\n        ]);\n        const buffer = this.gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);\n        const positionLocation = this.gl.getAttribLocation(this.colorProgram, 'a_position');\n        const texCoordLocation = this.gl.getAttribLocation(this.colorProgram, 'a_texCoord');\n        this.gl.enableVertexAttribArray(positionLocation);\n        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 16, 0);\n        this.gl.enableVertexAttribArray(texCoordLocation);\n        this.gl.vertexAttribPointer(texCoordLocation, 2, this.gl.FLOAT, false, 16, 8);\n        return vao;\n    }\n    createTexture() {\n        const texture = this.gl.createTexture();\n        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n        return texture;\n    }\n    updateTexture(sourceFrame) {\n        if (this.lastFrame === sourceFrame) {\n            return;\n        }\n        if (sourceFrame.displayWidth !== this.canvas.width || sourceFrame.displayHeight !== this.canvas.height) {\n            this.canvas.width = sourceFrame.displayWidth;\n            this.canvas.height = sourceFrame.displayHeight;\n        }\n        this.gl.activeTexture(this.gl.TEXTURE0);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.sourceTexture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, sourceFrame);\n        this.lastFrame = sourceFrame;\n    }\n    extractColor(sourceFrame) {\n        this.updateTexture(sourceFrame);\n        this.gl.useProgram(this.colorProgram);\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.bindVertexArray(this.vao);\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n        return new VideoFrame(this.canvas, {\n            timestamp: sourceFrame.timestamp,\n            duration: sourceFrame.duration ?? undefined,\n            alpha: 'discard',\n        });\n    }\n    extractAlpha(sourceFrame) {\n        this.updateTexture(sourceFrame);\n        this.gl.useProgram(this.alphaProgram);\n        this.gl.uniform2f(this.alphaResolutionLocation, this.canvas.width, this.canvas.height);\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.bindVertexArray(this.vao);\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n        const { width, height } = this.canvas;\n        const chromaSamples = Math.ceil(width / 2) * Math.ceil(height / 2);\n        const yuvSize = width * height + chromaSamples * 2;\n        const requiredHeight = Math.ceil(yuvSize / (width * 4));\n        let yuv = new Uint8Array(4 * width * requiredHeight);\n        this.gl.readPixels(0, 0, width, requiredHeight, this.gl.RGBA, this.gl.UNSIGNED_BYTE, yuv);\n        yuv = yuv.subarray(0, yuvSize);\n        assert(yuv[width * height] === 128); // Where chroma data starts\n        assert(yuv[yuv.length - 1] === 128); // Assert the YUV data has been fully written\n        // Defining this separately because TypeScript doesn't know `transfer` and I can't be bothered to do declaration\n        // merging right now\n        const init = {\n            format: 'I420',\n            codedWidth: width,\n            codedHeight: height,\n            timestamp: sourceFrame.timestamp,\n            duration: sourceFrame.duration ?? undefined,\n            transfer: [yuv.buffer],\n        };\n        return new VideoFrame(yuv, init);\n    }\n    close() {\n        this.gl.getExtension('WEBGL_lose_context')?.loseContext();\n        this.gl = null;\n    }\n}\n/**\n * This source can be used to add raw, unencoded video samples (frames) to an output video track. These frames will\n * automatically be encoded and then piped into the output.\n * @group Media sources\n * @public\n */\nexport class VideoSampleSource extends VideoSource {\n    /**\n     * Creates a new {@link VideoSampleSource} whose samples are encoded according to the specified\n     * {@link VideoEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateVideoEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes a video sample (frame) and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(videoSample, encodeOptions) {\n        if (!(videoSample instanceof VideoSample)) {\n            throw new TypeError('videoSample must be a VideoSample.');\n        }\n        return this._encoder.add(videoSample, false, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add video frames to the output track from a fixed canvas element. Since canvases are often\n * used for rendering, this source provides a convenient wrapper around {@link VideoSampleSource}.\n * @group Media sources\n * @public\n */\nexport class CanvasSource extends VideoSource {\n    /**\n     * Creates a new {@link CanvasSource} from a canvas element or `OffscreenCanvas` whose samples are encoded\n     * according to the specified {@link VideoEncodingConfig}.\n     */\n    constructor(canvas, encodingConfig) {\n        if (!(typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement)\n            && !(typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n            throw new TypeError('canvas must be an HTMLCanvasElement or OffscreenCanvas.');\n        }\n        validateVideoEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._canvas = canvas;\n    }\n    /**\n     * Captures the current canvas state as a video sample (frame), encodes it and adds it to the output.\n     *\n     * @param timestamp - The timestamp of the sample, in seconds.\n     * @param duration - The duration of the sample, in seconds.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(timestamp, duration = 0, encodeOptions) {\n        if (!Number.isFinite(timestamp) || timestamp < 0) {\n            throw new TypeError('timestamp must be a non-negative number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        const sample = new VideoSample(this._canvas, { timestamp, duration });\n        return this._encoder.add(sample, true, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Video source that encodes the frames of a\n * [`MediaStreamVideoTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) and pipes them into the\n * output. This is useful for capturing live or real-time data such as webcams or screen captures. Frames will\n * automatically start being captured once the connected {@link Output} is started, and will keep being captured until\n * the {@link Output} is finalized or this source is closed.\n * @group Media sources\n * @public\n */\nexport class MediaStreamVideoTrackSource extends VideoSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    /** Whether this source is currently paused as a result of calling `.pause()`. */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Creates a new {@link MediaStreamVideoTrackSource} from a\n     * [`MediaStreamVideoTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack), which will pull\n     * video samples from the stream in real time and encode them according to {@link VideoEncodingConfig}.\n     */\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'video') {\n            throw new TypeError('track must be a video MediaStreamTrack.');\n        }\n        validateVideoEncodingConfig(encodingConfig);\n        encodingConfig = {\n            ...encodingConfig,\n            latencyMode: 'realtime',\n        };\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._workerTrackId = null;\n        /** @internal */\n        this._workerListener = null;\n        /** @internal */\n        this._promiseWithResolvers = promiseWithResolvers();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        /** @internal */\n        this._paused = false;\n        /** @internal */\n        this._lastSampleTimestamp = null;\n        /** @internal */\n        this._pauseOffset = 0;\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        let firstVideoFrameTimestamp = null;\n        let errored = false;\n        const onVideoFrame = (videoFrame) => {\n            if (errored) {\n                videoFrame.close();\n                return;\n            }\n            const currentTimestamp = videoFrame.timestamp / 1e6;\n            if (this._paused) {\n                const frameSeen = firstVideoFrameTimestamp !== null;\n                if (frameSeen) {\n                    if (this._lastSampleTimestamp !== null) {\n                        // In addition to dropping this frame, let's also keep track of the time we have lost due to the\n                        // pause. Doing it like this instead of simply keeping track of the paused time is better since\n                        // it retains the frame rate of the underlying source.\n                        const timeDelta = currentTimestamp - this._lastSampleTimestamp;\n                        // We modify this field instead of _timestampOffset since we still might have data in flight\n                        // in the encoder, with which we don't want to mess.\n                        this._pauseOffset -= timeDelta;\n                    }\n                    this._lastSampleTimestamp = currentTimestamp;\n                }\n                videoFrame.close();\n                return;\n            }\n            if (firstVideoFrameTimestamp === null) {\n                firstVideoFrameTimestamp = currentTimestamp;\n                const muxer = this._connectedTrack.output._muxer;\n                if (muxer.firstMediaStreamTimestamp === null) {\n                    muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                    this._timestampOffset = -firstVideoFrameTimestamp;\n                }\n                else {\n                    this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                        - firstVideoFrameTimestamp;\n                }\n            }\n            this._lastSampleTimestamp = currentTimestamp;\n            if (this._encoder.getQueueSize() >= 4) {\n                // Drop frames if the encoder is overloaded\n                videoFrame.close();\n                return;\n            }\n            const sample = new VideoSample(videoFrame, {\n                timestamp: currentTimestamp + this._pauseOffset,\n            });\n            void this._encoder.add(sample, true)\n                .catch((error) => {\n                errored = true;\n                this._abortController?.abort();\n                this._promiseWithResolvers.reject(error);\n                if (this._workerTrackId !== null) {\n                    // Tell the worker to stop the track\n                    sendMessageToMediaStreamTrackProcessorWorker({\n                        type: 'stopTrack',\n                        trackId: this._workerTrackId,\n                    });\n                }\n            });\n        };\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // We can do it here directly, perfect\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({ write: onVideoFrame });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // It might still be supported in a worker, so let's check that\n            const supportedInWorker = await mediaStreamTrackProcessorIsSupportedInWorker();\n            if (supportedInWorker) {\n                this._workerTrackId = nextMediaStreamTrackProcessorWorkerId++;\n                sendMessageToMediaStreamTrackProcessorWorker({\n                    type: 'videoTrack',\n                    trackId: this._workerTrackId,\n                    track: this._track,\n                });\n                this._workerListener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'videoFrame' && message.trackId === this._workerTrackId) {\n                        onVideoFrame(message.videoFrame);\n                    }\n                    else if (message.type === 'error' && message.trackId === this._workerTrackId) {\n                        this._promiseWithResolvers.reject(message.error);\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', this._workerListener);\n            }\n            else {\n                throw new Error('MediaStreamTrackProcessor is required but not supported by this browser.');\n            }\n        }\n    }\n    /**\n     * Pauses the capture of video frames - any video frames emitted by the underlying media stream will be ignored\n     * while paused. This does *not* close the underlying `MediaStreamVideoTrack`, it just ignores its output.\n     */\n    pause() {\n        this._paused = true;\n    }\n    /** Resumes the capture of video frames after being paused. */\n    resume() {\n        this._paused = false;\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._workerTrackId !== null) {\n            assert(this._workerListener);\n            sendMessageToMediaStreamTrackProcessorWorker({\n                type: 'stopTrack',\n                trackId: this._workerTrackId,\n            });\n            // Wait for the worker to stop the track\n            await new Promise((resolve) => {\n                const listener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'trackStopped' && message.trackId === this._workerTrackId) {\n                        assert(this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                        resolve();\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n            });\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Base class for audio sources - sources for audio tracks.\n * @group Media sources\n * @public\n */\nexport class AudioSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!AUDIO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid audio codec '${codec}'. Must be one of: ${AUDIO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic audio source; can be used to directly pipe encoded packets into the output file.\n * @group Media sources\n * @public\n */\nexport class EncodedAudioPacketSource extends AudioSource {\n    /** Creates a new {@link EncodedAudioPacketSource} whose packets are encoded using `codec`. */\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output audio track. Packets must be added in *decode order*.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack, packet, meta);\n    }\n}\nclass AudioEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastNumberOfChannels = null;\n        this.lastSampleRate = null;\n        this.isPcmEncoder = false;\n        this.outputSampleSize = null;\n        this.writeOutputValue = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new CallSerializer();\n        this.customEncoderQueueSize = 0;\n        this.lastEndSampleIndex = null;\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.error = null;\n        this.errorNeedsNewStack = true;\n    }\n    async add(audioSample, shouldClose) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure audio parameters remain constant\n            if (this.lastNumberOfChannels !== null && this.lastSampleRate !== null) {\n                if (audioSample.numberOfChannels !== this.lastNumberOfChannels\n                    || audioSample.sampleRate !== this.lastSampleRate) {\n                    throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at`\n                        + ` ${this.lastSampleRate} Hz, got ${audioSample.numberOfChannels} channels at`\n                        + ` ${audioSample.sampleRate} Hz.`);\n                }\n            }\n            else {\n                this.lastNumberOfChannels = audioSample.numberOfChannels;\n                this.lastSampleRate = audioSample.sampleRate;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    this.ensureEncoder(audioSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            assert(this.encoderInitialized);\n            // Handle padding of gaps with silence to avoid audio drift over time, like in\n            // https://github.com/Vanilagy/mediabunny/issues/176\n            // TODO An open question is how encoders deal with the first AudioData having a non-zero timestamp, and with\n            // AudioDatas that have an overlapping timestamp range.\n            {\n                const startSampleIndex = Math.round(audioSample.timestamp * audioSample.sampleRate);\n                const endSampleIndex = Math.round((audioSample.timestamp + audioSample.duration) * audioSample.sampleRate);\n                if (this.lastEndSampleIndex === null) {\n                    this.lastEndSampleIndex = endSampleIndex;\n                }\n                else {\n                    const sampleDiff = startSampleIndex - this.lastEndSampleIndex;\n                    if (sampleDiff >= 64) {\n                        // The gap is big enough, let's add a correction sample\n                        const fillSample = new AudioSample({\n                            data: new Float32Array(sampleDiff * audioSample.numberOfChannels),\n                            format: 'f32-planar',\n                            sampleRate: audioSample.sampleRate,\n                            numberOfChannels: audioSample.numberOfChannels,\n                            numberOfFrames: sampleDiff,\n                            timestamp: this.lastEndSampleIndex / audioSample.sampleRate,\n                        });\n                        await this.add(fillSample, true); // Recursive call\n                    }\n                    this.lastEndSampleIndex += audioSample.numberOfFrames;\n                }\n            }\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = audioSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.error ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `audioSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n            else if (this.isPcmEncoder) {\n                await this.doPcmEncoding(audioSample, shouldClose);\n            }\n            else {\n                assert(this.encoder);\n                const audioData = audioSample.toAudioData();\n                this.encoder.encode(audioData);\n                audioData.close();\n                if (shouldClose) {\n                    audioSample.close();\n                }\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                audioSample.close();\n            }\n        }\n    }\n    async doPcmEncoding(audioSample, shouldClose) {\n        assert(this.outputSampleSize);\n        assert(this.writeOutputValue);\n        // Need to extract data from the audio data before we close it\n        const { numberOfChannels, numberOfFrames, sampleRate, timestamp } = audioSample;\n        const CHUNK_SIZE = 2048;\n        const outputs = [];\n        // Prepare all of the output buffers, each being bounded by CHUNK_SIZE so we don't generate huge packets\n        for (let frame = 0; frame < numberOfFrames; frame += CHUNK_SIZE) {\n            const frameCount = Math.min(CHUNK_SIZE, audioSample.numberOfFrames - frame);\n            const outputSize = frameCount * numberOfChannels * this.outputSampleSize;\n            const outputBuffer = new ArrayBuffer(outputSize);\n            const outputView = new DataView(outputBuffer);\n            outputs.push({ frameCount, view: outputView });\n        }\n        const allocationSize = audioSample.allocationSize(({ planeIndex: 0, format: 'f32-planar' }));\n        const floats = new Float32Array(allocationSize / Float32Array.BYTES_PER_ELEMENT);\n        for (let i = 0; i < numberOfChannels; i++) {\n            audioSample.copyTo(floats, { planeIndex: i, format: 'f32-planar' });\n            for (let j = 0; j < outputs.length; j++) {\n                const { frameCount, view } = outputs[j];\n                for (let k = 0; k < frameCount; k++) {\n                    this.writeOutputValue(view, (k * numberOfChannels + i) * this.outputSampleSize, floats[j * CHUNK_SIZE + k]);\n                }\n            }\n        }\n        if (shouldClose) {\n            audioSample.close();\n        }\n        const meta = {\n            decoderConfig: {\n                codec: this.encodingConfig.codec,\n                numberOfChannels,\n                sampleRate,\n            },\n        };\n        for (let i = 0; i < outputs.length; i++) {\n            const { frameCount, view } = outputs[i];\n            const outputBuffer = view.buffer;\n            const startFrame = i * CHUNK_SIZE;\n            const packet = new EncodedPacket(new Uint8Array(outputBuffer), 'key', timestamp + startFrame / sampleRate, frameCount / sampleRate);\n            this.encodingConfig.onEncodedPacket?.(packet, meta);\n            await this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta); // With backpressure\n        }\n    }\n    ensureEncoder(audioSample) {\n        const encoderError = new Error();\n        this.ensureEncoderPromise = (async () => {\n            const { numberOfChannels, sampleRate } = audioSample;\n            const encoderConfig = buildAudioEncoderConfig({\n                numberOfChannels,\n                sampleRate,\n                ...this.encodingConfig,\n            });\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = customAudioEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class \"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                await this.customEncoder.init();\n            }\n            else if (PCM_AUDIO_CODECS.includes(this.encodingConfig.codec)) {\n                this.initPcmEncoder();\n            }\n            else {\n                if (typeof AudioEncoder === 'undefined') {\n                    throw new Error('AudioEncoder is not supported by this browser.');\n                }\n                const support = await AudioEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.numberOfChannels} channels, ${encoderConfig.sampleRate} Hz) is not`\n                        + ` supported by this browser. Consider using another codec or changing your audio parameters.`);\n                }\n                this.encoder = new AudioEncoder({\n                    output: (chunk, meta) => {\n                        // WebKit emits an invalid description for AAC (https://bugs.webkit.org/show_bug.cgi?id=302253),\n                        // which we try to detect here. If detected, we'll provide our own description instead, derived\n                        // from the codec string and audio parameters.\n                        if (this.encodingConfig.codec === 'aac' && meta?.decoderConfig) {\n                            let needsDescriptionOverwrite = false;\n                            if (!meta.decoderConfig.description || meta.decoderConfig.description.byteLength < 2) {\n                                needsDescriptionOverwrite = true;\n                            }\n                            else {\n                                const audioSpecificConfig = parseAacAudioSpecificConfig(toUint8Array(meta.decoderConfig.description));\n                                needsDescriptionOverwrite = audioSpecificConfig.objectType === 0;\n                            }\n                            if (needsDescriptionOverwrite) {\n                                const objectType = Number(last(encoderConfig.codec.split('.')));\n                                meta.decoderConfig.description = buildAacAudioSpecificConfig({\n                                    objectType,\n                                    numberOfChannels: meta.decoderConfig.numberOfChannels,\n                                    sampleRate: meta.decoderConfig.sampleRate,\n                                });\n                            }\n                        }\n                        const packet = EncodedPacket.fromEncodedChunk(chunk);\n                        this.encodingConfig.onEncodedPacket?.(packet, meta);\n                        void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta)\n                            .catch((error) => {\n                            this.error ??= error;\n                            this.errorNeedsNewStack = false;\n                        });\n                    },\n                    error: (error) => {\n                        error.stack = encoderError.stack; // Provide a more useful stack trace\n                        this.error ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n            }\n            assert(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    initPcmEncoder() {\n        this.isPcmEncoder = true;\n        const codec = this.encodingConfig.codec;\n        const { dataType, sampleSize, littleEndian } = parsePcmCodec(codec);\n        this.outputSampleSize = sampleSize;\n        // All these functions receive a float sample as input and map it into the desired format\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint8(byteOffset, clamp((value + 1) * 127.5, 0, 255));\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            view.setInt8(byteOffset, clamp(Math.round(value * 128), -128, 127));\n                        };\n                    }\n                    else if (dataType === 'ulaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = clamp(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, toUlaw(int16));\n                        };\n                    }\n                    else if (dataType === 'alaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = clamp(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, toAlaw(int16));\n                        };\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint16(byteOffset, clamp((value + 1) * 32767.5, 0, 65535), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, clamp(Math.round(value * 32767), -32768, 32767), littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 3:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => setUint24(view, byteOffset, clamp((value + 1) * 8388607.5, 0, 16777215), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => setInt24(view, byteOffset, clamp(Math.round(value * 8388607), -8388608, 8388607), littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 4:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint32(byteOffset, clamp((value + 1) * 2147483647.5, 0, 4294967295), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, clamp(Math.round(value * 2147483647), -2147483648, 2147483647), littleEndian);\n                    }\n                    else if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat64(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            default:\n                {\n                    assertNever(sampleSize);\n                    assert(false);\n                }\n                ;\n        }\n    }\n    async flushAndClose(forceClose) {\n        if (!forceClose)\n            this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                await this.encoder.flush();\n            }\n            if (this.encoder.state !== 'closed') {\n                this.encoder.close();\n            }\n        }\n        if (!forceClose)\n            this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else if (this.isPcmEncoder) {\n            return 0;\n        }\n        else {\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.error) {\n            if (this.errorNeedsNewStack) {\n                this.error.stack = new Error().stack; // Provide an even more useful stack trace\n            }\n            throw this.error;\n        }\n    }\n}\n/**\n * This source can be used to add raw, unencoded audio samples to an output audio track. These samples will\n * automatically be encoded and then piped into the output.\n * @group Media sources\n * @public\n */\nexport class AudioSampleSource extends AudioSource {\n    /**\n     * Creates a new {@link AudioSampleSource} whose samples are encoded according to the specified\n     * {@link AudioEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes an audio sample and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(audioSample) {\n        if (!(audioSample instanceof AudioSample)) {\n            throw new TypeError('audioSample must be an AudioSample.');\n        }\n        return this._encoder.add(audioSample, false);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add audio data from an AudioBuffer to the output track. This is useful when working with\n * the Web Audio API.\n * @group Media sources\n * @public\n */\nexport class AudioBufferSource extends AudioSource {\n    /**\n     * Creates a new {@link AudioBufferSource} whose `AudioBuffer` instances are encoded according to the specified\n     * {@link AudioEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._accumulatedTime = 0;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Converts an AudioBuffer to audio samples, encodes them and adds them to the output. The first AudioBuffer will\n     * be played at timestamp 0, and any subsequent AudioBuffer will have a timestamp equal to the total duration of\n     * all previous AudioBuffers.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    async add(audioBuffer) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const iterator = AudioSample._fromAudioBuffer(audioBuffer, this._accumulatedTime);\n        this._accumulatedTime += audioBuffer.duration;\n        for (const audioSample of iterator) {\n            await this._encoder.add(audioSample, true);\n        }\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Audio source that encodes the data of a\n * [`MediaStreamAudioTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) and pipes it into the\n * output. This is useful for capturing live or real-time audio such as microphones or audio from other media elements.\n * Audio will automatically start being captured once the connected {@link Output} is started, and will keep being\n * captured until the {@link Output} is finalized or this source is closed.\n * @group Media sources\n * @public\n */\nexport class MediaStreamAudioTrackSource extends AudioSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    /** Whether this source is currently paused as a result of calling `.pause()`. */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Creates a new {@link MediaStreamAudioTrackSource} from a `MediaStreamAudioTrack`, which will pull audio samples\n     * from the stream in real time and encode them according to {@link AudioEncodingConfig}.\n     */\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'audio') {\n            throw new TypeError('track must be an audio MediaStreamTrack.');\n        }\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._audioContext = null;\n        /** @internal */\n        this._scriptProcessorNode = null; // Deprecated but goated\n        /** @internal */\n        this._promiseWithResolvers = promiseWithResolvers();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        /** @internal */\n        this._paused = false;\n        /** @internal */\n        this._lastSampleTimestamp = null;\n        /** @internal */\n        this._pauseOffset = 0;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        let firstAudioDataTimestamp = null;\n        let errored = false;\n        const onAudioSample = (audioSample) => {\n            if (errored) {\n                audioSample.close();\n                return;\n            }\n            const currentTimestamp = audioSample.timestamp;\n            if (this._paused) {\n                const dataSeen = firstAudioDataTimestamp !== null;\n                if (dataSeen) {\n                    if (this._lastSampleTimestamp !== null) {\n                        // In addition to dropping this sample, let's also keep track of the time we have lost due to\n                        // the pause. Doing it like this instead of simply keeping track of the paused time is better\n                        // since it retains the sample rate of the underlying source.\n                        const timeDelta = currentTimestamp - this._lastSampleTimestamp;\n                        // We modify this field instead of _timestampOffset since we still might have data in flight\n                        // in the encoder, with which we don't want to mess.\n                        this._pauseOffset -= timeDelta;\n                    }\n                    this._lastSampleTimestamp = currentTimestamp;\n                }\n                audioSample.close();\n                return;\n            }\n            if (firstAudioDataTimestamp === null) {\n                firstAudioDataTimestamp = audioSample.timestamp;\n                const muxer = this._connectedTrack.output._muxer;\n                if (muxer.firstMediaStreamTimestamp === null) {\n                    muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                    this._timestampOffset = -firstAudioDataTimestamp;\n                }\n                else {\n                    this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                        - firstAudioDataTimestamp;\n                }\n            }\n            this._lastSampleTimestamp = currentTimestamp;\n            if (this._encoder.getQueueSize() >= 4) {\n                // Drop data if the encoder is overloaded\n                audioSample.close();\n                return;\n            }\n            audioSample.setTimestamp(currentTimestamp + this._pauseOffset);\n            void this._encoder.add(audioSample, true)\n                .catch((error) => {\n                errored = true;\n                this._abortController?.abort();\n                this._promiseWithResolvers.reject(error);\n                void this._audioContext?.suspend();\n            });\n        };\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // Great, MediaStreamTrackProcessor is supported, this is the preferred way of doing things\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({\n                write: audioData => onAudioSample(new AudioSample(audioData)),\n            });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // Let's fall back to an AudioContext approach\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n            const AudioContext = window.AudioContext || window.webkitAudioContext;\n            this._audioContext = new AudioContext({ sampleRate: this._track.getSettings().sampleRate });\n            const sourceNode = this._audioContext.createMediaStreamSource(new MediaStream([this._track]));\n            this._scriptProcessorNode = this._audioContext.createScriptProcessor(4096);\n            if (this._audioContext.state === 'suspended') {\n                await this._audioContext.resume();\n            }\n            sourceNode.connect(this._scriptProcessorNode);\n            this._scriptProcessorNode.connect(this._audioContext.destination);\n            let totalDuration = 0;\n            this._scriptProcessorNode.onaudioprocess = (event) => {\n                const iterator = AudioSample._fromAudioBuffer(event.inputBuffer, totalDuration);\n                totalDuration += event.inputBuffer.duration;\n                for (const audioSample of iterator) {\n                    onAudioSample(audioSample);\n                }\n            };\n        }\n    }\n    /**\n     * Pauses the capture of audio data - any audio data emitted by the underlying media stream will be ignored\n     * while paused. This does *not* close the underlying `MediaStreamAudioTrack`, it just ignores its output.\n     */\n    pause() {\n        this._paused = true;\n    }\n    /** Resumes the capture of audio data after being paused. */\n    resume() {\n        this._paused = false;\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._audioContext) {\n            assert(this._scriptProcessorNode);\n            this._scriptProcessorNode.disconnect();\n            await this._audioContext.suspend();\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\nconst mediaStreamTrackProcessorWorkerCode = () => {\n    const sendMessage = (message, transfer) => {\n        if (transfer) {\n            self.postMessage(message, { transfer });\n        }\n        else {\n            self.postMessage(message);\n        }\n    };\n    // Immediately send a message to the main thread, letting them know of the support\n    sendMessage({\n        type: 'support',\n        supported: typeof MediaStreamTrackProcessor !== 'undefined',\n    });\n    const abortControllers = new Map();\n    const activeTracks = new Map();\n    self.addEventListener('message', (event) => {\n        const message = event.data;\n        switch (message.type) {\n            case 'videoTrack':\n                {\n                    activeTracks.set(message.trackId, message.track);\n                    const processor = new MediaStreamTrackProcessor({ track: message.track });\n                    const consumer = new WritableStream({\n                        write: (videoFrame) => {\n                            if (!activeTracks.has(message.trackId)) {\n                                videoFrame.close();\n                                return;\n                            }\n                            // Send it to the main thread\n                            sendMessage({\n                                type: 'videoFrame',\n                                trackId: message.trackId,\n                                videoFrame,\n                            }, [videoFrame]);\n                        },\n                    });\n                    const abortController = new AbortController();\n                    abortControllers.set(message.trackId, abortController);\n                    processor.readable.pipeTo(consumer, {\n                        signal: abortController.signal,\n                    }).catch((error) => {\n                        // Handle AbortError silently\n                        if (error instanceof DOMException && error.name === 'AbortError')\n                            return;\n                        sendMessage({\n                            type: 'error',\n                            trackId: message.trackId,\n                            error,\n                        });\n                    });\n                }\n                ;\n                break;\n            case 'stopTrack':\n                {\n                    const abortController = abortControllers.get(message.trackId);\n                    if (abortController) {\n                        abortController.abort();\n                        abortControllers.delete(message.trackId);\n                    }\n                    const track = activeTracks.get(message.trackId);\n                    track?.stop();\n                    activeTracks.delete(message.trackId);\n                    sendMessage({\n                        type: 'trackStopped',\n                        trackId: message.trackId,\n                    });\n                }\n                ;\n                break;\n            default: assertNever(message);\n        }\n    });\n};\nlet nextMediaStreamTrackProcessorWorkerId = 0;\nlet mediaStreamTrackProcessorWorker = null;\nconst initMediaStreamTrackProcessorWorker = () => {\n    const blob = new Blob([`(${mediaStreamTrackProcessorWorkerCode.toString()})()`], { type: 'application/javascript' });\n    const url = URL.createObjectURL(blob);\n    mediaStreamTrackProcessorWorker = new Worker(url);\n};\nlet mediaStreamTrackProcessorIsSupportedInWorkerCache = null;\nconst mediaStreamTrackProcessorIsSupportedInWorker = async () => {\n    if (mediaStreamTrackProcessorIsSupportedInWorkerCache !== null) {\n        return mediaStreamTrackProcessorIsSupportedInWorkerCache;\n    }\n    if (!mediaStreamTrackProcessorWorker) {\n        initMediaStreamTrackProcessorWorker();\n    }\n    return new Promise((resolve) => {\n        assert(mediaStreamTrackProcessorWorker);\n        const listener = (event) => {\n            const message = event.data;\n            if (message.type === 'support') {\n                mediaStreamTrackProcessorIsSupportedInWorkerCache = message.supported;\n                mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                resolve(message.supported);\n            }\n        };\n        mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n    });\n};\nconst sendMessageToMediaStreamTrackProcessorWorker = (message, transfer) => {\n    assert(mediaStreamTrackProcessorWorker);\n    if (transfer) {\n        mediaStreamTrackProcessorWorker.postMessage(message, transfer);\n    }\n    else {\n        mediaStreamTrackProcessorWorker.postMessage(message);\n    }\n};\n/**\n * Base class for subtitle sources - sources for subtitle tracks.\n * @group Media sources\n * @public\n */\nexport class SubtitleSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!SUBTITLE_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid subtitle codec '${codec}'. Must be one of: ${SUBTITLE_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * This source can be used to add subtitles from a subtitle text file.\n * @group Media sources\n * @public\n */\nexport class TextSubtitleSource extends SubtitleSource {\n    /** Creates a new {@link TextSubtitleSource} where added text chunks are in the specified `codec`. */\n    constructor(codec) {\n        super(codec);\n        /** @internal */\n        this._error = null;\n        this._parser = new SubtitleParser({\n            codec,\n            output: (cue, metadata) => {\n                void this._connectedTrack?.output._muxer.addSubtitleCue(this._connectedTrack, cue, metadata)\n                    .catch((error) => {\n                    this._error ??= error;\n                });\n            },\n        });\n    }\n    /**\n     * Parses the subtitle text according to the specified codec and adds it to the output track. You don't have to\n     * add the entire subtitle file at once here; you can provide it in chunks.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(text) {\n        if (typeof text !== 'string') {\n            throw new TypeError('text must be a string.');\n        }\n        this._checkForError();\n        this._ensureValidAdd();\n        this._parser.parse(text);\n        return this._connectedTrack.output._muxer.mutex.currentPromise;\n    }\n    /** @internal */\n    _checkForError() {\n        if (this._error) {\n            throw this._error;\n        }\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (!forceClose) {\n            this._checkForError();\n        }\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AsyncMutex, isIso639Dash2LanguageCode } from './misc.js';\nimport { validateMetadataTags, validateTrackDisposition } from './metadata.js';\nimport { OutputFormat } from './output-format.js';\nimport { AudioSource, SubtitleSource, VideoSource } from './media-source.js';\nimport { Target } from './target.js';\n/**\n * List of all track types.\n * @group Miscellaneous\n * @public\n */\nexport const ALL_TRACK_TYPES = ['video', 'audio', 'subtitle'];\nconst validateBaseTrackMetadata = (metadata) => {\n    if (!metadata || typeof metadata !== 'object') {\n        throw new TypeError('metadata must be an object.');\n    }\n    if (metadata.languageCode !== undefined && !isIso639Dash2LanguageCode(metadata.languageCode)) {\n        throw new TypeError('metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.');\n    }\n    if (metadata.name !== undefined && typeof metadata.name !== 'string') {\n        throw new TypeError('metadata.name, when provided, must be a string.');\n    }\n    if (metadata.disposition !== undefined) {\n        validateTrackDisposition(metadata.disposition);\n    }\n    if (metadata.maximumPacketCount !== undefined\n        && (!Number.isInteger(metadata.maximumPacketCount) || metadata.maximumPacketCount < 0)) {\n        throw new TypeError('metadata.maximumPacketCount, when provided, must be a non-negative integer.');\n    }\n};\n/**\n * Main class orchestrating the creation of a new media file.\n * @group Output files\n * @public\n */\nexport class Output {\n    /**\n     * Creates a new instance of {@link Output} which can then be used to create a new media file according to the\n     * specified {@link OutputOptions}.\n     */\n    constructor(options) {\n        /** The current state of the output. */\n        this.state = 'pending';\n        /** @internal */\n        this._tracks = [];\n        /** @internal */\n        this._startPromise = null;\n        /** @internal */\n        this._cancelPromise = null;\n        /** @internal */\n        this._finalizePromise = null;\n        /** @internal */\n        this._mutex = new AsyncMutex();\n        /** @internal */\n        this._metadataTags = {};\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!(options.format instanceof OutputFormat)) {\n            throw new TypeError('options.format must be an OutputFormat.');\n        }\n        if (!(options.target instanceof Target)) {\n            throw new TypeError('options.target must be a Target.');\n        }\n        if (options.target._output) {\n            throw new Error('Target is already used for another output.');\n        }\n        options.target._output = this;\n        this.format = options.format;\n        this.target = options.target;\n        this._writer = options.target._createWriter();\n        this._muxer = options.format._createMuxer(this);\n    }\n    /** Adds a video track to the output with the given source. Can only be called before the output is started. */\n    addVideoTrack(source, metadata = {}) {\n        if (!(source instanceof VideoSource)) {\n            throw new TypeError('source must be a VideoSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        if (metadata.rotation !== undefined && ![0, 90, 180, 270].includes(metadata.rotation)) {\n            throw new TypeError(`Invalid video rotation: ${metadata.rotation}. Has to be 0, 90, 180 or 270.`);\n        }\n        if (!this.format.supportsVideoRotationMetadata && metadata.rotation) {\n            throw new Error(`${this.format._name} does not support video rotation metadata.`);\n        }\n        if (metadata.frameRate !== undefined\n            && (!Number.isFinite(metadata.frameRate) || metadata.frameRate <= 0)) {\n            throw new TypeError(`Invalid video frame rate: ${metadata.frameRate}. Must be a positive number.`);\n        }\n        this._addTrack('video', source, metadata);\n    }\n    /** Adds an audio track to the output with the given source. Can only be called before the output is started. */\n    addAudioTrack(source, metadata = {}) {\n        if (!(source instanceof AudioSource)) {\n            throw new TypeError('source must be an AudioSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('audio', source, metadata);\n    }\n    /** Adds a subtitle track to the output with the given source. Can only be called before the output is started. */\n    addSubtitleTrack(source, metadata = {}) {\n        if (!(source instanceof SubtitleSource)) {\n            throw new TypeError('source must be a SubtitleSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('subtitle', source, metadata);\n    }\n    /**\n     * Sets descriptive metadata tags about the media file, such as title, author, date, or cover art. When called\n     * multiple times, only the metadata from the last call will be used.\n     *\n     * Can only be called before the output is started.\n     */\n    setMetadataTags(tags) {\n        validateMetadataTags(tags);\n        if (this.state !== 'pending') {\n            throw new Error('Cannot set metadata tags after output has been started or canceled.');\n        }\n        this._metadataTags = tags;\n    }\n    /** @internal */\n    _addTrack(type, source, metadata) {\n        if (this.state !== 'pending') {\n            throw new Error('Cannot add track after output has been started or canceled.');\n        }\n        if (source._connectedTrack) {\n            throw new Error('Source is already used for a track.');\n        }\n        // Verify maximum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === type ? 1 : 0), 0);\n        const maxCount = supportedTrackCounts[type].max;\n        if (presentTracksOfThisType === maxCount) {\n            throw new Error(maxCount === 0\n                ? `${this.format._name} does not support ${type} tracks.`\n                : (`${this.format._name} does not support more than ${maxCount} ${type} track`\n                    + `${maxCount === 1 ? '' : 's'}.`));\n        }\n        const maxTotalCount = supportedTrackCounts.total.max;\n        if (this._tracks.length === maxTotalCount) {\n            throw new Error(`${this.format._name} does not support more than ${maxTotalCount} tracks`\n                + `${maxTotalCount === 1 ? '' : 's'} in total.`);\n        }\n        const track = {\n            id: this._tracks.length + 1,\n            output: this,\n            type,\n            source: source,\n            metadata,\n        };\n        if (track.type === 'video') {\n            const supportedVideoCodecs = this.format.getSupportedVideoCodecs();\n            if (supportedVideoCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support video tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedVideoCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` video codecs are: ${supportedVideoCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'audio') {\n            const supportedAudioCodecs = this.format.getSupportedAudioCodecs();\n            if (supportedAudioCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support audio tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedAudioCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` audio codecs are: ${supportedAudioCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'subtitle') {\n            const supportedSubtitleCodecs = this.format.getSupportedSubtitleCodecs();\n            if (supportedSubtitleCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support subtitle tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedSubtitleCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` subtitle codecs are: ${supportedSubtitleCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        this._tracks.push(track);\n        source._connectedTrack = track;\n    }\n    /**\n     * Starts the creation of the output file. This method should be called after all tracks have been added. Only after\n     * the output has started can media samples be added to the tracks.\n     *\n     * @returns A promise that resolves when the output has successfully started and is ready to receive media samples.\n     */\n    async start() {\n        // Verify minimum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        for (const trackType of ALL_TRACK_TYPES) {\n            const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === trackType ? 1 : 0), 0);\n            const minCount = supportedTrackCounts[trackType].min;\n            if (presentTracksOfThisType < minCount) {\n                throw new Error(minCount === supportedTrackCounts[trackType].max\n                    ? (`${this.format._name} requires exactly ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`)\n                    : (`${this.format._name} requires at least ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`));\n            }\n        }\n        const totalMinCount = supportedTrackCounts.total.min;\n        if (this._tracks.length < totalMinCount) {\n            throw new Error(totalMinCount === supportedTrackCounts.total.max\n                ? (`${this.format._name} requires exactly ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`)\n                : (`${this.format._name} requires at least ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`));\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._startPromise) {\n            console.warn('Output has already been started.');\n            return this._startPromise;\n        }\n        return this._startPromise = (async () => {\n            this.state = 'started';\n            this._writer.start();\n            const release = await this._mutex.acquire();\n            await this._muxer.start();\n            const promises = this._tracks.map(track => track.source._start());\n            await Promise.all(promises);\n            release();\n        })();\n    }\n    /**\n     * Resolves with the full MIME type of the output file, including track codecs.\n     *\n     * The returned promise will resolve only once the precise codec strings of all tracks are known.\n     */\n    getMimeType() {\n        return this._muxer.getMimeType();\n    }\n    /**\n     * Cancels the creation of the output file, releasing internal resources like encoders and preventing further\n     * samples from being added.\n     *\n     * @returns A promise that resolves once all internal resources have been released.\n     */\n    async cancel() {\n        if (this._cancelPromise) {\n            console.warn('Output has already been canceled.');\n            return this._cancelPromise;\n        }\n        else if (this.state === 'finalizing' || this.state === 'finalized') {\n            console.warn('Output has already been finalized.');\n            return;\n        }\n        return this._cancelPromise = (async () => {\n            this.state = 'canceled';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(true)); // Force close\n            await Promise.all(promises);\n            await this._writer.close();\n            release();\n        })();\n    }\n    /**\n     * Finalizes the output file. This method must be called after all media samples across all tracks have been added.\n     * Once the Promise returned by this method completes, the output file is ready.\n     */\n    async finalize() {\n        if (this.state === 'pending') {\n            throw new Error('Cannot finalize before starting.');\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Cannot finalize after canceling.');\n        }\n        if (this._finalizePromise) {\n            console.warn('Output has already been finalized.');\n            return this._finalizePromise;\n        }\n        return this._finalizePromise = (async () => {\n            this.state = 'finalizing';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(false));\n            await Promise.all(promises);\n            await this._muxer.finalize();\n            await this._writer.flush();\n            await this._writer.finalize();\n            this.state = 'finalized';\n            release();\n        })();\n    }\n}\n","import { Pair } from 'bitecs';\r\nimport { Output, Mp4OutputFormat, BufferTarget, CanvasSource } from 'mediabunny';\r\nimport { Sequence, SequenceState, Tween, TweenState, ChildOf, type State } from '@multiplekex/shallot';\r\nimport { StepTransition, type RecordSequenceConfig } from '@blog-components/sequence';\r\n\r\nfunction setCanvasSize(canvas: HTMLCanvasElement, width: number, height: number): void {\r\n  const dpr = window.devicePixelRatio || 1;\r\n  canvas.style.width = `${width / dpr}px`;\r\n  canvas.style.height = `${height / dpr}px`;\r\n  canvas.width = width;\r\n  canvas.height = height;\r\n}\r\n\r\nfunction findSequenceForTransition(state: State, from: number, to: number): number | null {\r\n  for (const eid of state.query([Sequence, StepTransition])) {\r\n    if (StepTransition.from[eid] === from && StepTransition.to[eid] === to) {\r\n      return eid;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\nexport function setupCanvasRecording(canvas: HTMLCanvasElement, state: State): void {\r\n  canvas.__recordSequence__ = async (\r\n    config: RecordSequenceConfig,\r\n    onProgress?: (frame: number, total: number) => void\r\n  ): Promise<Blob | null> => {\r\n    const seqEid = findSequenceForTransition(state, config.fromStep, config.toStep);\r\n    if (seqEid === null) return null;\r\n\r\n    const origWidth = canvas.width;\r\n    const origHeight = canvas.height;\r\n    const origStyle = canvas.style.cssText;\r\n\r\n    setCanvasSize(canvas, config.width, config.height);\r\n    await new Promise((r) => requestAnimationFrame(r));\r\n\r\n    Sequence.state[seqEid] = SequenceState.IDLE;\r\n    Sequence.elapsed[seqEid] = 0;\r\n    for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\r\n      Tween.state[childEid] = TweenState.IDLE;\r\n      Tween.elapsed[childEid] = 0;\r\n    }\r\n    Sequence.state[seqEid] = SequenceState.PLAYING;\r\n\r\n    let maxDuration = 0;\r\n    for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\r\n      maxDuration = Math.max(maxDuration, Tween.duration[childEid]);\r\n    }\r\n    const duration = maxDuration + 0.1;\r\n    const totalFrames = Math.ceil(duration * config.fps);\r\n\r\n    const output = new Output({\r\n      format: new Mp4OutputFormat({ fastStart: 'in-memory' }),\r\n      target: new BufferTarget(),\r\n    });\r\n\r\n    const videoSource = new CanvasSource(canvas, {\r\n      codec: 'avc',\r\n      bitrate: config.bitrate,\r\n    });\r\n\r\n    output.addVideoTrack(videoSource);\r\n    await output.start();\r\n\r\n    const stepTime = 1 / config.fps;\r\n\r\n    for (let i = 0; i < totalFrames; i++) {\r\n      setCanvasSize(canvas, config.width, config.height);\r\n      state.step(stepTime);\r\n\r\n      const timestamp = i / config.fps;\r\n      await videoSource.add(timestamp, stepTime);\r\n\r\n      if (i % 30 === 0) {\r\n        onProgress?.(i, totalFrames);\r\n        await new Promise((r) => setTimeout(r, 0));\r\n      }\r\n    }\r\n\r\n    await output.finalize();\r\n\r\n    canvas.width = origWidth;\r\n    canvas.height = origHeight;\r\n    canvas.style.cssText = origStyle;\r\n\r\n    return new Blob([output.target.buffer!], { type: 'video/mp4' });\r\n  };\r\n}\r\n","// Speculative Decoding Color Scheme\r\n// Scientific visualization palette with warm/cool semantic distinction\r\n\r\n// === MODEL PAIR (Complementary: Navy vs Amber) ===\r\n// Target: Cool navy = slow, authoritative, \"ground truth\"\r\n// Draft: Warm amber = fast, speculative, \"educated guess\"\r\nexport const TARGET_MODEL = 0x2a4a6d; // Deep navy (H210)\r\nexport const DRAFT_MODEL = 0xb8864a;  // Warm amber (H35) - distinct hue\r\n\r\n// === DATA PAIR (Teal/Green family, H155-180) ===\r\n// Input: teal, Output: green-teal (shows transformation)\r\nexport const INPUT = 0x6b9ea0;        // Muted teal (H182)\r\nexport const INPUT_TEXT = 0x4a7072;   // Darker teal for readability\r\n\r\nexport const OUTPUT = 0x5aaa8f;       // Green-teal (H155) - \"generated\"\r\nexport const OUTPUT_TEXT = 0x3d7560;  // Darker green for readability\r\n\r\n// === DISTRIBUTION ANALYSIS ===\r\nexport const MIN_REGION = 0x14b8a6;  // Teal - common ground between draft/target\r\n\r\n// === VALIDATION ===\r\nexport const VALID = 0x3fb87a;       // Soft sage-green - correct prediction\r\nexport const INVALID = 0xdc5858;     // Soft coral - incorrect prediction\r\n\r\n// === SUPPORTING ===\r\nexport const LINE = 0x6b7280;\r\nexport const LINE_ACTIVE = 0x4b5563;\r\nexport const SURFACE = 0xffffff;\r\nexport const SURFACE_ALT = 0xf8f9fa;\r\nexport const TEXT = 0x212529;\r\n\r\n// Hex string versions for CSS\r\nexport const hex = {\r\n  targetModel: '#2a4a6d',\r\n  draftModel: '#b8864a',\r\n  input: '#6b9ea0',\r\n  inputText: '#4a7072',\r\n  output: '#5aaa8f',\r\n  outputText: '#3d7560',\r\n  minRegion: '#14b8a6',\r\n  line: '#6b7280',\r\n  lineActive: '#4b5563',\r\n  surface: '#ffffff',\r\n  surfaceAlt: '#f8f9fa',\r\n  text: '#212529',\r\n} as const;\r\n","import { setTraits, ChildOf, Pair, Transform, type Plugin, type State, type System } from '@multiplekex/shallot';\r\nimport { Line, Text } from '@multiplekex/shallot/extras';\r\nimport { LINE } from './colors';\r\n\r\nexport const Border = {\r\n  padding: [] as number[],\r\n  color: [] as number[],\r\n  thickness: [] as number[],\r\n  transition: [] as number[],\r\n};\r\n\r\nsetTraits(Border, {\r\n  defaults: () => ({\r\n    padding: 0.15,\r\n    color: LINE,\r\n    thickness: 2,\r\n    transition: 1,\r\n  }),\r\n});\r\n\r\nexport const BorderLine = {};\r\n\r\nconst CHAR_WIDTH_RATIO = 0.55;\r\n\r\nconst BorderSystem: System = {\r\n  group: 'simulation',\r\n  update(state: State) {\r\n    for (const eid of state.query([Border, Text, Transform])) {\r\n      const content = Text.content[eid] ?? '';\r\n      const fontSize = Text.fontSize[eid] || 1;\r\n      const padding = Border.padding[eid];\r\n      const color = Border.color[eid];\r\n      const thickness = Border.thickness[eid];\r\n      const t = Math.min(1, Border.transition[eid]);\r\n\r\n      const textWidth = content.length * fontSize * CHAR_WIDTH_RATIO;\r\n      const textHeight = fontSize;\r\n\r\n      const w = textWidth / 2 + padding;\r\n      const h = textHeight / 2 + padding;\r\n\r\n      const existingLines = [...state.query([Pair(ChildOf.relation, eid), BorderLine, Line])];\r\n\r\n      if (existingLines.length === 0) {\r\n        for (let i = 0; i < 4; i++) {\r\n          const lineEid = state.addEntity();\r\n          state.addComponent(lineEid, Transform);\r\n          state.addComponent(lineEid, Line);\r\n          state.addComponent(lineEid, BorderLine);\r\n          state.addComponent(lineEid, Pair(ChildOf.relation, eid));\r\n\r\n          Line.color[lineEid] = color;\r\n          Line.thickness[lineEid] = thickness;\r\n          Line.visible[lineEid] = 1;\r\n          Line.opacity[lineEid] = 1;\r\n        }\r\n      }\r\n\r\n      const lines = [...state.query([Pair(ChildOf.relation, eid), BorderLine, Line])];\r\n\r\n      // Bottom line (local coords relative to parent)\r\n      Transform.posX[lines[0]] = -w;\r\n      Transform.posY[lines[0]] = -h;\r\n      Transform.posZ[lines[0]] = 0;\r\n      Line.offsetX[lines[0]] = w * 2 * t;\r\n      Line.offsetY[lines[0]] = 0;\r\n      Line.offsetZ[lines[0]] = 0;\r\n\r\n      // Top line\r\n      Transform.posX[lines[1]] = -w;\r\n      Transform.posY[lines[1]] = h;\r\n      Transform.posZ[lines[1]] = 0;\r\n      Line.offsetX[lines[1]] = w * 2 * t;\r\n      Line.offsetY[lines[1]] = 0;\r\n      Line.offsetZ[lines[1]] = 0;\r\n\r\n      // Left line\r\n      Transform.posX[lines[2]] = -w;\r\n      Transform.posY[lines[2]] = -h;\r\n      Transform.posZ[lines[2]] = 0;\r\n      Line.offsetX[lines[2]] = 0;\r\n      Line.offsetY[lines[2]] = h * 2 * t;\r\n      Line.offsetZ[lines[2]] = 0;\r\n\r\n      // Right line\r\n      Transform.posX[lines[3]] = w;\r\n      Transform.posY[lines[3]] = -h;\r\n      Transform.posZ[lines[3]] = 0;\r\n      Line.offsetX[lines[3]] = 0;\r\n      Line.offsetY[lines[3]] = h * 2 * t;\r\n      Line.offsetZ[lines[3]] = 0;\r\n    }\r\n  },\r\n};\r\n\r\nexport const BorderPlugin: Plugin = {\r\n  components: { Border, BorderLine },\r\n  systems: [BorderSystem],\r\n};\r\n","import { setTraits, ChildOf, Pair, Transform, Mesh, MeshShape, defineRelation, type Plugin, type State, type System } from '@multiplekex/shallot';\r\nimport { TARGET_MODEL, DRAFT_MODEL, VALID, INVALID } from './colors';\r\n\r\nexport const ProbabilityDistribution = {\r\n  barCount: [] as number[],\r\n  transition: [] as number[],\r\n  blend: [] as number[],\r\n  smoothness: [] as number[],\r\n  comparisonTransition: [] as number[],\r\n  comparisonZ: [] as number[],\r\n  acceptanceTransition: [] as number[],\r\n  acceptanceYOffset: [] as number[],\r\n  acceptanceSize: [] as number[],\r\n  residualTransition: [] as number[],\r\n  minTransition: [] as number[],\r\n  excessDraftTransition: [] as number[],\r\n  excessTargetTransition: [] as number[],\r\n  transferProgress: [] as number[],\r\n};\r\n\r\nsetTraits(ProbabilityDistribution, {\r\n  defaults: () => ({\r\n    barCount: 5,\r\n    transition: 1,\r\n    blend: 0,\r\n    smoothness: 0.15,\r\n    comparisonTransition: 0,\r\n    comparisonZ: -0.6,\r\n    acceptanceTransition: 0,\r\n    acceptanceYOffset: 0.5,\r\n    acceptanceSize: 0.35,\r\n    residualTransition: 0,\r\n    minTransition: 0,\r\n    excessDraftTransition: 0,\r\n    excessTargetTransition: 0,\r\n    transferProgress: 0,\r\n  }),\r\n});\r\n\r\nexport const DistributionBar = {\r\n  index: [] as number[],\r\n  probability: [] as number[],\r\n  goalProbability: [] as number[],\r\n};\r\n\r\nsetTraits(DistributionBar, {\r\n  defaults: () => ({\r\n    index: 0,\r\n    probability: 0.2,\r\n    goalProbability: 0.2,\r\n  }),\r\n});\r\n\r\nconst DistributionBarOwner = defineRelation('distribution-bar-owner', { exclusive: true });\r\nconst ComparisonBarOwner = defineRelation('comparison-bar-owner', { exclusive: true });\r\nconst AcceptanceMarkerOwner = defineRelation('acceptance-marker-owner', { exclusive: true });\r\nconst ResidualBarOwner = defineRelation('residual-bar-owner', { exclusive: true });\r\nconst MinBarOwner = defineRelation('min-bar-owner', { exclusive: true });\r\nconst ExcessDraftBarOwner = defineRelation('excess-draft-bar-owner', { exclusive: true });\r\nconst ExcessTargetBarOwner = defineRelation('excess-target-bar-owner', { exclusive: true });\r\n\r\nexport const AcceptanceMarker = {\r\n  index: [] as number[],\r\n};\r\n\r\nsetTraits(AcceptanceMarker, {\r\n  defaults: () => ({\r\n    index: 0,\r\n  }),\r\n});\r\n\r\nexport const BarHighlight = {\r\n  distribution: [] as number[],\r\n  barIndex: [] as number[],\r\n  yOffset: [] as number[],\r\n};\r\n\r\nsetTraits(BarHighlight, {\r\n  defaults: () => ({\r\n    distribution: 0,\r\n    barIndex: 0,\r\n    yOffset: 0.7,\r\n  }),\r\n});\r\n\r\nconst targetDistributions = new Map<number, number[]>();\r\nconst draftDistributions = new Map<number, number[]>();\r\n\r\nexport function setDistributionProbabilities(distEid: number, targetProbs: number[], draftProbs?: number[]): void {\r\n  targetDistributions.set(distEid, targetProbs);\r\n  if (draftProbs) {\r\n    draftDistributions.set(distEid, draftProbs);\r\n  }\r\n}\r\n\r\nfunction lerpColor(c1: number, c2: number, t: number): number {\r\n  const r1 = (c1 >> 16) & 0xff;\r\n  const g1 = (c1 >> 8) & 0xff;\r\n  const b1 = c1 & 0xff;\r\n  const r2 = (c2 >> 16) & 0xff;\r\n  const g2 = (c2 >> 8) & 0xff;\r\n  const b2 = c2 & 0xff;\r\n  const r = Math.round(r1 + (r2 - r1) * t);\r\n  const g = Math.round(g1 + (g2 - g1) * t);\r\n  const b = Math.round(b1 + (b2 - b1) * t);\r\n  return (r << 16) | (g << 8) | b;\r\n}\r\n\r\nconst RED = 0xdc5858;\r\nconst YELLOW = 0xe5a040;\r\nconst GREEN = 0x3fb87a;\r\n\r\nfunction acceptanceColor(acceptance: number): number {\r\n  // Nonlinear: yellow at 90%, making lower acceptance more obvious\r\n  if (acceptance < 0.9) {\r\n    return lerpColor(RED, YELLOW, acceptance / 0.9);\r\n  } else {\r\n    return lerpColor(YELLOW, GREEN, (acceptance - 0.9) / 0.1);\r\n  }\r\n}\r\n\r\nconst CHART_WIDTH = 8;\r\nconst MAX_HEIGHT = 5.5;\r\n\r\nfunction smoothLerp(smoothness: number, dt: number): number {\r\n  const s = Math.max(0, Math.min(1, smoothness));\r\n  return 1 - Math.pow(1 - s, dt * 60);\r\n}\r\n\r\nconst ProbabilityDistributionSystem: System = {\r\n  group: 'simulation',\r\n  update(state: State) {\r\n    const dt = state.time.deltaTime;\r\n\r\n    for (const distEid of state.query([ProbabilityDistribution, Transform])) {\r\n      const barCount = ProbabilityDistribution.barCount[distEid];\r\n      const transition = ProbabilityDistribution.transition[distEid];\r\n      const blend = ProbabilityDistribution.blend[distEid];\r\n      const smoothness = ProbabilityDistribution.smoothness[distEid];\r\n      const comparisonTransition = ProbabilityDistribution.comparisonTransition[distEid];\r\n      const comparisonZ = ProbabilityDistribution.comparisonZ[distEid];\r\n\r\n      const existingBars = [...state.query([Pair(DistributionBarOwner.relation, distEid), DistributionBar, Mesh, Transform])];\r\n\r\n      while (existingBars.length < barCount) {\r\n        const barEid = state.addEntity();\r\n        state.addComponent(barEid, Transform);\r\n        state.addComponent(barEid, Mesh);\r\n        state.addComponent(barEid, DistributionBar);\r\n        state.addComponent(barEid, Pair(ChildOf.relation, distEid));\r\n        state.addComponent(barEid, Pair(DistributionBarOwner.relation, distEid));\r\n\r\n        Mesh.shape[barEid] = MeshShape.Box;\r\n        DistributionBar.index[barEid] = existingBars.length;\r\n        existingBars.push(barEid);\r\n      }\r\n\r\n      const barSpacing = CHART_WIDTH / barCount;\r\n      const barWidth = barSpacing * 0.7;\r\n      const startX = -CHART_WIDTH / 2 + barSpacing / 2;\r\n\r\n      const targetProbs = targetDistributions.get(distEid);\r\n      const draftProbs = draftDistributions.get(distEid);\r\n      const t = smoothLerp(smoothness, dt);\r\n      const color = lerpColor(TARGET_MODEL, DRAFT_MODEL, blend);\r\n\r\n      for (let i = 0; i < barCount; i++) {\r\n        const barEid = existingBars[i];\r\n\r\n        const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\r\n        const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\r\n        const goalP = targetP + (draftP - targetP) * blend;\r\n\r\n        DistributionBar.goalProbability[barEid] = goalP;\r\n        DistributionBar.probability[barEid] += (goalP - DistributionBar.probability[barEid]) * t;\r\n\r\n        const probability = DistributionBar.probability[barEid];\r\n        const height = Math.max(0.05, probability * MAX_HEIGHT);\r\n\r\n        Transform.posX[barEid] = startX + i * barSpacing;\r\n        Transform.posY[barEid] = (height / 2) * transition;\r\n        Transform.posZ[barEid] = 0;\r\n\r\n        Mesh.sizeX[barEid] = barWidth * transition;\r\n        Mesh.sizeY[barEid] = height * transition;\r\n        Mesh.sizeZ[barEid] = barWidth * transition;\r\n\r\n        Mesh.color[barEid] = color;\r\n      }\r\n\r\n      const existingComparisonBars = [...state.query([Pair(ComparisonBarOwner.relation, distEid), Mesh, Transform])];\r\n\r\n      if (comparisonTransition > 0) {\r\n        while (existingComparisonBars.length < barCount) {\r\n          const barEid = state.addEntity();\r\n          state.addComponent(barEid, Transform);\r\n          state.addComponent(barEid, Mesh);\r\n          state.addComponent(barEid, Pair(ChildOf.relation, distEid));\r\n          state.addComponent(barEid, Pair(ComparisonBarOwner.relation, distEid));\r\n          Mesh.shape[barEid] = MeshShape.Box;\r\n          existingComparisonBars.push(barEid);\r\n        }\r\n\r\n        for (let i = 0; i < barCount; i++) {\r\n          const compBarEid = existingComparisonBars[i];\r\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\r\n          const height = Math.max(0.05, targetP * MAX_HEIGHT);\r\n\r\n          Transform.posX[compBarEid] = startX + i * barSpacing;\r\n          Transform.posY[compBarEid] = (height / 2) * comparisonTransition;\r\n          Transform.posZ[compBarEid] = comparisonZ;\r\n\r\n          Mesh.sizeX[compBarEid] = barWidth * comparisonTransition;\r\n          Mesh.sizeY[compBarEid] = height * comparisonTransition;\r\n          Mesh.sizeZ[compBarEid] = barWidth * comparisonTransition;\r\n\r\n          Mesh.color[compBarEid] = TARGET_MODEL;\r\n        }\r\n      } else {\r\n        for (const compBarEid of existingComparisonBars) {\r\n          Mesh.sizeX[compBarEid] = 0;\r\n          Mesh.sizeY[compBarEid] = 0;\r\n          Mesh.sizeZ[compBarEid] = 0;\r\n        }\r\n      }\r\n\r\n      const acceptanceTransition = ProbabilityDistribution.acceptanceTransition[distEid];\r\n      const acceptanceYOffset = ProbabilityDistribution.acceptanceYOffset[distEid];\r\n      const acceptanceSize = ProbabilityDistribution.acceptanceSize[distEid];\r\n\r\n      const existingMarkers = [...state.query([Pair(AcceptanceMarkerOwner.relation, distEid), AcceptanceMarker, Mesh, Transform])];\r\n\r\n      if (acceptanceTransition > 0) {\r\n        while (existingMarkers.length < barCount) {\r\n          const markerEid = state.addEntity();\r\n          state.addComponent(markerEid, Transform);\r\n          state.addComponent(markerEid, Mesh);\r\n          state.addComponent(markerEid, AcceptanceMarker);\r\n          state.addComponent(markerEid, Pair(ChildOf.relation, distEid));\r\n          state.addComponent(markerEid, Pair(AcceptanceMarkerOwner.relation, distEid));\r\n          Mesh.shape[markerEid] = MeshShape.Sphere;\r\n          AcceptanceMarker.index[markerEid] = existingMarkers.length;\r\n          existingMarkers.push(markerEid);\r\n        }\r\n\r\n        for (let i = 0; i < barCount; i++) {\r\n          const markerEid = existingMarkers[i];\r\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\r\n          const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\r\n          const maxHeight = Math.max(targetP, draftP) * MAX_HEIGHT;\r\n          const acceptance = draftP > 0 ? Math.min(1, targetP / draftP) : 1;\r\n\r\n          Transform.posX[markerEid] = startX + i * barSpacing;\r\n          Transform.posY[markerEid] = maxHeight + acceptanceYOffset;\r\n          Transform.posZ[markerEid] = comparisonZ / 2;\r\n\r\n          const scaledSize = acceptanceSize * acceptanceTransition;\r\n          Mesh.sizeX[markerEid] = scaledSize;\r\n          Mesh.sizeY[markerEid] = scaledSize;\r\n          Mesh.sizeZ[markerEid] = scaledSize;\r\n\r\n          Mesh.color[markerEid] = acceptanceColor(acceptance);\r\n        }\r\n      } else {\r\n        for (const markerEid of existingMarkers) {\r\n          Mesh.sizeX[markerEid] = 0;\r\n          Mesh.sizeY[markerEid] = 0;\r\n          Mesh.sizeZ[markerEid] = 0;\r\n        }\r\n      }\r\n\r\n      const residualTransition = ProbabilityDistribution.residualTransition[distEid];\r\n      const existingResidualBars = [...state.query([Pair(ResidualBarOwner.relation, distEid), Mesh, Transform])];\r\n\r\n      if (residualTransition > 0) {\r\n        while (existingResidualBars.length < barCount) {\r\n          const barEid = state.addEntity();\r\n          state.addComponent(barEid, Transform);\r\n          state.addComponent(barEid, Mesh);\r\n          state.addComponent(barEid, Pair(ChildOf.relation, distEid));\r\n          state.addComponent(barEid, Pair(ResidualBarOwner.relation, distEid));\r\n          Mesh.shape[barEid] = MeshShape.Box;\r\n          existingResidualBars.push(barEid);\r\n        }\r\n\r\n        for (let i = 0; i < barCount; i++) {\r\n          const barEid = existingResidualBars[i];\r\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\r\n          const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\r\n          const residualP = Math.max(0, targetP - draftP);\r\n\r\n          if (residualP <= 0.001) {\r\n            Mesh.sizeX[barEid] = 0;\r\n            Mesh.sizeY[barEid] = 0;\r\n            Mesh.sizeZ[barEid] = 0;\r\n            continue;\r\n          }\r\n\r\n          const height = residualP * MAX_HEIGHT * residualTransition;\r\n\r\n          Transform.posX[barEid] = startX + i * barSpacing;\r\n          Transform.posY[barEid] = height / 2;\r\n          Transform.posZ[barEid] = 0;\r\n\r\n          Mesh.sizeX[barEid] = barWidth * residualTransition;\r\n          Mesh.sizeY[barEid] = height;\r\n          Mesh.sizeZ[barEid] = barWidth * residualTransition;\r\n\r\n          Mesh.color[barEid] = 0x9333ea;\r\n        }\r\n      } else {\r\n        for (const barEid of existingResidualBars) {\r\n          Mesh.sizeX[barEid] = 0;\r\n          Mesh.sizeY[barEid] = 0;\r\n          Mesh.sizeZ[barEid] = 0;\r\n        }\r\n      }\r\n\r\n      // Min bars (green/accepted) - from y=0 to min(draft, target)\r\n      const minTransition = ProbabilityDistribution.minTransition[distEid];\r\n      const existingMinBars = [...state.query([Pair(MinBarOwner.relation, distEid), Mesh, Transform])];\r\n\r\n      if (minTransition > 0) {\r\n        while (existingMinBars.length < barCount) {\r\n          const barEid = state.addEntity();\r\n          state.addComponent(barEid, Transform);\r\n          state.addComponent(barEid, Mesh);\r\n          state.addComponent(barEid, Pair(ChildOf.relation, distEid));\r\n          state.addComponent(barEid, Pair(MinBarOwner.relation, distEid));\r\n          Mesh.shape[barEid] = MeshShape.Box;\r\n          existingMinBars.push(barEid);\r\n        }\r\n\r\n        for (let i = 0; i < barCount; i++) {\r\n          const barEid = existingMinBars[i];\r\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\r\n          const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\r\n          const minP = Math.min(targetP, draftP);\r\n\r\n          const height = Math.max(0.05, minP * MAX_HEIGHT * minTransition);\r\n\r\n          Transform.posX[barEid] = startX + i * barSpacing;\r\n          Transform.posY[barEid] = height / 2;\r\n          Transform.posZ[barEid] = 0;\r\n\r\n          Mesh.sizeX[barEid] = barWidth * minTransition;\r\n          Mesh.sizeY[barEid] = height;\r\n          Mesh.sizeZ[barEid] = barWidth * minTransition;\r\n\r\n          Mesh.color[barEid] = VALID;\r\n        }\r\n      } else {\r\n        for (const barEid of existingMinBars) {\r\n          Mesh.sizeX[barEid] = 0;\r\n          Mesh.sizeY[barEid] = 0;\r\n          Mesh.sizeZ[barEid] = 0;\r\n        }\r\n      }\r\n\r\n      // Excess draft bars (red/rejected) - from y=min to y=draft when draft > target\r\n      const excessDraftTransition = ProbabilityDistribution.excessDraftTransition[distEid];\r\n      const transferProgress = ProbabilityDistribution.transferProgress[distEid];\r\n      const existingExcessDraftBars = [...state.query([Pair(ExcessDraftBarOwner.relation, distEid), Mesh, Transform])];\r\n\r\n      if (excessDraftTransition > 0) {\r\n        while (existingExcessDraftBars.length < barCount) {\r\n          const barEid = state.addEntity();\r\n          state.addComponent(barEid, Transform);\r\n          state.addComponent(barEid, Mesh);\r\n          state.addComponent(barEid, Pair(ChildOf.relation, distEid));\r\n          state.addComponent(barEid, Pair(ExcessDraftBarOwner.relation, distEid));\r\n          Mesh.shape[barEid] = MeshShape.Box;\r\n          existingExcessDraftBars.push(barEid);\r\n        }\r\n\r\n        for (let i = 0; i < barCount; i++) {\r\n          const barEid = existingExcessDraftBars[i];\r\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\r\n          const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\r\n          const minP = Math.min(targetP, draftP);\r\n          const excessP = Math.max(0, draftP - targetP);\r\n\r\n          if (excessP <= 0.001) {\r\n            Mesh.sizeX[barEid] = 0;\r\n            Mesh.sizeY[barEid] = 0;\r\n            Mesh.sizeZ[barEid] = 0;\r\n            continue;\r\n          }\r\n\r\n          // Smooth fade out as transfer progresses - scale all dimensions\r\n          const fadeScale = 1 - transferProgress;\r\n          const height = excessP * MAX_HEIGHT * excessDraftTransition * fadeScale;\r\n          const baseHeight = minP * MAX_HEIGHT;\r\n          const widthScale = barWidth * excessDraftTransition * fadeScale;\r\n\r\n          Transform.posX[barEid] = startX + i * barSpacing;\r\n          Transform.posY[barEid] = baseHeight + height / 2;\r\n          Transform.posZ[barEid] = 0;\r\n\r\n          Mesh.sizeX[barEid] = widthScale;\r\n          Mesh.sizeY[barEid] = height;\r\n          Mesh.sizeZ[barEid] = widthScale;\r\n\r\n          Mesh.color[barEid] = INVALID;\r\n        }\r\n      } else {\r\n        for (const barEid of existingExcessDraftBars) {\r\n          Mesh.sizeX[barEid] = 0;\r\n          Mesh.sizeY[barEid] = 0;\r\n          Mesh.sizeZ[barEid] = 0;\r\n        }\r\n      }\r\n\r\n      // Excess target bars (purple) - from y=min to y=target when target > draft\r\n      const excessTargetTransition = ProbabilityDistribution.excessTargetTransition[distEid];\r\n      const existingExcessTargetBars = [...state.query([Pair(ExcessTargetBarOwner.relation, distEid), Mesh, Transform])];\r\n\r\n      if (excessTargetTransition > 0) {\r\n        while (existingExcessTargetBars.length < barCount) {\r\n          const barEid = state.addEntity();\r\n          state.addComponent(barEid, Transform);\r\n          state.addComponent(barEid, Mesh);\r\n          state.addComponent(barEid, Pair(ChildOf.relation, distEid));\r\n          state.addComponent(barEid, Pair(ExcessTargetBarOwner.relation, distEid));\r\n          Mesh.shape[barEid] = MeshShape.Box;\r\n          existingExcessTargetBars.push(barEid);\r\n        }\r\n\r\n        for (let i = 0; i < barCount; i++) {\r\n          const barEid = existingExcessTargetBars[i];\r\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\r\n          const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\r\n          const minP = Math.min(targetP, draftP);\r\n          const excessP = Math.max(0, targetP - draftP);\r\n\r\n          if (excessP <= 0.001) {\r\n            Mesh.sizeX[barEid] = 0;\r\n            Mesh.sizeY[barEid] = 0;\r\n            Mesh.sizeZ[barEid] = 0;\r\n            continue;\r\n          }\r\n\r\n          // Fade in as transfer progresses\r\n          const fadeScale = transferProgress;\r\n          const height = excessP * MAX_HEIGHT * excessTargetTransition * fadeScale;\r\n          const baseHeight = minP * MAX_HEIGHT;\r\n\r\n          Transform.posX[barEid] = startX + i * barSpacing;\r\n          Transform.posY[barEid] = baseHeight + height / 2;\r\n          Transform.posZ[barEid] = 0;\r\n\r\n          Mesh.sizeX[barEid] = barWidth * excessTargetTransition;\r\n          Mesh.sizeY[barEid] = height;\r\n          Mesh.sizeZ[barEid] = barWidth * excessTargetTransition;\r\n\r\n          Mesh.color[barEid] = 0x9333ea; // Purple\r\n        }\r\n      } else {\r\n        for (const barEid of existingExcessTargetBars) {\r\n          Mesh.sizeX[barEid] = 0;\r\n          Mesh.sizeY[barEid] = 0;\r\n          Mesh.sizeZ[barEid] = 0;\r\n        }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nconst BarHighlightSystem: System = {\r\n  group: 'simulation',\r\n  update(state: State) {\r\n    for (const highlightEid of state.query([BarHighlight, Transform])) {\r\n      const distEid = BarHighlight.distribution[highlightEid];\r\n      const barIndex = BarHighlight.barIndex[highlightEid];\r\n      const yOffset = BarHighlight.yOffset[highlightEid];\r\n\r\n      if (!state.hasComponent(distEid, ProbabilityDistribution)) continue;\r\n\r\n      const barCount = ProbabilityDistribution.barCount[distEid];\r\n\r\n      const bars = [...state.query([Pair(DistributionBarOwner.relation, distEid), DistributionBar])];\r\n      const barEid = bars.find(eid => DistributionBar.index[eid] === barIndex);\r\n      if (barEid === undefined) continue;\r\n\r\n      const probability = DistributionBar.probability[barEid];\r\n\r\n      const barSpacing = CHART_WIDTH / barCount;\r\n      const startX = -CHART_WIDTH / 2 + barSpacing / 2;\r\n      const barX = startX + barIndex * barSpacing;\r\n      const barHeight = probability * MAX_HEIGHT;\r\n\r\n      Transform.posX[highlightEid] = barX;\r\n      Transform.posY[highlightEid] = 0.5 + barHeight + yOffset;\r\n    }\r\n  },\r\n};\r\n\r\nexport const ProbabilityDistributionPlugin: Plugin = {\r\n  components: { ProbabilityDistribution, DistributionBar, BarHighlight, AcceptanceMarker },\r\n  systems: [ProbabilityDistributionSystem, BarHighlightSystem],\r\n};\r\n","import { MAX_ENTITIES, resource, type Plugin, type State, type System } from '@multiplekex/shallot';\r\nimport { setTraits, type FieldAccessor } from '@multiplekex/shallot';\r\nimport { Compute, ComputePlugin, createEntityIdBuffer } from '@multiplekex/shallot';\r\nimport {\r\n  Render,\r\n  RenderPlugin,\r\n  DEPTH_FORMAT,\r\n  registerDrawContributor,\r\n  type DrawContributor,\r\n  type DrawContext,\r\n} from '@multiplekex/shallot';\r\nimport { Transform } from '@multiplekex/shallot';\r\n\r\nexport const GradientLegendData = {\r\n  data: new Float32Array(MAX_ENTITIES * 4),\r\n};\r\n\r\ninterface GradientLegendProxy extends Array<number>, FieldAccessor {}\r\n\r\nfunction legendProxy(offset: number): GradientLegendProxy {\r\n  const data = GradientLegendData.data;\r\n\r\n  function getValue(eid: number): number {\r\n    return data[eid * 4 + offset];\r\n  }\r\n\r\n  function setValue(eid: number, value: number): void {\r\n    data[eid * 4 + offset] = value;\r\n  }\r\n\r\n  return new Proxy([] as unknown as GradientLegendProxy, {\r\n    get(_, prop) {\r\n      if (prop === 'get') return getValue;\r\n      if (prop === 'set') return setValue;\r\n      const eid = Number(prop);\r\n      if (Number.isNaN(eid)) return undefined;\r\n      return getValue(eid);\r\n    },\r\n    set(_, prop, value) {\r\n      const eid = Number(prop);\r\n      if (Number.isNaN(eid)) return false;\r\n      setValue(eid, value);\r\n      return true;\r\n    },\r\n  });\r\n}\r\n\r\nexport const GradientLegend: {\r\n  transition: GradientLegendProxy;\r\n  width: GradientLegendProxy;\r\n  height: GradientLegendProxy;\r\n} = {\r\n  transition: legendProxy(0),\r\n  width: legendProxy(1),\r\n  height: legendProxy(2),\r\n};\r\n\r\nsetTraits(GradientLegend, {\r\n  defaults: () => ({\r\n    transition: 0,\r\n    width: 0.5,\r\n    height: 5,\r\n  }),\r\n  accessors: {\r\n    transition: GradientLegend.transition,\r\n    width: GradientLegend.width,\r\n    height: GradientLegend.height,\r\n  },\r\n});\r\n\r\nexport interface GradientLegendConfig {\r\n  scene: GPUBuffer;\r\n  legends: GPUBuffer;\r\n  entityIds: GPUBuffer;\r\n  matrices: GPUBuffer;\r\n  getCount: () => number;\r\n}\r\n\r\nexport const gradientLegendShader = /* wgsl */ `\r\nstruct VertexOutput {\r\n  @builtin(position) position: vec4<f32>,\r\n  @location(0) uv: vec2<f32>,\r\n  @location(1) transition: f32,\r\n}\r\n\r\nstruct Scene {\r\n  viewProj: mat4x4<f32>,\r\n  cameraWorld: mat4x4<f32>,\r\n  ambientColor: vec4<f32>,\r\n  sunDirection: vec4<f32>,\r\n  sunColor: vec4<f32>,\r\n  cameraMode: f32,\r\n  cameraSize: f32,\r\n  viewport: vec2<f32>,\r\n}\r\n\r\nstruct LegendData {\r\n  transition: f32,\r\n  width: f32,\r\n  height: f32,\r\n  _pad: f32,\r\n}\r\n\r\n@group(0) @binding(0) var<uniform> scene: Scene;\r\n@group(0) @binding(1) var<storage, read> entityIds: array<u32>;\r\n@group(0) @binding(2) var<storage, read> legends: array<LegendData>;\r\n@group(0) @binding(3) var<storage, read> matrices: array<mat4x4<f32>>;\r\n\r\n@vertex\r\nfn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VertexOutput {\r\n  let eid = entityIds[iid];\r\n  let legend = legends[eid];\r\n  let transform = matrices[eid];\r\n\r\n  let halfW = legend.width * 0.5 * legend.transition;\r\n  let halfH = legend.height * 0.5 * legend.transition;\r\n\r\n  var localPos: vec2<f32>;\r\n  var uv: vec2<f32>;\r\n  switch vid {\r\n    case 0u: { localPos = vec2(-halfW, -halfH); uv = vec2(0.0, 0.0); }\r\n    case 1u: { localPos = vec2(halfW, -halfH); uv = vec2(1.0, 0.0); }\r\n    case 2u: { localPos = vec2(halfW, halfH); uv = vec2(1.0, 1.0); }\r\n    case 3u: { localPos = vec2(-halfW, -halfH); uv = vec2(0.0, 0.0); }\r\n    case 4u: { localPos = vec2(halfW, halfH); uv = vec2(1.0, 1.0); }\r\n    case 5u: { localPos = vec2(-halfW, halfH); uv = vec2(0.0, 1.0); }\r\n    default: { localPos = vec2(0.0, 0.0); uv = vec2(0.0, 0.0); }\r\n  }\r\n\r\n  let worldPos = transform[3].xyz + vec3(localPos, 0.0);\r\n  let clipPos = scene.viewProj * vec4(worldPos, 1.0);\r\n\r\n  var out: VertexOutput;\r\n  out.position = clipPos;\r\n  out.uv = uv;\r\n  out.transition = legend.transition;\r\n  return out;\r\n}\r\n\r\nstruct FragmentOutput {\r\n  @location(0) color: vec4<f32>,\r\n  @location(1) mask: f32,\r\n}\r\n\r\n@fragment\r\nfn fs(input: VertexOutput) -> FragmentOutput {\r\n  let t = input.uv.y;\r\n\r\n  // Nonlinear: Red -> Yellow at 90%, Yellow -> Green in top 10%\r\n  var color: vec3<f32>;\r\n  let red = vec3(0.863, 0.345, 0.345);\r\n  let yellow = vec3(0.898, 0.627, 0.251);\r\n  let green = vec3(0.247, 0.722, 0.478);\r\n  if (t < 0.9) {\r\n    color = mix(red, yellow, t / 0.9);\r\n  } else {\r\n    color = mix(yellow, green, (t - 0.9) / 0.1);\r\n  }\r\n\r\n  var out: FragmentOutput;\r\n  out.color = vec4(color, input.transition);\r\n  out.mask = select(0.0, 1.0, input.transition > 0.01);\r\n  return out;\r\n}\r\n`;\r\n\r\nexport function createGradientLegendPipeline(\r\n  device: GPUDevice,\r\n  format: GPUTextureFormat,\r\n  maskFormat: GPUTextureFormat\r\n): GPURenderPipeline {\r\n  const module = device.createShaderModule({ code: gradientLegendShader });\r\n\r\n  return device.createRenderPipeline({\r\n    layout: 'auto',\r\n    vertex: {\r\n      module,\r\n      entryPoint: 'vs',\r\n    },\r\n    fragment: {\r\n      module,\r\n      entryPoint: 'fs',\r\n      targets: [\r\n        {\r\n          format,\r\n          blend: {\r\n            color: {\r\n              srcFactor: 'src-alpha',\r\n              dstFactor: 'one-minus-src-alpha',\r\n              operation: 'add',\r\n            },\r\n            alpha: {\r\n              srcFactor: 'one',\r\n              dstFactor: 'one-minus-src-alpha',\r\n              operation: 'add',\r\n            },\r\n          },\r\n        },\r\n        {\r\n          format: maskFormat,\r\n          writeMask: GPUColorWrite.RED,\r\n        },\r\n      ],\r\n    },\r\n    primitive: {\r\n      topology: 'triangle-list',\r\n    },\r\n    depthStencil: {\r\n      format: DEPTH_FORMAT,\r\n      depthCompare: 'less',\r\n      depthWriteEnabled: false,\r\n    },\r\n  });\r\n}\r\n\r\nfunction createGradientLegendContributor(config: GradientLegendConfig): DrawContributor {\r\n  let pipeline: GPURenderPipeline | null = null;\r\n  let bindGroup: GPUBindGroup | null = null;\r\n\r\n  return {\r\n    id: 'gradient-legend',\r\n    order: 1,\r\n\r\n    draw(pass: GPURenderPassEncoder, ctx: DrawContext) {\r\n      if (!pipeline) {\r\n        pipeline = createGradientLegendPipeline(ctx.device, ctx.format, ctx.maskFormat);\r\n      }\r\n\r\n      if (!bindGroup) {\r\n        bindGroup = ctx.device.createBindGroup({\r\n          layout: pipeline.getBindGroupLayout(0),\r\n          entries: [\r\n            { binding: 0, resource: { buffer: config.scene } },\r\n            { binding: 1, resource: { buffer: config.entityIds } },\r\n            { binding: 2, resource: { buffer: config.legends } },\r\n            { binding: 3, resource: { buffer: config.matrices } },\r\n          ],\r\n        });\r\n      }\r\n\r\n      const count = config.getCount();\r\n      if (count === 0) return;\r\n\r\n      pass.setPipeline(pipeline);\r\n      pass.setBindGroup(0, bindGroup);\r\n      pass.draw(6, count);\r\n    },\r\n  };\r\n}\r\n\r\nexport interface GradientLegendState {\r\n  buffer: GPUBuffer;\r\n  entityIds: GPUBuffer;\r\n  count: number;\r\n}\r\n\r\nexport const GradientLegends = resource<GradientLegendState>('gradient-legends');\r\n\r\nconst entityIdArray = new Uint32Array(MAX_ENTITIES);\r\n\r\nconst GradientLegendSystem: System = {\r\n  group: 'draw',\r\n\r\n  update(state: State) {\r\n    const compute = Compute.from(state);\r\n    const legends = GradientLegends.from(state);\r\n    if (!compute || !legends) return;\r\n\r\n    const { device } = compute;\r\n\r\n    let count = 0;\r\n    for (const eid of state.query([GradientLegend, Transform])) {\r\n      if (GradientLegend.transition[eid] <= 0) continue;\r\n      entityIdArray[count++] = eid;\r\n    }\r\n\r\n    device.queue.writeBuffer(legends.buffer, 0, GradientLegendData.data);\r\n    device.queue.writeBuffer(legends.entityIds, 0, entityIdArray, 0, count);\r\n    legends.count = count;\r\n  },\r\n};\r\n\r\nexport const GradientLegendPlugin: Plugin = {\r\n  systems: [GradientLegendSystem],\r\n  components: { GradientLegend },\r\n  dependencies: [ComputePlugin, RenderPlugin],\r\n\r\n  initialize(state: State) {\r\n    const compute = Compute.from(state);\r\n    const render = Render.from(state);\r\n    if (!compute || !render) return;\r\n\r\n    const { device } = compute;\r\n\r\n    const legendState: GradientLegendState = {\r\n      buffer: device.createBuffer({\r\n        label: 'gradient-legends',\r\n        size: MAX_ENTITIES * 4 * 4,\r\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\r\n      }),\r\n      entityIds: createEntityIdBuffer(device, MAX_ENTITIES),\r\n      count: 0,\r\n    };\r\n\r\n    state.setResource(GradientLegends, legendState);\r\n\r\n    registerDrawContributor(\r\n      state,\r\n      createGradientLegendContributor({\r\n        scene: render.scene,\r\n        legends: legendState.buffer,\r\n        entityIds: legendState.entityIds,\r\n        matrices: render.matrices,\r\n        getCount: () => legendState.count,\r\n      })\r\n    );\r\n  },\r\n};\r\n","import { setTraits, ChildOf, Pair, Transform, defineRelation, type Plugin, type State, type System } from '@multiplekex/shallot';\r\nimport { Text, Line, Arrow } from '@multiplekex/shallot/extras';\r\nimport { LINE, VALID, INVALID } from './colors';\r\n\r\nexport const TokenReplacement = {\r\n  trigger: [] as number[],\r\n};\r\n\r\nsetTraits(TokenReplacement, {\r\n  defaults: () => ({ trigger: 0 }),\r\n});\r\n\r\nconst tokenReplacementTexts = new Map<number, { original: string; replacement: string }>();\r\n\r\nexport function setTokenReplacementTexts(eid: number, original: string, replacement: string): void {\r\n  tokenReplacementTexts.set(eid, { original, replacement });\r\n}\r\n\r\nexport { Border, BorderPlugin } from './border';\r\nexport { ProbabilityDistribution, DistributionBar, BarHighlight, ProbabilityDistributionPlugin, setDistributionProbabilities } from './probability-distribution';\r\nexport { GradientLegend, GradientLegendPlugin } from './gradient-legend';\r\n\r\nexport const Network = {\r\n  active: [] as number[],\r\n  lineTransition: [] as number[],\r\n};\r\n\r\nsetTraits(Network, {\r\n  defaults: () => ({ active: 0, lineTransition: 1 }),\r\n});\r\n\r\nexport const TargetModel = {};\r\nexport const DraftModel = {};\r\nexport const ValidationModel = {};\r\n\r\nexport const Slot = {\r\n  index: [] as number[],\r\n  transition: [] as number[],\r\n};\r\n\r\nsetTraits(Slot, {\r\n  defaults: () => ({ index: 0, transition: 1 }),\r\n});\r\n\r\nexport const Latent = {};\r\nexport const Output = {};\r\n\r\nexport const ValidationMark = {\r\n  valid: [] as number[],\r\n  transition: [] as number[],\r\n};\r\n\r\nsetTraits(ValidationMark, {\r\n  defaults: () => ({ valid: 1, transition: 0 }),\r\n});\r\n\r\nconst SLOT_OFFSET_Z = -4;\r\nconst CHAR_WIDTH_RATIO = 0.55;\r\nconst WORD_GAP = 0.7;\r\nconst OUTPUT_GAP = 1.4;\r\nconst LINE_THICKNESS = 2;\r\n\r\nfunction getSlotTextWidth(state: State, slotEid: number): number {\r\n  for (const textEid of state.query([Pair(ChildOf.relation, slotEid), Text])) {\r\n    const content = Text.content[textEid] ?? '';\r\n    const fontSize = Text.fontSize[textEid] || 1;\r\n    return content.length * fontSize * CHAR_WIDTH_RATIO;\r\n  }\r\n  return 1;\r\n}\r\n\r\nconst SlotTransitionSystem: System = {\r\n  group: 'simulation',\r\n  update(state: State) {\r\n    for (const slotEid of state.query([Slot, Transform])) {\r\n      const t = Slot.transition[slotEid];\r\n      Transform.scaleX[slotEid] = t;\r\n      Transform.scaleY[slotEid] = t;\r\n      Transform.scaleZ[slotEid] = t;\r\n    }\r\n  },\r\n};\r\n\r\nconst SlotArrangementSystem: System = {\r\n  group: 'simulation',\r\n  update(state: State) {\r\n    for (const networkEid of state.query([Network, Transform])) {\r\n      const allSlots = [...state.query([Pair(ChildOf.relation, networkEid), Slot, Transform])];\r\n      if (allSlots.length === 0) continue;\r\n\r\n      allSlots.sort((a, b) => Slot.index[a] - Slot.index[b]);\r\n\r\n      const inputs = allSlots.filter((eid) => !state.hasComponent(eid, Output));\r\n      const outputs = allSlots.filter((eid) => state.hasComponent(eid, Output));\r\n\r\n      const inputWidths = inputs.map((eid) => getSlotTextWidth(state, eid));\r\n      const inputTotalWidth = inputWidths.reduce((sum, w) => sum + w, 0) + WORD_GAP * Math.max(0, inputs.length - 1);\r\n\r\n      let x = -inputTotalWidth / 2;\r\n      for (let i = 0; i < inputs.length; i++) {\r\n        const slotEid = inputs[i];\r\n        const w = inputWidths[i];\r\n        Transform.posX[slotEid] = x + w / 2;\r\n        Transform.posY[slotEid] = 0;\r\n        Transform.posZ[slotEid] = SLOT_OFFSET_Z;\r\n        x += w + WORD_GAP;\r\n      }\r\n\r\n      x = inputTotalWidth / 2 + OUTPUT_GAP;\r\n      for (let i = 0; i < outputs.length; i++) {\r\n        const slotEid = outputs[i];\r\n        const w = getSlotTextWidth(state, slotEid);\r\n        Transform.posX[slotEid] = x + w / 2;\r\n        Transform.posY[slotEid] = 0;\r\n        Transform.posZ[slotEid] = SLOT_OFFSET_Z;\r\n        x += w + WORD_GAP;\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nconst NetworkLine = {};\r\nconst NetworkLineTarget = defineRelation('network-line-target', { exclusive: true });\r\n\r\nconst NetworkLinesSystem: System = {\r\n  group: 'simulation',\r\n  update(state: State) {\r\n    for (const networkEid of state.query([Network, Transform])) {\r\n      const lineTransition = Network.lineTransition[networkEid];\r\n\r\n      for (const slotEid of state.query([Pair(ChildOf.relation, networkEid), Slot, Transform])) {\r\n        const existingLines = [...state.query([Pair(NetworkLineTarget.relation, slotEid), NetworkLine, Line])];\r\n\r\n        let lineEid: number;\r\n        if (existingLines.length === 0) {\r\n          lineEid = state.addEntity();\r\n          state.addComponent(lineEid, Transform);\r\n          state.addComponent(lineEid, Line);\r\n          state.addComponent(lineEid, Arrow);\r\n          state.addComponent(lineEid, NetworkLine);\r\n          state.addComponent(lineEid, Pair(ChildOf.relation, networkEid));\r\n          state.addComponent(lineEid, Pair(NetworkLineTarget.relation, slotEid));\r\n\r\n          Line.color[lineEid] = LINE;\r\n          Line.thickness[lineEid] = LINE_THICKNESS;\r\n          Line.visible[lineEid] = 1;\r\n\r\n          Arrow.start[lineEid] = 0;\r\n          Arrow.end[lineEid] = 1;\r\n          Arrow.size[lineEid] = 1;\r\n        } else {\r\n          lineEid = existingLines[0];\r\n        }\r\n\r\n        const slotX = Transform.posX[slotEid];\r\n        const slotY = Transform.posY[slotEid];\r\n        const slotZ = Transform.posZ[slotEid];\r\n        const t = Math.min(1, Slot.transition[slotEid]);\r\n\r\n        Line.offsetX[lineEid] = slotX * t;\r\n        Line.offsetY[lineEid] = slotY * t;\r\n        Line.offsetZ[lineEid] = slotZ * t;\r\n        Line.opacity[lineEid] = lineTransition;\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nconst LatentArrow = {};\r\nconst LatentArrowOwner = defineRelation('latent-arrow-owner', { exclusive: true });\r\n\r\nconst ValidationLine = {};\r\nconst ValidationLineTarget = defineRelation('validation-line-target', { exclusive: true });\r\n\r\nconst LatentArrowsSystem: System = {\r\n  group: 'simulation',\r\n  update(state: State) {\r\n    for (const slotEid of state.query([Slot, Transform])) {\r\n      const latents = [...state.query([Pair(ChildOf.relation, slotEid), Latent, Transform])];\r\n      if (latents.length === 0) continue;\r\n\r\n      const latentEid = latents[0];\r\n\r\n      const existingArrows = [...state.query([Pair(LatentArrowOwner.relation, slotEid), LatentArrow, Line])];\r\n\r\n      let arrowEid: number;\r\n      if (existingArrows.length === 0) {\r\n        arrowEid = state.addEntity();\r\n        state.addComponent(arrowEid, Transform);\r\n        state.addComponent(arrowEid, Line);\r\n        state.addComponent(arrowEid, Arrow);\r\n        state.addComponent(arrowEid, LatentArrow);\r\n        state.addComponent(arrowEid, Pair(ChildOf.relation, slotEid));\r\n        state.addComponent(arrowEid, Pair(LatentArrowOwner.relation, slotEid));\r\n\r\n        Line.color[arrowEid] = LINE;\r\n        Line.thickness[arrowEid] = LINE_THICKNESS;\r\n        Line.visible[arrowEid] = 1;\r\n        Line.opacity[arrowEid] = 1;\r\n\r\n        Arrow.start[arrowEid] = 0;\r\n        Arrow.end[arrowEid] = 1;\r\n        Arrow.size[arrowEid] = 1;\r\n      } else {\r\n        arrowEid = existingArrows[0];\r\n      }\r\n\r\n      const latentZ = Transform.posZ[latentEid] - 3.5;\r\n\r\n      Transform.posX[arrowEid] = 0;\r\n      Transform.posY[arrowEid] = 0;\r\n      Transform.posZ[arrowEid] = latentZ;\r\n\r\n      Line.offsetX[arrowEid] = 0;\r\n      Line.offsetY[arrowEid] = 0;\r\n      Line.offsetZ[arrowEid] = -0.8;\r\n    }\r\n  },\r\n};\r\n\r\nconst ValidationLinesSystem: System = {\r\n  group: 'simulation',\r\n  update(state: State) {\r\n    for (const validationEid of state.query([ValidationModel, Transform])) {\r\n      const validationScale = Transform.scaleX[validationEid];\r\n      if (validationScale < 0.01) continue;\r\n\r\n      for (const draftEid of state.query([DraftModel, Transform])) {\r\n        const draftSlots = [...state.query([Pair(ChildOf.relation, draftEid), Slot, Transform])];\r\n        if (draftSlots.length === 0) continue;\r\n\r\n        const draftX = Transform.posX[draftEid];\r\n        const draftY = Transform.posY[draftEid];\r\n        const draftZ = Transform.posZ[draftEid];\r\n\r\n        for (const slotEid of draftSlots) {\r\n          const slotTransition = Math.max(0, Math.min(1, Slot.transition[slotEid]));\r\n\r\n          const existingLines = [...state.query([Pair(ValidationLineTarget.relation, slotEid), ValidationLine, Line])];\r\n\r\n          let lineEid: number;\r\n          if (existingLines.length === 0) {\r\n            lineEid = state.addEntity();\r\n            state.addComponent(lineEid, Transform);\r\n            state.addComponent(lineEid, Line);\r\n            state.addComponent(lineEid, Arrow);\r\n            state.addComponent(lineEid, ValidationLine);\r\n            state.addComponent(lineEid, Pair(ValidationLineTarget.relation, slotEid));\r\n\r\n            Line.color[lineEid] = LINE;\r\n            Line.thickness[lineEid] = LINE_THICKNESS;\r\n            Line.visible[lineEid] = 1;\r\n\r\n            Arrow.start[lineEid] = 0;\r\n            Arrow.end[lineEid] = 1;\r\n            Arrow.size[lineEid] = 1;\r\n          } else {\r\n            lineEid = existingLines[0];\r\n          }\r\n\r\n          if (slotTransition < 0.01) {\r\n            Line.opacity[lineEid] = 0;\r\n            continue;\r\n          }\r\n\r\n          const slotX = Transform.posX[slotEid];\r\n          const slotZ = Transform.posZ[slotEid];\r\n          const worldSlotX = draftX + slotX * slotTransition;\r\n          const worldSlotY = draftY;\r\n          const worldSlotZ = draftZ + slotZ * slotTransition;\r\n\r\n          const validationX = Transform.posX[validationEid];\r\n          const validationY = Transform.posY[validationEid];\r\n          const validationZ = Transform.posZ[validationEid];\r\n\r\n          Transform.posX[lineEid] = validationX;\r\n          Transform.posY[lineEid] = validationY;\r\n          Transform.posZ[lineEid] = validationZ;\r\n\r\n          Line.offsetX[lineEid] = (worldSlotX - validationX) * validationScale;\r\n          Line.offsetY[lineEid] = (worldSlotY - validationY) * validationScale;\r\n          Line.offsetZ[lineEid] = (worldSlotZ - validationZ) * validationScale;\r\n          Line.opacity[lineEid] = validationScale * slotTransition;\r\n        }\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nconst TokenReplacementSystem: System = {\r\n  group: 'simulation',\r\n  update(state: State) {\r\n    for (const eid of state.query([TokenReplacement, Text])) {\r\n      const trigger = TokenReplacement.trigger[eid];\r\n      const texts = tokenReplacementTexts.get(eid);\r\n      if (!texts) continue;\r\n\r\n      const currentText = Text.content[eid] ?? '';\r\n      const { original, replacement } = texts;\r\n\r\n      if (trigger > 0.5 && currentText !== replacement && replacement) {\r\n        Text.content[eid] = replacement;\r\n      } else if (trigger <= 0.5 && currentText !== original && original) {\r\n        Text.content[eid] = original;\r\n      }\r\n    }\r\n  },\r\n};\r\n\r\nexport const SpecdecPlugin: Plugin = {\r\n  components: { Network, TargetModel, DraftModel, ValidationModel, Slot, Latent, Output, NetworkLine, LatentArrow, ValidationLine, TokenReplacement },\r\n  systems: [SlotTransitionSystem, SlotArrangementSystem, NetworkLinesSystem, LatentArrowsSystem, ValidationLinesSystem, TokenReplacementSystem],\r\n};\r\n"],"names":["findStepElements","container","root","setupStepUI","elements","options","steps","onStepChange","maxStep","currentStep","stepInfo","maxHeight","step","updateDisplay","btnPrev","btnNext","counter","title","description","content","goToStep","clamped","handlePrev","handleNext","handleKeydown","e","assert","x","last","arr","isU32","value","Bitstream","bytes","byteOffset","byteIndex","byte","bitIndex","bit","n","result","i","end","clone","readExpGolomb","bitstream","leadingZeroBits","readSignedExpGolomb","codeNum","toUint8Array","source","toDataView","textEncoder","COLOR_PRIMARIES_MAP","TRANSFER_CHARACTERISTICS_MAP","MATRIX_COEFFICIENTS_MAP","colorSpaceIsComplete","colorSpace","isAllowSharedBufferSource","AsyncMutex","resolver","nextPromise","resolve","resolved","currentPromiseAlias","promiseWithResolvers","reject","res","rej","assertNever","setUint24","view","littleEndian","UNDETERMINED_LANGUAGE","ISO_639_2_REGEX","isIso639Dash2LanguageCode","SECOND_TO_MICROSECOND_FACTOR","computeRationalApproximation","maxDenominator","sign","prevNumerator","prevDenominator","currNumerator","currDenominator","remainder","integer","nextNumerator","nextDenominator","CallSerializer","fn","isFirefoxCache","isFirefox","keyValueIterator","object","key","polyfillSymbolDispose","RichImageData","data","mimeType","AttachedFile","name","validateMetadataTags","tags","image","validateTrackDisposition","disposition","VIDEO_CODECS","PCM_AUDIO_CODECS","NON_PCM_AUDIO_CODECS","AUDIO_CODECS","SUBTITLE_CODECS","AVC_LEVEL_TABLE","HEVC_LEVEL_TABLE","VP9_LEVEL_TABLE","AV1_LEVEL_TABLE","buildVideoCodecString","codec","width","height","bitrate","totalMacroblocks","levelInfo","level","levelIndication","hexProfileIndication","hexProfileCompatibility","hexLevelIndication","pictureSize","generateAv1CodecConfigurationFromCodecString","codecString","parts","firstByte","profile","levelAndTier","secondByte","tier","highBitDepth","twelveBit","monochrome","chromaSubsamplingX","chromaSubsamplingY","chromaSamplePosition","thirdByte","aacFrequencyTable","aacChannelMap","buildAacAudioSpecificConfig","config","frequencyIndex","customSampleRate","channelConfiguration","bitCount","byteCount","PCM_CODEC_REGEX","parsePcmCodec","match","dataType","sampleSize","silentValue","inferCodecFromCodecString","getVideoEncoderConfigExtension","VALID_VIDEO_CODEC_STRING_PREFIXES","AVC_CODEC_STRING_REGEX","HEVC_CODEC_STRING_REGEX","VP9_CODEC_STRING_REGEX","AV1_CODEC_STRING_REGEX","validateVideoChunkMetadata","metadata","prefix","primariesValues","transferValues","matrixValues","VALID_AUDIO_CODEC_STRING_PREFIXES","validateAudioChunkMetadata","validateSubtitleMetadata","Muxer","output","track","timestampInSeconds","isKeyPacket","timestampInfo","AvcNalUnitType","HevcNalUnitType","iterateNalUnitsInAnnexB","packetData","nalStart","zeroIndex","startCodeLength","iterateAvcNalUnitsAnnexB","extractNalUnitTypeForAvc","removeEmulationPreventionBytes","len","concatNalUnitsInLengthPrefixed","nalUnits","lengthSize","totalLength","a","b","offset","nalUnit","dataView","extractAvcDecoderConfigurationRecord","spsUnits","ppsUnits","spsExtUnits","loc","type","spsData","spsInfo","parseAvcSps","hasExtendedData","error","serializeAvcDecoderConfigurationRecord","record","sps","length","pps","spsExt","profileIdc","constraintFlags","levelIdc","chromaFormatIdc","bitDepthLumaMinus8","bitDepthChromaMinus8","separateColourPlaneFlag","sizeOfScalingList","lastScale","nextScale","j","deltaScale","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","codedWidth","codedHeight","displayWidth","displayHeight","frameMbsOnlyFlag","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","cropUnitX","cropUnitY","subWidthC","subHeightC","colourPrimaries","transferCharacteristics","matrixCoefficients","fullRangeFlag","numReorderFrames","maxDecFrameBuffering","nalHrdParametersPresentFlag","skipAvcHrdParameters","vclHrdParametersPresentFlag","constraintSet3Flag","picWidthInMbs","picHeightInMapUnits","frameHeightInMbs","maxDpbFrames","cpb_cnt_minus1","iterateHevcNalUnitsAnnexB","extractNalUnitTypeForHevc","parseHevcSps","spsMaxSubLayersMinus1","spsTemporalIdNestingFlag","general_profile_space","general_tier_flag","general_profile_idc","general_profile_compatibility_flags","general_constraint_indicator_flags","general_level_idc","parseProfileTierLevel","picWidthInLumaSamples","picHeightInLumaSamples","confWinLeftOffset","confWinRightOffset","confWinTopOffset","confWinBottomOffset","chromaArrayType","startI","spsMaxNumReorderPics","skipScalingListData","numShortTermRefPicSets","skipAllStRefPicSets","numLongTermRefPicsSps","minSpatialSegmentationIdc","vui","parseHevcVui","extractHevcDecoderConfigurationRecord","vpsUnits","seiUnits","parallelismType","ppsBitstream","tiles_enabled_flag","entropy_coding_sync_enabled_flag","arrays","maxNumSubLayersMinus1","sub_layer_profile_present_flag","sub_layer_level_present_flag","sizeId","matrixId","coefNum","num_short_term_ref_pic_sets","NumDeltaPocs","stRpsIdx","skipStRefPicSet","NumDeltaPocsThis","inter_ref_pic_set_prediction_flag","RefRpsIdx","delta_idx_minus1","numDelta","num_negative_pics","num_positive_pics","sps_max_sub_layers_minus1","skipHevcHrdParameters","commonInfPresentFlag","nal_hrd_parameters_present_flag","vcl_hrd_parameters_present_flag","sub_pic_hrd_params_present_flag","fixed_pic_rate_general_flag","fixed_pic_rate_within_cvs_flag","low_delay_hrd_flag","CpbCnt","skipSubLayerHrdParameters","serializeHevcDecoderConfigurationRecord","nal","parseOpusIdentificationHeader","outputChannelCount","preSkip","inputSampleRate","outputGain","channelMappingFamily","channelMappingTable","FlacBlockType","customVideoEncoders","PLACEHOLDER_DATA","EncodedPacket","timestamp","duration","sequenceNumber","byteLength","sideData","chunk","lastVideoGcErrorLog","lastAudioGcErrorLog","finalizationRegistry","now","VIDEO_SAMPLE_PIXEL_FORMATS","VIDEO_SAMPLE_PIXEL_FORMATS_SET","VideoSample","init","createDefaultPlaneLayout","VideoSampleColorSpace","canvas","context","isVideoFrame","validateVideoFrameCopyToOptions","videoFrame","size","destination","layout","imageData","arg1","arg2","arg3","arg4","arg5","arg6","arg7","arg8","sx","sy","sWidth","sHeight","dx","dy","dWidth","dHeight","centerX","centerY","aspectRatioChange","validateCropRectangle","canvasWidth","canvasHeight","rotation","rotatedWidth","rotatedHeight","clampCropRectangle","newWidth","newHeight","sampleWidth","sampleHeight","scale","newRotation","newTimestamp","newDuration","crop","outerWidth","outerHeight","plane","format","planes","getPlaneConfigs","layouts","currentOffset","planeWidth","planeHeight","stride","planeSize","yuv","yBytes","uvBytes","subX","subY","hasAlpha","configs","buildIsobmffMimeType","info","string","uniqueCodecMimeTypes","MIN_BOX_HEADER_SIZE","MAX_BOX_HEADER_SIZE","MIN_ADTS_FRAME_HEADER_SIZE","MAX_ADTS_FRAME_HEADER_SIZE","readAdtsFrameHeader","slice","startPos","readBytes","protectionAbsence","objectType","samplingFrequencyIndex","frameLength","numberOfAacFrames","crcCheck","FileSlice","start","filePos","checkIsInRange","bytesToRead","inlineTimestampRegex","formatSubtitleTimestamp","hours","minutes","seconds","milliseconds","IsobmffBoxWriter","writer","text","box","child","endPos","boxOffset","u8","u16","i16","u24","u32","i32","u64","fixed_8_8","fixed_16_16","fixed_2_30","variableUnsignedInt","remaining","ascii","nullTerminated","_","lastPresentedSample","samples","sample","rotationMatrix","rotationInDegrees","theta","cosTheta","sinTheta","IDENTITY_MATRIX","matrixToBytes","matrix","contents","children","fullBox","version","flags","ftyp","details","mdat","reserveLargeSize","free","moov","muxer","mvhd","trak","mvex","udta","creationTime","trackDatas","intoTimescale","lastSample","GLOBAL_TIMESCALE","nextTrackId","needsU64","u32OrU64","trackData","trackMetadata","getTrackMetadata","tkhd","mdia","durationInGlobalTimescale","mdhd","hdlr","TRACK_TYPE_TO_COMPONENT_SUBTYPE","TRACK_TYPE_TO_HANDLER_NAME","minf","localDuration","getLanguageCodeInt","hasComponentType","handlerType","manufacturer","TRACK_TYPE_TO_HEADER_BOX","dinf","stbl","vmhd","smhd","nmhd","dref","url","needsCtts","stsd","stts","ctts","cslg","stsc","stsz","stco","stss","sampleDescription","videoSampleDescription","videoCodecToBoxName","boxName","audioCodecToBoxName","soundSampleDescription","subtitleSampleDescription","SUBTITLE_CODEC_TO_BOX_NAME","compressionType","VIDEO_CODEC_TO_CONFIGURATION_BOX","colr","avcC","hvcC","vpcC","decoderConfig","bitDepth","chromaSubsampling","videoFullRangeFlag","av1C","sampleSizeInBits","audioCodecToConfigurationBox","esds","objectTypeIndication","wave","frma","enda","dOps","header","dfLa","pcmC","formatFlags","SUBTITLE_CODEC_TO_CONFIGURATION_BOX","vttC","keySamples","index","acc","leastDecodeToDisplayDelta","greatestDecodeToDisplayDelta","compositionStartTime","compositionEndTime","entry","compositionToDtsShift","trex","moof","mfhd","traf","fragmentSampleFlags","byte1","byte2","byte3","byte4","sampleIsDifferenceSample","tfhd","tfdt","trun","tfFlags","referenceSample","referenceSampleInfo","allSampleDurations","allSampleSizes","allSampleFlags","allSampleCompositionTimeOffsets","uniqueSampleDurations","uniqueSampleSizes","uniqueSampleFlags","uniqueSampleCompositionTimeOffsets","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetsPresent","mfra","tfra","mfro","trackIndex","vtte","vttc","payload","identifier","settings","sourceId","vtta","notes","boxes","metadataFormat","metadataTags","metaBox","metaMdir","metaMdta","addQuickTimeMetadataTagBoxes","metadataTagStringBoxShort","encoded","DATA_BOX_MIME_TYPE_MAP","generateMetadataPairs","isMdta","pairs","dataStringBoxLong","pair","fullCodecString","isQuickTime","code","language","Writer","pos","neededSize","newLength","copy","ARRAY_BUFFER_INITIAL_SIZE","ARRAY_BUFFER_MAX_SIZE","BufferTargetWriter","target","newBuffer","newBytes","newPos","Target","BufferTarget","TIMESTAMP_OFFSET","timeInSeconds","timescale","round","IsobmffMuxer","MovOutputFormat","fastStartDefault","release","holdsAvc","codecStrings","packet","meta","existingTrackData","requiresAnnexBTransformation","decoderConfigurationRecord","newTrackData","requiresAdtsStripping","adtsFrame","sampleRate","numberOfChannels","internalSample","headerLength","untilTimestamp","lastEndTimestamp","delta","deltaInTimescale","samplesNeeded","paddingSample","cue","until","timestamps","sortedTimestamps","sampleStart","sampleEnd","body","containsTimestamp","endTimestamp","nextSample","totalDuration","lastEntry","sampleCompositionTimeOffset","durationInTimescale","timescaleUnits","lastTableEntry","entryBefore","lastCompositionTimeOffsetTableEntry","maximumPacketCount","beginNewChunk","currentChunkDuration","keyFrameQueuedEverywhere","otherTrackData","firstQueuedSample","sampleCount","isFinalCall","outer","trackWithMinTimestamp","minTimestamp","flushWriter","fragmentNumber","movieBox","tracksInFragment","moofBox","moofOffset","mdatStartPos","currentPos","fragmentStartTimestamp","mdatSize","needsLargeMdatSize","newMoofBox","mdatBox","moovBox","reservedSize","upperBound","movieBoxSize","currentChunkPos","mfraBox","mfraBoxSize","mdatPos","remainingSpace","OutputFormat","IsobmffOutputFormat","Mp4OutputFormat","validateVideoEncodingConfig","Quality","validateVideoEncodingAdditionalOptions","buildVideoEncoderConfig","resolvedBitrate","factor","pixels","codecEfficiencyFactors","referencePixels","referenceBitrate","scaleFactor","finalBitrate","baseBitrate","prev","curr","MediaSource","forceClose","connectedTrack","VideoSource","VideoEncoderWrapper","encodingConfig","videoSample","shouldClose","encodeOptions","sizeChangeBehavior","canvasIsNew","keyFrameInterval","multipleOfKeyFrameInterval","finalEncodeOptions","clonedSample","promise","ColorAlphaSplitter","colorFrame","alphaFrame","encoderError","encoderConfig","MatchingCustomEncoder","colorChunkQueue","nullAlphaChunkQueue","encodedAlphaChunkCount","alphaEncoderQueue","addPacket","colorChunk","alphaChunk","alphaData","initialWidth","initialHeight","gl","vertexShader","fragmentShader","program","shader","vao","vertices","buffer","positionLocation","texCoordLocation","texture","sourceFrame","chromaSamples","yuvSize","requiredHeight","CanvasSource","AudioSource","SubtitleSource","ALL_TRACK_TYPES","validateBaseTrackMetadata","Output$1","supportedTrackCounts","presentTracksOfThisType","count","maxCount","maxTotalCount","supportedVideoCodecs","supportedAudioCodecs","supportedSubtitleCodecs","trackType","minCount","totalMinCount","promises","setCanvasSize","dpr","findSequenceForTransition","state","from","to","eid","Sequence","StepTransition","setupCanvasRecording","onProgress","seqEid","origWidth","origHeight","origStyle","r","SequenceState","childEid","Pair","ChildOf","Tween","TweenState","maxDuration","totalFrames","Output","videoSource","stepTime","TARGET_MODEL","DRAFT_MODEL","VALID","INVALID","LINE","Border","setTraits","BorderLine","CHAR_WIDTH_RATIO","BorderSystem","Text","Transform","fontSize","padding","color","thickness","t","textWidth","textHeight","w","h","Line","lineEid","lines","BorderPlugin","ProbabilityDistribution","DistributionBar","DistributionBarOwner","defineRelation","ComparisonBarOwner","AcceptanceMarkerOwner","ResidualBarOwner","MinBarOwner","ExcessDraftBarOwner","ExcessTargetBarOwner","AcceptanceMarker","BarHighlight","targetDistributions","draftDistributions","setDistributionProbabilities","distEid","targetProbs","draftProbs","lerpColor","c1","c2","r1","g1","b1","r2","g2","b2","g","RED","YELLOW","GREEN","acceptanceColor","acceptance","CHART_WIDTH","MAX_HEIGHT","smoothLerp","smoothness","dt","s","ProbabilityDistributionSystem","barCount","transition","blend","comparisonTransition","comparisonZ","existingBars","Mesh","barEid","MeshShape","barSpacing","barWidth","startX","targetP","draftP","goalP","probability","existingComparisonBars","compBarEid","acceptanceTransition","acceptanceYOffset","acceptanceSize","existingMarkers","markerEid","scaledSize","residualTransition","existingResidualBars","residualP","minTransition","existingMinBars","minP","excessDraftTransition","transferProgress","existingExcessDraftBars","excessP","fadeScale","baseHeight","widthScale","excessTargetTransition","existingExcessTargetBars","BarHighlightSystem","highlightEid","barIndex","yOffset","barX","barHeight","ProbabilityDistributionPlugin","GradientLegendData","MAX_ENTITIES","legendProxy","getValue","setValue","prop","GradientLegend","gradientLegendShader","createGradientLegendPipeline","device","maskFormat","module","DEPTH_FORMAT","createGradientLegendContributor","pipeline","bindGroup","pass","ctx","GradientLegends","resource","entityIdArray","GradientLegendSystem","compute","Compute","legends","GradientLegendPlugin","ComputePlugin","RenderPlugin","render","Render","legendState","createEntityIdBuffer","registerDrawContributor","TokenReplacement","tokenReplacementTexts","setTokenReplacementTexts","original","replacement","Network","TargetModel","DraftModel","ValidationModel","Slot","Latent","ValidationMark","SLOT_OFFSET_Z","WORD_GAP","OUTPUT_GAP","LINE_THICKNESS","getSlotTextWidth","slotEid","textEid","SlotTransitionSystem","SlotArrangementSystem","networkEid","allSlots","inputs","outputs","inputWidths","inputTotalWidth","sum","NetworkLine","NetworkLineTarget","NetworkLinesSystem","lineTransition","existingLines","Arrow","slotX","slotY","slotZ","LatentArrow","LatentArrowOwner","ValidationLine","ValidationLineTarget","LatentArrowsSystem","latents","latentEid","existingArrows","arrowEid","latentZ","ValidationLinesSystem","validationEid","validationScale","draftEid","draftSlots","draftX","draftY","draftZ","slotTransition","worldSlotX","worldSlotY","worldSlotZ","validationX","validationY","validationZ","TokenReplacementSystem","trigger","texts","currentText","SpecdecPlugin"],"mappings":"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","x_google_ignoreList":[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]}