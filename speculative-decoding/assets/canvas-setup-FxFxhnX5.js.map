{"version":3,"mappings":"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AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUhCC,GAAiC;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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","names":["A","n","pe","fe","Ke","o","z","r","a","i","s","ue","de","K","u","Ye","Je","nt","M","p","c","me","X","f","d","P","k","T","U","x","Y","y","ye","le","he","be","b","I","L","xe","ot","Re","rt","at","st","it","B","pt","g","ge","ve","Ce","ft","ne","Te","Z","oe","ut","$","te","Ie","J","Ee","We","Se","Me","De","Oe","H","re","W","l","R","Qe","v","D","se","He","ae","$e","qe","je","F","Pe","ie","E","ee","m","h","_e","Ge","ze","Q","ce","O","q","V","w","Be","It","_","Fe","we","j","N","G","C","Mt","Ne","Le","CycleError","message","toposort","nodes","edges","graph","inDegree","node","from","to","detectCycle","queue","sorted","dep","newDegree","visited","stack","hasCycle","Time","OrderingError","Scheduler","system","state","deltaTime","fixedDt","group","cached","all","filtered","sortSystems","systems","allSystems","validateSystems","first","last","normal","buildEdges","target","ref","checkGroup","refGroup","detectTarget","createWebRuntime","path","response","callback","createHeadlessRuntime","isWebviewResource","TAURI_FS_MODULE","createStandaloneRuntime","readTextFile","readFile","_runtime","createRuntime","_initPromise","initRuntime","toKebabCase","str","toCamelCase","letter","traitsMap","setTraits","component","traits","getTraits","registry","registerComponent","name","kebabName","getRegisteredComponent","createFieldProxy","data","stride","offset","getValue","eid","setValue","value","prop","MAX_ENTITIES","State","createWorld","key","runtime","now","dt","pluginOrSystem","plugin","addEntity","removeEntity","entityExists","getAllEntities","terms","query","getEntityComponents","addComponent","defaults","comp","field","arr","components","removeComponent","removeComponents","hasComponent","getComponent","subject","relation","getRelationTargets","targets","StateBuilder","canvas","loading","plugins","cleanup","pluginSet","allPlugins","total","onProgress","progress","parse","load","__vitePreload","xml","warmable","warmDone","warmBase","warmPromises","resource","resourceKey","defineRelation","options","bitecsCreateRelation","def","getRelationDef","ChildOf","DEG_TO_RAD","RAD_TO_DEG","clamp","min","max","eulerToQuaternion","hx","hy","hz","cx","sx","cy","sy","cz","sz","quaternionToEuler","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","m13","ey","perspective","fov","aspect","near","far","nf","orthographic","size","lr","bt","multiply","out","invert","r00","r01","r02","r10","r11","r12","r20","r21","r22","tx","ty","tz","extractFrustumPlanes","viewProj","planes","len","lookAt","eyeX","eyeY","eyeZ","targetX","targetY","targetZ","upX","upY","upZ","zx","zy","zLen","xLen","yx","trace","qw","qx","qy","qz","levenshtein","matrix","cost","findClosestMatch","input","candidates","inputKebab","bestMatch","bestScore","candidate","candidateKebab","distance","maxLen","threshold","tokenize","tokens","regex","lastIndex","match","before","tag","content","tagName","selfClosing","attrs","parseTagAttrs","attrRegex","inner","token","errors","pendingComments","pendingBlank","result","parseNodeFromTokens","e","startIndex","rawAttrs","nodeId","attrName","attrValue","children","childToken","postLoadHooks","registerPostLoadHook","hook","nameToEntity","nodeToEntity","pendingFieldRefs","createEntityTree","parent","Pair","componentAttrs","refs","unknown","categorizeAttrs","attr","applyRelation","applyComponent","targetEid","setFieldValue","context","registered","child","relationDef","val","props","values","entityRefs","parseAttrs","err","allValues","allEntityRefs","allErrors","isCSSAttrSyntax","parsePropertyString","propName","propValue","detectVec2","base","detectVec3","detectVec4","parseNumber","num","parseValues","valueStr","trimmed","start","isWhitespace","isEnd","splitProperties","componentName","propertyString","properties","colonIdx","rawName","fieldNames","suggestion","parsed","nums","producers","output","producer","topoSort","adjacency","compile","ComputeGraph","id","removed","device","preparable","done","promises","Canvas","createEntityIdBuffer","maxInstances","requestGPU","adapter","maxTextureDimension2D","info","event","Compute","MIN_CANVAS_SIZE","syncCanvasSize","dpr","rect","width","height","resizeObserver","observedCanvas","ComputeSystem","compute","resources","format","plan","canvasView","ctx","texture","view","buffer","encoder","ComputePlugin","initCanvas","element","Activity","createActivity","spinner","messages","displayedMessage","updateSpinner","currentMessage","released","idx","dark","createSpinner","theme","container","spinnerEl","updatePosition","parentRect","bottom","right","label","style","observer","spinnerDark","ActivityPlugin","Inputs","keys","keysPressed","keysReleased","mouse","inputs","code","lastPointerX","lastPointerY","activePointerId","activeButton","handleKeyDown","handleKeyUp","setButtonState","button","pressed","clearPointerState","handlePointerDown","handlePointerUp","handlePointerCancel","handlePointerMove","handleWheel","handleContextMenu","resetFrameState","clearAllState","InputSystem","canvasRes","InputResetSystem","InputPlugin","linear","t","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInBack","easeOutBack","easeInOutBack","easeInElastic","easeOutElastic","easeInOutElastic","easeOutBounce","easeInBounce","easeInOutBounce","EASING_FUNCTIONS","EASING_INDEX","getEasingIndex","getEasing","index","compareNumbers","compareByEndTime","childrenBuffer","tweensBuffer","Pause","SequenceState","Sequence","sortedChildren","parentEid","childEid","computeTweenDelays","seqEid","cumulativeDelay","Tween","updateSequences","prevElapsed","elapsed","TweenState","delay","shouldStart","wasStarted","captureFromValue","resolve","duration","ensureResolved","resolveAll","checkCompletion","allComplete","hasChildren","fieldAccessors","bindFieldAccessor","bindingId","fieldPath","camelPath","accessor","getFieldAccessor","parseTweenAttrs","part","setupTweenFromXml","TweenTarget","parseTargetPath","rest","firstDot","entity","dotIndex","pendingXmlTweens","tweenEid","finalizePendingTweens","pending","toValue","binding","updateTweens","tweenState","rawProgress","easedProgress","TweenSystem","TweenPlugin","wasm","compute_transforms","count","get_indices_ptr","get_matrices_ptr","get_max_entities","get_no_parent","get_parents_ptr","get_pos_x_ptr","get_pos_y_ptr","get_pos_z_ptr","get_quat_w_ptr","get_quat_x_ptr","get_quat_y_ptr","get_quat_z_ptr","get_scale_x_ptr","get_scale_y_ptr","get_scale_z_ptr","init_data","EXPECTED_RESPONSE_TYPES","__wbg_load","module","imports","bytes","instance","__wbg_get_imports","__wbg_finalize_init","__wbg_init","module_or_path","posX","posY","posZ","quatX","quatY","quatZ","quatW","scaleX","scaleY","scaleZ","matrices","indices","parents","NoParent","init","wasmInit","maxEntities","eulerProxy","axis","Transform","WorldTransform","wasm.init","wasm.posX","wasm.posY","wasm.posZ","wasm.quatX","wasm.quatY","wasm.quatZ","wasm.quatW","wasm.scaleX","wasm.scaleY","wasm.scaleZ","wasm.matrices","TransformSystem","Not","Wildcard","wasm.indices","wasm.parents","wasm.NoParent","Hierarchy","wasm.compute","TransformsPlugin","_state","RenderMode","CameraMode","Camera","Tonemap","FXAA","Raytracing","Vignette","Bloom","Quantize","Shadows","Reflections","Refractions","Haze","Sky","Moon","Stars","Clouds","Sun","Viewport","unpackColor","packed","sceneBuffer","scene","sceneU32","uploadCamera","shadowSoftness","shadowSamples","reflectionDepth","refractionDepth","instanceCount","haze","sky","moon","stars","clouds","sun","proj","world","clearColorPacked","hazeColorPacked","zenithPacked","horizonPacked","moonAzimuth","moonElevation","moonCosEl","cloudColorPacked","sunColorPacked","AmbientLight","DirectionalLight","normalizeDirection","lightData","packLightUniforms","ambient","directional","ambientRgb","dx","dy","dz","sunRgb","INDIRECT_SIZE","createIndirectBuffer","slotCount","writeIndirect","slot","args","createBox","vertices","createSphere","segments","rings","theta","phi","nx","ny","nz","createPlane","MAX_SHAPES","createShapeAtlas","allVertices","allIndices","shapeMetas","vertexOffset","indexOffset","maxTriangles","shapeId","mesh","getMesh","triCount","verticesData","indicesData","metaData","meta","MAX_SURFACES","MAX_BATCH_SLOTS","INVALID_SHAPE","batchEntityIds","meshes","initBuiltIns","MeshShape","MeshShapes","MeshColors","MeshSizes","MeshPBR","MeshEmission","MeshVolumes","Volume","colorProxy","colorChannelProxy","channelIndex","sizeProxy","pbrProxy","defaultValue","emissionProxy","emissionIntensityProxy","Mesh","createMeshBuffers","vertex","collectBatches","entities","getSurface","shape","surface","batchIndex","entry","updateBatches","batchEntities","indirect","batch","buffers","SURFACE_DATA_STRUCT_WGSL","SCENE_STRUCT_WGSL","DATA_STRUCT_WGSL","WGSL_STRUCTS","NOISE_WGSL","compileVertexBody","STARS_WGSL","MOON_WGSL","CLOUDS_WGSL","SKY_DIR_WGSL","SKY_WGSL","HAZE_WGSL","SPECULAR_WGSL","REFRACTION_WGSL","reflectionWgsl","shadows","WGSL_LIGHTING_CALC","SHADOW_WGSL","compileApplyLighting","lit","reflections","createSurfaceRegistry","SurfaceType","getAllSurfaces","defaultRegistry","getDefaultAllSurfaces","SurfaceIds","Surface","SCENE_UNIFORM_SIZE","DEPTH_FORMAT","LINEAR_DEPTH_FORMAT","MASK_FORMAT","EID_FORMAT","COLOR_FORMAT","createSceneBuffer","ensureTextures","textures","textureViews","existing","color","linearDepth","depth","mask","pingA","pingB","LEAF_FLAG","isLeaf","leafIndex","LEAF_FLAG_WGSL","TREE_NODE_STRUCT_WGSL","BVH_NODE_STRUCT_WGSL","TREE_NODE_SIZE","BVH_NODE_SIZE","BLAS_NODE_STRUCT_WGSL","BLAS_TRIANGLE_STRUCT_WGSL","RAY_STRUCT_WGSL","HIT_RESULT_STRUCT_WGSL","OCT_DECODE_WGSL","BVH_STRUCTS","TLAS_BLAS_STRUCTS","TLAS_BLAS_BINDINGS","TLAS_BLAS_TRAVERSAL","TLAS_BLAS_ANY_HIT","EPSILON","RT_STRUCTS","RT_BINDINGS","RT_UTILS","RT_RAY_GEN","RT_INTERSECTION","compileSurfaceVariant","vertexBody","fragmentBody","lightingCode","compileDispatchFunctions","surfaceCount","vertexCases","fragmentCases","lightingCases","compileUberShader","surfaces","_shadows","_reflections","_refractions","surfaceVariants","dispatchFunctions","compileRefractionTracer","compileRefractionBranch","compileRasterShader","createRasterPipeline","colorFormat","compileSkyShader","createSkyPipeline","createForwardNode","config","rasterPipeline","rtPipeline","rtCompiling","skyPipeline","executeRT","colorView","linearDepthView","eidView","bindGroup0","bindGroup1","colorTexture","pass","executeRaster","depthView","batches","clearColor","hasSky","skyPass","skyBindGroup","batchBindGroup","release","createRTPipeline","wantRT","compileRTShader","depthConvertShader","createDepthConvertNode","pipeline","bindGroup","Pass","Draws","registerDraw","draw","draws","getDrawsByPass","shader","blitShader","FLAG_TONEMAP","FLAG_FXAA","FLAG_VIGNETTE","FLAG_BLOOM","FLAG_QUANTIZE","createPostProcessNode","blitPipeline","uniformBuffer","linearSampler","nearestSampler","mainModule","blitModule","maskView","pingAView","pingBView","renderSize","sampler","currentInput","currentOutput","pingPong","beforePostProcess","contributor","passCtx","postProcessContributors","hasBuiltinEffects","flags","floats","uints","afterPostProcess","createOverlayNode","targetView","drawCtx","beforeOverlays","sharedCtx","afterOverlays","vec3","vec3Min","vec3Max","vec3Add","vec3Sub","vec3Scale","octEncode","absSum","vx","vy","signX","signY","newVx","newVy","extractShapeTriangles","triangles","indexCount","i0","i1","i2","v0","v1","v2","n0","n1","n2","computeBounds","tri","expandBits","mortonCode3D","computeMortonCode","centroid","bounds","safeSize","normalized","clamped","quantized","buildMortonPairs","radixSort","pairs","bitOffset","histogram","pair","digit","sum","clz32","delta","sortedPairs","codeI","codeJ","determineRange","deltaLeft","deltaRight","deltaMin","lmax","findSplit","firstCode","lastCode","deltaNode","split","middle","splitCode","buildKarrasTree","numInternal","gamma","leftIsLeaf","rightIsLeaf","leftChild","rightChild","getTriangleBounds","propagateBounds","boundsFlags","leafIdx","current","isLeafNode","iter","oldFlag","left","leftBounds","rightBounds","leftTri","rightTri","buildShapeBLAS","sortedTriIds","rootBounds","BLAS_TRIANGLE_SIZE","createBLASAtlas","blasData","trianglesMap","metas","totalNodes","totalTriIds","totalTris","blas","nodesData","triIdsData","trianglesData","nodeOffset","triIdOffset","triOffset","triId","floatView","nodesBuffer","triIdsBuffer","metaBuffer","trianglesBuffer","shapeAABBsData","shapeAABBs","WG_X","WG_Y","WG_SIZE","ITEMS_PER_WG","blockSumShader","reorderShader","prefixSumShader","dispatchSize","PrefixSum","passes","wgCount","dispatch","blockSums","layout","pipelineLayout","RadixSort","prefixSum","workgroups","tmpKeys","tmpVals","localSums","blockSumModule","reorderModule","blockSumLayout","reorderLayout","pipelinePromises","bit","blockSumPipeline","reorderPipeline","pipelines","even","inK","inV","outK","outV","createRadixSort","WORKGROUP_SIZE","MAX_TREE_DEPTH","createTLASBuffers","INSTANCE_AABB_STRUCT_WGSL","SCENE_BOUNDS_STRUCT_WGSL","SCENE_BOUNDS_READ_STRUCT_WGSL","FLOAT_INT_CONVERSION_WGSL","MORTON_CODE_WGSL","CLZ_WGSL","LEAF_FUNCTIONS_WGSL","boundsShader","mortonShader","treeShader","propagateShader","collapseShader","createTLASNode","bindGroups","boundsModule","mortonModule","treeModule","propagateModule","collapseModule","morton","tree","propagate","collapse","sort","initBounds","boundsPass","mortonPass","sortPass","treePass","propagatePass","collapsePass","createInstanceNode","createDataNode","EntityIds","countBuffer","Render","getRenderState","RenderSystem","render","renderWidth","renderHeight","vw","vh","uploadCount","hasShadows","hazeParams","skyParams","moonParams","starsParams","cloudsParams","sunParams","ambientData","directionalData","lightUniforms","meshEntities","meshCount","surfaceType","volume","DefaultSurfaceSystem","RenderPlugin","createPropertyBuffer","shapeAtlas","blasAtlas","renderState","drawState","instanceNode","dataNode","tlasNode","getRaytracing","getClearColor","getSky","forwardNode","light","LOGO_SVG","createOverlay","bg","overlay","createProgressBar","track","bar","shallotLoading","logo","progressBar","minimalLoading","shallotDark","minimalLight","DEFAULT_PLUGINS","Tau","OrbitButton","Orbit","smoothLerp","smoothness","normalizeAngle","angleDiff","diff","isOrbitButton","OrbitSystem","sensitivity","zoomSpeed","minPitch","maxPitch","isOrtho","currentSize","sizeScale","zoomDelta","currentDistance","distanceScale","targetSize","yaw","pitch","camX","camY","camZ","rotation","OrbitPlugin","LineData","packedColorProxy","Line","lineShader","createLinesPipeline","maskFormat","createLinesDraw","Lines","entityIdArray","LinesSystem","lines","LinesPlugin","linesState","ArrowData","Arrow","END_FLAG","arrowShader","createArrowsPipeline","createArrowsDraw","Arrows","arrowEntityIdArray","ArrowsSystem","arrows","ArrowsPlugin","arrowsState","u8","i16","u16","u32","seek","parseTables","tables","sfntVersion","numTables","length","parseHead","table","unitsPerEm","indexToLocFormat","parseHhea","ascender","descender","lineGap","numHMetrics","parseHmtx","numGlyphs","advances","lastAdvance","parseMaxp","parseLoca","offsets","parseCmap","charToGlyph","numSubtables","format4Offset","format12Offset","platformId","encodingId","numGroups","startCode","endCode","startGlyph","segCount","endCodes","startCodes","idDeltas","idRangeOffsetPos","idRangeOffsets","end","rangeOffset","glyphId","glyphIdOffset","parseKern","kerning","version","numPairs","subtableLength","ON_CURVE","X_SHORT","Y_SHORT","REPEAT","X_SAME","Y_SAME","parseGlyph","glyfOffset","loca","numContours","xMin","yMin","xMax","yMax","parseCompositeGlyph","endPts","numPoints","instructionLength","flag","repeat","xs","ys","contourStart","contourEnd","points","firstOn","mid","reordered","next","midX","midY","hasMore","glyphIndex","savedOffset","transformed","transformPath","parseFont","headTable","hheaTable","hmtxTable","maxpTable","cmapTable","locaTable","glyfTable","kernTable","head","hhea","hmtx","cmap","kern","glyphCache","getGlyphId","char","getGlyph","glyph","loadFont","url","pointOnQuadraticBezier","x0","y0","x1","y1","t2","pointOnCubicBezier","x3","y3","segmentPath","pathString","curvePoints","segmentRE","firstX","firstY","prevX","prevY","curveX","curveY","distanceShader","finalizeShader","SDFGenerator","distanceModule","finalizeModule","outputTexture","outputX","outputY","maxDist","uniformData","segmentData","seg","distanceBindGroup","distancePass","finalizeBindGroup","outputView","finalizePass","MAX_GLYPHS","GLYPH_FLOATS","SDF_SIZE","SDF_EXPONENT","fontUrls","loadedFonts","DEFAULT_FONT","font","loadFonts","TextData","fonts","textContent","contentProxy","Text","pendingTextContent","parseTextAttrs","finalizePendingText","_context","colorStr","createGlyphAtlas","sdfGenerator","ensureGlyph","atlas","advance","padding","paddedBounds","glyphWidth","glyphHeight","metrics","ensureString","text","layoutText","fontSize","glyphs","scale","cursorX","maxHeight","prevChar","glyphW","glyphH","textShader","createTextPipeline","createTextDraw","Glyphs","TextSystem","atlases","staging","ranges","stagingU32","glyphsByFont","fontId","actualFontId","anchorX","anchorY","offsetX","offsetY","glyphCount","fontIdx","fontGlyphs","TextPlugin","loadedFont","textState","fontIndex","DEFAULT_PHYSICS_CONFIG","DEFAULT_BUBBLE_CONFIG","DEFAULT_TEXTURE_CONFIG","STRIDE","GradientData","seeds","color1s","color2s","overlayColors","floatProxy","stringProxy","map","Gradient","StepController","StepTransition","TokenIndex","createStepControllerSystem","isTransitioning","createStepPlugin","findStepElements","root","setupStepUI","elements","steps","getStep","setStep","maxStep","stepInfo","step","updateDisplay","currentStep","btnPrev","btnNext","counter","title","description","handlePrev","handleNext","handleKeydown","interval","connectStepControls","onStepChange","controllerEid","setStepImmediate","dispose","assert","isU32","Bitstream","byteOffset","byteIndex","byte","bitIndex","clone","readExpGolomb","bitstream","leadingZeroBits","readSignedExpGolomb","codeNum","toUint8Array","source","toDataView","textEncoder","COLOR_PRIMARIES_MAP","TRANSFER_CHARACTERISTICS_MAP","MATRIX_COEFFICIENTS_MAP","colorSpaceIsComplete","colorSpace","isAllowSharedBufferSource","AsyncMutex","resolver","nextPromise","resolved","currentPromiseAlias","promiseWithResolvers","reject","res","rej","assertNever","setUint24","littleEndian","UNDETERMINED_LANGUAGE","ISO_639_2_REGEX","isIso639Dash2LanguageCode","SECOND_TO_MICROSECOND_FACTOR","computeRationalApproximation","maxDenominator","sign","prevNumerator","prevDenominator","currNumerator","currDenominator","remainder","integer","nextNumerator","nextDenominator","CallSerializer","fn","isFirefoxCache","isFirefox","keyValueIterator","object","polyfillSymbolDispose","RichImageData","mimeType","AttachedFile","validateMetadataTags","tags","image","validateTrackDisposition","disposition","VIDEO_CODECS","PCM_AUDIO_CODECS","NON_PCM_AUDIO_CODECS","AUDIO_CODECS","SUBTITLE_CODECS","AVC_LEVEL_TABLE","HEVC_LEVEL_TABLE","VP9_LEVEL_TABLE","AV1_LEVEL_TABLE","buildVideoCodecString","codec","bitrate","totalMacroblocks","levelInfo","level","levelIndication","hexProfileIndication","hexProfileCompatibility","hexLevelIndication","pictureSize","generateAv1CodecConfigurationFromCodecString","codecString","parts","firstByte","profile","levelAndTier","secondByte","tier","highBitDepth","twelveBit","monochrome","chromaSubsamplingX","chromaSubsamplingY","chromaSamplePosition","thirdByte","aacFrequencyTable","aacChannelMap","buildAacAudioSpecificConfig","frequencyIndex","customSampleRate","channelConfiguration","bitCount","byteCount","PCM_CODEC_REGEX","parsePcmCodec","dataType","sampleSize","silentValue","inferCodecFromCodecString","getVideoEncoderConfigExtension","VALID_VIDEO_CODEC_STRING_PREFIXES","AVC_CODEC_STRING_REGEX","HEVC_CODEC_STRING_REGEX","VP9_CODEC_STRING_REGEX","AV1_CODEC_STRING_REGEX","validateVideoChunkMetadata","metadata","prefix","primariesValues","transferValues","matrixValues","VALID_AUDIO_CODEC_STRING_PREFIXES","validateAudioChunkMetadata","validateSubtitleMetadata","AvcNalUnitType","HevcNalUnitType","iterateNalUnitsInAnnexB","packetData","nalStart","zeroIndex","startCodeLength","extractNalUnitTypeForAvc","removeEmulationPreventionBytes","concatNalUnitsInLengthPrefixed","nalUnits","lengthSize","totalLength","nalUnit","dataView","extractAvcDecoderConfigurationRecord","spsUnits","ppsUnits","spsExtUnits","loc","type","spsData","spsInfo","parseAvcSps","hasExtendedData","error","serializeAvcDecoderConfigurationRecord","record","sps","pps","spsExt","profileIdc","constraintFlags","levelIdc","chromaFormatIdc","bitDepthLumaMinus8","bitDepthChromaMinus8","separateColourPlaneFlag","sizeOfScalingList","lastScale","nextScale","deltaScale","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","codedWidth","codedHeight","displayWidth","displayHeight","frameMbsOnlyFlag","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","cropUnitX","cropUnitY","subWidthC","subHeightC","colourPrimaries","transferCharacteristics","matrixCoefficients","fullRangeFlag","numReorderFrames","maxDecFrameBuffering","nalHrdParametersPresentFlag","skipAvcHrdParameters","vclHrdParametersPresentFlag","constraintSet3Flag","picWidthInMbs","picHeightInMapUnits","frameHeightInMbs","maxDpbFrames","cpb_cnt_minus1","extractNalUnitTypeForHevc","parseHevcSps","spsMaxSubLayersMinus1","spsTemporalIdNestingFlag","general_profile_space","general_tier_flag","general_profile_idc","general_profile_compatibility_flags","general_constraint_indicator_flags","general_level_idc","parseProfileTierLevel","picWidthInLumaSamples","picHeightInLumaSamples","confWinLeftOffset","confWinRightOffset","confWinTopOffset","confWinBottomOffset","chromaArrayType","startI","spsMaxNumReorderPics","skipScalingListData","numShortTermRefPicSets","skipAllStRefPicSets","numLongTermRefPicsSps","minSpatialSegmentationIdc","vui","parseHevcVui","extractHevcDecoderConfigurationRecord","vpsUnits","seiUnits","parallelismType","ppsBitstream","tiles_enabled_flag","entropy_coding_sync_enabled_flag","arrays","maxNumSubLayersMinus1","sub_layer_profile_present_flag","sub_layer_level_present_flag","sizeId","matrixId","coefNum","num_short_term_ref_pic_sets","NumDeltaPocs","stRpsIdx","skipStRefPicSet","NumDeltaPocsThis","inter_ref_pic_set_prediction_flag","RefRpsIdx","delta_idx_minus1","numDelta","num_negative_pics","num_positive_pics","sps_max_sub_layers_minus1","skipHevcHrdParameters","commonInfPresentFlag","nal_hrd_parameters_present_flag","vcl_hrd_parameters_present_flag","sub_pic_hrd_params_present_flag","fixed_pic_rate_general_flag","fixed_pic_rate_within_cvs_flag","low_delay_hrd_flag","CpbCnt","skipSubLayerHrdParameters","serializeHevcDecoderConfigurationRecord","nal","parseOpusIdentificationHeader","outputChannelCount","preSkip","inputSampleRate","outputGain","channelMappingFamily","channelMappingTable","FlacBlockType","customVideoEncoders","PLACEHOLDER_DATA","EncodedPacket","timestamp","sequenceNumber","byteLength","sideData","chunk","lastVideoGcErrorLog","lastAudioGcErrorLog","finalizationRegistry","VIDEO_SAMPLE_PIXEL_FORMATS","VIDEO_SAMPLE_PIXEL_FORMATS_SET","VideoSample","createDefaultPlaneLayout","VideoSampleColorSpace","isVideoFrame","validateVideoFrameCopyToOptions","videoFrame","destination","imageData","arg1","arg2","arg3","arg4","arg5","arg6","arg7","arg8","sWidth","sHeight","dWidth","dHeight","centerX","centerY","aspectRatioChange","validateCropRectangle","canvasWidth","canvasHeight","rotatedWidth","rotatedHeight","clampCropRectangle","newWidth","newHeight","sampleWidth","sampleHeight","newRotation","newTimestamp","newDuration","crop","outerWidth","outerHeight","plane","getPlaneConfigs","layouts","currentOffset","planeWidth","planeHeight","planeSize","yuv","yBytes","uvBytes","subX","subY","hasAlpha","configs","buildIsobmffMimeType","string","uniqueCodecMimeTypes","MIN_BOX_HEADER_SIZE","MAX_BOX_HEADER_SIZE","MIN_ADTS_FRAME_HEADER_SIZE","MAX_ADTS_FRAME_HEADER_SIZE","readAdtsFrameHeader","slice","startPos","readBytes","protectionAbsence","objectType","samplingFrequencyIndex","frameLength","numberOfAacFrames","crcCheck","FileSlice","filePos","checkIsInRange","bytesToRead","Muxer","timestampInSeconds","isKeyPacket","timestampInfo","inlineTimestampRegex","formatSubtitleTimestamp","hours","minutes","seconds","milliseconds","IsobmffBoxWriter","writer","box","endPos","boxOffset","u24","i32","u64","fixed_8_8","fixed_16_16","fixed_2_30","variableUnsignedInt","remaining","ascii","nullTerminated","lastPresentedSample","samples","sample","rotationMatrix","rotationInDegrees","cosTheta","sinTheta","IDENTITY_MATRIX","matrixToBytes","contents","fullBox","ftyp","details","mdat","reserveLargeSize","free","moov","muxer","mvhd","trak","mvex","udta","creationTime","trackDatas","intoTimescale","lastSample","GLOBAL_TIMESCALE","nextTrackId","needsU64","u32OrU64","trackData","trackMetadata","getTrackMetadata","tkhd","mdia","durationInGlobalTimescale","mdhd","hdlr","TRACK_TYPE_TO_COMPONENT_SUBTYPE","TRACK_TYPE_TO_HANDLER_NAME","minf","localDuration","getLanguageCodeInt","hasComponentType","handlerType","manufacturer","TRACK_TYPE_TO_HEADER_BOX","dinf","stbl","vmhd","smhd","nmhd","dref","needsCtts","stsd","stts","ctts","cslg","stsc","stsz","stco","stss","sampleDescription","videoSampleDescription","videoCodecToBoxName","boxName","audioCodecToBoxName","soundSampleDescription","subtitleSampleDescription","SUBTITLE_CODEC_TO_BOX_NAME","compressionType","VIDEO_CODEC_TO_CONFIGURATION_BOX","colr","avcC","hvcC","vpcC","decoderConfig","bitDepth","chromaSubsampling","videoFullRangeFlag","av1C","sampleSizeInBits","audioCodecToConfigurationBox","esds","objectTypeIndication","wave","frma","enda","dOps","header","dfLa","pcmC","formatFlags","SUBTITLE_CODEC_TO_CONFIGURATION_BOX","vttC","keySamples","acc","leastDecodeToDisplayDelta","greatestDecodeToDisplayDelta","compositionStartTime","compositionEndTime","compositionToDtsShift","trex","moof","mfhd","traf","fragmentSampleFlags","byte1","byte2","byte3","byte4","sampleIsDifferenceSample","tfhd","tfdt","trun","tfFlags","referenceSample","referenceSampleInfo","allSampleDurations","allSampleSizes","allSampleFlags","allSampleCompositionTimeOffsets","uniqueSampleDurations","uniqueSampleSizes","uniqueSampleFlags","uniqueSampleCompositionTimeOffsets","firstSampleFlagsPresent","sampleDurationPresent","sampleSizePresent","sampleFlagsPresent","sampleCompositionTimeOffsetsPresent","mfra","tfra","mfro","trackIndex","vtte","vttc","payload","identifier","settings","sourceId","vtta","notes","boxes","metadataFormat","metadataTags","metaBox","metaMdir","metaMdta","addQuickTimeMetadataTagBoxes","metadataTagStringBoxShort","encoded","DATA_BOX_MIME_TYPE_MAP","generateMetadataPairs","isMdta","dataStringBoxLong","fullCodecString","isQuickTime","language","Writer","pos","neededSize","newLength","copy","ARRAY_BUFFER_INITIAL_SIZE","ARRAY_BUFFER_MAX_SIZE","BufferTargetWriter","newBuffer","newBytes","newPos","Target","BufferTarget","TIMESTAMP_OFFSET","timeInSeconds","timescale","round","IsobmffMuxer","MovOutputFormat","fastStartDefault","holdsAvc","codecStrings","packet","existingTrackData","requiresAnnexBTransformation","decoderConfigurationRecord","newTrackData","requiresAdtsStripping","adtsFrame","sampleRate","numberOfChannels","internalSample","headerLength","untilTimestamp","lastEndTimestamp","deltaInTimescale","samplesNeeded","paddingSample","cue","until","timestamps","sortedTimestamps","sampleStart","sampleEnd","body","containsTimestamp","endTimestamp","nextSample","totalDuration","lastEntry","sampleCompositionTimeOffset","durationInTimescale","timescaleUnits","lastTableEntry","entryBefore","lastCompositionTimeOffsetTableEntry","maximumPacketCount","beginNewChunk","currentChunkDuration","keyFrameQueuedEverywhere","otherTrackData","firstQueuedSample","sampleCount","isFinalCall","outer","trackWithMinTimestamp","minTimestamp","flushWriter","fragmentNumber","movieBox","tracksInFragment","moofBox","moofOffset","mdatStartPos","currentPos","fragmentStartTimestamp","mdatSize","needsLargeMdatSize","newMoofBox","mdatBox","moovBox","reservedSize","upperBound","movieBoxSize","currentChunkPos","mfraBox","mfraBoxSize","mdatPos","remainingSpace","OutputFormat","IsobmffOutputFormat","Mp4OutputFormat","validateVideoEncodingConfig","Quality","validateVideoEncodingAdditionalOptions","buildVideoEncoderConfig","resolvedBitrate","factor","pixels","codecEfficiencyFactors","referencePixels","referenceBitrate","scaleFactor","finalBitrate","baseBitrate","prev","curr","MediaSource","forceClose","connectedTrack","VideoSource","VideoEncoderWrapper","encodingConfig","videoSample","shouldClose","encodeOptions","sizeChangeBehavior","canvasIsNew","keyFrameInterval","multipleOfKeyFrameInterval","finalEncodeOptions","clonedSample","promise","ColorAlphaSplitter","colorFrame","alphaFrame","encoderError","encoderConfig","MatchingCustomEncoder","colorChunkQueue","nullAlphaChunkQueue","encodedAlphaChunkCount","alphaEncoderQueue","addPacket","colorChunk","alphaChunk","alphaData","initialWidth","initialHeight","gl","vertexShader","fragmentShader","program","vao","positionLocation","texCoordLocation","sourceFrame","chromaSamples","yuvSize","requiredHeight","CanvasSource","AudioSource","SubtitleSource","ALL_TRACK_TYPES","validateBaseTrackMetadata","Output","supportedTrackCounts","presentTracksOfThisType","maxCount","maxTotalCount","supportedVideoCodecs","supportedAudioCodecs","supportedSubtitleCodecs","trackType","minCount","totalMinCount","setCanvasSize","findSequenceForTransition","encodeSequence","maxEndTime","endTime","totalFrames","videoSource","stepTime","setupCanvasRecording","origWidth","origHeight","origStyle","blob","setupCanvas","createVisibilityLoop","onTick","canvasEl","visible","lastTime","tick","setupScrollPassthrough","setupDemo","disposeControls","reportHeight"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80],"sources":["../../../../node_modules/bitecs/dist/core/index.min.mjs","../../../../node_modules/@multiplekex/shallot/src/core/scheduler.ts","../../../../node_modules/@multiplekex/shallot/src/core/runtime.ts","../../../../node_modules/@multiplekex/shallot/src/core/strings.ts","../../../../node_modules/@multiplekex/shallot/src/core/component.ts","../../../../node_modules/@multiplekex/shallot/src/core/state.ts","../../../../node_modules/@multiplekex/shallot/src/core/builder.ts","../../../../node_modules/@multiplekex/shallot/src/core/resource.ts","../../../../node_modules/@multiplekex/shallot/src/core/relation.ts","../../../../node_modules/@multiplekex/shallot/src/core/math.ts","../../../../node_modules/@multiplekex/shallot/src/core/xml.ts","../../../../node_modules/@multiplekex/shallot/src/standard/compute/graph.ts","../../../../node_modules/@multiplekex/shallot/src/standard/compute/index.ts","../../../../node_modules/@multiplekex/shallot/src/standard/activity/index.ts","../../../../node_modules/@multiplekex/shallot/src/standard/input/index.ts","../../../../node_modules/@multiplekex/shallot/src/standard/tween/easing.ts","../../../../node_modules/@multiplekex/shallot/src/standard/tween/sequence.ts","../../../../node_modules/@multiplekex/shallot/src/standard/tween/tween.ts","../../../../node_modules/@multiplekex/shallot/rust/transforms/pkg/shallot_transforms.js","../../../../node_modules/@multiplekex/shallot/src/standard/transforms/wasm.ts","../../../../node_modules/@multiplekex/shallot/src/standard/transforms/index.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/camera.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/light.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/indirect.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/mesh/box.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/mesh/sphere.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/mesh/plane.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/mesh/unified.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/mesh/index.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/surface/structs.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/surface/noise.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/surface/wgsl.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/surface/index.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/scene.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/bvh/structs.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/bvh/traverse.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/shaders.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/forward/raster.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/forward/index.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/depth.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/pass.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/postprocess.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/overlay.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/bvh/blas.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/bvh/radix.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/bvh/tlas.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/instance.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/data.ts","../../../../node_modules/@multiplekex/shallot/src/standard/render/index.ts","../../../../node_modules/@multiplekex/shallot/src/standard/loading/index.ts","../../../../node_modules/@multiplekex/shallot/src/standard/defaults.ts","../../../../node_modules/@multiplekex/shallot/src/extras/orbit/index.ts","../../../../node_modules/@multiplekex/shallot/src/extras/lines/index.ts","../../../../node_modules/@multiplekex/shallot/src/extras/arrows/index.ts","../../../../node_modules/@multiplekex/shallot/src/extras/text/font.ts","../../../../node_modules/@multiplekex/shallot/src/extras/text/sdf.ts","../../../../node_modules/@multiplekex/shallot/src/extras/text/index.ts","../../../../node_modules/@multiplekex/shallot/src/extras/gradient/index.ts","../../../../src/sequence/step-plugin.ts","../../../../src/sequence/ui.ts","../../../../node_modules/mediabunny/dist/modules/src/misc.js","../../../../node_modules/mediabunny/dist/modules/src/metadata.js","../../../../node_modules/mediabunny/dist/modules/src/codec.js","../../../../node_modules/mediabunny/dist/modules/src/codec-data.js","../../../../node_modules/mediabunny/dist/modules/src/custom-coder.js","../../../../node_modules/mediabunny/dist/modules/src/packet.js","../../../../node_modules/mediabunny/dist/modules/src/sample.js","../../../../node_modules/mediabunny/dist/modules/src/isobmff/isobmff-misc.js","../../../../node_modules/mediabunny/dist/modules/src/isobmff/isobmff-reader.js","../../../../node_modules/mediabunny/dist/modules/src/adts/adts-reader.js","../../../../node_modules/mediabunny/dist/modules/src/reader.js","../../../../node_modules/mediabunny/dist/modules/src/muxer.js","../../../../node_modules/mediabunny/dist/modules/src/subtitles.js","../../../../node_modules/mediabunny/dist/modules/src/isobmff/isobmff-boxes.js","../../../../node_modules/mediabunny/dist/modules/src/writer.js","../../../../node_modules/mediabunny/dist/modules/src/target.js","../../../../node_modules/mediabunny/dist/modules/src/isobmff/isobmff-muxer.js","../../../../node_modules/mediabunny/dist/modules/src/output-format.js","../../../../node_modules/mediabunny/dist/modules/src/encode.js","../../../../node_modules/mediabunny/dist/modules/src/media-source.js","../../../../node_modules/mediabunny/dist/modules/src/output.js","../../../../src/recording/core.ts","../../../../src/recording/canvas-recording.ts","../../../../src/sequence/canvas-setup.ts"],"sourcesContent":["var A=(e,t,n)=>Object.defineProperty(e,t,{value:n,enumerable:!1,writable:!0,configurable:!0});var pe=(e,t)=>t&e.entityMask,fe=(e,t)=>t>>>e.versionShift&(1<<e.versionBits)-1,Ke=(e,t)=>{let o=fe(e,t)+1&(1<<e.versionBits)-1;return t&e.entityMask|o<<e.versionShift},Xe=e=>({versioning:!0,versionBits:e}),z=e=>{let t=e?typeof e==\"function\"?e():e:{versioning:!1,versionBits:8},n=t.versionBits??8,o=t.versioning??!1,r=32-n,a=(1<<r)-1,i=r,s=(1<<n)-1<<i;return{aliveCount:0,dense:[],sparse:[],maxId:0,versioning:o,versionBits:n,entityMask:a,versionShift:i,versionMask:s}},ue=e=>{if(e.aliveCount<e.dense.length){let n=e.dense[e.aliveCount],o=n;return e.sparse[o]=e.aliveCount,e.aliveCount++,n}let t=++e.maxId;return e.dense.push(t),e.sparse[t]=e.aliveCount,e.aliveCount++,t},de=(e,t)=>{let n=e.sparse[t];if(n===void 0||n>=e.aliveCount)return;let o=e.aliveCount-1,r=e.dense[o];if(e.sparse[r]=n,e.dense[n]=r,e.sparse[t]=o,e.dense[o]=t,e.versioning){let a=Ke(e,t);e.dense[o]=a}e.aliveCount--},K=(e,t)=>{let n=pe(e,t),o=e.sparse[n];return o!==void 0&&o<e.aliveCount&&e.dense[o]===t};var u=Symbol.for(\"bitecs_internal\"),Ye=(e,t)=>A(e||{},u,{entityIndex:t||z(),entityMasks:[[]],entityComponents:new Map,bitflag:1,componentMap:new Map,componentCount:0,queries:new Set,queriesHashMap:new Map,notQueries:new Set,dirtyQueries:new Set,entitiesWithRelations:new Set,hierarchyData:new Map,hierarchyActiveRelations:new Set,hierarchyQueryCache:new Map});function Je(...e){let t,n;return e.forEach(o=>{typeof o==\"object\"&&\"dense\"in o&&\"sparse\"in o&&\"aliveCount\"in o?t=o:typeof o==\"object\"&&(n=o)}),Ye(n,t)}var Ze=e=>{let t=e[u];return t.entityIndex=z(),t.entityMasks=[[]],t.entityComponents=new Map,t.bitflag=1,t.componentMap=new Map,t.componentCount=0,t.queries=new Set,t.queriesHashMap=new Map,t.notQueries=new Set,t.dirtyQueries=new Set,t.entitiesWithRelations=new Set,t.hierarchyData=new Map,t.hierarchyActiveRelations=new Set,t.hierarchyQueryCache=new Map,e},et=e=>{delete e[u]},tt=e=>Array.from(e[u].componentMap.keys()),nt=e=>Array.from(e[u].entityComponents.keys());var M=()=>{let e=[],t=[],n=s=>e[t[s]]===s;return{add:s=>{n(s)||(t[s]=e.push(s)-1)},remove:s=>{if(!n(s))return;let p=t[s],c=e.pop();c!==s&&(e[p]=c,t[c]=p)},has:n,sparse:t,dense:e,reset:()=>{e.length=0,t.length=0},sort:s=>{e.sort(s);for(let p=0;p<e.length;p++)t[e[p]]=p}}},me=typeof SharedArrayBuffer<\"u\"?SharedArrayBuffer:ArrayBuffer,X=(e=1e3)=>{let t=[],n=0,o=new Uint32Array(new me(e*4)),r=c=>c<t.length&&t[c]<n&&o[t[c]]===c;return{add:c=>{if(!r(c)){if(n>=o.length){let f=new Uint32Array(new me(o.length*2*4));f.set(o),o=f}o[n]=c,t[c]=n,n++}},remove:c=>{if(!r(c))return;n--;let f=t[c],d=o[n];o[f]=d,t[d]=f},has:r,sparse:t,get dense(){return new Uint32Array(o.buffer,0,n)},reset:()=>{n=0,t.length=0},sort:c=>{let f=Array.from(o.subarray(0,n));f.sort(c);for(let d=0;d<f.length;d++)o[d]=f[d];for(let d=0;d<n;d++)t[o[d]]=d}}};var P=()=>{let e=new Set;return{subscribe:o=>(e.add(o),()=>{e.delete(o)}),notify:(o,...r)=>Array.from(e).reduce((a,i)=>{let s=i(o,...r);return s&&typeof s==\"object\"?{...a,...s}:a},{})}};var k=Symbol.for(\"bitecs-relation\"),T=Symbol.for(\"bitecs-pairTarget\"),U=Symbol.for(\"bitecs-isPairComponent\"),x=Symbol.for(\"bitecs-relationData\"),Y=()=>{let e={pairsMap:new Map,initStore:void 0,exclusiveRelation:!1,autoRemoveSubject:!1,onTargetRemoved:void 0},t=n=>{if(n===void 0)throw Error(\"Relation target is undefined\");let o=n===\"*\"?y:n;if(!e.pairsMap.has(o)){let r=e.initStore?e.initStore(n):{};A(r,k,t),A(r,T,o),A(r,U,!0),e.pairsMap.set(o,r)}return e.pairsMap.get(o)};return A(t,x,e),t},ye=e=>t=>{let n=t[x];return n.initStore=e,t},le=e=>{let t=e[x];return t.exclusiveRelation=!0,e},he=e=>{let t=e[x];return t.autoRemoveSubject=!0,e},be=e=>t=>{let n=t[x];return n.onTargetRemoved=e,t};var b=(e,t)=>{if(e===void 0)throw Error(\"Relation is undefined\");return e(t)},I=(e,t,n)=>{let o=L(e,t),r=[];for(let a of o)a[k]===n&&a[T]!==y&&!xe(a[T])&&r.push(a[T]);return r};function ot(...e){if(e.length===1&&typeof e[0]==\"object\"){let{store:t,exclusive:n,autoRemoveSubject:o,onTargetRemoved:r}=e[0];return[t&&ye(t),n&&le,o&&he,r&&be(r)].filter(Boolean).reduce((i,s)=>s(i),Y())}else return e.reduce((n,o)=>o(n),Y())}var Re=Symbol.for(\"bitecs-wildcard\");function rt(){let e=Y();return Object.defineProperty(e,Re,{value:!0,enumerable:!1,writable:!1,configurable:!1}),e}function at(){let e=Symbol.for(\"bitecs-global-wildcard\");return globalThis[e]||(globalThis[e]=rt()),globalThis[e]}var y=at();function st(){return Y()}function it(){let e=Symbol.for(\"bitecs-global-isa\");return globalThis[e]||(globalThis[e]=st()),globalThis[e]}var B=it();function ct(e){return e?Object.getOwnPropertySymbols(e).includes(Re):!1}function xe(e){return e?Object.getOwnPropertySymbols(e).includes(x):!1}var pt=64,g=4294967295,ge=1024;function ve(e,t){let{depths:n}=e;if(t<n.length)return n;let o=Math.max(t+1,n.length*2,n.length+ge),r=new Uint32Array(o);return r.fill(g),r.set(n),e.depths=r,r}function Ce(e,t,n,o){let{depthToEntities:r}=e;if(o!==void 0&&o!==g){let a=r.get(o);a&&(a.remove(t),a.dense.length===0&&r.delete(o))}n!==g&&(r.has(n)||r.set(n,X()),r.get(n).add(t))}function ft(e,t){t>e.maxDepth&&(e.maxDepth=t)}function ne(e,t,n,o){e.depths[t]=n,Ce(e,t,n,o),ft(e,n)}function Te(e,t){e[u].hierarchyQueryCache.delete(t)}function Z(e,t){let n=e[u];return n.hierarchyActiveRelations.has(t)||(n.hierarchyActiveRelations.add(t),oe(e,t),ut(e,t)),n.hierarchyData.get(t)}function ut(e,t){let n=$(e,[b(t,y)]);for(let r of n)te(e,t,r);let o=new Set;for(let r of n)for(let a of I(e,r,t))o.has(a)||(o.add(a),te(e,t,a))}function oe(e,t){let n=e[u];if(!n.hierarchyData.has(t)){let o=Math.max(ge,n.entityIndex.dense.length*2),r=new Uint32Array(o);r.fill(g),n.hierarchyData.set(t,{depths:r,dirty:M(),depthToEntities:new Map,maxDepth:0})}}function Ie(e,t,n,o=new Set){if(o.has(n))return 0;o.add(n);let r=I(e,n,t);if(r.length===0)return 0;if(r.length===1)return J(e,t,r[0],o)+1;let a=1/0;for(let i of r){let s=J(e,t,i,o);if(s<a&&(a=s,a===0))break}return a===1/0?0:a+1}function J(e,t,n,o){let r=e[u];oe(e,t);let a=r.hierarchyData.get(t),{depths:i}=a;if(i=ve(a,n),i[n]===g){let s=Ie(e,t,n,o);return ne(a,n,s),s}return i[n]}function te(e,t,n){return J(e,t,n,new Set)}function Ee(e,t,n,o,r=M()){if(r.has(n))return;r.add(n);let a=$(e,[t(n)]);for(let i of a)o.add(i),Ee(e,t,i,o,r)}function We(e,t,n,o,r=new Set){let a=e[u];if(!a.hierarchyActiveRelations.has(t))return;oe(e,t);let i=a.hierarchyData.get(t);if(r.has(n)){i.dirty.add(n);return}r.add(n);let{depths:s,dirty:p}=i,c=o!==void 0?te(e,t,o)+1:0;if(c>pt)return;let f=s[n];ne(i,n,c,f===g?void 0:f),f!==c&&(Ee(e,t,n,p,M()),Te(e,t))}function Se(e,t,n){let o=e[u];if(!o.hierarchyActiveRelations.has(t))return;let r=o.hierarchyData.get(t),{depths:a}=r;a=ve(r,n),Me(e,t,n,a,M()),Te(e,t)}function Me(e,t,n,o,r){if(r.has(n))return;r.add(n);let i=e[u].hierarchyData.get(t);if(n<o.length){let p=o[n];p!==g&&(i.depths[n]=g,Ce(i,n,g,p))}let s=$(e,[t(n)]);for(let p of s)Me(e,t,p,o,r)}function De(e,t){let o=e[u].hierarchyData.get(t);if(!o)return;let{dirty:r,depths:a}=o;if(r.dense.length!==0){for(let i of r.dense)if(a[i]===g){let s=Ie(e,t,i);ne(o,i,s)}r.reset()}}function Oe(e,t,n,o={}){let r=e[u];Z(e,t);let a=H(e,[t,...n]),i=r.hierarchyQueryCache.get(t);if(i&&i.hash===a)return i.result;De(e,t),re(e,n,o);let s=r.queriesHashMap.get(H(e,n)),p=r.hierarchyData.get(t),{depths:c}=p;s.sort((d,W)=>{let l=c[d],R=c[W];return l!==R?l-R:d-W});let f=(o.buffered,s.dense);return r.hierarchyQueryCache.set(t,{hash:a,result:f}),f}function Qe(e,t,n,o={}){let r=Z(e,t);De(e,t);let a=r.depthToEntities.get(n);return a?(o.buffered,a.dense):o.buffered?new Uint32Array(0):[]}function dt(e,t,n){return Z(e,n),J(e,n,t,new Set)}function mt(e,t){return Z(e,t).maxDepth}var v=Symbol.for(\"bitecs-opType\"),D=Symbol.for(\"bitecs-opTerms\"),se=e=>(...t)=>({[v]:e,[D]:t}),Ae=se(\"Or\"),ke=se(\"And\"),He=se(\"Not\"),yt=Ae,lt=ke,ht=He,ae=Symbol.for(\"bitecs-hierarchyType\"),$e=Symbol.for(\"bitecs-hierarchyRel\"),qe=Symbol.for(\"bitecs-hierarchyDepth\"),je=(e,t)=>({[ae]:\"Hierarchy\",[$e]:e,[qe]:t}),bt=je,F=Symbol.for(\"bitecs-modifierType\"),Rt={[F]:\"buffer\"},Pe={[F]:\"nested\"},ie=Pe,Ue=e=>(...t)=>({[v]:e,[D]:t}),xt=Ue(\"add\"),gt=Ue(\"remove\"),vt=e=>({[v]:\"set\",[D]:[e]}),Ct=e=>({[v]:\"get\",[D]:[e]});function Tt(e,t,n){let o=e[u],{[v]:r,[D]:a}=t;if(r===\"add\"||r===\"remove\")return(o.queriesHashMap.get(H(e,a))||ee(e,a))[r===\"add\"?\"addObservable\":\"removeObservable\"].subscribe(n);if(r===\"set\"||r===\"get\"){if(a.length!==1)throw new Error(\"Set and Get hooks can only observe a single component\");return(o.componentMap.get(a[0])||E(e,a[0]))[r===\"set\"?\"setObservable\":\"getObservable\"].subscribe(n)}throw new Error(`Invalid hook type: ${r}`)}var H=(e,t)=>{let n=e[u],o=a=>(n.componentMap.has(a)||E(e,a),n.componentMap.get(a).id),r=a=>v in a?`${a[v].toLowerCase()}(${a[D].map(r).sort().join(\",\")})`:o(a).toString();return t.map(r).sort().join(\"-\")},ee=(e,t,n={})=>{let o=e[u],r=H(e,t),a=[],i=m=>{v in m?m[D].forEach(i):(o.componentMap.has(m)||E(e,m),a.push(m))};t.forEach(i);let s=[],p=[],c=[],f=(m,h)=>{h.forEach(S=>{o.componentMap.has(S)||E(e,S),m.push(S)})};t.forEach(m=>{if(v in m){let{[v]:h,[D]:S}=m;if(h===\"Not\")f(p,S);else if(h===\"Or\")f(c,S);else if(h===\"And\")f(s,S);else throw new Error(`Nested combinator ${h} not supported yet - use simple queries for best performance`)}else o.componentMap.has(m)||E(e,m),s.push(m)});let d=a.map(m=>o.componentMap.get(m)),W=[...new Set(d.map(m=>m.generationId))],l=(m,h)=>(m[h.generationId]=(m[h.generationId]||0)|h.bitflag,m),R=s.map(m=>o.componentMap.get(m)).reduce(l,{}),_e=p.map(m=>o.componentMap.get(m)).reduce(l,{}),Ge=c.map(m=>o.componentMap.get(m)).reduce(l,{}),ze=d.reduce(l,{}),Q=Object.assign(n.buffered?X():M(),{allComponents:a,orComponents:c,notComponents:p,masks:R,notMasks:_e,orMasks:Ge,hasMasks:ze,generations:W,toRemove:M(),addObservable:P(),removeObservable:P(),queues:{}});o.queries.add(Q),o.queriesHashMap.set(r,Q),d.forEach(m=>{m.queries.add(Q)}),p.length&&o.notQueries.add(Q);let ce=o.entityIndex;for(let m=0;m<ce.aliveCount;m++){let h=ce.dense[m];if(O(e,h,q))continue;V(e,Q,h)&&w(Q,h)}return Q};function re(e,t,n={}){let o=e[u],r=H(e,t),a=o.queriesHashMap.get(r);return a?n.buffered&&!(\"buffer\"in a.dense)&&(a=ee(e,t,{buffered:!0})):a=ee(e,t,n),n.buffered,a.dense}function $(e,t,...n){let o=t.find(p=>p&&typeof p==\"object\"&&ae in p),r=t.filter(p=>!(p&&typeof p==\"object\"&&ae in p)),a=!1,i=!0,s=n.some(p=>p&&typeof p==\"object\"&&F in p);for(let p of n)if(s&&p&&typeof p==\"object\"&&F in p){let c=p;c[F]===\"buffer\"&&(a=!0),c[F]===\"nested\"&&(i=!1)}else if(!s){let c=p;c.buffered!==void 0&&(a=c.buffered),c.commit!==void 0&&(i=c.commit)}if(o){let{[$e]:p,[qe]:c}=o;return c!==void 0?Qe(e,p,c,{buffered:a}):Oe(e,p,r,{buffered:a})}return i&&Be(e),re(e,r,{buffered:a})}function V(e,t,n){let o=e[u],{masks:r,notMasks:a,orMasks:i,generations:s}=t,p=Object.keys(i).length===0;for(let c=0;c<s.length;c++){let f=s[c],d=r[f],W=a[f],l=i[f],R=o.entityMasks[f][n];if(W&&R&W||d&&(R&d)!==d)return!1;l&&R&l&&(p=!0)}return p}var w=(e,t)=>{if(e.toRemove.has(t)){e.toRemove.remove(t),e.addObservable.notify(t);return}e.has(t)||(e.add(t),e.addObservable.notify(t))},It=e=>{for(let t=0;t<e.toRemove.dense.length;t++){let n=e.toRemove.dense[t];e.remove(n)}e.toRemove.reset()},Be=e=>{let t=e[u];t.dirtyQueries.size&&(t.dirtyQueries.forEach(It),t.dirtyQueries.clear())},_=(e,t,n)=>{let o=e[u];!t.has(n)||t.toRemove.has(n)||(t.toRemove.add(n),o.dirtyQueries.add(t),t.removeObservable.notify(n))},Et=(e,t)=>{let n=e[u],o=H(e,t),r=n.queriesHashMap.get(o);r&&(n.queries.delete(r),n.queriesHashMap.delete(o))};var E=(e,t)=>{if(!t)throw new Error(\"bitECS - Cannot register null or undefined component\");let n=e[u],o=new Set,r={id:n.componentCount++,generationId:n.entityMasks.length-1,bitflag:n.bitflag,ref:t,queries:o,setObservable:P(),getObservable:P()};return n.componentMap.set(t,r),n.bitflag*=2,n.bitflag>=2**31&&(n.bitflag=1,n.entityMasks.push([])),r},Wt=(e,t)=>{t.forEach(n=>E(e,n))},O=(e,t,n)=>{let o=e[u],r=o.componentMap.get(n);if(!r)return!1;let{generationId:a,bitflag:i}=r;return(o.entityMasks[a][t]&i)===i},Fe=(e,t,n)=>{let r=e[u].componentMap.get(n);if(r&&O(e,t,n))return r.getObservable.notify(t)},Ve=(e,t)=>({component:e,data:t}),we=(e,t,n,o,r=new Set)=>{if(!r.has(o)){r.add(o),j(t,n,B(o));for(let a of L(t,o))if(a!==q&&!O(t,n,a)){j(t,n,a);let i=e.componentMap.get(a);if(i?.setObservable){let s=Fe(t,o,a);i.setObservable.notify(n,s)}}for(let a of I(t,o,B))we(e,t,n,a,r)}},St=(e,t,n,o)=>{j(e,t,Ve(n,o))},j=(e,t,n)=>{if(!N(e,t))throw new Error(`Cannot add component - entity ${t} does not exist in the world.`);let o=e[u],r=\"component\"in n?n.component:n,a=\"data\"in n?n.data:void 0;o.componentMap.has(r)||E(e,r);let i=o.componentMap.get(r);if(O(e,t,r))return a!==void 0&&i.setObservable.notify(t,a),!1;let{generationId:s,bitflag:p,queries:c}=i;if(o.entityMasks[s][t]|=p,O(e,t,q)||c.forEach(f=>{V(e,f,t)?w(f,t):_(e,f,t)}),o.entityComponents.get(t).add(r),a!==void 0&&i.setObservable.notify(t,a),r[U]){let f=r[k],d=r[T];if(G(e,t,b(f,y),b(y,d)),typeof d==\"number\"&&(G(e,d,b(y,t),b(y,f)),o.entitiesWithRelations.add(d),o.entitiesWithRelations.add(t)),o.entitiesWithRelations.add(d),f[x].exclusiveRelation===!0&&d!==y){let l=I(e,t,f)[0];l!=null&&l!==d&&C(e,t,f(l))}if(f===B){let l=I(e,t,B);for(let R of l)we(o,e,t,R)}We(e,f,t,typeof d==\"number\"?d:void 0)}return!0};function G(e,t,...n){(Array.isArray(n[0])?n[0]:n).forEach(r=>{j(e,t,r)})}var C=(e,t,...n)=>{let o=e[u];if(!N(e,t))throw new Error(`Cannot remove component - entity ${t} does not exist in the world.`);n.forEach(r=>{if(!O(e,t,r))return;let a=o.componentMap.get(r),{generationId:i,bitflag:s,queries:p}=a;if(o.entityMasks[i][t]&=~s,p.forEach(c=>{c.toRemove.remove(t),V(e,c,t)?w(c,t):_(e,c,t)}),o.entityComponents.get(t).delete(r),r[U]){let c=r[T],f=r[k];Se(e,f,t),C(e,t,b(y,c)),typeof c==\"number\"&&N(e,c)&&(C(e,c,b(y,t)),C(e,c,b(y,f))),I(e,t,f).length===0&&C(e,t,b(f,y))}})},Mt=C;var q={},Dt=e=>{let t=Ne(e);return j(e,t,q),t};function Ne(e,...t){let n=e[u],o=ue(n.entityIndex);return n.notQueries.forEach(r=>{V(e,r,o)&&w(r,o)}),n.entityComponents.set(o,new Set),t.length>0&&G(e,o,t),o}var Le=(e,t)=>{let n=e[u];if(!K(n.entityIndex,t))return;let o=[t],r=new Set;for(;o.length>0;){let a=o.shift();if(r.has(a))continue;r.add(a);let i=[];if(n.entitiesWithRelations.has(a)){for(let s of $(e,[y(a)],ie))if(N(e,s))for(let p of n.entityComponents.get(s)){if(!p[U])continue;let f=p[k][x];i.push(()=>C(e,s,b(y,a))),p[T]===a&&(i.push(()=>C(e,s,p)),f.autoRemoveSubject&&o.push(s),f.onTargetRemoved&&i.push(()=>f.onTargetRemoved(e,s,a)))}n.entitiesWithRelations.delete(a)}for(let s of i)s();for(let s of o)Le(e,s);for(let s of n.queries)_(e,s,a);de(n.entityIndex,a),n.entityComponents.delete(a);for(let s=0;s<n.entityMasks.length;s++)n.entityMasks[s][a]=0}},L=(e,t)=>{let n=e[u];if(t===void 0)throw new Error(\"getEntityComponents: entity id is undefined.\");if(!K(n.entityIndex,t))throw new Error(`getEntityComponents: entity ${t} does not exist in the world.`);return Array.from(n.entityComponents.get(t))},N=(e,t)=>K(e[u].entityIndex,t);var Ot=(...e)=>(...t)=>e.reduce((n,o)=>[o(...n)],t)[0];var Qt=e=>e;function At(e){let t=[];return e?Object.assign(t,e):t}export{u as $internal,lt as All,ke as And,yt as Any,bt as Cascade,je as Hierarchy,B as IsA,ht as None,He as Not,Ae as Or,b as Pair,q as Prefab,y as Wildcard,j as addComponent,G as addComponents,Ne as addEntity,Dt as addPrefab,At as aos,Rt as asBuffer,Be as commitRemovals,z as createEntityIndex,ot as createRelation,Je as createWorld,et as deleteWorld,N as entityExists,nt as getAllEntities,Fe as getComponent,L as getEntityComponents,dt as getHierarchyDepth,pe as getId,mt as getMaxHierarchyDepth,I as getRelationTargets,fe as getVersion,tt as getWorldComponents,O as hasComponent,Pe as isNested,xe as isRelation,ct as isWildcard,le as makeExclusive,ie as noCommit,Tt as observe,xt as onAdd,Ct as onGet,gt as onRemove,vt as onSet,Ot as pipe,$ as query,E as registerComponent,Wt as registerComponents,ee as registerQuery,C as removeComponent,Mt as removeComponents,Le as removeEntity,Et as removeQuery,Ze as resetWorld,Ve as set,St as setComponent,Qt as soa,he as withAutoRemoveSubject,be as withOnTargetRemoved,ye as withStore,Xe as withVersioning};\n//# sourceMappingURL=index.min.mjs.map\n","import type { State } from \"./state\";\n\nexport class CycleError extends Error {\n    constructor(message = \"Circular dependency detected\") {\n        super(message);\n        this.name = \"CycleError\";\n    }\n}\n\nexport function toposort<T>(nodes: T[], edges: [T, T][]): T[] {\n    if (nodes.length === 0) return [];\n\n    const graph = new Map<T, Set<T>>();\n    const inDegree = new Map<T, number>();\n\n    for (const node of nodes) {\n        graph.set(node, new Set());\n        inDegree.set(node, 0);\n    }\n\n    for (const [from, to] of edges) {\n        if (!graph.has(from) || !graph.has(to)) continue;\n        graph.get(from)!.add(to);\n        inDegree.set(to, inDegree.get(to)! + 1);\n    }\n\n    detectCycle(nodes, graph);\n\n    const queue: T[] = [];\n    const sorted: T[] = [];\n\n    for (const node of nodes) {\n        if (inDegree.get(node) === 0) queue.push(node);\n    }\n\n    while (queue.length > 0) {\n        const node = queue.shift()!;\n        sorted.push(node);\n\n        for (const dep of graph.get(node)!) {\n            const newDegree = inDegree.get(dep)! - 1;\n            inDegree.set(dep, newDegree);\n            if (newDegree === 0) queue.push(dep);\n        }\n    }\n\n    return sorted;\n}\n\nfunction detectCycle<T>(nodes: T[], graph: Map<T, Set<T>>): void {\n    const visited = new Set<T>();\n    const stack = new Set<T>();\n\n    function hasCycle(node: T): boolean {\n        if (stack.has(node)) return true;\n        if (visited.has(node)) return false;\n\n        visited.add(node);\n        stack.add(node);\n\n        for (const dep of graph.get(node)!) {\n            if (hasCycle(dep)) return true;\n        }\n\n        stack.delete(node);\n        return false;\n    }\n\n    for (const node of nodes) {\n        if (hasCycle(node)) throw new CycleError();\n    }\n}\n\nexport const Time = {\n    FIXED_DT: 1 / 50,\n    DEFAULT_DT: 1 / 60,\n} as const;\n\nexport interface GameTime {\n    deltaTime: number;\n    fixedDeltaTime: number;\n    elapsed: number;\n}\n\nexport type SystemGroup = \"setup\" | \"fixed\" | \"simulation\" | \"draw\";\n\nexport interface System {\n    readonly update?: (state: State) => void;\n    readonly setup?: (state: State) => void;\n    readonly dispose?: (state: State) => void;\n    readonly group?: SystemGroup;\n    readonly first?: boolean;\n    readonly last?: boolean;\n    readonly before?: readonly System[];\n    readonly after?: readonly System[];\n}\n\nexport class OrderingError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"OrderingError\";\n    }\n}\n\nexport class Scheduler {\n    private readonly _systems = new Set<System>();\n    private _systemsVersion = 0;\n    private _accumulator = 0;\n    private readonly _initialized = new WeakSet<System>();\n    private _cache = new Map<SystemGroup, System[]>();\n    private _cacheVersion = -1;\n    private _time: GameTime = {\n        deltaTime: 0,\n        fixedDeltaTime: Time.FIXED_DT,\n        elapsed: 0,\n    };\n\n    get systems(): ReadonlySet<System> {\n        return this._systems;\n    }\n\n    get systemsVersion(): number {\n        return this._systemsVersion;\n    }\n\n    get accumulator(): number {\n        return this._accumulator;\n    }\n\n    get time(): Readonly<GameTime> {\n        return this._time;\n    }\n\n    register(system: System): void {\n        this._systems.add(system);\n        this._systemsVersion++;\n    }\n\n    unregister(system: System): void {\n        if (this._systems.delete(system)) {\n            this._systemsVersion++;\n        }\n    }\n\n    step(state: State, deltaTime = Time.DEFAULT_DT): void {\n        const fixedDt = Time.FIXED_DT;\n\n        this._time.deltaTime = deltaTime;\n        this._time.elapsed += deltaTime;\n        this._accumulator += deltaTime;\n\n        this.runGroup(state, \"setup\");\n\n        while (this._accumulator >= fixedDt) {\n            this._time.deltaTime = fixedDt;\n            this.runGroup(state, \"fixed\");\n            this._accumulator -= fixedDt;\n        }\n\n        this._time.deltaTime = deltaTime;\n        this.runGroup(state, \"simulation\");\n        this.runGroup(state, \"draw\");\n    }\n\n    private runGroup(state: State, group: SystemGroup): void {\n        for (const system of this.getSorted(group)) {\n            if (!this._initialized.has(system)) {\n                system.setup?.(state);\n                this._initialized.add(system);\n            }\n            system.update?.(state);\n        }\n    }\n\n    private getSorted(group: SystemGroup): System[] {\n        if (this._systemsVersion !== this._cacheVersion) {\n            this._cache.clear();\n            this._cacheVersion = this._systemsVersion;\n        }\n\n        const cached = this._cache.get(group);\n        if (cached) return cached;\n\n        const all = Array.from(this._systems);\n        const filtered = all.filter((s) => (s.group ?? \"simulation\") === group);\n        const sorted = sortSystems(filtered, all);\n        this._cache.set(group, sorted);\n        return sorted;\n    }\n}\n\nfunction sortSystems(systems: System[], allSystems?: System[]): System[] {\n    const all = allSystems ?? systems;\n    validateSystems(systems, all);\n\n    const first = systems.filter((s) => s.first);\n    const last = systems.filter((s) => s.last);\n    const normal = systems.filter((s) => !s.first && !s.last);\n\n    return [\n        ...toposort(first, buildEdges(first)),\n        ...toposort(normal, buildEdges(normal)),\n        ...toposort(last, buildEdges(last)),\n    ];\n}\n\nfunction buildEdges(systems: System[]): [System, System][] {\n    const edges: [System, System][] = [];\n    for (const system of systems) {\n        for (const target of system.before ?? []) {\n            if (systems.includes(target)) edges.push([system, target]);\n        }\n        for (const target of system.after ?? []) {\n            if (systems.includes(target)) edges.push([target, system]);\n        }\n    }\n    return edges;\n}\n\nfunction validateSystems(systems: System[], all: System[]): void {\n    for (const s of systems) {\n        if (s.first && s.last) {\n            throw new OrderingError(\"System cannot have both first and last constraints\");\n        }\n\n        const group = s.group ?? \"simulation\";\n        for (const ref of s.before ?? []) checkGroup(ref, group, all);\n        for (const ref of s.after ?? []) checkGroup(ref, group, all);\n    }\n}\n\nfunction checkGroup(ref: System, group: string, all: System[]): void {\n    if (!all.includes(ref)) return;\n    const refGroup = ref.group ?? \"simulation\";\n    if (refGroup !== group) {\n        throw new OrderingError(`Cross-group constraint: ${group} references ${refGroup}`);\n    }\n}\n","export type RuntimeTarget = \"headless\" | \"standalone\" | \"web\";\n\nexport interface Runtime {\n    readonly target: RuntimeTarget;\n    readFile(path: string): Promise<string>;\n    readBinary(path: string): Promise<ArrayBuffer>;\n    requestFrame(callback: () => void): void;\n    now(): number;\n}\n\ndeclare const __TAURI_INTERNALS__: unknown;\ndeclare const Bun: unknown;\n\nexport function detectTarget(): RuntimeTarget {\n    if (typeof __TAURI_INTERNALS__ !== \"undefined\") {\n        return \"standalone\";\n    }\n\n    if (typeof Bun !== \"undefined\") {\n        return \"headless\";\n    }\n\n    if (typeof window !== \"undefined\" && typeof fetch === \"function\") {\n        return \"web\";\n    }\n\n    throw new Error(\"Unknown runtime environment\");\n}\n\nfunction createWebRuntime(): Runtime {\n    return {\n        target: \"web\",\n\n        async readFile(path: string): Promise<string> {\n            const response = await fetch(path);\n            if (!response.ok) {\n                throw new Error(`Failed to load ${path}: ${response.status}`);\n            }\n            return response.text();\n        },\n\n        async readBinary(path: string): Promise<ArrayBuffer> {\n            const response = await fetch(path);\n            if (!response.ok) {\n                throw new Error(`Failed to load ${path}: ${response.status}`);\n            }\n            return response.arrayBuffer();\n        },\n\n        requestFrame(callback: () => void): void {\n            requestAnimationFrame(callback);\n        },\n\n        now(): number {\n            return performance.now();\n        },\n    };\n}\n\nfunction createHeadlessRuntime(): Runtime {\n    return {\n        target: \"headless\",\n\n        async readFile(path: string): Promise<string> {\n            const file = (\n                Bun as {\n                    file: (path: string) => {\n                        text: () => Promise<string>;\n                        arrayBuffer: () => Promise<ArrayBuffer>;\n                    };\n                }\n            ).file(path);\n            return file.text();\n        },\n\n        async readBinary(path: string): Promise<ArrayBuffer> {\n            const file = (\n                Bun as {\n                    file: (path: string) => {\n                        text: () => Promise<string>;\n                        arrayBuffer: () => Promise<ArrayBuffer>;\n                    };\n                }\n            ).file(path);\n            return file.arrayBuffer();\n        },\n\n        requestFrame(callback: () => void): void {\n            setTimeout(callback, 0);\n        },\n\n        now(): number {\n            return performance.now();\n        },\n    };\n}\n\nfunction isWebviewResource(path: string): boolean {\n    return path.startsWith(\"/\") || path.startsWith(\"./\") || path.startsWith(\"../\");\n}\n\nconst TAURI_FS_MODULE = \"@tauri-apps/\" + \"plugin-fs\";\n\nfunction createStandaloneRuntime(): Runtime {\n    return {\n        target: \"standalone\",\n\n        async readFile(path: string): Promise<string> {\n            if (isWebviewResource(path)) {\n                const response = await fetch(path);\n                if (!response.ok) {\n                    throw new Error(`Failed to load ${path}: ${response.status}`);\n                }\n                return response.text();\n            }\n            // @ts-ignore - Tauri plugin only available in Tauri context\n            const { readTextFile } = await import(/* @vite-ignore */ TAURI_FS_MODULE);\n            return readTextFile(path);\n        },\n\n        async readBinary(path: string): Promise<ArrayBuffer> {\n            if (isWebviewResource(path)) {\n                const response = await fetch(path);\n                if (!response.ok) {\n                    throw new Error(`Failed to load ${path}: ${response.status}`);\n                }\n                return response.arrayBuffer();\n            }\n            // @ts-ignore - Tauri plugin only available in Tauri context\n            const { readFile } = await import(/* @vite-ignore */ TAURI_FS_MODULE);\n            const bytes = await readFile(path);\n            return bytes.buffer;\n        },\n\n        requestFrame(callback: () => void): void {\n            requestAnimationFrame(callback);\n        },\n\n        now(): number {\n            return performance.now();\n        },\n    };\n}\n\nlet _runtime: Runtime | undefined;\n\nasync function createRuntime(): Promise<Runtime> {\n    const target = detectTarget();\n\n    switch (target) {\n        case \"headless\":\n            return createHeadlessRuntime();\n        case \"standalone\":\n            return createStandaloneRuntime();\n        case \"web\":\n            return createWebRuntime();\n    }\n}\n\nlet _initPromise: Promise<Runtime> | undefined;\n\nexport function getRuntime(): Runtime {\n    if (_runtime) return _runtime;\n\n    if (!_initPromise) {\n        _initPromise = createRuntime().then((r) => {\n            _runtime = r;\n            return r;\n        });\n    }\n\n    throw new Error(\"Runtime not initialized. Call initRuntime() first.\");\n}\n\nexport async function initRuntime(): Promise<Runtime> {\n    if (_runtime) return _runtime;\n\n    if (!_initPromise) {\n        _initPromise = createRuntime();\n    }\n\n    _runtime = await _initPromise;\n    return _runtime;\n}\n\nexport function resetRuntime(): void {\n    _runtime = undefined;\n    _initPromise = undefined;\n}\n","export function toKebabCase(str: string): string {\n    return str\n        .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n        .replace(/[\\s_]+/g, \"-\")\n        .toLowerCase();\n}\n\nexport function toCamelCase(str: string): string {\n    return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n","import { toKebabCase } from \"./strings\";\n\nexport type ComponentArray = number[] | Float32Array | Uint32Array;\nexport type ComponentData = Record<string, ComponentArray>;\nexport type ComponentLike = Record<string, unknown>;\n\nexport interface FieldAccessor {\n    get(eid: number): number;\n    set(eid: number, value: number): void;\n}\n\nexport interface ComponentTraits {\n    defaults?: () => Record<string, number>;\n    adapter?: (attrs: Record<string, string>, eid: number) => Record<string, number>;\n}\n\nconst traitsMap = new WeakMap<ComponentLike, ComponentTraits>();\n\nexport function setTraits(component: ComponentLike, traits: ComponentTraits): void {\n    traitsMap.set(component, traits);\n}\n\nexport function getTraits(component: ComponentLike): ComponentTraits | undefined {\n    return traitsMap.get(component);\n}\n\nexport interface RegisteredComponent {\n    readonly component: ComponentLike;\n    readonly name: string;\n    readonly traits?: ComponentTraits;\n}\n\nconst registry = new Map<string, RegisteredComponent>();\n\nexport function registerComponent(name: string, component: ComponentLike): void {\n    const kebabName = toKebabCase(name);\n    const traits = traitsMap.get(component);\n    registry.set(kebabName, { component, name: kebabName, traits });\n}\n\nexport function getRegisteredComponent(name: string): RegisteredComponent | undefined {\n    return registry.get(toKebabCase(name));\n}\n\nexport function clearRegistry(): void {\n    registry.clear();\n}\n\nexport interface FieldProxy extends Array<number>, FieldAccessor {}\n\nexport function createFieldProxy(data: Float32Array, stride: number, offset: number): FieldProxy {\n    function getValue(eid: number): number {\n        return data[eid * stride + offset];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * stride + offset] = value;\n    }\n\n    return new Proxy([] as unknown as FieldProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n","import {\n    addComponent,\n    addEntity,\n    createWorld,\n    entityExists,\n    getAllEntities,\n    getComponent,\n    getEntityComponents,\n    getRelationTargets,\n    hasComponent,\n    query,\n    removeComponent,\n    removeComponents,\n    removeEntity,\n    type ComponentRef,\n    type World,\n} from \"bitecs\";\nimport { Scheduler, Time, type GameTime, type System } from \"./scheduler\";\nimport type { RelationDef } from \"./relation\";\nimport type { Plugin, StateBuilder } from \"./builder\";\nimport { initRuntime, type Runtime } from \"./runtime\";\nimport { registerComponent, getTraits, type ComponentData } from \"./component\";\nimport { type ResourceKey } from \"./resource\";\n\nexport const MAX_ENTITIES = 65536;\n\nexport class State {\n    readonly world: World;\n    readonly scheduler = new Scheduler();\n\n    private _resources = new Map<symbol, unknown>();\n    private _disposed = false;\n    private _running = false;\n    private _runtime: Runtime | null = null;\n    private _lastTime = 0;\n    private _maxEid = 0;\n\n    get time(): Readonly<GameTime> {\n        return this.scheduler.time;\n    }\n\n    get running(): boolean {\n        return this._running;\n    }\n\n    get maxEid(): number {\n        return this._maxEid;\n    }\n\n    static Builder: (new () => StateBuilder) | null = null;\n\n    static new(): StateBuilder {\n        if (!State.Builder) {\n            throw new Error(\"StateBuilder not injected. Import from 'shallot' or 'shallot/core'.\");\n        }\n        return new State.Builder();\n    }\n\n    constructor() {\n        this.world = createWorld();\n    }\n\n    setResource<T>(key: ResourceKey<T>, value: T): void {\n        this._resources.set(key, value);\n    }\n\n    getResource<T>(key: ResourceKey<T>): T | undefined {\n        return this._resources.get(key) as T | undefined;\n    }\n\n    deleteResource<T>(key: ResourceKey<T>): boolean {\n        return this._resources.delete(key);\n    }\n\n    async start(runtime?: Runtime): Promise<void> {\n        if (this._running) return;\n        this._runtime = runtime ?? (await initRuntime());\n        this._running = true;\n        this._lastTime = this._runtime.now();\n        this.scheduleFrame();\n    }\n\n    stop(): void {\n        this._running = false;\n    }\n\n    private scheduleFrame(): void {\n        if (!this._running || !this._runtime) return;\n        this._runtime.requestFrame(() => this.tick());\n    }\n\n    private tick(): void {\n        if (!this._running || !this._runtime) return;\n        const now = this._runtime.now();\n        const dt = (now - this._lastTime) / 1000;\n        this._lastTime = now;\n        this.step(dt);\n        this.scheduleFrame();\n    }\n\n    register(pluginOrSystem: Plugin | System): void {\n        if (\n            \"update\" in pluginOrSystem ||\n            \"setup\" in pluginOrSystem ||\n            \"dispose\" in pluginOrSystem\n        ) {\n            this.scheduler.register(pluginOrSystem as System);\n        } else {\n            const plugin = pluginOrSystem as Plugin;\n            if (plugin.components) {\n                for (const [name, component] of Object.entries(plugin.components)) {\n                    registerComponent(name, component);\n                }\n            }\n            if (plugin.systems) {\n                for (const system of plugin.systems) {\n                    this.scheduler.register(system);\n                }\n            }\n        }\n    }\n\n    unregister(system: System): void {\n        this.scheduler.unregister(system);\n    }\n\n    step(deltaTime = Time.DEFAULT_DT): void {\n        this.scheduler.step(this, deltaTime);\n    }\n\n    addEntity(): number {\n        const eid = addEntity(this.world);\n        if (eid >= MAX_ENTITIES) {\n            throw new Error(`Entity limit exceeded: ${eid} >= ${MAX_ENTITIES}`);\n        }\n        if (eid > this._maxEid) this._maxEid = eid;\n        return eid;\n    }\n\n    removeEntity(eid: number): void {\n        removeEntity(this.world, eid);\n    }\n\n    entityExists(eid: number): boolean {\n        return entityExists(this.world, eid);\n    }\n\n    getAllEntities(): readonly number[] {\n        return getAllEntities(this.world);\n    }\n\n    query(terms: ComponentRef[]): Iterable<number> {\n        return query(this.world, terms);\n    }\n\n    getEntityComponents(eid: number): ComponentRef[] {\n        return getEntityComponents(this.world, eid);\n    }\n\n    addComponent<T extends ComponentRef>(eid: number, component: T): void {\n        addComponent(this.world, eid, component);\n\n        const traits = getTraits(component as ComponentData);\n        if (traits?.defaults) {\n            const defaults = traits.defaults();\n            const comp = component as ComponentData;\n            for (const [field, value] of Object.entries(defaults)) {\n                const arr = comp[field];\n                if (arr != null) {\n                    arr[eid] = value;\n                }\n            }\n        }\n    }\n\n    addComponents(eid: number, ...components: ComponentRef[]): void {\n        for (const component of components) {\n            this.addComponent(eid, component);\n        }\n    }\n\n    removeComponent(eid: number, ...components: ComponentRef[]): void {\n        removeComponent(this.world, eid, ...components);\n    }\n\n    removeComponents(eid: number, ...components: ComponentRef[]): void {\n        removeComponents(this.world, eid, ...components);\n    }\n\n    hasComponent<T extends ComponentRef>(eid: number, component: T): boolean {\n        return hasComponent(this.world, eid, component);\n    }\n\n    getComponent<T extends ComponentRef>(eid: number, component: T) {\n        return getComponent(this.world, eid, component);\n    }\n\n    setComponent<T extends ComponentRef>(\n        eid: number,\n        component: T,\n        data: Record<string, number>\n    ): void {\n        this.addComponent(eid, component);\n        const comp = component as Record<string, number[]>;\n        for (const [field, value] of Object.entries(data)) {\n            const arr = comp[field];\n            if (arr != null) {\n                arr[eid] = value;\n            }\n        }\n    }\n\n    addRelation(subject: number, relation: RelationDef, target: number): void {\n        addComponent(this.world, subject, relation.relation(target));\n    }\n\n    hasRelation(subject: number, relation: RelationDef, target: number): boolean {\n        return hasComponent(this.world, subject, relation.relation(target));\n    }\n\n    getRelationTargets(subject: number, relation: RelationDef): number[] {\n        return getRelationTargets(this.world, subject, relation.relation);\n    }\n\n    getFirstRelationTarget(subject: number, relation: RelationDef): number {\n        const targets = getRelationTargets(this.world, subject, relation.relation);\n        return targets.length > 0 ? targets[0] : -1;\n    }\n\n    dispose(): void {\n        if (this._disposed) return;\n        this.stop();\n        for (const system of this.scheduler.systems) {\n            system.dispose?.(this);\n        }\n        this._disposed = true;\n    }\n}\n","import { State } from \"./state\";\nimport { toposort, type System } from \"./scheduler\";\nimport { registerComponent, type ComponentLike } from \"./component\";\nimport { initRuntime } from \"./runtime\";\nimport type { RelationDef } from \"./relation\";\n\nexport interface Plugin {\n    readonly systems?: readonly System[];\n    readonly components?: Record<string, ComponentLike>;\n    readonly relations?: readonly RelationDef[];\n    readonly dependencies?: readonly Plugin[];\n    readonly initialize?: (\n        state: State,\n        onProgress?: (progress: number) => void\n    ) => void | Promise<void>;\n    readonly warm?: (state: State, onProgress?: (progress: number) => void) => void | Promise<void>;\n}\n\nexport interface Loading {\n    show(): (() => void) | void;\n    update(progress: number): void;\n}\n\nexport const NoLoading: Loading = { show: () => {}, update: () => {} };\n\nexport class StateBuilder {\n    static defaultPlugins: readonly Plugin[] = [];\n    static initCanvas: ((state: State, canvas: HTMLCanvasElement) => void) | null = null;\n    static defaultLoading: ((canvas: HTMLCanvasElement) => Loading) | null = null;\n\n    private readonly _plugins: Plugin[] = [];\n    private readonly _systems: System[] = [];\n    private readonly _scenes: string[] = [];\n    private readonly _excludedPlugins = new Set<Plugin>();\n    private _useDefaultPlugins = true;\n    private _canvas: HTMLCanvasElement | null = null;\n    private _loading: Loading | null = null;\n\n    withCanvas(canvas: HTMLCanvasElement): this {\n        this._canvas = canvas;\n        return this;\n    }\n\n    withLoading(loading: Loading): this {\n        this._loading = loading;\n        return this;\n    }\n\n    withPlugins(...plugins: Plugin[]): this {\n        this._plugins.push(...plugins);\n        return this;\n    }\n\n    withoutPlugin(plugin: Plugin): this {\n        this._excludedPlugins.add(plugin);\n        return this;\n    }\n\n    withoutPlugins(...plugins: Plugin[]): this {\n        for (const p of plugins) this._excludedPlugins.add(p);\n        return this;\n    }\n\n    withoutDefaultPlugins(): this {\n        this._useDefaultPlugins = false;\n        return this;\n    }\n\n    withSystems(...systems: System[]): this {\n        this._systems.push(...systems);\n        return this;\n    }\n\n    withScene(path: string): this {\n        this._scenes.push(path);\n        return this;\n    }\n\n    async build(): Promise<State> {\n        const state = new State();\n\n        if (this._canvas && StateBuilder.initCanvas) {\n            StateBuilder.initCanvas(state, this._canvas);\n        }\n\n        const loading =\n            this._loading ?? (this._canvas && StateBuilder.defaultLoading?.(this._canvas));\n        const cleanup = loading?.show();\n\n        const pluginSet = new Set<Plugin>();\n\n        if (this._useDefaultPlugins) {\n            for (const plugin of StateBuilder.defaultPlugins) {\n                if (!this._excludedPlugins.has(plugin)) {\n                    pluginSet.add(plugin);\n                }\n            }\n        }\n\n        for (const plugin of this._plugins) {\n            pluginSet.add(plugin);\n        }\n\n        const allPlugins = [...pluginSet];\n\n        for (const plugin of allPlugins) {\n            if (plugin.components) {\n                for (const [name, component] of Object.entries(plugin.components)) {\n                    registerComponent(name, component);\n                }\n            }\n            if (plugin.systems) {\n                for (const system of plugin.systems) {\n                    state.scheduler.register(system);\n                }\n            }\n        }\n\n        const edges: [Plugin, Plugin][] = [];\n        for (const plugin of allPlugins) {\n            for (const dep of plugin.dependencies ?? []) {\n                if (allPlugins.includes(dep)) {\n                    edges.push([dep, plugin]);\n                }\n            }\n        }\n        const sorted = toposort(allPlugins, edges);\n\n        const total = sorted.length * 2 + this._scenes.length;\n\n        for (let i = 0; i < sorted.length; i++) {\n            const plugin = sorted[i];\n            const onProgress = loading\n                ? (progress: number) => loading.update((i + progress) / total)\n                : undefined;\n            await plugin.initialize?.(state, onProgress);\n            loading?.update((i + 1) / total);\n        }\n\n        for (const system of this._systems) {\n            state.scheduler.register(system);\n        }\n\n        if (this._scenes.length > 0) {\n            const { parse, load } = await import(\"./xml\");\n            const runtime = await initRuntime();\n            for (let i = 0; i < this._scenes.length; i++) {\n                const xml = await runtime.readFile(this._scenes[i]);\n                const nodes = parse(xml);\n                load(nodes, state);\n                loading?.update((sorted.length + i + 1) / total);\n            }\n        }\n\n        const warmable = sorted.filter((p) => p.warm);\n        let warmDone = 0;\n        const warmBase = sorted.length + this._scenes.length;\n\n        const warmPromises = warmable.map(async (plugin) => {\n            await plugin.warm!(state, (progress: number) => {\n                if (loading) {\n                    loading.update((warmBase + warmDone + progress) / total);\n                }\n            });\n            warmDone++;\n            loading?.update((warmBase + warmDone) / total);\n        });\n\n        await Promise.all(warmPromises);\n\n        if (cleanup) {\n            loading?.update(1);\n            await new Promise((r) => setTimeout(r, 200));\n            cleanup();\n        }\n\n        return state;\n    }\n\n    async run(): Promise<State> {\n        const state = await this.build();\n        await state.start();\n        return state;\n    }\n}\n\nState.Builder = StateBuilder;\n","export interface ResourceContainer {\n    getResource<T>(key: ResourceKey<T>): T | undefined;\n}\n\nexport type ResourceKey<T> = symbol & {\n    __type?: T;\n    from(state: ResourceContainer): T | undefined;\n};\n\nexport function resource<T>(name: string): ResourceKey<T> {\n    const key = Symbol(name) as symbol;\n    const resourceKey = Object.assign(key, {\n        from(state: ResourceContainer): T | undefined {\n            return state.getResource(resourceKey);\n        },\n    });\n    return resourceKey as ResourceKey<T>;\n}\n","import { createRelation as bitecsCreateRelation, type Relation } from \"bitecs\";\nimport { toKebabCase } from \"./strings\";\n\nexport interface RelationOptions {\n    readonly exclusive?: boolean;\n    readonly autoRemoveSubject?: boolean;\n}\n\nexport interface RelationDef {\n    readonly name: string;\n    readonly relation: Relation<unknown>;\n    readonly exclusive?: boolean;\n    readonly autoRemoveSubject?: boolean;\n}\n\nconst registry = new Map<string, RelationDef>();\n\nexport function defineRelation(name: string, options?: RelationOptions): RelationDef {\n    const relation = bitecsCreateRelation({\n        exclusive: options?.exclusive,\n        autoRemoveSubject: options?.autoRemoveSubject,\n    });\n\n    const def: RelationDef = {\n        name: toKebabCase(name),\n        relation,\n        exclusive: options?.exclusive,\n        autoRemoveSubject: options?.autoRemoveSubject,\n    };\n\n    registry.set(def.name, def);\n    return def;\n}\n\nexport function getRelationDef(name: string): RelationDef | undefined {\n    return registry.get(toKebabCase(name));\n}\n\nexport function clearRelationDefs(): void {\n    registry.clear();\n}\n\nexport const ChildOf = defineRelation(\"child-of\", {\n    exclusive: true,\n    autoRemoveSubject: true,\n});\n","const DEG_TO_RAD = Math.PI / 180;\nconst RAD_TO_DEG = 180 / Math.PI;\n\nexport function clamp(value: number, min: number, max: number): number {\n    return value < min ? min : value > max ? max : value;\n}\n\nexport function lerp(a: number, b: number, t: number): number {\n    return a + (b - a) * t;\n}\n\nexport function slerp(\n    fromX: number,\n    fromY: number,\n    fromZ: number,\n    fromW: number,\n    toX: number,\n    toY: number,\n    toZ: number,\n    toW: number,\n    t: number\n): { x: number; y: number; z: number; w: number } {\n    if (!Number.isFinite(t) || !Number.isFinite(fromW) || !Number.isFinite(toW)) {\n        throw new Error(\n            `slerp received NaN: from=[${fromX},${fromY},${fromZ},${fromW}], to=[${toX},${toY},${toZ},${toW}], t=${t}`\n        );\n    }\n\n    let dot = fromX * toX + fromY * toY + fromZ * toZ + fromW * toW;\n\n    if (dot < 0) {\n        dot = -dot;\n        toX = -toX;\n        toY = -toY;\n        toZ = -toZ;\n        toW = -toW;\n    }\n\n    let s0: number, s1: number;\n    if (dot > 0.9995) {\n        s0 = 1 - t;\n        s1 = t;\n    } else {\n        const theta0 = Math.acos(dot);\n        const sinTheta0 = Math.sqrt(1 - dot * dot);\n        const theta = theta0 * t;\n        const sinTheta = Math.sin(theta);\n        s0 = Math.cos(theta) - (dot * sinTheta) / sinTheta0;\n        s1 = sinTheta / sinTheta0;\n    }\n\n    return {\n        x: s0 * fromX + s1 * toX,\n        y: s0 * fromY + s1 * toY,\n        z: s0 * fromZ + s1 * toZ,\n        w: s0 * fromW + s1 * toW,\n    };\n}\n\nexport function rotateQuaternion(\n    qx: number,\n    qy: number,\n    qz: number,\n    qw: number,\n    dx: number,\n    dy: number,\n    dz: number\n): { x: number; y: number; z: number; w: number } {\n    const hx = dx * DEG_TO_RAD * 0.5;\n    const hy = dy * DEG_TO_RAD * 0.5;\n    const hz = dz * DEG_TO_RAD * 0.5;\n    const cx = Math.cos(hx),\n        sx = Math.sin(hx);\n    const cy = Math.cos(hy),\n        sy = Math.sin(hy);\n    const cz = Math.cos(hz),\n        sz = Math.sin(hz);\n\n    const bx = sx * cy * cz + cx * sy * sz;\n    const by = cx * sy * cz - sx * cy * sz;\n    const bz = cx * cy * sz + sx * sy * cz;\n    const bw = cx * cy * cz - sx * sy * sz;\n\n    return {\n        x: qw * bx + qx * bw + qy * bz - qz * by,\n        y: qw * by - qx * bz + qy * bw + qz * bx,\n        z: qw * bz + qx * by - qy * bx + qz * bw,\n        w: qw * bw - qx * bx - qy * by - qz * bz,\n    };\n}\n\nexport function eulerToQuaternion(\n    x: number,\n    y: number,\n    z: number\n): { x: number; y: number; z: number; w: number } {\n    const hx = x * DEG_TO_RAD * 0.5;\n    const hy = y * DEG_TO_RAD * 0.5;\n    const hz = z * DEG_TO_RAD * 0.5;\n    const cx = Math.cos(hx),\n        sx = Math.sin(hx);\n    const cy = Math.cos(hy),\n        sy = Math.sin(hy);\n    const cz = Math.cos(hz),\n        sz = Math.sin(hz);\n\n    return {\n        x: sx * cy * cz + cx * sy * sz,\n        y: cx * sy * cz - sx * cy * sz,\n        z: cx * cy * sz + sx * sy * cz,\n        w: cx * cy * cz - sx * sy * sz,\n    };\n}\n\nexport function quaternionToEuler(\n    x: number,\n    y: number,\n    z: number,\n    w: number\n): { x: number; y: number; z: number } {\n    const x2 = x + x,\n        y2 = y + y,\n        z2 = z + z;\n    const xx = x * x2,\n        xy = x * y2,\n        xz = x * z2;\n    const yy = y * y2,\n        yz = y * z2,\n        zz = z * z2;\n    const wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    const m13 = xz + wy;\n    const ey = Math.asin(m13 < -1 ? -1 : m13 > 1 ? 1 : m13);\n\n    if (m13 > -0.9999999 && m13 < 0.9999999) {\n        return {\n            x: Math.atan2(wx - yz, 1 - (xx + yy)) * RAD_TO_DEG,\n            y: ey * RAD_TO_DEG,\n            z: Math.atan2(wz - xy, 1 - (yy + zz)) * RAD_TO_DEG,\n        };\n    } else {\n        return {\n            x: Math.atan2(yz + wx, 1 - (xx + zz)) * RAD_TO_DEG,\n            y: ey * RAD_TO_DEG,\n            z: 0,\n        };\n    }\n}\n\nexport function perspective(fov: number, aspect: number, near: number, far: number): Float32Array {\n    if (fov <= 0) throw new Error(`Invalid FOV: ${fov} (must be > 0)`);\n    if (aspect <= 0) throw new Error(`Invalid aspect ratio: ${aspect} (must be > 0)`);\n    if (near === far) throw new Error(`Invalid depth planes: near === far (${near})`);\n    const f = 1 / Math.tan((fov * Math.PI) / 360);\n    const nf = 1 / (near - far);\n    return new Float32Array([\n        f / aspect,\n        0,\n        0,\n        0,\n        0,\n        f,\n        0,\n        0,\n        0,\n        0,\n        far * nf,\n        -1,\n        0,\n        0,\n        far * near * nf,\n        0,\n    ]);\n}\n\nexport function orthographic(\n    size: number,\n    aspect: number,\n    near: number,\n    far: number\n): Float32Array {\n    if (size <= 0) throw new Error(`Invalid orthographic size: ${size} (must be > 0)`);\n    if (aspect <= 0) throw new Error(`Invalid aspect ratio: ${aspect} (must be > 0)`);\n    if (near === far) throw new Error(`Invalid depth planes: near === far (${near})`);\n    const lr = 1 / (size * aspect);\n    const bt = 1 / size;\n    const nf = 1 / (near - far);\n    return new Float32Array([lr, 0, 0, 0, 0, bt, 0, 0, 0, 0, nf, 0, 0, 0, near * nf, 1]);\n}\n\nexport function multiply(a: Float32Array, b: Float32Array): Float32Array {\n    const out = new Float32Array(16);\n    for (let i = 0; i < 4; i++) {\n        for (let j = 0; j < 4; j++) {\n            out[j * 4 + i] =\n                a[i] * b[j * 4] +\n                a[i + 4] * b[j * 4 + 1] +\n                a[i + 8] * b[j * 4 + 2] +\n                a[i + 12] * b[j * 4 + 3];\n        }\n    }\n    return out;\n}\n\nexport function invert(m: Float32Array): Float32Array {\n    const out = new Float32Array(16);\n    const r00 = m[0],\n        r01 = m[1],\n        r02 = m[2];\n    const r10 = m[4],\n        r11 = m[5],\n        r12 = m[6];\n    const r20 = m[8],\n        r21 = m[9],\n        r22 = m[10];\n    const tx = m[12],\n        ty = m[13],\n        tz = m[14];\n\n    out[0] = r00;\n    out[1] = r10;\n    out[2] = r20;\n    out[3] = 0;\n    out[4] = r01;\n    out[5] = r11;\n    out[6] = r21;\n    out[7] = 0;\n    out[8] = r02;\n    out[9] = r12;\n    out[10] = r22;\n    out[11] = 0;\n    out[12] = -(r00 * tx + r01 * ty + r02 * tz);\n    out[13] = -(r10 * tx + r11 * ty + r12 * tz);\n    out[14] = -(r20 * tx + r21 * ty + r22 * tz);\n    out[15] = 1;\n\n    return out;\n}\n\nexport function extractFrustumPlanes(viewProj: Float32Array): Float32Array {\n    const planes = new Float32Array(24);\n    const m = viewProj;\n\n    planes[0] = m[3] + m[0];\n    planes[1] = m[7] + m[4];\n    planes[2] = m[11] + m[8];\n    planes[3] = m[15] + m[12];\n\n    planes[4] = m[3] - m[0];\n    planes[5] = m[7] - m[4];\n    planes[6] = m[11] - m[8];\n    planes[7] = m[15] - m[12];\n\n    planes[8] = m[3] + m[1];\n    planes[9] = m[7] + m[5];\n    planes[10] = m[11] + m[9];\n    planes[11] = m[15] + m[13];\n\n    planes[12] = m[3] - m[1];\n    planes[13] = m[7] - m[5];\n    planes[14] = m[11] - m[9];\n    planes[15] = m[15] - m[13];\n\n    planes[16] = m[2];\n    planes[17] = m[6];\n    planes[18] = m[10];\n    planes[19] = m[14];\n\n    planes[20] = m[3] - m[2];\n    planes[21] = m[7] - m[6];\n    planes[22] = m[11] - m[10];\n    planes[23] = m[15] - m[14];\n    for (let i = 0; i < 6; i++) {\n        const len = Math.hypot(planes[i * 4], planes[i * 4 + 1], planes[i * 4 + 2]);\n        if (len > 0) {\n            planes[i * 4] /= len;\n            planes[i * 4 + 1] /= len;\n            planes[i * 4 + 2] /= len;\n            planes[i * 4 + 3] /= len;\n        }\n    }\n    return planes;\n}\n\nexport function lookAt(\n    eyeX: number,\n    eyeY: number,\n    eyeZ: number,\n    targetX: number,\n    targetY: number,\n    targetZ: number,\n    upX = 0,\n    upY = 1,\n    upZ = 0\n): { x: number; y: number; z: number; w: number } {\n    if (\n        !Number.isFinite(eyeX) ||\n        !Number.isFinite(eyeY) ||\n        !Number.isFinite(eyeZ) ||\n        !Number.isFinite(targetX) ||\n        !Number.isFinite(targetY) ||\n        !Number.isFinite(targetZ)\n    ) {\n        throw new Error(\n            `lookAt received NaN: eye=[${eyeX},${eyeY},${eyeZ}], target=[${targetX},${targetY},${targetZ}]`\n        );\n    }\n\n    let zx = eyeX - targetX;\n    let zy = eyeY - targetY;\n    let zz = eyeZ - targetZ;\n    let zLen = Math.sqrt(zx * zx + zy * zy + zz * zz);\n\n    if (zLen === 0) {\n        zz = 1;\n    } else {\n        zLen = 1 / zLen;\n        zx *= zLen;\n        zy *= zLen;\n        zz *= zLen;\n    }\n\n    let xx = upY * zz - upZ * zy;\n    let xy = upZ * zx - upX * zz;\n    let xz = upX * zy - upY * zx;\n    let xLen = Math.sqrt(xx * xx + xy * xy + xz * xz);\n\n    if (xLen < 1e-6) {\n        if (Math.abs(zz) > Math.abs(zx)) {\n            upX += 1e-4;\n        } else {\n            upZ += 1e-4;\n        }\n        xx = upY * zz - upZ * zy;\n        xy = upZ * zx - upX * zz;\n        xz = upX * zy - upY * zx;\n        xLen = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    }\n\n    if (xLen < 1e-6) {\n        xx = 1;\n        xy = 0;\n        xz = 0;\n    } else {\n        xLen = 1 / xLen;\n        xx *= xLen;\n        xy *= xLen;\n        xz *= xLen;\n    }\n\n    const yx = zy * xz - zz * xy;\n    const yy = zz * xx - zx * xz;\n    const yz = zx * xy - zy * xx;\n\n    const trace = xx + yy + zz;\n    let qw: number, qx: number, qy: number, qz: number;\n\n    if (trace > 0) {\n        const s = 0.5 / Math.sqrt(trace + 1);\n        qw = 0.25 / s;\n        qx = (yz - zy) * s;\n        qy = (zx - xz) * s;\n        qz = (xy - yx) * s;\n    } else if (xx > yy && xx > zz) {\n        const s = 2 * Math.sqrt(1 + xx - yy - zz);\n        qw = (yz - zy) / s;\n        qx = 0.25 * s;\n        qy = (yx + xy) / s;\n        qz = (zx + xz) / s;\n    } else if (yy > zz) {\n        const s = 2 * Math.sqrt(1 + yy - xx - zz);\n        qw = (zx - xz) / s;\n        qx = (yx + xy) / s;\n        qy = 0.25 * s;\n        qz = (yz + zy) / s;\n    } else {\n        const s = 2 * Math.sqrt(1 + zz - xx - yy);\n        qw = (xy - yx) / s;\n        qx = (zx + xz) / s;\n        qy = (yz + zy) / s;\n        qz = 0.25 * s;\n    }\n\n    return { x: qx, y: qy, z: qz, w: qw };\n}\n","import { addComponent, Pair } from \"bitecs\";\nimport type { State } from \"./state\";\nimport { getRegisteredComponent, type ComponentLike, type RegisteredComponent } from \"./component\";\nimport { getRelationDef, ChildOf } from \"./relation\";\nimport { toKebabCase, toCamelCase } from \"./strings\";\n\nconst INDENT = \"    \";\nconst MAX_LINE = 100;\n\nfunction levenshtein(a: string, b: string): number {\n    if (a.length === 0) return b.length;\n    if (b.length === 0) return a.length;\n\n    const matrix: number[][] = [];\n    for (let i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n    }\n    for (let j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n    }\n\n    for (let i = 1; i <= b.length; i++) {\n        for (let j = 1; j <= a.length; j++) {\n            const cost = a[j - 1] === b[i - 1] ? 0 : 1;\n            matrix[i][j] = Math.min(\n                matrix[i - 1][j] + 1,\n                matrix[i][j - 1] + 1,\n                matrix[i - 1][j - 1] + cost\n            );\n        }\n    }\n\n    return matrix[b.length][a.length];\n}\n\nfunction findClosestMatch(input: string, candidates: string[]): string | null {\n    const inputKebab = toKebabCase(input);\n\n    let bestMatch: string | null = null;\n    let bestScore = Infinity;\n\n    for (const candidate of candidates) {\n        const candidateKebab = toKebabCase(candidate);\n\n        if (inputKebab === candidateKebab) {\n            return candidate;\n        }\n\n        if (inputKebab.endsWith(candidateKebab) || inputKebab.endsWith(\"-\" + candidateKebab)) {\n            return candidate;\n        }\n\n        const distance = levenshtein(inputKebab, candidateKebab);\n        const maxLen = Math.max(inputKebab.length, candidateKebab.length);\n        const threshold = Math.ceil(maxLen * 0.5);\n\n        if (distance < bestScore && distance <= threshold) {\n            bestScore = distance;\n            bestMatch = candidate;\n        }\n    }\n\n    return bestMatch;\n}\n\nexport interface Node {\n    id?: string;\n    attrs: Attr[];\n    children: Node[];\n    comments?: string[];\n    blankBefore?: boolean;\n}\n\nexport interface Attr {\n    name: string;\n    value: string;\n}\n\nexport interface Ref {\n    attr: string;\n    target: string;\n}\n\nexport interface ParseError {\n    message: string;\n    path?: string;\n}\n\ninterface PendingFieldRef {\n    eid: number;\n    component: ComponentLike;\n    field: string;\n    targetName: string;\n}\n\ninterface Token {\n    type: \"comment\" | \"open\" | \"close\" | \"blank\";\n    value: string;\n    selfClosing?: boolean;\n    attrs?: Record<string, string>;\n    tagName?: string;\n}\n\nfunction tokenize(xml: string): Token[] {\n    const tokens: Token[] = [];\n    const regex = /<!--[\\s\\S]*?-->|<\\/?\\s*(\\w+)[^>]*\\/?>/g;\n    let lastIndex = 0;\n    let match: RegExpExecArray | null;\n\n    while ((match = regex.exec(xml)) !== null) {\n        const before = xml.slice(lastIndex, match.index);\n        if (/\\n\\s*\\n/.test(before)) {\n            tokens.push({ type: \"blank\", value: \"\" });\n        }\n        lastIndex = match.index + match[0].length;\n\n        const tag = match[0];\n\n        if (tag.startsWith(\"<!--\")) {\n            const content = tag.slice(4, -3).trim();\n            tokens.push({ type: \"comment\", value: content });\n        } else if (tag.startsWith(\"</\")) {\n            const tagName = tag.match(/<\\/\\s*(\\w+)/)?.[1] ?? \"\";\n            tokens.push({ type: \"close\", value: tag, tagName });\n        } else {\n            const selfClosing = tag.endsWith(\"/>\");\n            const tagMatch = tag.match(/<\\s*(\\w+)/);\n            const tagName = tagMatch?.[1] ?? \"\";\n            const attrs = parseTagAttrs(tag);\n            tokens.push({ type: \"open\", value: tag, selfClosing, tagName, attrs });\n        }\n    }\n\n    return tokens;\n}\n\nfunction parseTagAttrs(tag: string): Record<string, string> {\n    const attrs: Record<string, string> = {};\n    const attrRegex = /([^\\s=<>\\/]+)(?:\\s*=\\s*\"([^\"]*)\")?/g;\n    const inner = tag.replace(/^<\\s*\\w+/, \"\").replace(/\\/?>$/, \"\");\n    let match: RegExpExecArray | null;\n\n    while ((match = attrRegex.exec(inner)) !== null) {\n        const name = match[1];\n        const value = match[2] ?? \"\";\n        attrs[name] = value;\n    }\n\n    return attrs;\n}\n\nexport function parse(xml: string): Node[] {\n    const unclosedMatch = xml.match(/<[^>]*$/);\n    if (unclosedMatch) {\n        throw new Error(`xml parse error: Unclosed tag at end of document`);\n    }\n\n    const tokens = tokenize(xml);\n\n    for (const token of tokens) {\n        if (token.type === \"open\" && token.tagName !== \"scene\" && token.tagName !== \"a\") {\n            const tagName = token.tagName ?? \"unknown\";\n            if (tagName.toLowerCase() === \"a\" || tagName.toLowerCase() === \"scene\") {\n                continue;\n            }\n            throw new Error(`xml parse error: Unknown tag <${tagName}>`);\n        }\n    }\n\n    const nodes: Node[] = [];\n    const errors: ParseError[] = [];\n\n    let i = 0;\n    let pendingComments: string[] = [];\n    let pendingBlank = false;\n\n    while (i < tokens.length) {\n        const token = tokens[i];\n\n        if (token.type === \"blank\") {\n            pendingBlank = true;\n            i++;\n            continue;\n        }\n\n        if (token.type === \"comment\") {\n            pendingComments.push(token.value);\n            i++;\n            continue;\n        }\n\n        if (token.type === \"open\" && token.tagName === \"scene\") {\n            pendingComments = [];\n            pendingBlank = false;\n            i++;\n            continue;\n        }\n\n        if (token.type === \"close\" && token.tagName === \"scene\") {\n            i++;\n            continue;\n        }\n\n        if (token.type === \"open\" && token.tagName === \"a\") {\n            const result = parseNodeFromTokens(tokens, i, errors);\n            if (result.node) {\n                result.node.comments = pendingComments.length > 0 ? pendingComments : undefined;\n                result.node.blankBefore = pendingBlank || undefined;\n                nodes.push(result.node);\n            }\n            pendingComments = [];\n            pendingBlank = false;\n            i = result.nextIndex;\n            continue;\n        }\n\n        if (token.type === \"open\" && token.tagName?.toLowerCase() === \"scene\") {\n            throw new Error(`Invalid tag \"${token.tagName}\". Use lowercase <scene>`);\n        }\n\n        if (\n            token.type === \"open\" &&\n            token.tagName?.toLowerCase() === \"a\" &&\n            token.tagName !== \"a\"\n        ) {\n            throw new Error(`Invalid tag \"${token.tagName}\". Use lowercase <a>`);\n        }\n\n        i++;\n    }\n\n    if (errors.length > 0) {\n        throw new Error(errors.map((e) => e.message).join(\"\\n\"));\n    }\n\n    return nodes;\n}\n\nfunction parseNodeFromTokens(\n    tokens: Token[],\n    startIndex: number,\n    errors: ParseError[]\n): { node: Node | null; nextIndex: number } {\n    const token = tokens[startIndex];\n\n    if (token.type !== \"open\" || token.tagName !== \"a\") {\n        if (token.tagName?.toLowerCase() === \"a\") {\n            errors.push({ message: `Invalid tag \"${token.tagName}\". Use lowercase <a>` });\n        }\n        return { node: null, nextIndex: startIndex + 1 };\n    }\n\n    const rawAttrs = token.attrs ?? {};\n    const attrs: Attr[] = [];\n    let nodeId: string | undefined;\n\n    for (const [attrName, attrValue] of Object.entries(rawAttrs)) {\n        if (attrName === \"id\") {\n            nodeId = attrValue;\n        } else {\n            attrs.push({ name: attrName, value: attrValue });\n        }\n    }\n\n    const children: Node[] = [];\n    let i = startIndex + 1;\n\n    if (!token.selfClosing) {\n        let pendingComments: string[] = [];\n        let pendingBlank = false;\n\n        while (i < tokens.length) {\n            const childToken = tokens[i];\n\n            if (childToken.type === \"blank\") {\n                pendingBlank = true;\n                i++;\n                continue;\n            }\n\n            if (childToken.type === \"comment\") {\n                pendingComments.push(childToken.value);\n                i++;\n                continue;\n            }\n\n            if (childToken.type === \"close\" && childToken.tagName === \"a\") {\n                i++;\n                break;\n            }\n\n            if (childToken.type === \"open\" && childToken.tagName === \"a\") {\n                const result = parseNodeFromTokens(tokens, i, errors);\n                if (result.node) {\n                    result.node.comments = pendingComments.length > 0 ? pendingComments : undefined;\n                    result.node.blankBefore = pendingBlank || undefined;\n                    children.push(result.node);\n                }\n                pendingComments = [];\n                pendingBlank = false;\n                i = result.nextIndex;\n                continue;\n            }\n\n            i++;\n        }\n    }\n\n    return {\n        node: { id: nodeId, attrs, children },\n        nextIndex: i,\n    };\n}\n\nexport interface PostLoadContext {\n    getEntityByName(name: string): number | null;\n}\n\nexport type PostLoadHook = (state: State, context: PostLoadContext) => void;\n\nconst postLoadHooks: PostLoadHook[] = [];\n\nexport function registerPostLoadHook(hook: PostLoadHook): void {\n    postLoadHooks.push(hook);\n}\n\nexport function unregisterPostLoadHook(hook: PostLoadHook): void {\n    const idx = postLoadHooks.indexOf(hook);\n    if (idx !== -1) postLoadHooks.splice(idx, 1);\n}\n\ninterface QueuedEntity {\n    node: Node;\n    eid: number;\n    parent?: number;\n}\n\nexport function load(nodes: Node[], state: State): Map<Node, number> {\n    const nameToEntity = new Map<string, number>();\n    const nodeToEntity = new Map<Node, number>();\n    const errors: ParseError[] = [];\n    const queue: QueuedEntity[] = [];\n    const pendingFieldRefs: PendingFieldRef[] = [];\n\n    for (const node of nodes) {\n        createEntityTree(state, node, nameToEntity, nodeToEntity, undefined, queue);\n    }\n\n    for (const { node, eid, parent } of queue) {\n        if (parent !== undefined) {\n            addComponent(state.world, eid, Pair(ChildOf.relation, parent));\n        }\n\n        const { componentAttrs, refs, unknown } = categorizeAttrs(node.attrs);\n\n        for (const attr of unknown) {\n            const nodeId = node.id ? ` (id=\"${node.id}\")` : \"\";\n            errors.push({ message: `Unknown component \"${attr.name}\"${nodeId}` });\n        }\n\n        for (const ref of refs) {\n            applyRelation(state, eid, ref, nameToEntity, errors);\n        }\n\n        for (const attr of componentAttrs) {\n            applyComponent(state, eid, attr, errors, pendingFieldRefs);\n        }\n    }\n\n    for (const ref of pendingFieldRefs) {\n        const targetEid = nameToEntity.get(ref.targetName);\n        if (targetEid === undefined) {\n            errors.push({ message: `Unknown entity: \"@${ref.targetName}\"` });\n            continue;\n        }\n        setFieldValue(ref.component, ref.field, ref.eid, targetEid);\n    }\n\n    const context: PostLoadContext = {\n        getEntityByName: (name) => nameToEntity.get(name) ?? null,\n    };\n    for (const hook of postLoadHooks) {\n        hook(state, context);\n    }\n\n    if (errors.length > 0) {\n        throw new Error(errors.map((e) => e.message).join(\"\\n\"));\n    }\n\n    return nodeToEntity;\n}\n\ninterface CategorizedAttrs {\n    componentAttrs: { name: string; value: string; def: RegisteredComponent }[];\n    refs: Ref[];\n    unknown: { name: string; value: string }[];\n}\n\nfunction categorizeAttrs(attrs: Attr[]): CategorizedAttrs {\n    const componentAttrs: { name: string; value: string; def: RegisteredComponent }[] = [];\n    const refs: Ref[] = [];\n    const unknown: { name: string; value: string }[] = [];\n\n    for (const attr of attrs) {\n        if (attr.value.startsWith(\"@\") && attr.value.length > 1) {\n            refs.push({ attr: attr.name, target: attr.value.slice(1) });\n            continue;\n        }\n\n        const registered = getRegisteredComponent(attr.name);\n        if (registered) {\n            componentAttrs.push({ name: attr.name, value: attr.value, def: registered });\n            continue;\n        }\n\n        unknown.push({ name: attr.name, value: attr.value });\n    }\n\n    return { componentAttrs, refs, unknown };\n}\n\nfunction createEntityTree(\n    state: State,\n    node: Node,\n    nameToEntity: Map<string, number>,\n    nodeToEntity: Map<Node, number>,\n    parent: number | undefined,\n    queue: QueuedEntity[]\n): number {\n    const eid = state.addEntity();\n\n    if (node.id) {\n        nameToEntity.set(node.id, eid);\n    }\n    nodeToEntity.set(node, eid);\n\n    queue.push({ node, eid, parent });\n\n    for (const child of node.children) {\n        createEntityTree(state, child, nameToEntity, nodeToEntity, eid, queue);\n    }\n\n    return eid;\n}\n\nfunction applyRelation(\n    state: State,\n    eid: number,\n    ref: Ref,\n    nameToEntity: Map<string, number>,\n    errors: ParseError[]\n): void {\n    const relationDef = getRelationDef(ref.attr);\n    if (!relationDef) {\n        errors.push({ message: `Unknown relation: \"${ref.attr}\"` });\n        return;\n    }\n\n    const targetEid = nameToEntity.get(ref.target);\n    if (targetEid === undefined) {\n        errors.push({ message: `Unknown entity: \"@${ref.target}\"` });\n        return;\n    }\n\n    state.addRelation(eid, relationDef, targetEid);\n}\n\nfunction applyComponent(\n    state: State,\n    eid: number,\n    attr: { name: string; value: string; def: RegisteredComponent },\n    errors: ParseError[],\n    pendingFieldRefs: PendingFieldRef[]\n): void {\n    const { def, value } = attr;\n    const { component, name, traits } = def;\n\n    state.addComponent(eid, component as never);\n\n    const defaults = traits?.defaults?.() ?? {};\n    for (const [field, val] of Object.entries(defaults)) {\n        setFieldValue(component, field, eid, val as number);\n    }\n\n    const props: Record<string, string> = {};\n    if (value !== \"\") {\n        props[\"_value\"] = value;\n    }\n\n    let values: Record<string, number>;\n    let entityRefs: { field: string; targetName: string }[] = [];\n\n    if (traits?.adapter) {\n        values = traits.adapter(props, eid);\n    } else {\n        const result = parseAttrs(def, props);\n        values = result.values;\n        entityRefs = result.entityRefs;\n        for (const err of result.errors) {\n            errors.push({ message: `<${name}> ${err}` });\n        }\n    }\n\n    for (const [field, val] of Object.entries(values)) {\n        setFieldValue(component, field, eid, val);\n    }\n\n    for (const ref of entityRefs) {\n        pendingFieldRefs.push({\n            eid,\n            component,\n            field: ref.field,\n            targetName: ref.targetName,\n        });\n    }\n}\n\nfunction parseAttrs(\n    def: RegisteredComponent,\n    props: Record<string, string>\n): {\n    values: Record<string, number>;\n    entityRefs: { field: string; targetName: string }[];\n    errors: string[];\n} {\n    const allValues: Record<string, number> = {};\n    const allEntityRefs: { field: string; targetName: string }[] = [];\n    const allErrors: string[] = [];\n\n    if (props._value) {\n        if (isCSSAttrSyntax(props._value)) {\n            const result = parsePropertyString(def.name, props._value, def.component);\n            Object.assign(allValues, result.values);\n            allEntityRefs.push(...result.entityRefs);\n            allErrors.push(...result.errors);\n        }\n    }\n\n    for (const [propName, propValue] of Object.entries(props)) {\n        if (propName === \"_value\") continue;\n        if (!propValue) continue;\n\n        if (isCSSAttrSyntax(propValue)) {\n            const result = parsePropertyString(def.name, propValue, def.component);\n            Object.assign(allValues, result.values);\n            allEntityRefs.push(...result.entityRefs);\n            allErrors.push(...result.errors);\n        } else {\n            const result = parsePropertyString(\n                def.name,\n                `${propName}: ${propValue}`,\n                def.component\n            );\n            Object.assign(allValues, result.values);\n            allEntityRefs.push(...result.entityRefs);\n            allErrors.push(...result.errors);\n        }\n    }\n\n    return { values: allValues, entityRefs: allEntityRefs, errors: allErrors };\n}\n\nfunction setFieldValue(component: ComponentLike, field: string, eid: number, value: number): void {\n    const arr = component[field];\n    if (arr != null && (ArrayBuffer.isView(arr) || Array.isArray(arr))) {\n        (arr as number[])[eid] = value;\n    }\n}\n\nfunction detectVec2(component: ComponentLike, base: string): boolean {\n    return `${base}X` in component && `${base}Y` in component;\n}\n\nfunction detectVec3(component: ComponentLike, base: string): boolean {\n    return detectVec2(component, base) && `${base}Z` in component;\n}\n\nfunction detectVec4(component: ComponentLike, base: string): boolean {\n    return detectVec3(component, base) && `${base}W` in component;\n}\n\nfunction parseNumber(value: string): number | null {\n    value = value.trim();\n\n    if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n        return parseInt(value, 16);\n    }\n\n    if (value.startsWith(\"#\")) {\n        return parseInt(value.slice(1), 16);\n    }\n\n    if (value === \"true\") return 1;\n    if (value === \"false\") return 0;\n\n    const num = parseFloat(value);\n    return isNaN(num) ? null : num;\n}\n\nfunction parseValues(valueStr: string): (number | null)[] {\n    const result: (number | null)[] = [];\n    const trimmed = valueStr.trim();\n    let start = 0;\n    for (let i = 0; i <= trimmed.length; i++) {\n        const isWhitespace = i < trimmed.length && /\\s/.test(trimmed[i]);\n        const isEnd = i === trimmed.length;\n        if (isWhitespace || isEnd) {\n            if (start < i) {\n                result.push(parseNumber(trimmed.slice(start, i)));\n            }\n            start = i + 1;\n        }\n    }\n    return result;\n}\n\nfunction splitProperties(str: string): string[] {\n    const result: string[] = [];\n    let start = 0;\n    for (let i = 0; i <= str.length; i++) {\n        if (i === str.length || str[i] === \";\") {\n            const prop = str.slice(start, i).trim();\n            if (prop) result.push(prop);\n            start = i + 1;\n        }\n    }\n    return result;\n}\n\nfunction parsePropertyString(\n    componentName: string,\n    propertyString: string,\n    component: ComponentLike\n): {\n    values: Record<string, number>;\n    entityRefs: { field: string; targetName: string }[];\n    errors: string[];\n} {\n    const values: Record<string, number> = {};\n    const entityRefs: { field: string; targetName: string }[] = [];\n    const errors: string[] = [];\n\n    const properties = splitProperties(propertyString);\n\n    for (const prop of properties) {\n        const colonIdx = prop.indexOf(\":\");\n        if (colonIdx === -1) {\n            errors.push(`Invalid syntax: \"${prop}\" (expected \"field: value\")`);\n            continue;\n        }\n\n        const rawName = prop.slice(0, colonIdx).trim();\n        const valueStr = prop.slice(colonIdx + 1).trim();\n\n        if (!rawName || !valueStr) {\n            errors.push(`Invalid syntax: \"${prop}\" (empty field or value)`);\n            continue;\n        }\n\n        const name = toCamelCase(rawName);\n\n        if (valueStr.startsWith(\"@\") && valueStr.length > 1) {\n            if (name in component) {\n                entityRefs.push({ field: name, targetName: valueStr.slice(1) });\n            } else {\n                const fieldNames = Object.keys(component);\n                const suggestion = findClosestMatch(rawName, fieldNames);\n                if (suggestion) {\n                    errors.push(\n                        `${componentName}: unknown field \"${rawName}\", did you mean \"${toKebabCase(suggestion)}\"?`\n                    );\n                } else {\n                    errors.push(`${componentName}: unknown field \"${rawName}\"`);\n                }\n            }\n            continue;\n        }\n\n        const parsed = parseValues(valueStr);\n\n        if (parsed.some((v) => v === null)) {\n            errors.push(`Invalid number in \"${prop}\"`);\n            continue;\n        }\n\n        const nums = parsed as number[];\n\n        if (detectVec4(component, name)) {\n            if (nums.length === 4) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[1];\n                values[`${name}Z`] = nums[2];\n                values[`${name}W`] = nums[3];\n            } else if (nums.length === 1) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[0];\n                values[`${name}Z`] = nums[0];\n                values[`${name}W`] = nums[0];\n            } else {\n                errors.push(\n                    `${componentName}.${rawName}: expected 1 or 4 values, got ${nums.length}`\n                );\n            }\n            continue;\n        }\n\n        if (detectVec3(component, name)) {\n            if (nums.length === 3) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[1];\n                values[`${name}Z`] = nums[2];\n            } else if (nums.length === 1) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[0];\n                values[`${name}Z`] = nums[0];\n            } else {\n                errors.push(\n                    `${componentName}.${rawName}: expected 1 or 3 values, got ${nums.length}`\n                );\n            }\n            continue;\n        }\n\n        if (detectVec2(component, name)) {\n            if (nums.length === 2) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[1];\n            } else if (nums.length === 1) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[0];\n            } else {\n                errors.push(\n                    `${componentName}.${rawName}: expected 1 or 2 values, got ${nums.length}`\n                );\n            }\n            continue;\n        }\n\n        if (name in component) {\n            if (nums.length === 1) {\n                values[name] = nums[0];\n            } else {\n                errors.push(`${componentName}.${rawName}: expected 1 value, got ${nums.length}`);\n            }\n            continue;\n        }\n\n        const fieldNames = Object.keys(component);\n        const suggestion = findClosestMatch(rawName, fieldNames);\n        if (suggestion) {\n            errors.push(\n                `${componentName}: unknown field \"${rawName}\", did you mean \"${toKebabCase(suggestion)}\"?`\n            );\n        } else {\n            errors.push(`${componentName}: unknown field \"${rawName}\"`);\n        }\n    }\n\n    return { values, entityRefs, errors };\n}\n\nfunction isCSSAttrSyntax(value: string): boolean {\n    return value.includes(\":\") && (value.includes(\";\") || /^[\\w-]+\\s*:/.test(value));\n}\n\nexport function serialize(nodes: Node[]): string {\n    const lines: string[] = [\"<scene>\"];\n    let isFirst = true;\n\n    for (const node of nodes) {\n        serializeNode(node, lines, 1, isFirst);\n        isFirst = false;\n    }\n\n    lines.push(\"</scene>\");\n    return lines.join(\"\\n\");\n}\n\nfunction serializeNode(node: Node, lines: string[], depth: number, isFirst: boolean): void {\n    const indent = INDENT.repeat(depth);\n\n    if (node.blankBefore && !isFirst) {\n        lines.push(\"\");\n    }\n\n    if (node.comments) {\n        for (const comment of node.comments) {\n            lines.push(`${indent}<!-- ${comment} -->`);\n        }\n    }\n\n    const attrParts = buildAttrParts(node);\n    const singleLine = `${indent}<a${attrParts.join(\"\")}${node.children.length === 0 ? \" />\" : \">\"}`;\n\n    if (singleLine.length <= MAX_LINE) {\n        lines.push(singleLine);\n    } else {\n        lines.push(`${indent}<a`);\n        const attrIndent = INDENT.repeat(depth + 1);\n        for (const part of attrParts) {\n            lines.push(`${attrIndent}${part.trim()}`);\n        }\n        lines.push(`${indent}${node.children.length === 0 ? \"/>\" : \">\"}`);\n    }\n\n    if (node.children.length > 0) {\n        let childIsFirst = true;\n        for (const child of node.children) {\n            serializeNode(child, lines, depth + 1, childIsFirst);\n            childIsFirst = false;\n        }\n        lines.push(`${indent}</a>`);\n    }\n}\n\nfunction buildAttrParts(node: Node): string[] {\n    const parts: string[] = [];\n\n    if (node.id) {\n        parts.push(` id=\"${escapeAttr(node.id)}\"`);\n    }\n\n    const sortedAttrs = [...node.attrs].sort((a, b) => a.name.localeCompare(b.name));\n\n    for (const attr of sortedAttrs) {\n        if (attr.value === \"\") {\n            parts.push(` ${attr.name}`);\n        } else {\n            parts.push(` ${attr.name}=\"${escapeAttr(attr.value)}\"`);\n        }\n    }\n\n    return parts;\n}\n\nfunction escapeAttr(str: string): string {\n    return str\n        .replace(/&/g, \"&amp;\")\n        .replace(/\"/g, \"&quot;\")\n        .replace(/</g, \"&lt;\")\n        .replace(/>/g, \"&gt;\");\n}\n","import { CycleError } from \"../../core\";\n\nexport type ResourceId = string;\nexport type NodeId = string;\n\nexport interface ResourceRef {\n    id: ResourceId;\n    access: \"read\" | \"write\";\n}\n\nexport interface ExecutionContext {\n    readonly device: GPUDevice;\n    readonly queue: GPUQueue;\n    readonly encoder: GPUCommandEncoder;\n    readonly context: GPUCanvasContext;\n    readonly format: GPUTextureFormat;\n    readonly canvasView: GPUTextureView;\n    getTexture(id: ResourceId): GPUTexture | null;\n    getTextureView(id: ResourceId): GPUTextureView | null;\n    getBuffer(id: ResourceId): GPUBuffer | null;\n    setTexture(id: ResourceId, texture: GPUTexture): void;\n    setTextureView(id: ResourceId, view: GPUTextureView): void;\n    setBuffer(id: ResourceId, buffer: GPUBuffer): void;\n}\n\nexport interface ComputeNode {\n    readonly id: NodeId;\n    readonly inputs: readonly ResourceRef[];\n    readonly outputs: readonly ResourceRef[];\n    readonly sync?: boolean;\n    readonly execute: (ctx: ExecutionContext) => void;\n    readonly prepare?: (device: GPUDevice) => Promise<void>;\n}\n\nexport interface ExecutionPlan {\n    readonly sorted: readonly ComputeNode[];\n}\n\nfunction buildEdges(nodes: ComputeNode[]): [ComputeNode, ComputeNode][] {\n    const edges: [ComputeNode, ComputeNode][] = [];\n    const producers = new Map<ResourceId, ComputeNode>();\n\n    for (const node of nodes) {\n        for (const output of node.outputs) {\n            producers.set(output.id, node);\n        }\n    }\n\n    for (const node of nodes) {\n        for (const input of node.inputs) {\n            const producer = producers.get(input.id);\n            if (producer && producer !== node) {\n                edges.push([producer, node]);\n            }\n        }\n    }\n\n    return edges;\n}\n\nfunction topoSort(nodes: ComputeNode[]): ComputeNode[] {\n    if (nodes.length === 0) return [];\n\n    const edges = buildEdges(nodes);\n    const adjacency = new Map<ComputeNode, ComputeNode[]>();\n    const inDegree = new Map<ComputeNode, number>();\n\n    for (const node of nodes) {\n        adjacency.set(node, []);\n        inDegree.set(node, 0);\n    }\n\n    for (const [from, to] of edges) {\n        adjacency.get(from)!.push(to);\n        inDegree.set(to, inDegree.get(to)! + 1);\n    }\n\n    const queue: ComputeNode[] = [];\n    for (const node of nodes) {\n        if (inDegree.get(node) === 0) {\n            queue.push(node);\n        }\n    }\n\n    const sorted: ComputeNode[] = [];\n    let i = 0;\n\n    while (i < queue.length) {\n        const node = queue[i++];\n        sorted.push(node);\n\n        for (const dep of adjacency.get(node)!) {\n            const newDegree = inDegree.get(dep)! - 1;\n            inDegree.set(dep, newDegree);\n            if (newDegree === 0) {\n                queue.push(dep);\n            }\n        }\n    }\n\n    if (sorted.length !== nodes.length) {\n        throw new CycleError();\n    }\n\n    return sorted;\n}\n\nfunction compile(nodes: ComputeNode[]): ExecutionPlan {\n    if (nodes.length === 0) {\n        return { sorted: [] };\n    }\n\n    return { sorted: topoSort(nodes) };\n}\n\nexport class ComputeGraph {\n    readonly nodes = new Map<NodeId, ComputeNode>();\n    private _plan: ExecutionPlan | null = null;\n\n    get planCached(): boolean {\n        return this._plan !== null;\n    }\n\n    add(node: ComputeNode): void {\n        if (this.nodes.has(node.id)) {\n            throw new Error(`Node '${node.id}' already exists`);\n        }\n        this.nodes.set(node.id, node);\n        this._plan = null;\n    }\n\n    set(id: NodeId, node: ComputeNode): void {\n        if (node.id !== id) {\n            throw new Error(`Node id '${node.id}' must match slot id '${id}'`);\n        }\n        this.nodes.set(id, node);\n        this._plan = null;\n    }\n\n    remove(id: NodeId): boolean {\n        const removed = this.nodes.delete(id);\n        if (removed) {\n            this._plan = null;\n        }\n        return removed;\n    }\n\n    compile(): ExecutionPlan {\n        if (!this._plan) {\n            this._plan = compile(Array.from(this.nodes.values()));\n        }\n        return this._plan;\n    }\n\n    async prepare(\n        device: GPUDevice,\n        onProgress?: (done: number, total: number) => void\n    ): Promise<void> {\n        const preparable = Array.from(this.nodes.values()).filter((n) => n.prepare);\n        const total = preparable.length;\n        let done = 0;\n\n        const promises = preparable.map(async (node) => {\n            await node.prepare!(device);\n            done++;\n            onProgress?.(done, total);\n        });\n\n        await Promise.all(promises);\n    }\n}\n","import { resource, type Plugin, type State, type System } from \"../../core\";\nimport { ComputeGraph, type ExecutionContext, type ResourceId } from \"./graph\";\n\nexport { ComputeGraph } from \"./graph\";\nexport type {\n    ResourceId,\n    NodeId,\n    ResourceRef,\n    ExecutionContext,\n    ComputeNode,\n    ExecutionPlan,\n} from \"./graph\";\n\nexport { readBuffer, readFloat32, readUint32, StagingPool } from \"./readback\";\n\nexport interface Canvas {\n    readonly element: HTMLCanvasElement;\n    readonly context: GPUCanvasContext;\n    readonly format: GPUTextureFormat;\n}\n\nexport const Canvas = resource<Canvas>(\"canvas\");\n\nexport function createEntityIdBuffer(device: GPUDevice, maxInstances: number): GPUBuffer {\n    return device.createBuffer({\n        label: \"entityIds\",\n        size: maxInstances * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n}\n\nexport async function requestGPU(): Promise<GPUDevice> {\n    if (!navigator.gpu) {\n        throw new Error(\"WebGPU not supported\");\n    }\n\n    const adapter = await navigator.gpu.requestAdapter();\n    if (!adapter) {\n        throw new Error(\"No GPU adapter found\");\n    }\n\n    const maxTextureDimension2D = adapter.limits.maxTextureDimension2D;\n\n    const device = await adapter.requestDevice({\n        requiredLimits: {\n            maxTextureDimension2D,\n        },\n    });\n\n    device.lost.then((info) => {\n        console.error(`GPU device lost: ${info.reason}`, info.message);\n    });\n\n    device.onuncapturederror = (event) => {\n        console.error(\"GPU uncaptured error:\", event.error);\n    };\n\n    return device;\n}\n\nexport interface ComputeResources {\n    textures: Map<ResourceId, GPUTexture>;\n    textureViews: Map<ResourceId, GPUTextureView>;\n    buffers: Map<ResourceId, GPUBuffer>;\n}\n\nexport interface Compute {\n    readonly device: GPUDevice;\n    readonly graph: ComputeGraph;\n    readonly resources: ComputeResources;\n    frameIndex: number;\n}\n\nexport const Compute = resource<Compute>(\"compute\");\n\nconst MIN_CANVAS_SIZE = 1;\n\nfunction syncCanvasSize(canvas: HTMLCanvasElement): void {\n    const dpr = window.devicePixelRatio || 1;\n    const rect = canvas.getBoundingClientRect();\n\n    const width = Math.max(MIN_CANVAS_SIZE, Math.floor(rect.width * dpr));\n    const height = Math.max(MIN_CANVAS_SIZE, Math.floor(rect.height * dpr));\n\n    if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n    }\n}\n\nlet resizeObserver: ResizeObserver | null = null;\nlet observedCanvas: HTMLCanvasElement | null = null;\n\nexport const ComputeSystem: System = {\n    group: \"draw\",\n\n    setup(state: State) {\n        const canvas = Canvas.from(state);\n        if (!canvas) return;\n\n        observedCanvas = canvas.element;\n        syncCanvasSize(observedCanvas);\n\n        resizeObserver = new ResizeObserver(() => {\n            if (observedCanvas) syncCanvasSize(observedCanvas);\n        });\n        resizeObserver.observe(observedCanvas);\n    },\n\n    update(state: State) {\n        const compute = Compute.from(state);\n        const canvas = Canvas.from(state);\n        if (!compute || !canvas) return;\n\n        const { device, graph, resources } = compute;\n        const { context, format } = canvas;\n        const plan = graph.compile();\n\n        if (plan.sorted.length === 0) return;\n\n        const canvasTexture = context.getCurrentTexture();\n        const canvasView = canvasTexture.createView();\n\n        const ctx: ExecutionContext = {\n            device,\n            queue: device.queue,\n            encoder: null as unknown as GPUCommandEncoder,\n            context,\n            format,\n            canvasView,\n            getTexture(id: ResourceId) {\n                return resources.textures.get(id) ?? null;\n            },\n            getTextureView(id: ResourceId) {\n                return resources.textureViews.get(id) ?? null;\n            },\n            getBuffer(id: ResourceId) {\n                return resources.buffers.get(id) ?? null;\n            },\n            setTexture(id: ResourceId, texture: GPUTexture) {\n                resources.textures.set(id, texture);\n            },\n            setTextureView(id: ResourceId, view: GPUTextureView) {\n                resources.textureViews.set(id, view);\n            },\n            setBuffer(id: ResourceId, buffer: GPUBuffer) {\n                resources.buffers.set(id, buffer);\n            },\n        };\n\n        let encoder = device.createCommandEncoder();\n        (ctx as { encoder: GPUCommandEncoder }).encoder = encoder;\n\n        for (const node of plan.sorted) {\n            node.execute(ctx);\n\n            if (node.sync) {\n                device.queue.submit([encoder.finish()]);\n                encoder = device.createCommandEncoder();\n                (ctx as { encoder: GPUCommandEncoder }).encoder = encoder;\n            }\n        }\n\n        device.queue.submit([encoder.finish()]);\n        compute.frameIndex++;\n    },\n\n    dispose() {\n        resizeObserver?.disconnect();\n        resizeObserver = null;\n        observedCanvas = null;\n    },\n};\n\nexport const ComputePlugin: Plugin = {\n    systems: [ComputeSystem],\n\n    async initialize(state: State, onProgress?: (progress: number) => void) {\n        const canvas = Canvas.from(state);\n        if (!canvas) return;\n\n        const device = await requestGPU();\n        const { context, format } = canvas;\n\n        context.configure({ device, format, alphaMode: \"premultiplied\" });\n\n        const graph = new ComputeGraph();\n        const resources: ComputeResources = {\n            textures: new Map(),\n            textureViews: new Map(),\n            buffers: new Map(),\n        };\n\n        state.setResource(Compute, { device, graph, resources, frameIndex: 0 });\n        onProgress?.(1);\n    },\n};\n\nexport function initCanvas(state: State, element: HTMLCanvasElement): void {\n    const context = element.getContext(\"webgpu\")!;\n    const format = navigator.gpu.getPreferredCanvasFormat();\n    element.style.imageRendering = \"pixelated\";\n    state.setResource(Canvas, { element, context, format });\n}\n","import type { Plugin, State } from \"../../core\";\nimport { resource } from \"../../core\";\nimport { Canvas } from \"../compute\";\n\nexport interface Spinner {\n    show(message?: string): (() => void) | void;\n}\n\nexport type SpinnerFactory = (canvas: HTMLCanvasElement) => Spinner;\n\nexport interface Activity {\n    active: boolean;\n    message: string | undefined;\n    acquire(message?: string): () => void;\n}\n\nexport const Activity = resource<Activity>(\"activity\");\n\nexport function createActivity(spinner: Spinner | null): Activity {\n    const messages: (string | undefined)[] = [];\n    let cleanup: (() => void) | void = undefined;\n    let displayedMessage: string | undefined = undefined;\n\n    const updateSpinner = () => {\n        const currentMessage = messages[messages.length - 1];\n\n        if (messages.length > 0 && spinner) {\n            if (cleanup && displayedMessage !== currentMessage) {\n                cleanup();\n                cleanup = undefined;\n            }\n            if (!cleanup) {\n                cleanup = spinner.show(currentMessage);\n                displayedMessage = currentMessage;\n            }\n        } else if (messages.length === 0 && cleanup) {\n            cleanup();\n            cleanup = undefined;\n            displayedMessage = undefined;\n        }\n    };\n\n    return {\n        get active() {\n            return messages.length > 0;\n        },\n\n        get message() {\n            return messages[messages.length - 1];\n        },\n\n        acquire(message?: string) {\n            messages.push(message);\n            updateSpinner();\n\n            let released = false;\n            return () => {\n                if (released) return;\n                released = true;\n                const idx = messages.lastIndexOf(message);\n                if (idx !== -1) messages.splice(idx, 1);\n                updateSpinner();\n            };\n        },\n    };\n}\n\ninterface Theme {\n    track: string;\n    accent: string;\n}\n\nconst dark: Theme = { track: \"rgba(51, 51, 51, 0.5)\", accent: \"#c0b8b0\" };\nconst light: Theme = { track: \"rgba(200, 200, 200, 0.5)\", accent: \"#505050\" };\n\nfunction createSpinner(canvas: HTMLCanvasElement, theme: Theme): Spinner {\n    return {\n        show(message?: string) {\n            const container = document.createElement(\"div\");\n            const spinnerEl = document.createElement(\"div\");\n\n            const updatePosition = () => {\n                const rect = canvas.getBoundingClientRect();\n                const parentRect = canvas.parentElement?.getBoundingClientRect();\n                if (!parentRect) return;\n\n                const bottom = parentRect.bottom - rect.bottom + 12;\n                const right = parentRect.right - rect.right + 12;\n\n                container.style.cssText = `\n                    position: absolute;\n                    bottom: ${bottom}px;\n                    right: ${right}px;\n                    display: flex;\n                    flex-direction: row;\n                    align-items: center;\n                    gap: 8px;\n                    z-index: 1000;\n                    pointer-events: none;\n                `;\n\n                spinnerEl.style.cssText = `\n                    width: 20px;\n                    height: 20px;\n                    border: 2px solid ${theme.track};\n                    border-top-color: ${theme.accent};\n                    border-radius: 50%;\n                    animation: shallot-activity-spin 0.8s linear infinite;\n                `;\n            };\n\n            updatePosition();\n\n            if (message) {\n                const label = document.createElement(\"div\");\n                label.textContent = message;\n                label.style.cssText = `\n                    font-family: system-ui, sans-serif;\n                    font-size: 12px;\n                    color: ${theme.accent};\n                    white-space: nowrap;\n                    text-align: right;\n                `;\n                container.appendChild(label);\n            }\n\n            container.appendChild(spinnerEl);\n\n            if (!document.getElementById(\"shallot-activity-style\")) {\n                const style = document.createElement(\"style\");\n                style.id = \"shallot-activity-style\";\n                style.textContent = `\n                    @keyframes shallot-activity-spin {\n                        to { transform: rotate(360deg); }\n                    }\n                `;\n                document.head.appendChild(style);\n            }\n\n            const parent = canvas.parentElement;\n            if (parent) {\n                if (getComputedStyle(parent).position === \"static\") {\n                    parent.style.position = \"relative\";\n                }\n                parent.appendChild(container);\n            }\n\n            const observer = new ResizeObserver(updatePosition);\n            observer.observe(canvas);\n\n            return () => {\n                observer.disconnect();\n                container.remove();\n            };\n        },\n    };\n}\n\nexport const spinnerDark = (canvas: HTMLCanvasElement): Spinner => createSpinner(canvas, dark);\n\nexport const spinnerLight = (canvas: HTMLCanvasElement): Spinner => createSpinner(canvas, light);\n\nexport const ActivityPlugin: Plugin & { spinner: SpinnerFactory | null } = {\n    spinner: null,\n\n    initialize(state: State) {\n        const canvas = Canvas.from(state);\n        const spinner =\n            canvas && ActivityPlugin.spinner ? ActivityPlugin.spinner(canvas.element) : null;\n        state.setResource(Activity, createActivity(spinner));\n    },\n};\n","import { resource, type State, type System, type Plugin } from \"../../core\";\nimport { Canvas } from \"../compute\";\n\nexport interface Mouse {\n    deltaX: number;\n    deltaY: number;\n    scroll: number;\n    left: boolean;\n    right: boolean;\n    middle: boolean;\n}\n\nexport interface Inputs {\n    readonly mouse: Readonly<Mouse>;\n    isKeyDown(code: string): boolean;\n    isKeyPressed(code: string): boolean;\n    isKeyReleased(code: string): boolean;\n}\n\nexport const Inputs = resource<Inputs>(\"inputs\");\n\nconst keys = new Set<string>();\nconst keysPressed = new Set<string>();\nconst keysReleased = new Set<string>();\n\nconst mouse: Mouse = {\n    deltaX: 0,\n    deltaY: 0,\n    scroll: 0,\n    left: false,\n    right: false,\n    middle: false,\n};\n\nconst inputs: Inputs = {\n    mouse,\n    isKeyDown: (code: string) => keys.has(code),\n    isKeyPressed: (code: string) => keysPressed.has(code),\n    isKeyReleased: (code: string) => keysReleased.has(code),\n};\n\nlet canvas: HTMLCanvasElement | null = null;\nlet lastPointerX = 0;\nlet lastPointerY = 0;\nlet activePointerId: number | null = null;\nlet activeButton: number | null = null;\n\nfunction handleKeyDown(e: KeyboardEvent): void {\n    if (!keys.has(e.code)) {\n        keysPressed.add(e.code);\n    }\n    keys.add(e.code);\n}\n\nfunction handleKeyUp(e: KeyboardEvent): void {\n    keys.delete(e.code);\n    keysReleased.add(e.code);\n}\n\nfunction setButtonState(button: number, pressed: boolean): void {\n    if (button === 0) mouse.left = pressed;\n    if (button === 1) mouse.middle = pressed;\n    if (button === 2) mouse.right = pressed;\n}\n\nfunction clearPointerState(): void {\n    if (activeButton !== null) {\n        setButtonState(activeButton, false);\n    }\n    activePointerId = null;\n    activeButton = null;\n    lastPointerX = 0;\n    lastPointerY = 0;\n}\n\nfunction handlePointerDown(e: PointerEvent): void {\n    if (e.target !== canvas) return;\n    if (activePointerId === null) {\n        activePointerId = e.pointerId;\n        activeButton = e.button;\n        lastPointerX = e.clientX;\n        lastPointerY = e.clientY;\n        setButtonState(e.button, true);\n        canvas!.setPointerCapture(e.pointerId);\n        e.preventDefault();\n    }\n}\n\nfunction handlePointerUp(e: PointerEvent): void {\n    if (e.pointerId === activePointerId) {\n        canvas?.releasePointerCapture(e.pointerId);\n        clearPointerState();\n    }\n}\n\nfunction handlePointerCancel(e: PointerEvent): void {\n    if (e.pointerId === activePointerId) {\n        clearPointerState();\n    }\n}\n\nfunction handlePointerMove(e: PointerEvent): void {\n    if (e.pointerId !== activePointerId) return;\n    e.preventDefault();\n    mouse.deltaX += e.clientX - lastPointerX;\n    mouse.deltaY += e.clientY - lastPointerY;\n    lastPointerX = e.clientX;\n    lastPointerY = e.clientY;\n}\n\nfunction handleWheel(e: WheelEvent): void {\n    if (e.target !== canvas) return;\n    mouse.scroll += e.deltaY;\n    e.preventDefault();\n}\n\nfunction handleContextMenu(e: Event): void {\n    if (e.target === canvas) {\n        e.preventDefault();\n    }\n}\n\nfunction resetFrameState(): void {\n    keysPressed.clear();\n    keysReleased.clear();\n    mouse.deltaX = 0;\n    mouse.deltaY = 0;\n    mouse.scroll = 0;\n}\n\nfunction clearAllState(): void {\n    keys.clear();\n    keysPressed.clear();\n    keysReleased.clear();\n    mouse.deltaX = 0;\n    mouse.deltaY = 0;\n    mouse.scroll = 0;\n    mouse.left = false;\n    mouse.right = false;\n    mouse.middle = false;\n    activePointerId = null;\n    activeButton = null;\n    lastPointerX = 0;\n    lastPointerY = 0;\n}\n\nexport const InputSystem: System = {\n    group: \"simulation\",\n\n    setup(state: State) {\n        const canvasRes = Canvas.from(state);\n        if (!canvasRes) return;\n        canvas = canvasRes.element;\n        canvas.style.touchAction = \"none\";\n\n        window.addEventListener(\"keydown\", handleKeyDown);\n        window.addEventListener(\"keyup\", handleKeyUp);\n        canvas.addEventListener(\"pointerdown\", handlePointerDown);\n        window.addEventListener(\"pointerup\", handlePointerUp);\n        window.addEventListener(\"pointercancel\", handlePointerCancel);\n        window.addEventListener(\"pointermove\", handlePointerMove);\n        canvas.addEventListener(\"wheel\", handleWheel, { passive: false });\n        canvas.addEventListener(\"contextmenu\", handleContextMenu);\n\n        state.setResource(Inputs, inputs);\n    },\n\n    dispose(state: State) {\n        if (canvas) {\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            window.removeEventListener(\"keyup\", handleKeyUp);\n            canvas.removeEventListener(\"pointerdown\", handlePointerDown);\n            window.removeEventListener(\"pointerup\", handlePointerUp);\n            window.removeEventListener(\"pointercancel\", handlePointerCancel);\n            window.removeEventListener(\"pointermove\", handlePointerMove);\n            canvas.removeEventListener(\"wheel\", handleWheel);\n            canvas.removeEventListener(\"contextmenu\", handleContextMenu);\n            canvas = null;\n        }\n\n        clearAllState();\n        state.deleteResource(Inputs);\n    },\n};\n\nconst InputResetSystem: System = {\n    group: \"draw\",\n    last: true,\n\n    update() {\n        resetFrameState();\n    },\n};\n\nexport const InputPlugin: Plugin = {\n    systems: [InputSystem, InputResetSystem],\n};\n","export type EasingFn = (t: number) => number;\n\nconst linear: EasingFn = (t) => t;\n\nconst easeInQuad: EasingFn = (t) => t * t;\nconst easeOutQuad: EasingFn = (t) => t * (2 - t);\nconst easeInOutQuad: EasingFn = (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t);\n\nconst easeInCubic: EasingFn = (t) => t * t * t;\nconst easeOutCubic: EasingFn = (t) => --t * t * t + 1;\nconst easeInOutCubic: EasingFn = (t) =>\n    t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\nconst easeInQuart: EasingFn = (t) => t * t * t * t;\nconst easeOutQuart: EasingFn = (t) => 1 - --t * t * t * t;\nconst easeInOutQuart: EasingFn = (t) => (t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t);\n\nconst easeInQuint: EasingFn = (t) => t * t * t * t * t;\nconst easeOutQuint: EasingFn = (t) => 1 + --t * t * t * t * t;\nconst easeInOutQuint: EasingFn = (t) =>\n    t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n\nconst easeInSine: EasingFn = (t) => 1 - Math.cos((t * Math.PI) / 2);\nconst easeOutSine: EasingFn = (t) => Math.sin((t * Math.PI) / 2);\nconst easeInOutSine: EasingFn = (t) => -(Math.cos(Math.PI * t) - 1) / 2;\n\nconst easeInExpo: EasingFn = (t) => (t === 0 ? 0 : Math.pow(2, 10 * t - 10));\nconst easeOutExpo: EasingFn = (t) => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t));\nconst easeInOutExpo: EasingFn = (t) =>\n    t === 0\n        ? 0\n        : t === 1\n          ? 1\n          : t < 0.5\n            ? Math.pow(2, 20 * t - 10) / 2\n            : (2 - Math.pow(2, -20 * t + 10)) / 2;\n\nconst easeInCirc: EasingFn = (t) => 1 - Math.sqrt(1 - t * t);\nconst easeOutCirc: EasingFn = (t) => Math.sqrt(1 - --t * t);\nconst easeInOutCirc: EasingFn = (t) =>\n    t < 0.5\n        ? (1 - Math.sqrt(1 - 4 * t * t)) / 2\n        : (Math.sqrt(1 - (-2 * t + 2) * (-2 * t + 2)) + 1) / 2;\n\nconst easeInBack: EasingFn = (t) => {\n    const c = 1.70158;\n    return (c + 1) * t * t * t - c * t * t;\n};\nconst easeOutBack: EasingFn = (t) => {\n    const c = 1.70158;\n    return 1 + (c + 1) * Math.pow(t - 1, 3) + c * Math.pow(t - 1, 2);\n};\nconst easeInOutBack: EasingFn = (t) => {\n    const c = 1.70158 * 1.525;\n    return t < 0.5\n        ? (Math.pow(2 * t, 2) * ((c + 1) * 2 * t - c)) / 2\n        : (Math.pow(2 * t - 2, 2) * ((c + 1) * (t * 2 - 2) + c) + 2) / 2;\n};\n\nconst easeInElastic: EasingFn = (t) =>\n    t === 0\n        ? 0\n        : t === 1\n          ? 1\n          : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * ((2 * Math.PI) / 3));\nconst easeOutElastic: EasingFn = (t) =>\n    t === 0\n        ? 0\n        : t === 1\n          ? 1\n          : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1;\nconst easeInOutElastic: EasingFn = (t) =>\n    t === 0\n        ? 0\n        : t === 1\n          ? 1\n          : t < 0.5\n            ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * ((2 * Math.PI) / 4.5))) / 2\n            : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * ((2 * Math.PI) / 4.5))) /\n                  2 +\n              1;\n\nconst easeOutBounce: EasingFn = (t) => {\n    const n1 = 7.5625;\n    const d1 = 2.75;\n    if (t < 1 / d1) return n1 * t * t;\n    if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;\n    if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;\n    return n1 * (t -= 2.625 / d1) * t + 0.984375;\n};\nconst easeInBounce: EasingFn = (t) => 1 - easeOutBounce(1 - t);\nconst easeInOutBounce: EasingFn = (t) =>\n    t < 0.5 ? (1 - easeOutBounce(1 - 2 * t)) / 2 : (1 + easeOutBounce(2 * t - 1)) / 2;\n\nexport const EASING_FUNCTIONS: readonly EasingFn[] = [\n    linear,\n    easeInQuad,\n    easeOutQuad,\n    easeInOutQuad,\n    easeInCubic,\n    easeOutCubic,\n    easeInOutCubic,\n    easeInQuart,\n    easeOutQuart,\n    easeInOutQuart,\n    easeInQuint,\n    easeOutQuint,\n    easeInOutQuint,\n    easeInSine,\n    easeOutSine,\n    easeInOutSine,\n    easeInExpo,\n    easeOutExpo,\n    easeInOutExpo,\n    easeInCirc,\n    easeOutCirc,\n    easeInOutCirc,\n    easeInBack,\n    easeOutBack,\n    easeInOutBack,\n    easeInElastic,\n    easeOutElastic,\n    easeInOutElastic,\n    easeInBounce,\n    easeOutBounce,\n    easeInOutBounce,\n] as const;\n\nconst EASING_INDEX: Record<string, number> = {\n    linear: 0,\n    \"ease-in-quad\": 1,\n    \"ease-out-quad\": 2,\n    \"ease-in-out-quad\": 3,\n    \"ease-in-cubic\": 4,\n    \"ease-out-cubic\": 5,\n    \"ease-in-out-cubic\": 6,\n    \"ease-in-quart\": 7,\n    \"ease-out-quart\": 8,\n    \"ease-in-out-quart\": 9,\n    \"ease-in-quint\": 10,\n    \"ease-out-quint\": 11,\n    \"ease-in-out-quint\": 12,\n    \"ease-in-sine\": 13,\n    \"ease-out-sine\": 14,\n    \"ease-in-out-sine\": 15,\n    \"ease-in-expo\": 16,\n    \"ease-out-expo\": 17,\n    \"ease-in-out-expo\": 18,\n    \"ease-in-circ\": 19,\n    \"ease-out-circ\": 20,\n    \"ease-in-out-circ\": 21,\n    \"ease-in-back\": 22,\n    \"ease-out-back\": 23,\n    \"ease-in-out-back\": 24,\n    \"ease-in-elastic\": 25,\n    \"ease-out-elastic\": 26,\n    \"ease-in-out-elastic\": 27,\n    \"ease-in-bounce\": 28,\n    \"ease-out-bounce\": 29,\n    \"ease-in-out-bounce\": 30,\n};\n\nexport function getEasingIndex(name: string): number {\n    return EASING_INDEX[name] ?? 0;\n}\n\nexport function getEasing(index: number): EasingFn {\n    return EASING_FUNCTIONS[index] ?? linear;\n}\n","import { Pair } from \"bitecs\";\nimport { setTraits } from \"../../core/component\";\nimport { ChildOf, type State } from \"../../core\";\nimport { Tween, TweenState, ensureResolved, captureFromValue } from \"./tween\";\n\nconst compareNumbers = (a: number, b: number) => a - b;\nconst compareByEndTime = (a: { endTime: number }, b: { endTime: number }) => a.endTime - b.endTime;\n\nconst childrenBuffer: number[] = [];\nconst tweensBuffer: { eid: number; endTime: number }[] = [];\n\nexport const Pause = {\n    duration: [] as number[],\n};\n\nsetTraits(Pause, {\n    defaults: () => ({ duration: 0.5 }),\n});\n\nexport const SequenceState = {\n    IDLE: 0,\n    PLAYING: 1,\n    COMPLETE: 2,\n} as const;\n\nexport const Sequence = {\n    state: [] as number[],\n    elapsed: [] as number[],\n};\n\nsetTraits(Sequence, {\n    defaults: () => ({\n        state: SequenceState.IDLE,\n        elapsed: 0,\n    }),\n});\n\nfunction sortedChildren(state: State, parentEid: number): number[] {\n    childrenBuffer.length = 0;\n    for (const childEid of state.query([Pair(ChildOf.relation, parentEid)])) {\n        childrenBuffer.push(childEid);\n    }\n    childrenBuffer.sort(compareNumbers);\n    return childrenBuffer;\n}\n\nexport function computeTweenDelays(state: State, seqEid: number): void {\n    const children = sortedChildren(state, seqEid);\n    let cumulativeDelay = 0;\n\n    for (const childEid of children) {\n        if (state.hasComponent(childEid, Pause)) {\n            cumulativeDelay += Pause.duration[childEid] ?? 0;\n        } else if (state.hasComponent(childEid, Tween)) {\n            Tween.delay[childEid] = cumulativeDelay;\n        }\n    }\n}\n\nexport function updateSequences(state: State, dt: number): void {\n    for (const seqEid of state.query([Sequence])) {\n        if (Sequence.state[seqEid] !== SequenceState.PLAYING) continue;\n\n        const prevElapsed = Sequence.elapsed[seqEid] ?? 0;\n\n        if (prevElapsed === 0) {\n            computeTweenDelays(state, seqEid);\n        }\n        const elapsed = prevElapsed + dt;\n        Sequence.elapsed[seqEid] = elapsed;\n\n        for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\n            if (Tween.state[childEid] !== TweenState.IDLE) continue;\n\n            const delay = Tween.delay[childEid] ?? 0;\n            const shouldStart = elapsed >= delay;\n            const wasStarted = prevElapsed >= delay;\n\n            if (shouldStart) {\n                captureFromValue(state, childEid);\n                Tween.state[childEid] = TweenState.PLAYING;\n                Tween.elapsed[childEid] = wasStarted ? 0 : elapsed - delay - dt;\n            }\n        }\n    }\n}\n\nfunction resolve(state: State, seqEid: number): void {\n    computeTweenDelays(state, seqEid);\n    tweensBuffer.length = 0;\n\n    for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\n        if (\n            Tween.state[childEid] === TweenState.COMPLETE &&\n            Tween.elapsed[childEid] >= Tween.duration[childEid]\n        ) {\n            continue;\n        }\n        const delay = Tween.delay[childEid] ?? 0;\n        const duration = Tween.duration[childEid] ?? 0;\n        tweensBuffer.push({ eid: childEid, endTime: delay + duration });\n    }\n\n    tweensBuffer.sort(compareByEndTime);\n\n    for (const { eid } of tweensBuffer) {\n        Tween.state[eid] = TweenState.COMPLETE;\n        ensureResolved(state, eid);\n    }\n}\n\nexport function resolveSequence(state: State, seqEid: number): void {\n    if (Sequence.state[seqEid] === SequenceState.COMPLETE) return;\n    Sequence.state[seqEid] = SequenceState.COMPLETE;\n    resolve(state, seqEid);\n}\n\nexport function resetSequence(state: State, seqEid: number): void {\n    Sequence.state[seqEid] = SequenceState.IDLE;\n    Sequence.elapsed[seqEid] = 0;\n    for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\n        Tween.state[childEid] = TweenState.IDLE;\n        Tween.elapsed[childEid] = 0;\n    }\n}\n\nexport function resolveAll(state: State): void {\n    for (const seqEid of state.query([Sequence])) {\n        if (Sequence.state[seqEid] === SequenceState.COMPLETE) {\n            resolve(state, seqEid);\n        }\n    }\n}\n\nexport function checkCompletion(state: State): void {\n    for (const seqEid of state.query([Sequence])) {\n        if (Sequence.state[seqEid] !== SequenceState.PLAYING) continue;\n\n        let allComplete = true;\n        let hasChildren = false;\n\n        for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\n            hasChildren = true;\n            if (Tween.state[childEid] !== TweenState.COMPLETE) {\n                allComplete = false;\n                break;\n            }\n        }\n\n        if (hasChildren && allComplete) {\n            Sequence.state[seqEid] = SequenceState.COMPLETE;\n        }\n    }\n}\n","import {\n    defineRelation,\n    registerPostLoadHook,\n    toCamelCase,\n    type State,\n    type System,\n    type Plugin,\n    type PostLoadContext,\n} from \"../../core\";\nimport {\n    setTraits,\n    getRegisteredComponent,\n    type FieldAccessor,\n    type ComponentLike,\n} from \"../../core/component\";\nimport { getEasingIndex, getEasing } from \"./easing\";\nimport { Sequence, Pause, updateSequences, resolveAll, checkCompletion } from \"./sequence\";\n\nconst fieldAccessors = new Map<number, FieldAccessor>();\n\nfunction resolveFieldPath(path: string): { component: string; field: string } | null {\n    const dotIndex = path.lastIndexOf(\".\");\n    if (dotIndex === -1) return null;\n    return {\n        component: path.slice(0, dotIndex),\n        field: path.slice(dotIndex + 1),\n    };\n}\n\nfunction bindFieldAccessor(\n    bindingId: number,\n    componentName: string,\n    fieldPath: string\n): FieldAccessor | null {\n    const registered = getRegisteredComponent(componentName);\n    if (!registered) return null;\n\n    const camelPath = toCamelCase(fieldPath);\n    const field = (registered.component as ComponentLike)[camelPath];\n    if (field == null) return null;\n\n    let accessor: FieldAccessor;\n\n    if (\n        typeof field === \"object\" &&\n        typeof (field as FieldAccessor).get === \"function\" &&\n        typeof (field as FieldAccessor).set === \"function\"\n    ) {\n        accessor = field as FieldAccessor;\n    } else if (ArrayBuffer.isView(field) || Array.isArray(field)) {\n        const data = field as number[];\n        accessor = {\n            get: (eid) => data[eid],\n            set: (eid, v) => {\n                data[eid] = v;\n            },\n        };\n    } else {\n        return null;\n    }\n\n    fieldAccessors.set(bindingId, accessor);\n    return accessor;\n}\n\nfunction getFieldAccessor(bindingId: number): FieldAccessor | undefined {\n    return fieldAccessors.get(bindingId);\n}\n\nfunction parseTweenAttrs(attrs: Record<string, string>): Record<string, string> {\n    if (attrs._value) {\n        const parsed: Record<string, string> = {};\n        for (const part of attrs._value.split(\";\")) {\n            const colonIdx = part.indexOf(\":\");\n            if (colonIdx === -1) continue;\n            const key = part.slice(0, colonIdx).trim();\n            const value = part.slice(colonIdx + 1).trim();\n            if (key && value) parsed[key] = value;\n        }\n        return parsed;\n    }\n    return attrs;\n}\n\nexport const TweenState = {\n    IDLE: 0,\n    PLAYING: 1,\n    COMPLETE: 2,\n} as const;\n\nexport const Tween = {\n    state: [] as number[],\n    from: [] as number[],\n    to: [] as number[],\n    duration: [] as number[],\n    elapsed: [] as number[],\n    delay: [] as number[],\n    easingIndex: [] as number[],\n};\n\nsetTraits(Tween, {\n    defaults: () => ({\n        state: TweenState.IDLE,\n        from: 0,\n        to: 0,\n        duration: 1,\n        elapsed: 0,\n        delay: 0,\n        easingIndex: 0,\n    }),\n    adapter: (attrs: Record<string, string>, eid: number) => {\n        const parsed = parseTweenAttrs(attrs);\n        const result: Record<string, number> = {};\n\n        if (parsed.duration) result.duration = parseFloat(parsed.duration);\n        if (parsed.delay) result.delay = parseFloat(parsed.delay);\n        if (parsed.easing) result.easingIndex = getEasingIndex(parsed.easing);\n\n        if (parsed.target) {\n            setupTweenFromXml(parsed, eid);\n        }\n\n        return result;\n    },\n});\n\nexport const TweenTarget = defineRelation(\"tween-target\", {\n    exclusive: true,\n});\n\ninterface ParsedTargetPath {\n    readonly entity: string;\n    readonly component: string;\n    readonly field: string;\n}\n\nfunction parseTargetPath(path: string): ParsedTargetPath | null {\n    if (!path.startsWith(\"@\")) return null;\n\n    const rest = path.slice(1);\n    const firstDot = rest.indexOf(\".\");\n    if (firstDot === -1) return null;\n\n    const entity = rest.slice(0, firstDot);\n    const fieldPath = rest.slice(firstDot + 1);\n    const dotIndex = fieldPath.lastIndexOf(\".\");\n    if (dotIndex === -1) return null;\n\n    return {\n        entity,\n        component: fieldPath.slice(0, dotIndex),\n        field: fieldPath.slice(dotIndex + 1),\n    };\n}\n\ninterface PendingTween {\n    readonly tweenEid: number;\n    readonly target: string;\n    readonly to: string;\n}\n\nlet pendingXmlTweens: PendingTween[] = [];\n\nfunction setupTweenFromXml(attrs: Record<string, string>, tweenEid: number): void {\n    pendingXmlTweens.push({\n        tweenEid,\n        target: attrs.target,\n        to: attrs.to,\n    });\n}\n\nexport function finalizePendingTweens(state: State, context: PostLoadContext): void {\n    for (const pending of pendingXmlTweens) {\n        const parsed = parseTargetPath(pending.target);\n        if (!parsed) continue;\n\n        const targetEid = context.getEntityByName(parsed.entity);\n        if (targetEid === null) continue;\n\n        const binding = bindFieldAccessor(pending.tweenEid, parsed.component, parsed.field);\n        if (!binding) continue;\n\n        state.addRelation(pending.tweenEid, TweenTarget, targetEid);\n        const toValue =\n            pending.to.startsWith(\"0x\") || pending.to.startsWith(\"0X\")\n                ? parseInt(pending.to, 16)\n                : parseFloat(pending.to);\n        if (!Number.isFinite(toValue)) {\n            throw new Error(`Tween has invalid 'to' value: \"${pending.to}\" (parsed as ${toValue})`);\n        }\n        Tween.to[pending.tweenEid] = toValue;\n    }\n    pendingXmlTweens = [];\n}\n\nexport function captureFromValue(state: State, tweenEid: number): void {\n    const targetEid = state.getFirstRelationTarget(tweenEid, TweenTarget);\n    const binding = getFieldAccessor(tweenEid);\n\n    if (binding && targetEid >= 0) {\n        Tween.from[tweenEid] = binding.get(targetEid) ?? 0;\n    }\n}\n\nexport function ensureResolved(state: State, tweenEid: number): void {\n    const elapsed = Tween.elapsed[tweenEid];\n    const duration = Tween.duration[tweenEid];\n\n    if (duration > 0 && elapsed >= duration) return;\n\n    const targetEid = state.getFirstRelationTarget(tweenEid, TweenTarget);\n    const binding = getFieldAccessor(tweenEid);\n\n    if (binding && targetEid >= 0) {\n        const toValue = Tween.to[tweenEid];\n        if (!Number.isFinite(toValue)) {\n            throw new Error(`Tween ${tweenEid} has invalid to value: ${toValue}`);\n        }\n        Tween.from[tweenEid] = binding.get(targetEid) ?? 0;\n        binding.set(targetEid, toValue);\n    }\n\n    Tween.elapsed[tweenEid] = duration;\n}\n\nfunction updateTweens(state: State, dt: number): void {\n    for (const tweenEid of state.query([Tween])) {\n        const tweenState = Tween.state[tweenEid];\n\n        if (tweenState === TweenState.COMPLETE) {\n            ensureResolved(state, tweenEid);\n            continue;\n        }\n\n        if (tweenState !== TweenState.PLAYING) continue;\n\n        const targetEid = state.getFirstRelationTarget(tweenEid, TweenTarget);\n        const binding = getFieldAccessor(tweenEid);\n\n        if (Tween.elapsed[tweenEid] === 0 && binding && targetEid >= 0) {\n            Tween.from[tweenEid] = binding.get(targetEid) ?? 0;\n        }\n\n        Tween.elapsed[tweenEid] += dt;\n\n        const elapsed = Tween.elapsed[tweenEid];\n        const duration = Tween.duration[tweenEid];\n        const rawProgress = duration <= 0 ? 1 : Math.min(elapsed / duration, 1);\n\n        if (!Number.isFinite(rawProgress)) {\n            throw new Error(\n                `Tween ${tweenEid} invalid progress: elapsed=${elapsed}, duration=${duration}, dt=${dt}`\n            );\n        }\n\n        const easingFn = getEasing(Tween.easingIndex[tweenEid]);\n        const easedProgress = easingFn(rawProgress);\n\n        const from = Tween.from[tweenEid];\n        const to = Tween.to[tweenEid];\n        const value = from + (to - from) * easedProgress;\n\n        if (!Number.isFinite(value)) {\n            throw new Error(\n                `Tween ${tweenEid} computed NaN: from=${from}, to=${to}, eased=${easedProgress}, raw=${rawProgress}`\n            );\n        }\n\n        if (binding && targetEid >= 0) {\n            binding.set(targetEid, value);\n        }\n\n        if (rawProgress >= 1) {\n            Tween.state[tweenEid] = TweenState.COMPLETE;\n        }\n    }\n}\n\nexport interface TweenOptions {\n    readonly to: number;\n    readonly duration?: number;\n    readonly easing?: string;\n}\n\nexport function createTween(\n    state: State,\n    targetEid: number,\n    fieldPath: string,\n    options: TweenOptions\n): number | null {\n    const parsed = resolveFieldPath(fieldPath);\n    if (!parsed) return null;\n\n    const tweenEid = state.addEntity();\n    state.addComponent(tweenEid, Tween);\n\n    const binding = bindFieldAccessor(tweenEid, parsed.component, parsed.field);\n    if (!binding) {\n        state.removeEntity(tweenEid);\n        return null;\n    }\n\n    state.addRelation(tweenEid, TweenTarget, targetEid);\n\n    Tween.to[tweenEid] = options.to;\n    Tween.duration[tweenEid] = options.duration ?? 1;\n    Tween.elapsed[tweenEid] = 0;\n    Tween.easingIndex[tweenEid] = getEasingIndex(options.easing ?? \"linear\");\n\n    return tweenEid;\n}\n\nexport const TweenSystem: System = {\n    group: \"simulation\",\n\n    update(state: State) {\n        const dt = state.time.deltaTime;\n\n        resolveAll(state);\n        updateSequences(state, dt);\n        updateTweens(state, dt);\n        checkCompletion(state);\n    },\n};\n\nexport const TweenPlugin: Plugin = {\n    systems: [TweenSystem],\n    components: { Tween, Sequence, Pause },\n    relations: [TweenTarget],\n    initialize() {\n        registerPostLoadHook(finalizePendingTweens);\n    },\n};\n","let wasm;\n\n/**\n * @param {number} count\n */\nexport function compute_transforms(count) {\n    wasm.compute_transforms(count);\n}\n\n/**\n * @returns {number}\n */\nexport function get_indices_ptr() {\n    const ret = wasm.get_indices_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_matrices_ptr() {\n    const ret = wasm.get_matrices_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_max_entities() {\n    const ret = wasm.get_max_entities();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_no_parent() {\n    const ret = wasm.get_no_parent();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_parents_ptr() {\n    const ret = wasm.get_parents_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_pos_x_ptr() {\n    const ret = wasm.get_pos_x_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_pos_y_ptr() {\n    const ret = wasm.get_pos_y_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_pos_z_ptr() {\n    const ret = wasm.get_pos_z_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_quat_w_ptr() {\n    const ret = wasm.get_quat_w_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_quat_x_ptr() {\n    const ret = wasm.get_quat_x_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_quat_y_ptr() {\n    const ret = wasm.get_quat_y_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_quat_z_ptr() {\n    const ret = wasm.get_quat_z_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_scale_x_ptr() {\n    const ret = wasm.get_scale_x_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_scale_y_ptr() {\n    const ret = wasm.get_scale_y_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_scale_z_ptr() {\n    const ret = wasm.get_scale_z_ptr();\n    return ret >>> 0;\n}\n\nexport function init_data() {\n    wasm.init_data();\n}\n\nconst EXPECTED_RESPONSE_TYPES = new Set(['basic', 'cors', 'default']);\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n            } catch (e) {\n                const validResponse = module.ok && EXPECTED_RESPONSE_TYPES.has(module.type);\n\n                if (validResponse && module.headers.get('Content-Type') !== 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n\n    return imports;\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n    const instance = new WebAssembly.Instance(module, imports);\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('shallot_transforms_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","import wasmInit, {\n    get_pos_x_ptr,\n    get_pos_y_ptr,\n    get_pos_z_ptr,\n    get_quat_x_ptr,\n    get_quat_y_ptr,\n    get_quat_z_ptr,\n    get_quat_w_ptr,\n    get_scale_x_ptr,\n    get_scale_y_ptr,\n    get_scale_z_ptr,\n    get_matrices_ptr,\n    get_indices_ptr,\n    get_parents_ptr,\n    get_max_entities,\n    get_no_parent,\n    init_data,\n    compute_transforms,\n} from \"../../../rust/transforms/pkg/shallot_transforms.js\";\n\nexport let posX: Float32Array;\nexport let posY: Float32Array;\nexport let posZ: Float32Array;\nexport let quatX: Float32Array;\nexport let quatY: Float32Array;\nexport let quatZ: Float32Array;\nexport let quatW: Float32Array;\nexport let scaleX: Float32Array;\nexport let scaleY: Float32Array;\nexport let scaleZ: Float32Array;\nexport let matrices: Float32Array;\nexport let indices: Uint32Array;\nexport let parents: Uint32Array;\nexport let NoParent: number;\n\nexport async function init(): Promise<void> {\n    if (posX) return;\n    const wasm = await wasmInit();\n    init_data();\n    const buffer = wasm.memory.buffer;\n    const maxEntities = get_max_entities();\n\n    posX = new Float32Array(buffer, get_pos_x_ptr(), maxEntities);\n    posY = new Float32Array(buffer, get_pos_y_ptr(), maxEntities);\n    posZ = new Float32Array(buffer, get_pos_z_ptr(), maxEntities);\n    quatX = new Float32Array(buffer, get_quat_x_ptr(), maxEntities);\n    quatY = new Float32Array(buffer, get_quat_y_ptr(), maxEntities);\n    quatZ = new Float32Array(buffer, get_quat_z_ptr(), maxEntities);\n    quatW = new Float32Array(buffer, get_quat_w_ptr(), maxEntities);\n    scaleX = new Float32Array(buffer, get_scale_x_ptr(), maxEntities);\n    scaleY = new Float32Array(buffer, get_scale_y_ptr(), maxEntities);\n    scaleZ = new Float32Array(buffer, get_scale_z_ptr(), maxEntities);\n    matrices = new Float32Array(buffer, get_matrices_ptr(), maxEntities * 16);\n    indices = new Uint32Array(buffer, get_indices_ptr(), maxEntities);\n    parents = new Uint32Array(buffer, get_parents_ptr(), maxEntities);\n    NoParent = get_no_parent();\n}\n\nexport function compute(count: number): void {\n    compute_transforms(count);\n}\n","import { Hierarchy, Not, Wildcard } from \"bitecs\";\nimport {\n    ChildOf,\n    MAX_ENTITIES,\n    rotateQuaternion,\n    eulerToQuaternion,\n    quaternionToEuler,\n    type State,\n    type System,\n    type Plugin,\n} from \"../../core\";\nimport { setTraits } from \"../../core/component\";\nimport * as wasm from \"./wasm\";\n\nexport function rotate(eid: number, dx: number, dy: number, dz: number): void {\n    const q = rotateQuaternion(\n        Transform.quatX[eid],\n        Transform.quatY[eid],\n        Transform.quatZ[eid],\n        Transform.quatW[eid],\n        dx,\n        dy,\n        dz\n    );\n    Transform.quatX[eid] = q.x;\n    Transform.quatY[eid] = q.y;\n    Transform.quatZ[eid] = q.z;\n    Transform.quatW[eid] = q.w;\n}\n\ninterface EulerProxy extends Array<number> {\n    get(eid: number): number;\n    set(eid: number, value: number): void;\n}\n\nfunction eulerProxy(axis: \"x\" | \"y\" | \"z\"): EulerProxy {\n    function getValue(eid: number): number {\n        const e = quaternionToEuler(\n            Transform.quatX[eid],\n            Transform.quatY[eid],\n            Transform.quatZ[eid],\n            Transform.quatW[eid]\n        );\n        return e[axis];\n    }\n\n    function setValue(eid: number, value: number): void {\n        const e = quaternionToEuler(\n            Transform.quatX[eid],\n            Transform.quatY[eid],\n            Transform.quatZ[eid],\n            Transform.quatW[eid]\n        );\n        e[axis] = value;\n        const q = eulerToQuaternion(e.x, e.y, e.z);\n        Transform.quatX[eid] = q.x;\n        Transform.quatY[eid] = q.y;\n        Transform.quatZ[eid] = q.z;\n        Transform.quatW[eid] = q.w;\n    }\n\n    return new Proxy([] as unknown as EulerProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nexport const Transform: {\n    posX: Float32Array;\n    posY: Float32Array;\n    posZ: Float32Array;\n    quatX: Float32Array;\n    quatY: Float32Array;\n    quatZ: Float32Array;\n    quatW: Float32Array;\n    scaleX: Float32Array;\n    scaleY: Float32Array;\n    scaleZ: Float32Array;\n    eulerX: EulerProxy;\n    eulerY: EulerProxy;\n    eulerZ: EulerProxy;\n} = {\n    posX: new Float32Array(MAX_ENTITIES),\n    posY: new Float32Array(MAX_ENTITIES),\n    posZ: new Float32Array(MAX_ENTITIES),\n    quatX: new Float32Array(MAX_ENTITIES),\n    quatY: new Float32Array(MAX_ENTITIES),\n    quatZ: new Float32Array(MAX_ENTITIES),\n    quatW: new Float32Array(MAX_ENTITIES),\n    scaleX: new Float32Array(MAX_ENTITIES),\n    scaleY: new Float32Array(MAX_ENTITIES),\n    scaleZ: new Float32Array(MAX_ENTITIES),\n    eulerX: eulerProxy(\"x\"),\n    eulerY: eulerProxy(\"y\"),\n    eulerZ: eulerProxy(\"z\"),\n};\n\nexport const WorldTransform: { data: Float32Array } = {\n    data: new Float32Array(MAX_ENTITIES * 16),\n};\n\nsetTraits(Transform, {\n    defaults: () => ({\n        posX: 0,\n        posY: 0,\n        posZ: 0,\n        quatX: 0,\n        quatY: 0,\n        quatZ: 0,\n        quatW: 1,\n        scaleX: 1,\n        scaleY: 1,\n        scaleZ: 1,\n    }),\n});\n\nasync function init(): Promise<void> {\n    await wasm.init();\n\n    Transform.posX = wasm.posX;\n    Transform.posY = wasm.posY;\n    Transform.posZ = wasm.posZ;\n    Transform.quatX = wasm.quatX;\n    Transform.quatY = wasm.quatY;\n    Transform.quatZ = wasm.quatZ;\n    Transform.quatW = wasm.quatW;\n    Transform.scaleX = wasm.scaleX;\n    Transform.scaleY = wasm.scaleY;\n    Transform.scaleZ = wasm.scaleZ;\n    WorldTransform.data = wasm.matrices;\n}\n\nconst TransformSystem: System = {\n    group: \"simulation\",\n    last: true,\n\n    update(state: State) {\n        for (const eid of state.query([Transform, Not(WorldTransform)])) {\n            state.addComponent(eid, WorldTransform);\n        }\n\n        let count = 0;\n\n        for (const eid of state.query([Transform, Not(ChildOf.relation(Wildcard))])) {\n            wasm.indices[count] = eid;\n            wasm.parents[count] = wasm.NoParent;\n            count++;\n        }\n\n        for (const eid of state.query([\n            Transform,\n            ChildOf.relation(Wildcard),\n            Hierarchy(ChildOf.relation),\n        ])) {\n            wasm.indices[count] = eid;\n            wasm.parents[count] = state.getRelationTargets(eid, ChildOf)[0];\n            count++;\n        }\n\n        wasm.compute(count);\n    },\n};\n\nexport const TransformsPlugin: Plugin = {\n    systems: [TransformSystem],\n    components: { Transform, WorldTransform },\n    async initialize(_state, onProgress) {\n        await init();\n        onProgress?.(1);\n    },\n};\n","import { setTraits } from \"../../core/component\";\nimport { perspective, orthographic, multiply, invert, extractFrustumPlanes } from \"../../core/math\";\nimport { WorldTransform } from \"../transforms\";\n\nexport const RenderMode = {\n    Raster: 0,\n    Raytracing: 1,\n} as const;\n\nexport const CameraMode = {\n    Perspective: 0,\n    Orthographic: 1,\n} as const;\n\nexport const Camera = {\n    fov: [] as number[],\n    near: [] as number[],\n    far: [] as number[],\n    active: [] as number[],\n    clearColor: [] as number[],\n    renderMode: [] as number[],\n    mode: [] as number[],\n    size: [] as number[],\n};\n\nsetTraits(Camera, {\n    defaults: () => ({\n        fov: 60,\n        near: 0.1,\n        far: 1000,\n        active: 1,\n        clearColor: 0x1a1a1a,\n        renderMode: RenderMode.Raster,\n        mode: CameraMode.Perspective,\n        size: 5,\n    }),\n});\n\nexport const Tonemap = {\n    exposure: [] as number[],\n};\n\nsetTraits(Tonemap, {\n    defaults: () => ({ exposure: 1.0 }),\n});\n\nexport const FXAA = {};\n\nexport const Raytracing = {};\n\nexport const Vignette = {\n    strength: [] as number[],\n    inner: [] as number[],\n    outer: [] as number[],\n};\n\nsetTraits(Vignette, {\n    defaults: () => ({ strength: 0.5, inner: 0.4, outer: 0.8 }),\n});\n\nexport const Bloom = {\n    intensity: [] as number[],\n    threshold: [] as number[],\n    radius: [] as number[],\n};\n\nsetTraits(Bloom, {\n    defaults: () => ({\n        intensity: 0.15,\n        threshold: 0.0,\n        radius: 0.5,\n    }),\n});\n\nexport const Quantize = {\n    bands: [] as number[],\n};\n\nsetTraits(Quantize, {\n    defaults: () => ({ bands: 8 }),\n});\n\nexport const Shadows = {\n    softness: [] as number[],\n    samples: [] as number[],\n};\n\nsetTraits(Shadows, {\n    defaults: () => ({\n        softness: 0.5,\n        samples: 1,\n    }),\n});\n\nexport const Reflections = {\n    depth: [] as number[],\n};\n\nsetTraits(Reflections, {\n    defaults: () => ({ depth: 1 }),\n});\n\nexport const Refractions = {\n    depth: [] as number[],\n};\n\nsetTraits(Refractions, {\n    defaults: () => ({ depth: 2 }),\n});\n\nexport const Haze = {\n    density: [] as number[],\n    color: [] as number[],\n};\n\nsetTraits(Haze, {\n    defaults: () => ({\n        density: 0.005,\n        color: 0x4078d0,\n    }),\n});\n\nexport const Sky = {\n    zenith: [] as number[],\n    horizon: [] as number[],\n};\n\nsetTraits(Sky, {\n    defaults: () => ({\n        zenith: 0x4078d0,\n        horizon: 0x4098d8,\n    }),\n});\n\nexport const Moon = {\n    phase: [] as number[],\n    glow: [] as number[],\n    azimuth: [] as number[],\n    elevation: [] as number[],\n};\n\nsetTraits(Moon, {\n    defaults: () => ({\n        phase: 0.5,\n        glow: 0.3,\n        azimuth: 45,\n        elevation: 30,\n    }),\n});\n\nexport const Stars = {\n    intensity: [] as number[],\n    amount: [] as number[],\n};\n\nsetTraits(Stars, {\n    defaults: () => ({\n        intensity: 0.8,\n        amount: 0.5,\n    }),\n});\n\nexport const Clouds = {\n    coverage: [] as number[],\n    density: [] as number[],\n    height: [] as number[],\n    color: [] as number[],\n};\n\nsetTraits(Clouds, {\n    defaults: () => ({\n        coverage: 0.7,\n        density: 0.8,\n        height: 0.5,\n        color: 0xffffff,\n    }),\n});\n\nexport const Sun = {\n    size: [] as number[],\n    glow: [] as number[],\n    color: [] as number[],\n};\n\nsetTraits(Sun, {\n    defaults: () => ({\n        size: 1.0,\n        glow: 0.4,\n        color: 0,\n    }),\n});\n\nexport const Viewport = {\n    width: [] as number[],\n    height: [] as number[],\n};\n\nsetTraits(Viewport, {\n    defaults: () => ({ width: 0, height: 0 }),\n});\n\nexport interface SkyParams {\n    zenith: number;\n    horizon: number;\n}\n\nexport function unpackColor(packed: number): { r: number; g: number; b: number } {\n    return {\n        r: ((packed >> 16) & 0xff) / 255,\n        g: ((packed >> 8) & 0xff) / 255,\n        b: (packed & 0xff) / 255,\n    };\n}\n\nexport interface HazeParams {\n    density: number;\n    color: number;\n}\n\nexport interface MoonParams {\n    phase: number;\n    glow: number;\n    azimuth: number;\n    elevation: number;\n}\n\nexport interface StarsParams {\n    intensity: number;\n    amount: number;\n}\n\nexport interface CloudsParams {\n    coverage: number;\n    density: number;\n    height: number;\n    color: number;\n}\n\nexport interface SunParams {\n    size: number;\n    glow: number;\n    color: number;\n}\n\nconst sceneBuffer = new ArrayBuffer(512);\nconst scene = new Float32Array(sceneBuffer);\nconst sceneU32 = new Uint32Array(sceneBuffer);\n\nexport function uploadCamera(\n    device: GPUDevice,\n    buffer: GPUBuffer,\n    eid: number,\n    width: number,\n    height: number,\n    shadowSoftness: number = 0,\n    shadowSamples: number = 1,\n    reflectionDepth: number = 0,\n    refractionDepth: number = 0,\n    instanceCount: number = 0,\n    haze?: HazeParams,\n    sky?: SkyParams,\n    moon?: MoonParams,\n    stars?: StarsParams,\n    clouds?: CloudsParams,\n    sun?: SunParams\n): void {\n    const aspect = width / height;\n    const proj =\n        Camera.mode[eid] === CameraMode.Orthographic\n            ? orthographic(Camera.size[eid], aspect, Camera.near[eid], Camera.far[eid])\n            : perspective(Camera.fov[eid], aspect, Camera.near[eid], Camera.far[eid]);\n    const world = WorldTransform.data.subarray(eid * 16, eid * 16 + 16);\n    const view = invert(world);\n    const viewProj = multiply(proj, view);\n\n    // viewProj (0-63)\n    scene.set(viewProj, 0);\n    // world (64-127)\n    scene.set(world, 16);\n\n    // clearColor (176-191) - note: 128-175 is light uniforms, written separately\n    const clearColorPacked = Camera.clearColor[eid];\n    scene[44] = ((clearColorPacked >> 16) & 0xff) / 255;\n    scene[45] = ((clearColorPacked >> 8) & 0xff) / 255;\n    scene[46] = (clearColorPacked & 0xff) / 255;\n    scene[47] = 1.0;\n\n    // cameraMode, cameraSize, viewport (192-207)\n    scene[48] = Camera.mode[eid];\n    scene[49] = Camera.size[eid];\n    scene[50] = width;\n    scene[51] = height;\n\n    // fov, near, far, shadowSoftness (208-223)\n    scene[52] = Camera.fov[eid];\n    scene[53] = Camera.near[eid];\n    scene[54] = Camera.far[eid];\n    scene[55] = shadowSoftness;\n\n    // shadowSamples, reflectionDepth, refractionDepth, instanceCount (224-239)\n    sceneU32[56] = shadowSamples;\n    sceneU32[57] = reflectionDepth;\n    sceneU32[58] = refractionDepth;\n    sceneU32[59] = instanceCount;\n\n    // hazeDensity (240-255)\n    scene[60] = haze?.density ?? 0;\n    scene[61] = 0;\n    scene[62] = 0;\n    scene[63] = 0;\n\n    // hazeColor (256-271)\n    const hazeColorPacked = haze?.color ?? 0x8090b0;\n    scene[64] = ((hazeColorPacked >> 16) & 0xff) / 255;\n    scene[65] = ((hazeColorPacked >> 8) & 0xff) / 255;\n    scene[66] = (hazeColorPacked & 0xff) / 255;\n    scene[67] = 1.0;\n\n    // skyZenith (272-287)\n    const zenithPacked = sky?.zenith ?? 0;\n    scene[68] = ((zenithPacked >> 16) & 0xff) / 255;\n    scene[69] = ((zenithPacked >> 8) & 0xff) / 255;\n    scene[70] = (zenithPacked & 0xff) / 255;\n    scene[71] = sky ? 1.0 : 0.0;\n\n    // skyHorizon (288-303)\n    const horizonPacked = sky?.horizon ?? 0;\n    scene[72] = ((horizonPacked >> 16) & 0xff) / 255;\n    scene[73] = ((horizonPacked >> 8) & 0xff) / 255;\n    scene[74] = (horizonPacked & 0xff) / 255;\n    scene[75] = 1.0;\n\n    // frustumPlanes (304-399)\n    const planes = extractFrustumPlanes(viewProj);\n    scene.set(planes, 76);\n\n    // moonParams (400-415)\n    scene[100] = moon?.phase ?? 0.5;\n    scene[101] = moon?.glow ?? 0.3;\n    scene[102] = moon ? 1.0 : 0.0;\n    scene[103] = 0.0;\n\n    // moonDirection (416-431)\n    const moonAzimuth = ((moon?.azimuth ?? 45) * Math.PI) / 180;\n    const moonElevation = ((moon?.elevation ?? 30) * Math.PI) / 180;\n    const moonCosEl = Math.cos(moonElevation);\n    scene[104] = Math.sin(moonAzimuth) * moonCosEl;\n    scene[105] = Math.sin(moonElevation);\n    scene[106] = Math.cos(moonAzimuth) * moonCosEl;\n    scene[107] = 0.0;\n\n    // starParams (432-447)\n    scene[108] = stars?.intensity ?? 0.8;\n    scene[109] = stars?.amount ?? 0.5;\n    scene[110] = stars ? 1.0 : 0.0;\n    scene[111] = 0.0;\n\n    // cloudParams (448-463)\n    scene[112] = clouds?.coverage ?? 0;\n    scene[113] = clouds?.density ?? 0;\n    scene[114] = clouds?.height ?? 0;\n    scene[115] = clouds ? 1.0 : 0.0;\n\n    // cloudColor (464-479)\n    const cloudColorPacked = clouds?.color ?? 0xffffff;\n    scene[116] = ((cloudColorPacked >> 16) & 0xff) / 255;\n    scene[117] = ((cloudColorPacked >> 8) & 0xff) / 255;\n    scene[118] = (cloudColorPacked & 0xff) / 255;\n    scene[119] = 0.0;\n\n    // sunParams (480-495)\n    scene[120] = sun?.size ?? 1.0;\n    scene[121] = sun?.glow ?? 0.5;\n    scene[122] = sun && sun.color !== 0 ? 1.0 : 0.0;\n    scene[123] = 0.0;\n\n    // sunVisualColor (496-511)\n    const sunColorPacked = sun?.color ?? 0xffffff;\n    scene[124] = ((sunColorPacked >> 16) & 0xff) / 255;\n    scene[125] = ((sunColorPacked >> 8) & 0xff) / 255;\n    scene[126] = (sunColorPacked & 0xff) / 255;\n    scene[127] = 0.0;\n\n    device.queue.writeBuffer(buffer, 0, scene, 0, 32);\n    device.queue.writeBuffer(buffer, 176, scene, 44, 84);\n}\n","import { setTraits } from \"../../core/component\";\nimport { unpackColor } from \"./camera\";\n\nexport const AmbientLight = {\n    color: [] as number[],\n    intensity: [] as number[],\n};\n\nsetTraits(AmbientLight, {\n    defaults: () => ({ color: 0x888888, intensity: 1.0 }),\n});\n\nexport const DirectionalLight = {\n    color: [] as number[],\n    intensity: [] as number[],\n    directionX: [] as number[],\n    directionY: [] as number[],\n    directionZ: [] as number[],\n};\n\nsetTraits(DirectionalLight, {\n    defaults: () => ({\n        color: 0xffffff,\n        intensity: 0.8,\n        directionX: -0.6,\n        directionY: -1.0,\n        directionZ: -0.8,\n    }),\n});\n\nexport function normalizeDirection(x: number, y: number, z: number): [number, number, number] {\n    const len = Math.sqrt(x * x + y * y + z * z);\n    if (len < 0.0001) {\n        return [0, -1, 0];\n    }\n    return [x / len, y / len, z / len];\n}\n\nexport interface AmbientLightData {\n    color: number;\n    intensity: number;\n}\n\nexport interface DirectionalLightData {\n    color: number;\n    intensity: number;\n    directionX: number;\n    directionY: number;\n    directionZ: number;\n}\n\nconst lightData = new Float32Array(12);\n\nexport function packLightUniforms(\n    ambient: AmbientLightData,\n    directional: DirectionalLightData\n): Float32Array {\n    const ambientRgb = unpackColor(ambient.color);\n    lightData[0] = ambientRgb.r;\n    lightData[1] = ambientRgb.g;\n    lightData[2] = ambientRgb.b;\n    lightData[3] = ambient.intensity;\n\n    const [dx, dy, dz] = normalizeDirection(\n        directional.directionX,\n        directional.directionY,\n        directional.directionZ\n    );\n    lightData[4] = dx;\n    lightData[5] = dy;\n    lightData[6] = dz;\n    lightData[7] = 0;\n\n    const sunRgb = unpackColor(directional.color);\n    lightData[8] = sunRgb.r * directional.intensity;\n    lightData[9] = sunRgb.g * directional.intensity;\n    lightData[10] = sunRgb.b * directional.intensity;\n    lightData[11] = 0;\n\n    return lightData;\n}\n","export const INDIRECT_SIZE = 20;\n\nexport interface IndirectArgs {\n    indexCount: number;\n    instanceCount: number;\n    firstIndex: number;\n    baseVertex: number;\n    firstInstance: number;\n}\n\nexport function createIndirectBuffer(device: GPUDevice, slotCount: number): GPUBuffer {\n    return device.createBuffer({\n        label: \"indirect\",\n        size: slotCount * INDIRECT_SIZE,\n        usage:\n            GPUBufferUsage.INDIRECT |\n            GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_DST |\n            GPUBufferUsage.COPY_SRC,\n    });\n}\n\nexport function writeIndirect(\n    device: GPUDevice,\n    buffer: GPUBuffer,\n    slot: number,\n    args: IndirectArgs\n): void {\n    const offset = slot * INDIRECT_SIZE;\n    const data = new ArrayBuffer(INDIRECT_SIZE);\n    const view = new DataView(data);\n\n    view.setUint32(0, args.indexCount, true);\n    view.setUint32(4, args.instanceCount, true);\n    view.setUint32(8, args.firstIndex, true);\n    view.setInt32(12, args.baseVertex, true);\n    view.setUint32(16, args.firstInstance, true);\n\n    device.queue.writeBuffer(buffer, offset, data);\n}\n","import type { MeshData } from \"./index\";\n\nexport function createBox(): MeshData {\n    const vertices = new Float32Array([\n        -0.5, -0.5, 0.5, 0, 0, 1, 0.5, -0.5, 0.5, 0, 0, 1, 0.5, 0.5, 0.5, 0, 0, 1, -0.5, 0.5, 0.5,\n        0, 0, 1, 0.5, -0.5, -0.5, 0, 0, -1, -0.5, -0.5, -0.5, 0, 0, -1, -0.5, 0.5, -0.5, 0, 0, -1,\n        0.5, 0.5, -0.5, 0, 0, -1, -0.5, 0.5, 0.5, 0, 1, 0, 0.5, 0.5, 0.5, 0, 1, 0, 0.5, 0.5, -0.5,\n        0, 1, 0, -0.5, 0.5, -0.5, 0, 1, 0, -0.5, -0.5, -0.5, 0, -1, 0, 0.5, -0.5, -0.5, 0, -1, 0,\n        0.5, -0.5, 0.5, 0, -1, 0, -0.5, -0.5, 0.5, 0, -1, 0, 0.5, -0.5, 0.5, 1, 0, 0, 0.5, -0.5,\n        -0.5, 1, 0, 0, 0.5, 0.5, -0.5, 1, 0, 0, 0.5, 0.5, 0.5, 1, 0, 0, -0.5, -0.5, -0.5, -1, 0, 0,\n        -0.5, -0.5, 0.5, -1, 0, 0, -0.5, 0.5, 0.5, -1, 0, 0, -0.5, 0.5, -0.5, -1, 0, 0,\n    ]);\n\n    const indices = new Uint16Array([\n        0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18,\n        16, 18, 19, 20, 21, 22, 20, 22, 23,\n    ]);\n\n    return { vertices, indices, vertexCount: 24, indexCount: 36 };\n}\n","import type { MeshData } from \"./index\";\n\nexport function createSphere(segments = 32, rings = 16): MeshData {\n    const vertices: number[] = [];\n    const indices: number[] = [];\n    const radius = 0.5;\n\n    for (let y = 0; y <= rings; y++) {\n        const v = y / rings;\n        const theta = v * Math.PI;\n\n        for (let x = 0; x <= segments; x++) {\n            const u = x / segments;\n            const phi = u * Math.PI * 2;\n\n            const nx = Math.sin(theta) * Math.cos(phi);\n            const ny = Math.cos(theta);\n            const nz = Math.sin(theta) * Math.sin(phi);\n\n            vertices.push(nx * radius, ny * radius, nz * radius, nx, ny, nz);\n        }\n    }\n\n    for (let y = 0; y < rings; y++) {\n        for (let x = 0; x < segments; x++) {\n            const a = y * (segments + 1) + x;\n            const b = a + segments + 1;\n\n            indices.push(a, a + 1, b);\n            indices.push(a + 1, b + 1, b);\n        }\n    }\n\n    return {\n        vertices: new Float32Array(vertices),\n        indices: new Uint16Array(indices),\n        vertexCount: (rings + 1) * (segments + 1),\n        indexCount: rings * segments * 6,\n    };\n}\n","import type { MeshData } from \"./index\";\n\nexport function createPlane(): MeshData {\n    const vertices = new Float32Array([\n        -0.5, 0, 0.5, 0, 1, 0, 0.5, 0, 0.5, 0, 1, 0, 0.5, 0, -0.5, 0, 1, 0, -0.5, 0, -0.5, 0, 1, 0,\n    ]);\n\n    const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\n\n    return { vertices, indices, vertexCount: 4, indexCount: 6 };\n}\n","import { getMesh } from \".\";\n\nexport interface ShapeMeta {\n    vertexOffset: number;\n    indexOffset: number;\n    triCount: number;\n    _pad: number;\n}\n\nexport interface ShapeAtlas {\n    vertices: GPUBuffer;\n    indices: GPUBuffer;\n    meta: GPUBuffer;\n    shapeCount: number;\n    maxTriangles: number;\n}\n\nconst MAX_SHAPES = 16;\n\nexport function createShapeAtlas(device: GPUDevice): ShapeAtlas {\n    const allVertices: number[] = [];\n    const allIndices: number[] = [];\n    const shapeMetas: ShapeMeta[] = [];\n\n    let vertexOffset = 0;\n    let indexOffset = 0;\n    let maxTriangles = 0;\n\n    for (let shapeId = 0; shapeId < MAX_SHAPES; shapeId++) {\n        const mesh = getMesh(shapeId);\n        if (!mesh) {\n            shapeMetas.push({ vertexOffset: 0, indexOffset: 0, triCount: 0, _pad: 0 });\n            continue;\n        }\n\n        const triCount = mesh.indexCount / 3;\n        shapeMetas.push({\n            vertexOffset,\n            indexOffset,\n            triCount,\n            _pad: 0,\n        });\n\n        for (let i = 0; i < mesh.vertices.length; i++) {\n            allVertices.push(mesh.vertices[i]);\n        }\n\n        for (let i = 0; i < mesh.indices.length; i++) {\n            allIndices.push(mesh.indices[i]);\n        }\n\n        vertexOffset += mesh.vertices.length;\n        indexOffset += mesh.indices.length;\n        maxTriangles += triCount;\n    }\n\n    const verticesData = new Float32Array(allVertices);\n    const indicesData = new Uint32Array(allIndices);\n    const metaData = new Uint32Array(MAX_SHAPES * 4);\n\n    for (let i = 0; i < shapeMetas.length; i++) {\n        metaData[i * 4] = shapeMetas[i].vertexOffset;\n        metaData[i * 4 + 1] = shapeMetas[i].indexOffset;\n        metaData[i * 4 + 2] = shapeMetas[i].triCount;\n        metaData[i * 4 + 3] = 0;\n    }\n\n    const vertices = device.createBuffer({\n        label: \"unified-vertices\",\n        size: Math.max(verticesData.byteLength, 16),\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(vertices, 0, verticesData);\n\n    const indices = device.createBuffer({\n        label: \"unified-indices\",\n        size: Math.max(indicesData.byteLength, 16),\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(indices, 0, indicesData);\n\n    const meta = device.createBuffer({\n        label: \"unified-meta\",\n        size: metaData.byteLength,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(meta, 0, metaData);\n\n    return {\n        vertices,\n        indices,\n        meta,\n        shapeCount: shapeMetas.filter((m) => m.triCount > 0).length,\n        maxTriangles,\n    };\n}\n","import { MAX_ENTITIES } from \"../../../core\";\nimport { setTraits, type FieldAccessor } from \"../../../core/component\";\nimport { createEntityIdBuffer } from \"../../compute\";\nimport { writeIndirect } from \"../indirect\";\nimport { createBox } from \"./box\";\nimport { createSphere } from \"./sphere\";\nimport { createPlane } from \"./plane\";\n\nexport const MAX_SURFACES = 16;\nexport const MAX_BATCH_SLOTS = 64;\nconst INVALID_SHAPE = 0xffffffff;\n\nconst batchEntityIds = new Uint32Array(MAX_ENTITIES);\n\nexport interface MeshData {\n    vertices: Float32Array<ArrayBuffer>;\n    indices: Uint16Array<ArrayBuffer>;\n    vertexCount: number;\n    indexCount: number;\n}\n\nconst meshes: MeshData[] = [];\n\nfunction initBuiltIns(): void {\n    if (meshes.length === 0) {\n        meshes.push(createBox());\n        meshes.push(createSphere());\n        meshes.push(createPlane());\n    }\n}\n\ninitBuiltIns();\n\nexport const MeshShape = {\n    Box: 0,\n    Sphere: 1,\n    Plane: 2,\n} as const;\n\nexport function mesh(data: MeshData): number {\n    const id = meshes.length;\n    meshes.push(data);\n    return id;\n}\n\nexport function getMesh(id: number): MeshData | undefined {\n    return meshes[id];\n}\n\nexport function clearMeshes(): void {\n    meshes.length = 0;\n    initBuiltIns();\n}\n\nexport const MeshShapes = {\n    data: new Uint32Array(MAX_ENTITIES).fill(INVALID_SHAPE),\n};\n\nexport const MeshColors = {\n    data: new Float32Array(MAX_ENTITIES * 4),\n};\n\nexport const MeshSizes = {\n    data: new Float32Array(MAX_ENTITIES * 4),\n};\n\nexport const MeshPBR = {\n    data: new Float32Array(MAX_ENTITIES * 4),\n};\n\nexport const MeshEmission = {\n    data: new Float32Array(MAX_ENTITIES * 4),\n};\n\nexport const MeshVolumes = {\n    data: new Uint8Array(MAX_ENTITIES),\n};\n\nexport const Volume = {\n    Solid: 0,\n    HalfSpace: 1,\n} as const;\n\ninterface ColorProxy extends Array<number>, FieldAccessor {}\n\nfunction colorProxy(): ColorProxy {\n    const data = MeshColors.data;\n\n    function getValue(eid: number): number {\n        const offset = eid * 4;\n        const r = Math.round(data[offset] * 255);\n        const g = Math.round(data[offset + 1] * 255);\n        const b = Math.round(data[offset + 2] * 255);\n        return (r << 16) | (g << 8) | b;\n    }\n\n    function setValue(eid: number, value: number): void {\n        const offset = eid * 4;\n        data[offset] = ((value >> 16) & 0xff) / 255;\n        data[offset + 1] = ((value >> 8) & 0xff) / 255;\n        data[offset + 2] = (value & 0xff) / 255;\n    }\n\n    return new Proxy([] as unknown as ColorProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\ninterface ColorChannelProxy extends Array<number>, FieldAccessor {}\n\nfunction colorChannelProxy(channelIndex: number): ColorChannelProxy {\n    const data = MeshColors.data;\n\n    function getValue(eid: number): number {\n        return data[eid * 4 + channelIndex];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * 4 + channelIndex] = value;\n    }\n\n    return new Proxy([] as unknown as ColorChannelProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\ninterface SizeProxy extends Array<number>, FieldAccessor {}\n\nfunction sizeProxy(component: number): SizeProxy {\n    const data = MeshSizes.data;\n\n    function getValue(eid: number): number {\n        return data[eid * 4 + component];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * 4 + component] = value;\n    }\n\n    return new Proxy([] as unknown as SizeProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\ninterface PBRProxy extends Array<number>, FieldAccessor {}\n\nfunction pbrProxy(component: number, defaultValue: number): PBRProxy {\n    const data = MeshPBR.data;\n\n    function getValue(eid: number): number {\n        const val = data[eid * 4 + component];\n        return val === 0 && component === 0 ? defaultValue : val;\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * 4 + component] = value;\n    }\n\n    return new Proxy([] as unknown as PBRProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\ninterface EmissionProxy extends Array<number>, FieldAccessor {}\n\nfunction emissionProxy(): EmissionProxy {\n    const data = MeshEmission.data;\n\n    function getValue(eid: number): number {\n        const offset = eid * 4;\n        const r = Math.round(data[offset] * 255);\n        const g = Math.round(data[offset + 1] * 255);\n        const b = Math.round(data[offset + 2] * 255);\n        return (r << 16) | (g << 8) | b;\n    }\n\n    function setValue(eid: number, value: number): void {\n        const offset = eid * 4;\n        data[offset] = ((value >> 16) & 0xff) / 255;\n        data[offset + 1] = ((value >> 8) & 0xff) / 255;\n        data[offset + 2] = (value & 0xff) / 255;\n    }\n\n    return new Proxy([] as unknown as EmissionProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nfunction emissionIntensityProxy(): PBRProxy {\n    const data = MeshEmission.data;\n\n    function getValue(eid: number): number {\n        return data[eid * 4 + 3];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * 4 + 3] = value;\n    }\n\n    return new Proxy([] as unknown as PBRProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nexport const Mesh: {\n    shape: Uint32Array;\n    color: ColorProxy;\n    colorR: ColorChannelProxy;\n    colorG: ColorChannelProxy;\n    colorB: ColorChannelProxy;\n    opacity: ColorChannelProxy;\n    sizeX: SizeProxy;\n    sizeY: SizeProxy;\n    sizeZ: SizeProxy;\n    roughness: PBRProxy;\n    metallic: PBRProxy;\n    ior: PBRProxy;\n    emission: EmissionProxy;\n    emissionIntensity: PBRProxy;\n    volume: Uint8Array;\n} = {\n    shape: MeshShapes.data,\n    color: colorProxy(),\n    colorR: colorChannelProxy(0),\n    colorG: colorChannelProxy(1),\n    colorB: colorChannelProxy(2),\n    opacity: colorChannelProxy(3),\n    sizeX: sizeProxy(0),\n    sizeY: sizeProxy(1),\n    sizeZ: sizeProxy(2),\n    roughness: pbrProxy(0, 0.9),\n    metallic: pbrProxy(1, 0.0),\n    ior: pbrProxy(2, 1.0),\n    emission: emissionProxy(),\n    emissionIntensity: emissionIntensityProxy(),\n    volume: MeshVolumes.data,\n};\n\nsetTraits(Mesh, {\n    defaults: () => ({\n        shape: MeshShape.Box,\n        color: 0xffffff,\n        opacity: 1.0,\n        sizeX: 1,\n        sizeY: 1,\n        sizeZ: 1,\n        roughness: 1.0,\n        metallic: 0.0,\n        ior: 1.0,\n        emission: 0x000000,\n        emissionIntensity: 0.0,\n        volume: Volume.Solid,\n    }),\n});\n\nexport interface MeshBuffers {\n    vertex: GPUBuffer;\n    index: GPUBuffer;\n    indexCount: number;\n}\n\nexport function createMeshBuffers(device: GPUDevice, mesh: MeshData): MeshBuffers {\n    const vertex = device.createBuffer({\n        label: \"vertex\",\n        size: mesh.vertices.byteLength,\n        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(vertex, 0, mesh.vertices);\n\n    const index = device.createBuffer({\n        label: \"index\",\n        size: mesh.indices.byteLength,\n        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(index, 0, mesh.indices);\n\n    return { vertex, index, indexCount: mesh.indexCount };\n}\n\nexport type BatchEntities = (number[] | null)[];\n\nexport function collectBatches(\n    entities: Iterable<number>,\n    getSurface: (eid: number) => number,\n    out: BatchEntities\n): void {\n    for (let i = 0; i < MAX_BATCH_SLOTS; i++) {\n        if (out[i]) out[i]!.length = 0;\n    }\n    for (const eid of entities) {\n        const shape = Mesh.shape[eid];\n        const surface = getSurface(eid);\n        const batchIndex = shape * MAX_SURFACES + surface;\n        if (batchIndex >= MAX_BATCH_SLOTS) continue;\n        let entry = out[batchIndex];\n        if (!entry) {\n            entry = [];\n            out[batchIndex] = entry;\n        }\n        entry.push(eid);\n    }\n}\n\nexport interface Batch {\n    buffers: MeshBuffers;\n    entityIds: GPUBuffer;\n    count: number;\n}\n\nexport interface BatchState {\n    batches: (Batch | null)[];\n    buffers: Map<number, MeshBuffers>;\n}\n\nexport function updateBatches(\n    device: GPUDevice,\n    batchEntities: BatchEntities,\n    state: BatchState,\n    indirect: GPUBuffer\n): void {\n    for (let batchIndex = 0; batchIndex < MAX_BATCH_SLOTS; batchIndex++) {\n        const entities = batchEntities[batchIndex];\n        if (!entities || entities.length === 0) {\n            const batch = state.batches[batchIndex];\n            if (batch) {\n                batch.count = 0;\n                writeIndirect(device, indirect, batchIndex, {\n                    indexCount: 0,\n                    instanceCount: 0,\n                    firstIndex: 0,\n                    baseVertex: 0,\n                    firstInstance: 0,\n                });\n            }\n            continue;\n        }\n\n        let batch = state.batches[batchIndex];\n        if (!batch) {\n            const shape = Math.floor(batchIndex / MAX_SURFACES);\n            let buffers = state.buffers.get(shape);\n            if (!buffers) {\n                const data = getMesh(shape) ?? getMesh(MeshShape.Box)!;\n                buffers = createMeshBuffers(device, data);\n                state.buffers.set(shape, buffers);\n            }\n            batch = {\n                buffers,\n                entityIds: createEntityIdBuffer(device, MAX_ENTITIES),\n                count: 0,\n            };\n            state.batches[batchIndex] = batch;\n        }\n\n        for (let i = 0; i < entities.length; i++) {\n            batchEntityIds[i] = entities[i];\n        }\n        device.queue.writeBuffer(batch.entityIds, 0, batchEntityIds, 0, entities.length);\n        batch.count = entities.length;\n\n        writeIndirect(device, indirect, batchIndex, {\n            indexCount: batch.buffers.indexCount,\n            instanceCount: entities.length,\n            firstIndex: 0,\n            baseVertex: 0,\n            firstInstance: 0,\n        });\n    }\n}\n\nexport { createBox } from \"./box\";\nexport { createSphere } from \"./sphere\";\nexport { createPlane } from \"./plane\";\nexport { createShapeAtlas } from \"./unified\";\n","export const SURFACE_DATA_STRUCT_WGSL = /* wgsl */ `\nstruct SurfaceData {\n    baseColor: vec3<f32>,\n    roughness: f32,\n    metallic: f32,\n    opacity: f32,\n    emission: vec3<f32>,\n    normal: vec3<f32>,\n    worldPos: vec3<f32>,\n}`;\n\nexport const SCENE_STRUCT_WGSL = /* wgsl */ `\nstruct Scene {\n    viewProj: mat4x4<f32>,\n    cameraWorld: mat4x4<f32>,\n    ambientColor: vec4<f32>,\n    sunDirection: vec4<f32>,\n    sunColor: vec4<f32>,\n    clearColor: vec4<f32>,\n    cameraMode: f32,\n    cameraSize: f32,\n    viewport: vec2<f32>,\n    fov: f32,\n    near: f32,\n    far: f32,\n    shadowSoftness: f32,\n    shadowSamples: u32,\n    reflectionDepth: u32,\n    refractionDepth: u32,\n    instanceCount: u32,\n    hazeDensity: f32,\n    _pad2: f32,\n    _pad3: f32,\n    _pad4: f32,\n    hazeColor: vec4<f32>,\n    skyZenith: vec4<f32>,\n    skyHorizon: vec4<f32>,\n    frustumPlanes: array<vec4<f32>, 6>,\n    moonParams: vec4<f32>,\n    moonDirection: vec4<f32>,\n    starParams: vec4<f32>,\n    cloudParams: vec4<f32>,\n    cloudColor: vec4<f32>,\n    sunParams: vec4<f32>,\n    sunVisualColor: vec4<f32>,\n}`;\n\nexport const DATA_STRUCT_WGSL = /* wgsl */ `\nstruct Data {\n    baseColor: vec4<f32>,\n    pbr: vec4<f32>,\n    emission: vec4<f32>,\n    flags: u32,\n    _pad0: u32,\n    _pad1: u32,\n    _pad2: u32,\n}`;\n\nexport const WGSL_STRUCTS = /* wgsl */ `\nstruct VertexInput {\n    @location(0) position: vec3<f32>,\n    @location(1) normal: vec3<f32>,\n    @builtin(instance_index) instance: u32,\n}\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) color: vec4<f32>,\n    @location(1) worldNormal: vec3<f32>,\n    @location(2) @interpolate(flat) entityId: u32,\n    @location(3) worldPos: vec3<f32>,\n}\n\n${SURFACE_DATA_STRUCT_WGSL}\n\nstruct FragmentOutput {\n    @location(0) color: vec4<f32>,\n    @location(1) entityId: u32,\n}\n\n${SCENE_STRUCT_WGSL}\n\n@group(0) @binding(0) var<uniform> scene: Scene;\n@group(0) @binding(1) var<storage, read> entityIds: array<u32>;\n@group(0) @binding(2) var<storage, read> matrices: array<mat4x4<f32>>;\n@group(0) @binding(3) var<storage, read> colors: array<vec4<f32>>;\n@group(0) @binding(4) var<storage, read> sizes: array<vec4<f32>>;\n@group(0) @binding(5) var<storage, read> pbr: array<vec4<f32>>;\n@group(0) @binding(6) var<storage, read> emission: array<vec4<f32>>;\n@group(0) @binding(7) var<storage, read> shapes: array<u32>;\n`;\n","export const NOISE_WGSL = /* wgsl */ `\nfn hash2(p: vec2<f32>) -> f32 {\n    var p3 = fract(vec3(p.x, p.y, p.x) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfn simplex2(p: vec2<f32>) -> f32 {\n    let K1 = 0.366025404;\n    let K2 = 0.211324865;\n\n    let i = floor(p + (p.x + p.y) * K1);\n    let a = p - i + (i.x + i.y) * K2;\n\n    let o = select(vec2(0.0, 1.0), vec2(1.0, 0.0), a.x > a.y);\n    let b = a - o + K2;\n    let c = a - 1.0 + 2.0 * K2;\n\n    let h = max(0.5 - vec3(dot(a, a), dot(b, b), dot(c, c)), vec3(0.0));\n    let h4 = h * h * h * h;\n\n    let n = vec3(\n        dot(a, vec2(hash2(i) * 2.0 - 1.0, hash2(i + vec2(0.0, 1.0)) * 2.0 - 1.0)),\n        dot(b, vec2(hash2(i + o) * 2.0 - 1.0, hash2(i + o + vec2(0.0, 1.0)) * 2.0 - 1.0)),\n        dot(c, vec2(hash2(i + 1.0) * 2.0 - 1.0, hash2(i + vec2(1.0, 2.0)) * 2.0 - 1.0))\n    );\n\n    return dot(h4, n) * 70.0;\n}\n\nfn fbm2(p: vec2<f32>, octaves: i32) -> f32 {\n    var value = 0.0;\n    var amplitude = 0.5;\n    var frequency = 1.0;\n    var pos = p;\n\n    for (var i = 0; i < octaves; i++) {\n        value += amplitude * simplex2(pos * frequency);\n        amplitude *= 0.5;\n        frequency *= 2.0;\n    }\n\n    return value;\n}\n`;\n","export function compileVertexBody(vertex?: string): string {\n    return vertex\n        ? `var pos = worldPos;\n    ${vertex}\n    return pos;`\n        : \"return worldPos;\";\n}\n\nexport const STARS_WGSL = /* wgsl */ `\nfn hashStar(p: vec2<f32>) -> f32 {\n    var p3 = fract(vec3(p.x, p.y, p.x) * 0.1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfn hash2Star(p: vec2<f32>) -> vec2<f32> {\n    var p3 = fract(vec3(p.x, p.y, p.x) * vec3(0.1031, 0.1030, 0.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nfn sampleStars(dir: vec3<f32>) -> vec3<f32> {\n    if (scene.starParams.z <= 0.0 || dir.y < 0.0) {\n        return vec3(0.0);\n    }\n\n    let theta = atan2(dir.z, dir.x);\n    let phi = asin(clamp(dir.y, -1.0, 1.0));\n\n    let gridSize = mix(20.0, 100.0, scene.starParams.y);\n    let cell = vec2(theta * gridSize / 3.14159, phi * gridSize / 1.5708);\n    let cellId = floor(cell);\n    let cellFract = fract(cell);\n\n    var starColor = vec3(0.0);\n\n    for (var dy = -1; dy <= 1; dy++) {\n        for (var dx = -1; dx <= 1; dx++) {\n            let neighbor = cellId + vec2(f32(dx), f32(dy));\n            let starHash = hashStar(neighbor);\n\n            if (starHash > scene.starParams.y * 0.7) {\n                continue;\n            }\n\n            let starPos = hash2Star(neighbor);\n            let starCenter = neighbor + starPos;\n            let dist = length(cell - starCenter);\n\n            let brightness = hashStar(neighbor + vec2(100.0, 100.0));\n            let radius = 0.02 + brightness * 0.03;\n\n            if (dist < radius) {\n                let twinkle = 0.8 + 0.2 * sin(brightness * 100.0);\n                let intensity = scene.starParams.x * brightness * twinkle;\n                let falloff = 1.0 - smoothstep(0.0, radius, dist);\n\n                let temp = hashStar(neighbor + vec2(200.0, 200.0));\n                let tint = mix(vec3(1.0, 0.9, 0.8), vec3(0.8, 0.9, 1.0), temp);\n\n                starColor = max(starColor, tint * intensity * falloff);\n            }\n        }\n    }\n\n    return starColor;\n}\n`;\n\nimport { NOISE_WGSL } from \"./noise\";\n\nexport const MOON_WGSL = /* wgsl */ `\nfn sampleMoon(dir: vec3<f32>) -> vec3<f32> {\n    if (scene.moonParams.z <= 0.0) {\n        return vec3(0.0);\n    }\n\n    let moonDir = scene.moonDirection.xyz;\n    let moonDot = dot(dir, moonDir);\n\n    let moonSize = 0.9995;\n    let moonColor = vec3(0.9, 0.9, 0.85);\n\n    if (moonDot > moonSize) {\n        let toCenter = dir - moonDir * moonDot;\n        let diskRight = normalize(cross(moonDir, vec3(0.0, 1.0, 0.0)));\n        let diskUp = cross(diskRight, moonDir);\n\n        let diskRadius = sqrt(1.0 - moonSize * moonSize);\n        let u = dot(toCenter, diskRight) / diskRadius;\n        let v = dot(toCenter, diskUp) / diskRadius;\n\n        let r2 = u * u + v * v;\n        let z = sqrt(max(0.0, 1.0 - r2));\n\n        let phase = scene.moonParams.x;\n        let sunAngle = phase * 6.28318;\n        let sunLocalX = sin(sunAngle);\n        let sunLocalZ = -cos(sunAngle);\n\n        let illumination = u * sunLocalX + z * sunLocalZ;\n        let lit = select(0.15, 1.0, illumination > 0.0);\n\n        return moonColor * lit;\n    } else {\n        let glowFalloff = max(0.0, moonDot - 0.99) / (moonSize - 0.99);\n        let glow = pow(glowFalloff, 2.0) * scene.moonParams.y;\n        return moonColor * glow * 0.3;\n    }\n}\n`;\n\nexport const CLOUDS_WGSL = /* wgsl */ `\n${NOISE_WGSL}\n\nfn sampleClouds(dir: vec3<f32>) -> vec4<f32> {\n    if (scene.cloudParams.w <= 0.0 || dir.y < 0.01) {\n        return vec4(0.0);\n    }\n\n    let t = scene.cloudParams.z / max(dir.y, 0.001);\n    let uv = dir.xz * t;\n\n    var n = fbm2(uv, 5);\n\n    let coverage = scene.cloudParams.x;\n    let density = scene.cloudParams.y;\n    n = smoothstep(1.0 - coverage, 1.0, n * 0.5 + 0.5) * density;\n\n    n *= smoothstep(0.0, 0.15, dir.y);\n\n    return vec4(scene.cloudColor.rgb, n);\n}\n`;\n\nconst DEG_TO_RAD = Math.PI / 180;\n\nexport const SKY_DIR_WGSL = /* wgsl */ `\nconst DEG_TO_RAD: f32 = ${DEG_TO_RAD};\n\nfn computeSkyDir(screenX: f32, screenY: f32) -> vec3<f32> {\n    let width = scene.viewport.x;\n    let height = scene.viewport.y;\n\n    let ndcX = screenX * 2.0 - 1.0;\n    let ndcY = 1.0 - screenY * 2.0;\n\n    let aspect = width / height;\n\n    let cameraWorld = scene.cameraWorld;\n    let r00 = cameraWorld[0][0]; let r10 = cameraWorld[0][1]; let r20 = cameraWorld[0][2];\n    let r01 = cameraWorld[1][0]; let r11 = cameraWorld[1][1]; let r21 = cameraWorld[1][2];\n    let r02 = cameraWorld[2][0]; let r12 = cameraWorld[2][1]; let r22 = cameraWorld[2][2];\n\n    let skyFov = select(scene.fov, 60.0, scene.cameraMode > 0.5);\n    let tanHalfFov = tan((skyFov * DEG_TO_RAD) / 2.0);\n    let camDirX = ndcX * aspect * tanHalfFov;\n    let camDirY = ndcY * tanHalfFov;\n    let camDirZ = -1.0;\n    var dirX = r00 * camDirX + r01 * camDirY + r02 * camDirZ;\n    var dirY = r10 * camDirX + r11 * camDirY + r12 * camDirZ;\n    var dirZ = r20 * camDirX + r21 * camDirY + r22 * camDirZ;\n    let len = sqrt(dirX * dirX + dirY * dirY + dirZ * dirZ);\n    dirX /= len; dirY /= len; dirZ /= len;\n    return vec3(dirX, dirY, dirZ);\n}\n`;\n\nexport const SKY_WGSL = /* wgsl */ `\n${STARS_WGSL}\n${MOON_WGSL}\n${CLOUDS_WGSL}\n\nfn sampleSky(dir: vec3<f32>) -> vec3<f32> {\n    if (scene.skyZenith.a <= 0.0) {\n        return scene.clearColor.rgb;\n    }\n\n    let t = pow(clamp(dir.y, 0.0, 1.0), 0.25);\n    var color = mix(scene.skyHorizon.rgb, scene.skyZenith.rgb, t);\n\n    let horizonBand = 1.0 - abs(dir.y);\n    let horizonBlend = pow(horizonBand, 32.0);\n    color = mix(color, vec3(1.09), horizonBlend);\n\n    color += sampleStars(dir);\n\n    let clouds = sampleClouds(dir);\n    color = mix(color, clouds.rgb, clouds.a);\n\n    let moonContrib = sampleMoon(dir);\n    color += moonContrib * (1.0 - clouds.a * 0.7);\n\n    let sunDir = -scene.sunDirection.xyz;\n    let sunDot = dot(dir, sunDir);\n\n    let sunVisualColor = select(scene.sunColor.rgb, scene.sunVisualColor.rgb, scene.sunParams.z > 0.5);\n\n    let baseSunSize = 0.9995;\n    let sunSizeParam = scene.sunParams.x;\n    let sunThreshold = 1.0 - (1.0 - baseSunSize) * sunSizeParam;\n\n    if (sunDot > sunThreshold) {\n        color = sunVisualColor;\n    } else {\n        let glow = max(0.0, sunDot);\n        let glowParam = scene.sunParams.y;\n        let glowIntensity = pow(glow, 8.0) * glowParam;\n        color += sunVisualColor * glowIntensity;\n    }\n\n    if (scene.hazeDensity > 0.0) {\n        let horizonFactor = 1.0 - clamp(dir.y, 0.0, 1.0);\n        let hazeAmount = pow(horizonFactor, 2.0) * saturate(scene.hazeDensity * 5.0);\n        color = mix(color, scene.hazeColor.rgb, hazeAmount);\n    }\n\n    return color;\n}\n`;\n\nexport const HAZE_WGSL = /* wgsl */ `\nfn applyHaze(color: vec3<f32>, dist: f32) -> vec3<f32> {\n    if (scene.hazeDensity <= 0.0) {\n        return color;\n    }\n    let haze = 1.0 - exp(-scene.hazeDensity * dist);\n    return mix(color, scene.hazeColor.rgb, haze);\n}\n`;\n\nexport const SPECULAR_WGSL = /* wgsl */ `\nconst DIELECTRIC_F0: f32 = 0.04;\n\nfn blinnPhongSpecular(N: vec3<f32>, L: vec3<f32>, V: vec3<f32>, roughness: f32) -> f32 {\n    let H = normalize(L + V);\n    let NdotH = max(dot(N, H), 0.0);\n    let shininess = pow(2.0, (1.0 - roughness) * 10.0);\n    let intensity = (1.0 - roughness) * (1.0 - roughness);\n    return pow(NdotH, shininess) * intensity;\n}\n\nfn schlickFresnel(cosTheta: f32, F0: vec3<f32>) -> vec3<f32> {\n    return F0 + (vec3(1.0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfn computeF0Vec(baseColor: vec3<f32>, metallic: f32) -> vec3<f32> {\n    return mix(vec3(DIELECTRIC_F0), baseColor, metallic);\n}\n`;\n\nexport const REFRACTION_WGSL = /* wgsl */ `\nfn refractRay(I: vec3<f32>, N: vec3<f32>, eta: f32) -> vec4<f32> {\n    let cosI = -dot(I, N);\n    let sinT2 = eta * eta * (1.0 - cosI * cosI);\n    if (sinT2 > 1.0) {\n        return vec4(reflect(I, N), 1.0);\n    }\n    let cosT = sqrt(1.0 - sinT2);\n    return vec4(normalize(eta * I + (eta * cosI - cosT) * N), 0.0);\n}\n\nfn fresnelSchlickIOR(cosTheta: f32, n1: f32, n2: f32) -> f32 {\n    let r0 = pow((n1 - n2) / (n1 + n2), 2.0);\n    return r0 + (1.0 - r0) * pow(1.0 - cosTheta, 5.0);\n}\n`;\n\nexport function reflectionWgsl(shadows: boolean): string {\n    const shadowCheck = shadows\n        ? `var hitShadow = 1.0;\n        if (hitNdotL > 0.0) {\n            var shadowRay: Ray;\n            shadowRay.origin = hit.worldPos + hit.normal * REFLECTION_EPSILON;\n            shadowRay.direction = hitL;\n            if (traceAnyHit(shadowRay, 1000.0)) { hitShadow = 0.0; }\n        }`\n        : \"let hitShadow = 1.0;\";\n\n    return /* wgsl */ `\nconst REFLECTION_EPSILON: f32 = 0.001;\nconst MIN_CONTRIBUTION: f32 = 0.02;\n\nfn traceReflections(\n    startPos: vec3<f32>,\n    startNormal: vec3<f32>,\n    startDir: vec3<f32>,\n    diffuseColor: vec3<f32>,\n    startBaseColor: vec3<f32>,\n    startRoughness: f32,\n    startMetallic: f32,\n    maxBounces: u32\n) -> vec3<f32> {\n    let V = -startDir;\n    let NdotV = max(dot(startNormal, V), 0.0);\n\n    let F0 = computeF0Vec(startBaseColor, startMetallic);\n    var F = schlickFresnel(NdotV, F0);\n\n    let smoothness = 1.0 - startRoughness;\n    let roughnessAtten = smoothness * smoothness;\n    F *= roughnessAtten;\n\n    let avgF = (F.x + F.y + F.z) / 3.0;\n    if (avgF < MIN_CONTRIBUTION) {\n        return diffuseColor;\n    }\n\n    var currentPos = startPos;\n    var currentNormal = startNormal;\n    var currentDir = startDir;\n    var reflectionColor = vec3(0.0);\n    var throughput = F;\n\n    for (var bounce = 0u; bounce < maxBounces; bounce++) {\n        let avgThroughput = (throughput.x + throughput.y + throughput.z) / 3.0;\n        if (avgThroughput < MIN_CONTRIBUTION) {\n            break;\n        }\n\n        let reflectDir = reflect(currentDir, currentNormal);\n        var reflectRay: Ray;\n        reflectRay.origin = currentPos + currentNormal * REFLECTION_EPSILON;\n        reflectRay.direction = reflectDir;\n\n        var reflectColor = vec3(0.0);\n        var reflectRemaining = 1.0;\n        var opaqueHit: HitResult;\n        var foundOpaque = false;\n\n        for (var t = 0u; t < 2u; t++) {\n            let hit = trace(reflectRay);\n            if (!hit.hit) {\n                reflectColor += sampleSky(reflectDir) * reflectRemaining;\n                break;\n            }\n\n            let eid = hit.entityId;\n            let hitData = getData(eid);\n            let hitOpacity = hitData.baseColor.a;\n            let hitBaseColor = hitData.baseColor.rgb;\n            let hitRoughness = hitData.pbr.x;\n            let hitMetallic = hitData.pbr.y;\n            let hitEmission = hitData.emission.rgb * hitData.emission.a;\n\n            let hitV = -reflectDir;\n            let hitL = -scene.sunDirection.xyz;\n            let hitNdotL = max(dot(hit.normal, hitL), 0.0);\n            let hitNdotV = max(dot(hit.normal, hitV), 0.0);\n${shadowCheck}\n\n            let hitF0 = computeF0Vec(hitBaseColor, hitMetallic);\n            let hitF = schlickFresnel(hitNdotV, hitF0);\n            let hitiffuseWeight = (1.0 - hitMetallic) * (vec3(1.0) - hitF);\n            let hitAmbient = scene.ambientColor.rgb * scene.ambientColor.a;\n            let hitSun = scene.sunColor.rgb * hitNdotL * hitShadow;\n            let hitiffuse = hitBaseColor * (hitAmbient + hitSun) * hitiffuseWeight;\n            let hitSpec = blinnPhongSpecular(hit.normal, hitL, hitV, hitRoughness);\n            let hitSpecular = scene.sunColor.rgb * hitSpec * hitF * hitNdotL * hitShadow;\n            let hitLit = hitiffuse + hitSpecular + hitEmission;\n\n            reflectColor += applyHaze(hitLit, hit.t) * hitOpacity * reflectRemaining;\n\n            if (hitOpacity >= 1.0) {\n                opaqueHit = hit;\n                foundOpaque = true;\n                break;\n            }\n\n            reflectRemaining *= (1.0 - hitOpacity);\n            if (reflectRemaining < 0.02) { break; }\n            reflectRay.origin = hit.worldPos + reflectDir * REFLECTION_EPSILON;\n        }\n\n        reflectionColor += throughput * reflectColor;\n\n        if (!foundOpaque) { break; }\n\n        let opaqueEid = opaqueHit.entityId;\n        let opaque = getData(opaqueEid);\n        let hitSmoothness = 1.0 - opaque.pbr.x;\n        let hitRoughnessAtten = hitSmoothness * hitSmoothness;\n        let opaqueF0 = computeF0Vec(opaque.baseColor.rgb, opaque.pbr.y);\n        let opaqueNdotV = max(dot(opaqueHit.normal, -reflectDir), 0.0);\n        let opaqueF = schlickFresnel(opaqueNdotV, opaqueF0);\n        throughput *= opaqueF * hitRoughnessAtten;\n        currentPos = opaqueHit.worldPos;\n        currentNormal = opaqueHit.normal;\n        currentDir = reflectDir;\n    }\n\n    return diffuseColor * (vec3(1.0) - F) + reflectionColor;\n}\n`;\n}\n\nexport const WGSL_LIGHTING_CALC = /* wgsl */ `\nlet NdotL = max(dot(surface.normal, -scene.sunDirection.xyz), 0.0);\nlet ambient = scene.ambientColor.rgb * scene.ambientColor.a;\nlet sunDiffuse = scene.sunColor.rgb * NdotL;\nlet diffuseWeight = 1.0 - surface.metallic;\nlet lighting = (ambient + sunDiffuse) * diffuseWeight;\n`;\n\nexport const SHADOW_WGSL = /* wgsl */ `\nconst GOLDEN_ANGLE: f32 = 2.39996323;\nconst SHADOW_TRANSPARENCY_EPSILON: f32 = 0.001;\nconst MAX_SHADOW_TRANSPARENT_DEPTH: u32 = 2u;\n\nfn buildTangentBasis(dir: vec3<f32>) -> mat3x3<f32> {\n    let up = select(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), abs(dir.y) > 0.99);\n    let tangent = normalize(cross(dir, up));\n    let bitangent = cross(dir, tangent);\n    return mat3x3(tangent, bitangent, dir);\n}\n\nfn traceShadowWithTransparency(origin: vec3<f32>, sunDir: vec3<f32>, tMax: f32) -> f32 {\n    var shadowFactor = 1.0;\n    var currentPos = origin;\n\n    for (var i = 0u; i < MAX_SHADOW_TRANSPARENT_DEPTH; i++) {\n        var shadowRay: Ray;\n        shadowRay.origin = currentPos;\n        shadowRay.direction = sunDir;\n\n        let hit = trace(shadowRay);\n        if (!hit.hit || hit.t > tMax) {\n            break;\n        }\n\n        let shadow = getData(hit.entityId);\n        let opacity = shadow.baseColor.a;\n        shadowFactor *= (1.0 - opacity);\n\n        if (opacity >= 1.0 || shadowFactor < 0.02) {\n            break;\n        }\n\n        currentPos = hit.worldPos + sunDir * SHADOW_TRANSPARENCY_EPSILON;\n    }\n\n    return shadowFactor;\n}\n\nfn sampleSoftShadow(origin: vec3<f32>, sunDir: vec3<f32>, softness: f32, samples: u32) -> f32 {\n    if (samples == 0u) {\n        return 1.0;\n    }\n    if (samples == 1u || softness <= 0.0) {\n        return traceShadowWithTransparency(origin, sunDir, 1000.0);\n    }\n\n    let basis = buildTangentBasis(sunDir);\n    var totalShadow = 0.0;\n\n    let noise = fract(sin(dot(origin.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    let rotationOffset = noise * 6.28318530718;\n\n    for (var i = 0u; i < samples; i++) {\n        let angle = f32(i) * GOLDEN_ANGLE + rotationOffset;\n        let z = (f32(i) + 0.5) / f32(samples);\n        let r = sqrt(1.0 - z * z) * softness * 0.1;\n\n        let localOffset = vec3(cos(angle) * r, sin(angle) * r, 0.0);\n        let sampleDir = normalize(sunDir + basis * localOffset);\n\n        totalShadow += traceShadowWithTransparency(origin, sampleDir, 1000.0);\n    }\n\n    return totalShadow / f32(samples);\n}\n`;\n\nexport function compileApplyLighting(\n    lit?: boolean,\n    shadows?: boolean,\n    reflections?: boolean\n): string {\n    if (lit === false) {\n        return \"return surface.baseColor;\";\n    }\n\n    if (shadows && reflections) {\n        return `\n    let V = -rayDir;\n    let L = -scene.sunDirection.xyz;\n    let NdotL = max(dot(surface.normal, L), 0.0);\n    let NdotV = max(dot(surface.normal, V), 0.0);\n\n    var shadowFactor = 1.0;\n    if (NdotL > 0.0) {\n        let shadowOrigin = surface.worldPos + surface.normal * 0.001;\n        shadowFactor = sampleSoftShadow(shadowOrigin, L, scene.shadowSoftness, scene.shadowSamples);\n    }\n\n    let F0 = computeF0Vec(surface.baseColor, surface.metallic);\n    let F = schlickFresnel(NdotV, F0);\n\n    let ambient = scene.ambientColor.rgb * scene.ambientColor.a;\n    let sunDiffuse = scene.sunColor.rgb * NdotL * shadowFactor;\n    let diffuseWeight = 1.0 - surface.metallic;\n    let diffuseColor = surface.baseColor * (ambient + sunDiffuse) * diffuseWeight + surface.emission;\n\n    let specTerm = blinnPhongSpecular(surface.normal, L, V, surface.roughness);\n    let specular = scene.sunColor.rgb * specTerm * F * NdotL * shadowFactor;\n\n    var finalColor = diffuseColor * (vec3(1.0) - F) + specular;\n\n    if (scene.reflectionDepth > 0u) {\n        finalColor = traceReflections(\n            surface.worldPos, surface.normal, rayDir,\n            diffuseColor + specular, surface.baseColor,\n            surface.roughness, surface.metallic,\n            scene.reflectionDepth\n        );\n    }\n    return finalColor;`;\n    }\n\n    if (shadows) {\n        return `\n    let NdotL = max(dot(surface.normal, -scene.sunDirection.xyz), 0.0);\n    let ambient = scene.ambientColor.rgb * scene.ambientColor.a;\n\n    var shadowFactor = 1.0;\n    if (NdotL > 0.0) {\n        let shadowOrigin = surface.worldPos + surface.normal * 0.001;\n        shadowFactor = sampleSoftShadow(\n            shadowOrigin, -scene.sunDirection.xyz,\n            scene.shadowSoftness, scene.shadowSamples\n        );\n    }\n\n    let sunDiffuse = scene.sunColor.rgb * NdotL * shadowFactor;\n    let diffuseWeight = 1.0 - surface.metallic;\n    let lighting = (ambient + sunDiffuse) * diffuseWeight;\n    return surface.baseColor * lighting + surface.emission;`;\n    }\n\n    if (reflections) {\n        return `\n    let V = -rayDir;\n    let L = -scene.sunDirection.xyz;\n    let NdotL = max(dot(surface.normal, L), 0.0);\n    let NdotV = max(dot(surface.normal, V), 0.0);\n\n    let F0 = computeF0Vec(surface.baseColor, surface.metallic);\n    let F = schlickFresnel(NdotV, F0);\n\n    let ambient = scene.ambientColor.rgb * scene.ambientColor.a;\n    let sunDiffuse = scene.sunColor.rgb * NdotL;\n    let diffuseWeight = 1.0 - surface.metallic;\n    let diffuseColor = surface.baseColor * (ambient + sunDiffuse) * diffuseWeight + surface.emission;\n\n    let specTerm = blinnPhongSpecular(surface.normal, L, V, surface.roughness);\n    let specular = scene.sunColor.rgb * specTerm * F * NdotL;\n\n    var finalColor = diffuseColor * (vec3(1.0) - F) + specular;\n\n    if (scene.reflectionDepth > 0u) {\n        finalColor = traceReflections(\n            surface.worldPos, surface.normal, rayDir,\n            diffuseColor + specular, surface.baseColor,\n            surface.roughness, surface.metallic,\n            scene.reflectionDepth\n        );\n    }\n    return finalColor;`;\n    }\n\n    return `${WGSL_LIGHTING_CALC}\n    return surface.baseColor * lighting + surface.emission;`;\n}\n","import { MAX_ENTITIES } from \"../../../core\";\nimport { setTraits } from \"../../../core/component\";\n\nexport interface SurfaceData {\n    vertex?: string;\n    fragment?: string;\n    lit?: boolean;\n}\n\ninterface ComposedSurface extends SurfaceData {\n    composed: number[];\n}\n\nexport interface SurfaceRegistry {\n    surfaces: (SurfaceData | ComposedSurface)[];\n}\n\nexport function createSurfaceRegistry(): SurfaceRegistry {\n    const registry: SurfaceRegistry = { surfaces: [] };\n    initBuiltIns(registry);\n    return registry;\n}\n\nfunction initBuiltIns(registry: SurfaceRegistry): void {\n    registry.surfaces.push({ lit: true });\n\n    registry.surfaces.push({\n        lit: false,\n        fragment: `(*surface).baseColor = (*surface).normal * 0.5 + 0.5;`,\n    });\n\n    registry.surfaces.push({\n        lit: false,\n        fragment: `\n    let depth = position.z;\n    let remapped = pow(1.0 - depth, 0.1);\n    (*surface).baseColor = vec3(remapped);`,\n    });\n\n    registry.surfaces.push({ lit: false });\n}\n\nexport const SurfaceType = {\n    Default: 0,\n    Normals: 1,\n    Depth: 2,\n    Albedo: 3,\n} as const;\n\nexport function registerSurface(registry: SurfaceRegistry, data: SurfaceData): number {\n    const id = registry.surfaces.length;\n    registry.surfaces.push(data);\n    return id;\n}\n\nexport function getSurface(registry: SurfaceRegistry, id: number): SurfaceData | undefined {\n    return registry.surfaces[id];\n}\n\nexport function getAllSurfaces(registry: SurfaceRegistry): SurfaceData[] {\n    return [...registry.surfaces];\n}\n\nexport function clearSurfaces(registry: SurfaceRegistry): void {\n    registry.surfaces.length = 0;\n    initBuiltIns(registry);\n}\n\nexport function composeSurfaces(registry: SurfaceRegistry, ...ids: number[]): number {\n    const validIds = ids.filter((id) => id > 0 && id < registry.surfaces.length);\n    if (validIds.length === 0) return SurfaceType.Default;\n    if (validIds.length === 1) return validIds[0];\n\n    const vertexParts: string[] = [];\n    const fragmentParts: string[] = [];\n    let lit = true;\n\n    for (const id of validIds) {\n        const s = registry.surfaces[id];\n        if (!s) continue;\n\n        if (s.lit === false) lit = false;\n\n        if (\"composed\" in s) {\n            for (const composedId of s.composed) {\n                const inner = registry.surfaces[composedId];\n                if (inner?.vertex) vertexParts.push(inner.vertex);\n                if (inner?.fragment) fragmentParts.push(inner.fragment);\n            }\n        } else {\n            if (s.vertex) vertexParts.push(s.vertex);\n            if (s.fragment) fragmentParts.push(s.fragment);\n        }\n    }\n\n    const composedData: ComposedSurface = {\n        vertex: vertexParts.length > 0 ? vertexParts.join(\"\\n    \") : undefined,\n        fragment: fragmentParts.length > 0 ? fragmentParts.join(\"\\n    \") : undefined,\n        lit,\n        composed: validIds,\n    };\n\n    const id = registry.surfaces.length;\n    registry.surfaces.push(composedData);\n    return id;\n}\n\nconst defaultRegistry = createSurfaceRegistry();\n\nexport function surface(data: SurfaceData): number {\n    return registerSurface(defaultRegistry, data);\n}\n\nexport function getDefaultSurface(id: number): SurfaceData | undefined {\n    return getSurface(defaultRegistry, id);\n}\n\nexport function getDefaultAllSurfaces(): SurfaceData[] {\n    return getAllSurfaces(defaultRegistry);\n}\n\nexport function clearDefaultSurfaces(): void {\n    clearSurfaces(defaultRegistry);\n}\n\nexport function compose(...ids: number[]): number {\n    return composeSurfaces(defaultRegistry, ...ids);\n}\n\nexport const SurfaceIds = {\n    data: new Uint32Array(MAX_ENTITIES),\n};\n\nexport const Surface: {\n    type: number[];\n} = {\n    type: [],\n};\n\nsetTraits(Surface, {\n    defaults: () => ({\n        type: SurfaceType.Default,\n    }),\n});\n\nexport { compileSurface } from \"./compile\";\n","export const SCENE_UNIFORM_SIZE = 512;\nexport const DEPTH_FORMAT: GPUTextureFormat = \"depth24plus\";\nexport const LINEAR_DEPTH_FORMAT: GPUTextureFormat = \"r32float\";\nexport const MASK_FORMAT: GPUTextureFormat = \"r8unorm\";\nexport const EID_FORMAT: GPUTextureFormat = \"r32uint\";\nexport const COLOR_FORMAT: GPUTextureFormat = \"rgba8unorm\";\n\nexport function createSceneBuffer(device: GPUDevice): GPUBuffer {\n    return device.createBuffer({\n        label: \"scene\",\n        size: SCENE_UNIFORM_SIZE,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n}\n\nexport function ensureTextures(\n    device: GPUDevice,\n    format: GPUTextureFormat,\n    width: number,\n    height: number,\n    textures: Map<string, GPUTexture>,\n    textureViews: Map<string, GPUTextureView>\n): void {\n    const existing = textures.get(\"color\");\n    if (existing && existing.width === width && existing.height === height) return;\n\n    existing?.destroy();\n    textures.get(\"linear-depth\")?.destroy();\n    textures.get(\"eid\")?.destroy();\n    textures.get(\"depth\")?.destroy();\n    textures.get(\"mask\")?.destroy();\n    textures.get(\"pingA\")?.destroy();\n    textures.get(\"pingB\")?.destroy();\n\n    const color = device.createTexture({\n        label: \"color\",\n        size: { width, height },\n        format: COLOR_FORMAT,\n        usage:\n            GPUTextureUsage.STORAGE_BINDING |\n            GPUTextureUsage.RENDER_ATTACHMENT |\n            GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    const linearDepth = device.createTexture({\n        label: \"linear-depth\",\n        size: { width, height },\n        format: LINEAR_DEPTH_FORMAT,\n        usage: GPUTextureUsage.STORAGE_BINDING | GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    const eid = device.createTexture({\n        label: \"eid\",\n        size: { width, height },\n        format: EID_FORMAT,\n        usage:\n            GPUTextureUsage.STORAGE_BINDING |\n            GPUTextureUsage.RENDER_ATTACHMENT |\n            GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    const depth = device.createTexture({\n        label: \"depth\",\n        size: { width, height },\n        format: DEPTH_FORMAT,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    const mask = device.createTexture({\n        label: \"mask\",\n        size: { width, height },\n        format: MASK_FORMAT,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    const pingA = device.createTexture({\n        label: \"pingA\",\n        size: { width, height },\n        format,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    const pingB = device.createTexture({\n        label: \"pingB\",\n        size: { width, height },\n        format,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    textures.set(\"color\", color);\n    textureViews.set(\"color\", color.createView());\n    textures.set(\"linear-depth\", linearDepth);\n    textureViews.set(\"linear-depth\", linearDepth.createView());\n    textures.set(\"eid\", eid);\n    textureViews.set(\"eid\", eid.createView());\n    textures.set(\"depth\", depth);\n    textureViews.set(\"depth\", depth.createView());\n    textures.set(\"mask\", mask);\n    textureViews.set(\"mask\", mask.createView());\n    textures.set(\"pingA\", pingA);\n    textureViews.set(\"pingA\", pingA.createView());\n    textures.set(\"pingB\", pingB);\n    textureViews.set(\"pingB\", pingB.createView());\n}\n","export interface Vec3 {\n    x: number;\n    y: number;\n    z: number;\n}\n\nexport interface AABB {\n    min: Vec3;\n    max: Vec3;\n}\n\nexport interface Triangle {\n    v0: Vec3;\n    e1: Vec3;\n    e2: Vec3;\n    n0: Vec3;\n    n1: Vec3;\n    n2: Vec3;\n    entityId: number;\n}\n\nexport interface BVHNode {\n    min: Vec3;\n    max: Vec3;\n    leftChild: number;\n    rightChild: number;\n}\n\nexport interface Ray {\n    origin: Vec3;\n    direction: Vec3;\n}\n\nexport interface MortonPair {\n    code: number;\n    triangleId: number;\n}\n\nexport interface HitResult {\n    hit: boolean;\n    t: number;\n    entityId: number;\n    u: number;\n    v: number;\n    normal: Vec3;\n    worldPos: Vec3;\n}\n\nexport const LEAF_FLAG = 0x80000000;\n\nexport function isLeaf(child: number): boolean {\n    return (child & LEAF_FLAG) !== 0;\n}\n\nexport function leafIndex(child: number): number {\n    return child & ~LEAF_FLAG;\n}\n\nexport const LEAF_FLAG_WGSL = /* wgsl */ `const LEAF_FLAG: u32 = 0x80000000u;`;\n\nexport const TRIANGLE_STRUCT_WGSL = /* wgsl */ `\nstruct Triangle {\n    v0: vec3<f32>,\n    entityId: u32,\n    e1: vec3<f32>,\n    _pad0: u32,\n    e2: vec3<f32>,\n    _pad1: u32,\n    n0_enc: u32,\n    n1_enc: u32,\n    n2_enc: u32,\n    _pad2: u32,\n}\n\nfn octEncode(n: vec3<f32>) -> u32 {\n    let absSum = abs(n.x) + abs(n.y) + abs(n.z);\n    var vx = n.x / absSum;\n    var vy = n.y / absSum;\n    let vz = n.z / absSum;\n    if (vz < 0.0) {\n        let signX = select(-1.0, 1.0, vx >= 0.0);\n        let signY = select(-1.0, 1.0, vy >= 0.0);\n        let newVx = (1.0 - abs(vy)) * signX;\n        let newVy = (1.0 - abs(vx)) * signY;\n        vx = newVx;\n        vy = newVy;\n    }\n    let x = u32(clamp((vx * 0.5 + 0.5) * 65535.0, 0.0, 65535.0));\n    let y = u32(clamp((vy * 0.5 + 0.5) * 65535.0, 0.0, 65535.0));\n    return (y << 16u) | x;\n}\n\nfn octDecode(enc: u32) -> vec3<f32> {\n    let x = f32(enc & 0xFFFFu) / 65535.0 * 2.0 - 1.0;\n    let y = f32(enc >> 16u) / 65535.0 * 2.0 - 1.0;\n    let z = 1.0 - abs(x) - abs(y);\n    var n: vec3<f32>;\n    if (z < 0.0) {\n        let signX = select(-1.0, 1.0, x >= 0.0);\n        let signY = select(-1.0, 1.0, y >= 0.0);\n        n = vec3<f32>((1.0 - abs(y)) * signX, (1.0 - abs(x)) * signY, z);\n    } else {\n        n = vec3<f32>(x, y, z);\n    }\n    return normalize(n);\n}`;\n\nexport const TREE_NODE_STRUCT_WGSL = /* wgsl */ `\nstruct TreeNode {\n    minX: f32,\n    minY: f32,\n    minZ: f32,\n    leftChild: u32,\n    maxX: f32,\n    maxY: f32,\n    maxZ: f32,\n    rightChild: u32,\n}`;\n\nexport const BVH_NODE_STRUCT_WGSL = /* wgsl */ `\nstruct BVHNode {\n    c0_minX: f32, c0_minY: f32, c0_minZ: f32, child0: u32,\n    c0_maxX: f32, c0_maxY: f32, c0_maxZ: f32, _pad0: u32,\n    c1_minX: f32, c1_minY: f32, c1_minZ: f32, child1: u32,\n    c1_maxX: f32, c1_maxY: f32, c1_maxZ: f32, _pad1: u32,\n    c2_minX: f32, c2_minY: f32, c2_minZ: f32, child2: u32,\n    c2_maxX: f32, c2_maxY: f32, c2_maxZ: f32, _pad2: u32,\n    c3_minX: f32, c3_minY: f32, c3_minZ: f32, child3: u32,\n    c3_maxX: f32, c3_maxY: f32, c3_maxZ: f32, _pad3: u32,\n}`;\n\nexport const TREE_NODE_SIZE = 32;\nexport const BVH_NODE_SIZE = 128;\nexport const BLAS_NODE_SIZE = 32;\nexport const BLAS_TRIANGLE_SIZE = 64;\nexport const INVALID_NODE = 0xffffffff;\n\nexport const BLAS_NODE_STRUCT_WGSL = /* wgsl */ `\nstruct BLASNode {\n    minX: f32, minY: f32, minZ: f32, leftChild: u32,\n    maxX: f32, maxY: f32, maxZ: f32, rightChild: u32,\n}`;\n\nexport const BLAS_TRIANGLE_STRUCT_WGSL = /* wgsl */ `\nstruct BLASTriangle {\n    v0: vec3<f32>, _pad0: u32,\n    e1: vec3<f32>, _pad1: u32,\n    e2: vec3<f32>, _pad2: u32,\n    n0_enc: u32, n1_enc: u32, n2_enc: u32, _pad3: u32,\n}`;\n\nexport const RAY_STRUCT_WGSL = /* wgsl */ `\nstruct Ray {\n    origin: vec3<f32>,\n    direction: vec3<f32>,\n}`;\n\nexport const HIT_RESULT_STRUCT_WGSL = /* wgsl */ `\nstruct HitResult {\n    hit: bool,\n    t: f32,\n    entityId: u32,\n    u: f32,\n    v: f32,\n    normal: vec3<f32>,\n    worldPos: vec3<f32>,\n}`;\n","import {\n    BVH_NODE_STRUCT_WGSL,\n    LEAF_FLAG_WGSL,\n    BLAS_NODE_STRUCT_WGSL,\n    BLAS_TRIANGLE_STRUCT_WGSL,\n} from \"./structs\";\n\nexport const OCT_DECODE_WGSL = /* wgsl */ `\nfn octDecode(enc: u32) -> vec3<f32> {\n    let x = f32(enc & 0xFFFFu) / 65535.0 * 2.0 - 1.0;\n    let y = f32(enc >> 16u) / 65535.0 * 2.0 - 1.0;\n    let z = 1.0 - abs(x) - abs(y);\n    var n: vec3<f32>;\n    if (z < 0.0) {\n        let signX = select(-1.0, 1.0, x >= 0.0);\n        let signY = select(-1.0, 1.0, y >= 0.0);\n        n = vec3<f32>((1.0 - abs(y)) * signX, (1.0 - abs(x)) * signY, z);\n    } else {\n        n = vec3<f32>(x, y, z);\n    }\n    return normalize(n);\n}`;\n\nexport const BVH_STRUCTS = /* wgsl */ `\n${BVH_NODE_STRUCT_WGSL}\n\n${LEAF_FLAG_WGSL}\nconst INVALID_NODE: u32 = 0xFFFFFFFFu;\nconst MAX_STACK_DEPTH: u32 = 24u;\n\n${OCT_DECODE_WGSL}\n`;\n\nexport const TLAS_BLAS_STRUCTS = /* wgsl */ `\n${BLAS_NODE_STRUCT_WGSL}\n\n${BLAS_TRIANGLE_STRUCT_WGSL}\n`;\n\nexport const TLAS_BLAS_BINDINGS = /* wgsl */ `\n@group(1) @binding(0) var<storage, read> tlasNodes: array<BVHNode>;\n@group(1) @binding(1) var<storage, read> tlasInstanceIds: array<u32>;\n@group(1) @binding(2) var<storage, read> blasNodes: array<BLASNode>;\n@group(1) @binding(3) var<storage, read> blasTriIds: array<u32>;\n@group(1) @binding(4) var<storage, read> blasTriangles: array<BLASTriangle>;\n@group(1) @binding(5) var<storage, read> blasMeta: array<u32>;\n@group(1) @binding(6) var<storage, read> instanceInverses: array<mat4x4<f32>>;\n`;\n\nexport const TLAS_BLAS_TRAVERSAL = /* wgsl */ `\nfn isLeaf(child: u32) -> bool {\n    return (child & LEAF_FLAG) != 0u;\n}\n\nfn leafIndex(child: u32) -> u32 {\n    return child & ~LEAF_FLAG;\n}\n\nfn safeInverse(d: f32) -> f32 {\n    return select(1.0 / d, 1e30, abs(d) < 1e-10);\n}\n\nfn computeInvDir(dir: vec3<f32>) -> vec3<f32> {\n    return vec3(\n        safeInverse(dir.x),\n        safeInverse(dir.y),\n        safeInverse(dir.z)\n    );\n}\n\nfn intersectAABBDist(origin: vec3<f32>, invDir: vec3<f32>, nodeMin: vec3<f32>, nodeMax: vec3<f32>) -> f32 {\n    let t1 = (nodeMin - origin) * invDir;\n    let t2 = (nodeMax - origin) * invDir;\n\n    let tNear = min(t1, t2);\n    let tFar = max(t1, t2);\n\n    let tEnter = max(max(tNear.x, tNear.y), tNear.z);\n    let tExit = min(min(tFar.x, tFar.y), tFar.z);\n\n    if (tEnter <= tExit && tExit >= 0.0) {\n        return max(tEnter, 0.0);\n    }\n    return 1e30;\n}\n\nfn intersectBLASTriangle(ray: Ray, tri: BLASTriangle) -> HitResult {\n    var result: HitResult;\n    result.hit = false;\n    result.t = 0.0;\n    result.entityId = 0u;\n    result.u = 0.0;\n    result.v = 0.0;\n    result.normal = vec3(0.0, 1.0, 0.0);\n    result.worldPos = vec3(0.0);\n\n    let e1 = tri.e1;\n    let e2 = tri.e2;\n\n    let h = cross(ray.direction, e2);\n    let a = dot(e1, h);\n\n    if (a > -EPSILON && a < EPSILON) {\n        return result;\n    }\n\n    let f = 1.0 / a;\n    let s = ray.origin - tri.v0;\n    let u = f * dot(s, h);\n\n    if (u < 0.0 || u > 1.0) {\n        return result;\n    }\n\n    let q = cross(s, e1);\n    let v = f * dot(ray.direction, q);\n\n    if (v < 0.0 || u + v > 1.0) {\n        return result;\n    }\n\n    let t = f * dot(e2, q);\n\n    if (t > EPSILON) {\n        result.hit = true;\n        result.t = t;\n        result.u = u;\n        result.v = v;\n        let w = 1.0 - u - v;\n        let n0 = octDecode(tri.n0_enc);\n        let n1 = octDecode(tri.n1_enc);\n        let n2 = octDecode(tri.n2_enc);\n        result.normal = normalize(w * n0 + u * n1 + v * n2);\n        result.worldPos = ray.origin + t * ray.direction;\n    }\n\n    return result;\n}\n\nfn traceBLAS(\n    ray: Ray,\n    nodeOffset: u32,\n    triIdOffset: u32,\n    triOffset: u32,\n    triCount_: u32,\n    maxT: f32\n) -> HitResult {\n    var closest: HitResult;\n    closest.hit = false;\n    closest.t = maxT;\n    closest.entityId = 0u;\n    closest.u = 0.0;\n    closest.v = 0.0;\n    closest.normal = vec3(0.0, 1.0, 0.0);\n    closest.worldPos = vec3(0.0);\n\n    if (triCount_ == 0u) {\n        return closest;\n    }\n\n    if (triCount_ == 1u) {\n        let triIdx = blasTriIds[triIdOffset];\n        let tri = blasTriangles[triOffset + triIdx];\n        let hit = intersectBLASTriangle(ray, tri);\n        if (hit.hit && hit.t < maxT) {\n            return hit;\n        }\n        return closest;\n    }\n\n    let invDir = computeInvDir(ray.direction);\n\n    var stack: array<u32, MAX_STACK_DEPTH>;\n    var stackPtr = 0u;\n\n    stack[stackPtr] = 0u;\n    stackPtr++;\n\n    var iterations = 0u;\n    let maxIterations = min(triCount_ * 3u, 10000u);\n\n    while (stackPtr > 0u && iterations < maxIterations) {\n        iterations++;\n        stackPtr--;\n        let localIdx = stack[stackPtr];\n        let node = blasNodes[nodeOffset + localIdx];\n\n        let leftChild = node.leftChild;\n        let rightChild = node.rightChild;\n\n        if (leftChild != INVALID_NODE) {\n            if (isLeaf(leftChild)) {\n                let leafIdx = leafIndex(leftChild);\n                let triIdx = blasTriIds[triIdOffset + leafIdx];\n                let tri = blasTriangles[triOffset + triIdx];\n                let hit = intersectBLASTriangle(ray, tri);\n                if (hit.hit && hit.t < closest.t) {\n                    closest = hit;\n                }\n            } else {\n                let leftNode = blasNodes[nodeOffset + leftChild];\n                let leftMin = vec3(leftNode.minX, leftNode.minY, leftNode.minZ);\n                let leftMax = vec3(leftNode.maxX, leftNode.maxY, leftNode.maxZ);\n                let leftDist = intersectAABBDist(ray.origin, invDir, leftMin, leftMax);\n\n                if (leftDist < closest.t && stackPtr < MAX_STACK_DEPTH) {\n                    stack[stackPtr] = leftChild;\n                    stackPtr++;\n                }\n            }\n        }\n\n        if (rightChild != INVALID_NODE) {\n            if (isLeaf(rightChild)) {\n                let leafIdx = leafIndex(rightChild);\n                let triIdx = blasTriIds[triIdOffset + leafIdx];\n                let tri = blasTriangles[triOffset + triIdx];\n                let hit = intersectBLASTriangle(ray, tri);\n                if (hit.hit && hit.t < closest.t) {\n                    closest = hit;\n                }\n            } else {\n                let rightNode = blasNodes[nodeOffset + rightChild];\n                let rightMin = vec3(rightNode.minX, rightNode.minY, rightNode.minZ);\n                let rightMax = vec3(rightNode.maxX, rightNode.maxY, rightNode.maxZ);\n                let rightDist = intersectAABBDist(ray.origin, invDir, rightMin, rightMax);\n\n                if (rightDist < closest.t && stackPtr < MAX_STACK_DEPTH) {\n                    stack[stackPtr] = rightChild;\n                    stackPtr++;\n                }\n            }\n        }\n    }\n\n    return closest;\n}\n\nfn trace(ray: Ray) -> HitResult {\n    var closest: HitResult;\n    closest.hit = false;\n    closest.t = 1e30;\n    closest.entityId = 0u;\n    closest.u = 0.0;\n    closest.v = 0.0;\n    closest.normal = vec3(0.0, 1.0, 0.0);\n    closest.worldPos = vec3(0.0);\n\n    let count = getInstanceCount();\n    if (count == 0u) {\n        return closest;\n    }\n\n    let invDir = computeInvDir(ray.direction);\n\n    var stack: array<u32, MAX_STACK_DEPTH>;\n    var stackPtr = 0u;\n    stack[stackPtr] = 0u;\n    stackPtr++;\n\n    var iterations = 0u;\n    let maxIterations = min(count * 3u, 10000u);\n\n    while (stackPtr > 0u && iterations < maxIterations) {\n        iterations++;\n        stackPtr--;\n        let nodeIdx = stack[stackPtr];\n\n        let node = tlasNodes[nodeIdx];\n\n        var children: array<u32, 4>;\n        var dists: array<f32, 4>;\n\n        children[0] = node.child0;\n        children[1] = node.child1;\n        children[2] = node.child2;\n        children[3] = node.child3;\n\n        dists[0] = select(\n            intersectAABBDist(ray.origin, invDir,\n                vec3(node.c0_minX, node.c0_minY, node.c0_minZ),\n                vec3(node.c0_maxX, node.c0_maxY, node.c0_maxZ)),\n            1e30,\n            children[0] == INVALID_NODE\n        );\n        dists[1] = select(\n            intersectAABBDist(ray.origin, invDir,\n                vec3(node.c1_minX, node.c1_minY, node.c1_minZ),\n                vec3(node.c1_maxX, node.c1_maxY, node.c1_maxZ)),\n            1e30,\n            children[1] == INVALID_NODE\n        );\n        dists[2] = select(\n            intersectAABBDist(ray.origin, invDir,\n                vec3(node.c2_minX, node.c2_minY, node.c2_minZ),\n                vec3(node.c2_maxX, node.c2_maxY, node.c2_maxZ)),\n            1e30,\n            children[2] == INVALID_NODE\n        );\n        dists[3] = select(\n            intersectAABBDist(ray.origin, invDir,\n                vec3(node.c3_minX, node.c3_minY, node.c3_minZ),\n                vec3(node.c3_maxX, node.c3_maxY, node.c3_maxZ)),\n            1e30,\n            children[3] == INVALID_NODE\n        );\n\n        for (var i = 1u; i < 4u; i++) {\n            let keyDist = dists[i];\n            let keyChild = children[i];\n            var j = i;\n            while (j > 0u && dists[j - 1u] > keyDist) {\n                dists[j] = dists[j - 1u];\n                children[j] = children[j - 1u];\n                j--;\n            }\n            dists[j] = keyDist;\n            children[j] = keyChild;\n        }\n\n        for (var i = 3i; i >= 0i; i--) {\n            let child = children[i];\n            let dist = dists[i];\n\n            if (child == INVALID_NODE || dist >= closest.t) {\n                continue;\n            }\n\n            if (isLeaf(child)) {\n                let instanceIdx = leafIndex(child);\n                let eid = tlasInstanceIds[instanceIdx];\n                let shapeId = getShapeId(eid);\n\n                let nodeOffset = blasMeta[shapeId * 4u];\n                let triIdOffset = blasMeta[shapeId * 4u + 1u];\n                let triOffset = blasMeta[shapeId * 4u + 2u];\n                let triCount_ = blasMeta[shapeId * 4u + 3u];\n\n                if (triCount_ == 0u) {\n                    continue;\n                }\n\n                let invMatrix = instanceInverses[eid];\n                var objRay: Ray;\n                objRay.origin = (invMatrix * vec4(ray.origin, 1.0)).xyz;\n                objRay.direction = (invMatrix * vec4(ray.direction, 0.0)).xyz;\n\n                let blasHit = traceBLAS(objRay, nodeOffset, triIdOffset, triOffset, triCount_, closest.t);\n\n                if (blasHit.hit && blasHit.t < closest.t) {\n                    closest = blasHit;\n                    closest.entityId = eid;\n                    let normalMat = mat3x3(invMatrix[0].xyz, invMatrix[1].xyz, invMatrix[2].xyz);\n                    closest.normal = normalize(transpose(normalMat) * blasHit.normal);\n                    closest.worldPos = ray.origin + blasHit.t * ray.direction;\n                }\n            } else if (stackPtr < MAX_STACK_DEPTH) {\n                stack[stackPtr] = child;\n                stackPtr++;\n            }\n        }\n    }\n\n    return closest;\n}\n`;\n\nexport const TLAS_BLAS_ANY_HIT = /* wgsl */ `\nfn traceAnyHit(ray: Ray, tMax: f32) -> bool {\n    let count = getInstanceCount();\n    if (count == 0u) { return false; }\n\n    let invDir = computeInvDir(ray.direction);\n\n    var stack: array<u32, MAX_STACK_DEPTH>;\n    var stackPtr = 0u;\n    stack[stackPtr] = 0u;\n    stackPtr++;\n\n    var iterations = 0u;\n    let maxIterations = min(count * 3u, 10000u);\n\n    while (stackPtr > 0u && iterations < maxIterations) {\n        iterations++;\n        stackPtr--;\n        let nodeIdx = stack[stackPtr];\n\n        let node = tlasNodes[nodeIdx];\n\n        var children: array<u32, 4>;\n        var dists: array<f32, 4>;\n\n        children[0] = node.child0;\n        children[1] = node.child1;\n        children[2] = node.child2;\n        children[3] = node.child3;\n\n        dists[0] = select(\n            intersectAABBDist(ray.origin, invDir,\n                vec3(node.c0_minX, node.c0_minY, node.c0_minZ),\n                vec3(node.c0_maxX, node.c0_maxY, node.c0_maxZ)),\n            1e30,\n            children[0] == INVALID_NODE\n        );\n        dists[1] = select(\n            intersectAABBDist(ray.origin, invDir,\n                vec3(node.c1_minX, node.c1_minY, node.c1_minZ),\n                vec3(node.c1_maxX, node.c1_maxY, node.c1_maxZ)),\n            1e30,\n            children[1] == INVALID_NODE\n        );\n        dists[2] = select(\n            intersectAABBDist(ray.origin, invDir,\n                vec3(node.c2_minX, node.c2_minY, node.c2_minZ),\n                vec3(node.c2_maxX, node.c2_maxY, node.c2_maxZ)),\n            1e30,\n            children[2] == INVALID_NODE\n        );\n        dists[3] = select(\n            intersectAABBDist(ray.origin, invDir,\n                vec3(node.c3_minX, node.c3_minY, node.c3_minZ),\n                vec3(node.c3_maxX, node.c3_maxY, node.c3_maxZ)),\n            1e30,\n            children[3] == INVALID_NODE\n        );\n\n        for (var i = 0u; i < 4u; i++) {\n            let child = children[i];\n            let dist = dists[i];\n\n            if (child == INVALID_NODE || dist >= tMax) {\n                continue;\n            }\n\n            if (isLeaf(child)) {\n                let instanceIdx = leafIndex(child);\n                let eid = tlasInstanceIds[instanceIdx];\n                let shapeId = getShapeId(eid);\n\n                let nodeOffset = blasMeta[shapeId * 4u];\n                let triIdOffset = blasMeta[shapeId * 4u + 1u];\n                let triOffset = blasMeta[shapeId * 4u + 2u];\n                let triCount_ = blasMeta[shapeId * 4u + 3u];\n\n                if (triCount_ == 0u) {\n                    continue;\n                }\n\n                let invMatrix = instanceInverses[eid];\n                var objRay: Ray;\n                objRay.origin = (invMatrix * vec4(ray.origin, 1.0)).xyz;\n                objRay.direction = (invMatrix * vec4(ray.direction, 0.0)).xyz;\n\n                let blasHit = traceBLAS(objRay, nodeOffset, triIdOffset, triOffset, triCount_, tMax);\n                if (blasHit.hit && blasHit.t < tMax) {\n                    return true;\n                }\n            } else if (stackPtr < MAX_STACK_DEPTH) {\n                stack[stackPtr] = child;\n                stackPtr++;\n            }\n        }\n    }\n\n    return false;\n}\n`;\n","import type { SurfaceData } from \"./surface\";\nimport {\n    compileVertexBody,\n    compileApplyLighting,\n    reflectionWgsl,\n    SHADOW_WGSL,\n    SPECULAR_WGSL,\n    REFRACTION_WGSL,\n    SKY_DIR_WGSL,\n    SKY_WGSL,\n    HAZE_WGSL,\n} from \"./surface/wgsl\";\nimport {\n    BVH_STRUCTS,\n    TLAS_BLAS_STRUCTS,\n    TLAS_BLAS_BINDINGS,\n    TLAS_BLAS_TRAVERSAL,\n    TLAS_BLAS_ANY_HIT,\n} from \"./bvh/traverse\";\nimport { RAY_STRUCT_WGSL, HIT_RESULT_STRUCT_WGSL } from \"./bvh/structs\";\nimport { SURFACE_DATA_STRUCT_WGSL, SCENE_STRUCT_WGSL, DATA_STRUCT_WGSL } from \"./surface/structs\";\n\nexport { SCENE_STRUCT_WGSL };\n\nconst EPSILON = 1e-7;\n\nexport const RT_STRUCTS = /* wgsl */ `\n${RAY_STRUCT_WGSL}\n${HIT_RESULT_STRUCT_WGSL}\n${SURFACE_DATA_STRUCT_WGSL}\n${SCENE_STRUCT_WGSL}\n${DATA_STRUCT_WGSL}\n`;\n\nexport const RT_BINDINGS = /* wgsl */ `\n@group(0) @binding(0) var<uniform> scene: Scene;\n@group(0) @binding(1) var<storage, read> data: array<Data>;\n@group(0) @binding(2) var output_scene: texture_storage_2d<rgba8unorm, write>;\n@group(0) @binding(3) var output_depth: texture_storage_2d<r32float, write>;\n@group(0) @binding(4) var output_entityId: texture_storage_2d<r32uint, write>;\n`;\n\nexport const RT_UTILS = /* wgsl */ `\nfn getData(eid: u32) -> Data {\n    return data[eid];\n}\n\nfn getSurfaceType(eid: u32) -> u32 {\n    return data[eid].flags & 0xFFu;\n}\n\nfn getVolume(eid: u32) -> u32 {\n    return (data[eid].flags >> 8u) & 0xFu;\n}\n\nfn getShapeId(eid: u32) -> u32 {\n    return data[eid].flags >> 16u;\n}\n\nfn getInstanceCount() -> u32 {\n    return scene.instanceCount;\n}\n`;\n\nexport const RT_RAY_GEN = /* wgsl */ `\n${SKY_DIR_WGSL}\n\nstruct PrimaryRay {\n    origin: vec3<f32>,\n    direction: vec3<f32>,\n    skyDir: vec3<f32>,\n}\n\nfn generateRay(screenX: f32, screenY: f32) -> PrimaryRay {\n    var result: PrimaryRay;\n    result.skyDir = computeSkyDir(screenX, screenY);\n\n    let width = scene.viewport.x;\n    let height = scene.viewport.y;\n    let ndcX = screenX * 2.0 - 1.0;\n    let ndcY = 1.0 - screenY * 2.0;\n    let aspect = width / height;\n\n    let cameraWorld = scene.cameraWorld;\n    let camPosX = cameraWorld[3][0];\n    let camPosY = cameraWorld[3][1];\n    let camPosZ = cameraWorld[3][2];\n\n    if (scene.cameraMode > 0.5) {\n        let r00 = cameraWorld[0][0]; let r10 = cameraWorld[0][1]; let r20 = cameraWorld[0][2];\n        let r01 = cameraWorld[1][0]; let r11 = cameraWorld[1][1]; let r21 = cameraWorld[1][2];\n        let r02 = cameraWorld[2][0]; let r12 = cameraWorld[2][1]; let r22 = cameraWorld[2][2];\n\n        let halfHeight = scene.cameraSize;\n        let halfWidth = halfHeight * aspect;\n        let offsetX = ndcX * halfWidth;\n        let offsetY = ndcY * halfHeight;\n        let fwdX = -r02; let fwdY = -r12; let fwdZ = -r22;\n\n        result.origin = vec3(\n            camPosX + r00 * offsetX + r01 * offsetY + fwdX * scene.near,\n            camPosY + r10 * offsetX + r11 * offsetY + fwdY * scene.near,\n            camPosZ + r20 * offsetX + r21 * offsetY + fwdZ * scene.near\n        );\n        result.direction = vec3(fwdX, fwdY, fwdZ);\n    } else {\n        let dir = result.skyDir;\n        result.origin = vec3(camPosX + dir.x * scene.near, camPosY + dir.y * scene.near, camPosZ + dir.z * scene.near);\n        result.direction = dir;\n    }\n\n    return result;\n}\n`;\n\nexport const RT_INTERSECTION = /* wgsl */ `\nconst EPSILON: f32 = ${EPSILON};\n`;\n\nexport function compileRTSurface(data: SurfaceData): string {\n    return compileUberShader([data]);\n}\n\nfunction compileSurfaceVariant(id: number, data: SurfaceData): string {\n    const vertexBody = compileVertexBody(data.vertex);\n    const fragmentBody = data.fragment ?? \"\";\n    const lightingCode = compileApplyLighting(data.lit, true, true);\n\n    return `\nfn userVertexTransform_${id}(worldPos: vec3<f32>, normal: vec3<f32>, eid: u32) -> vec3<f32> {\n    ${vertexBody}\n}\n\nfn userFragment_${id}(surface: ptr<function, SurfaceData>, position: vec4<f32>) {\n    ${fragmentBody}\n}\n\nfn applyLighting_${id}(surface: SurfaceData, rayDir: vec3<f32>) -> vec3<f32> {\n    ${lightingCode}\n}\n`;\n}\n\nfunction compileDispatchFunctions(surfaceCount: number): string {\n    const vertexCases = Array.from(\n        { length: surfaceCount },\n        (_, i) => `        case ${i}u: { return userVertexTransform_${i}(worldPos, normal, eid); }`\n    ).join(\"\\n\");\n\n    const fragmentCases = Array.from(\n        { length: surfaceCount },\n        (_, i) => `        case ${i}u: { userFragment_${i}(surface, position); }`\n    ).join(\"\\n\");\n\n    const lightingCases = Array.from(\n        { length: surfaceCount },\n        (_, i) => `        case ${i}u: { return applyLighting_${i}(surface, rayDir); }`\n    ).join(\"\\n\");\n\n    return `\nfn dispatchVertexTransform(surfaceId: u32, worldPos: vec3<f32>, normal: vec3<f32>, eid: u32) -> vec3<f32> {\n    switch surfaceId {\n${vertexCases}\n        default: { return userVertexTransform_0(worldPos, normal, eid); }\n    }\n}\n\nfn dispatchFragment(surfaceId: u32, surface: ptr<function, SurfaceData>, position: vec4<f32>) {\n    switch surfaceId {\n${fragmentCases}\n        default: { userFragment_0(surface, position); }\n    }\n}\n\nfn dispatchLighting(surfaceId: u32, surface: SurfaceData, rayDir: vec3<f32>) -> vec3<f32> {\n    switch surfaceId {\n${lightingCases}\n        default: { return applyLighting_0(surface, rayDir); }\n    }\n}\n`;\n}\n\nexport function compileUberShader(\n    surfaces: SurfaceData[],\n    _shadows: boolean = true,\n    _reflections: boolean = true,\n    _refractions: boolean = true\n): string {\n    const surfaceVariants = surfaces.map((s, i) => compileSurfaceVariant(i, s)).join(\"\\n\");\n    const dispatchFunctions = compileDispatchFunctions(surfaces.length);\n\n    return /* wgsl */ `\n${RT_STRUCTS}\n${BVH_STRUCTS}\n${TLAS_BLAS_STRUCTS}\n${RT_BINDINGS}\n${RT_UTILS}\n${TLAS_BLAS_BINDINGS}\n${RT_RAY_GEN}\n${RT_INTERSECTION}\n${TLAS_BLAS_TRAVERSAL}\n${TLAS_BLAS_ANY_HIT}\n${SHADOW_WGSL}\n${SPECULAR_WGSL}\n${REFRACTION_WGSL}\n${SKY_WGSL}\n${HAZE_WGSL}\n${reflectionWgsl(true)}\n\n${surfaceVariants}\n${dispatchFunctions}\n\nconst MAX_TRANSPARENT_DEPTH: u32 = 4u;\nconst TRANSPARENCY_EPSILON: f32 = 0.001;\nconst MAX_REFRACTION_DEPTH: u32 = 2u;\nconst REFRACTION_EPSILON: f32 = 0.001;\n\n${compileRefractionTracer(true)}\n\n@compute @workgroup_size(8, 8)\nfn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n    let width = u32(scene.viewport.x);\n    let height = u32(scene.viewport.y);\n\n    if (gid.x >= width || gid.y >= height) {\n        return;\n    }\n\n    let screenX = (f32(gid.x) + 0.5) / f32(width);\n    let screenY = (f32(gid.y) + 0.5) / f32(height);\n\n    let primary = generateRay(screenX, screenY);\n    var ray: Ray;\n    ray.origin = primary.origin;\n    ray.direction = primary.direction;\n\n    var finalColor = vec3(0.0);\n    var remainingOpacity = 1.0;\n    var depth = 1e30;\n    var entityId = 0u;\n    var firstHit = true;\n\n    for (var i = 0u; i < MAX_TRANSPARENT_DEPTH; i++) {\n        let hit = trace(ray);\n\n        if (!hit.hit) {\n            finalColor += sampleSky(primary.skyDir) * remainingOpacity;\n            break;\n        }\n\n        let eid = hit.entityId;\n        let d = getData(eid);\n        let opacity = d.baseColor.a;\n        let surfaceId = getSurfaceType(eid);\n\n        if (firstHit) {\n            depth = hit.t;\n            entityId = eid;\n            firstHit = false;\n        }\n\n        let finalWorldPos = dispatchVertexTransform(surfaceId, hit.worldPos, hit.normal, eid);\n\n        var surface: SurfaceData;\n        surface.baseColor = d.baseColor.rgb;\n        surface.roughness = d.pbr.x;\n        surface.metallic = d.pbr.y;\n        surface.opacity = opacity;\n        surface.emission = d.emission.rgb * d.emission.a;\n        surface.normal = hit.normal;\n        surface.worldPos = finalWorldPos;\n\n        dispatchFragment(surfaceId, &surface, vec4(f32(gid.x), f32(gid.y), hit.t, 1.0));\n\n        ${compileRefractionBranch()}\n        let litColor = dispatchLighting(surfaceId, surface, primary.direction);\n        let hazeColor = applyHaze(litColor, hit.t);\n\n        let contribution = opacity * remainingOpacity;\n        finalColor += hazeColor * contribution;\n\n        if (opacity >= 1.0) {\n            break;\n        }\n\n        remainingOpacity *= (1.0 - opacity);\n        if (remainingOpacity < 0.02) {\n            break;\n        }\n\n        ray.origin = hit.worldPos + ray.direction * TRANSPARENCY_EPSILON;\n    }\n\n    textureStore(output_scene, vec2<i32>(gid.xy), vec4(finalColor, 1.0));\n    textureStore(output_depth, vec2<i32>(gid.xy), vec4(depth, 0.0, 0.0, 0.0));\n    textureStore(output_entityId, vec2<i32>(gid.xy), vec4(entityId, 0u, 0u, 0u));\n}\n`;\n}\n\nfunction compileRefractionTracer(_shadows: boolean = true): string {\n    const shadowCheck = `var hitShadow = 1.0;\n            if (hitNdotL > 0.0 && scene.shadowSamples > 0u) {\n                var shadowRay: Ray;\n                shadowRay.origin = refHit.worldPos + refHit.normal * REFRACTION_EPSILON;\n                shadowRay.direction = hitL;\n                if (traceAnyHit(shadowRay, 1000.0)) { hitShadow = 0.0; }\n            }`;\n\n    return /* wgsl */ `\nconst VOLUME_SOLID: u32 = 0u;\nconst VOLUME_HALF_SPACE: u32 = 1u;\n\nfn traceRefraction(\n    startPos: vec3<f32>,\n    startNormal: vec3<f32>,\n    rayDir: vec3<f32>,\n    ior: f32,\n    mediumColor: vec3<f32>,\n    volumeType: u32,\n    maxBounces: u32\n) -> vec3<f32> {\n    var currentPos = startPos;\n    var currentNormal = startNormal;\n    var currentDir = rayDir;\n    var currentIOR = ior;\n    var currentMediumColor = mediumColor;\n    var totalDistance = 0.0;\n    var inMedium = true;\n    let isHalfSpace = volumeType == VOLUME_HALF_SPACE;\n\n    for (var bounce = 0u; bounce < maxBounces; bounce++) {\n        let entering = dot(currentDir, currentNormal) < 0.0;\n        let n = select(-currentNormal, currentNormal, entering);\n        let n1 = select(currentIOR, 1.0, entering);\n        let n2 = select(1.0, currentIOR, entering);\n        let eta = n1 / n2;\n\n        let refractResult = refractRay(currentDir, n, eta);\n        let isTIR = refractResult.w > 0.5;\n\n        var refractRay_: Ray;\n        refractRay_.direction = refractResult.xyz;\n        refractRay_.origin = select(\n            currentPos - n * REFRACTION_EPSILON,\n            currentPos + n * REFRACTION_EPSILON,\n            isTIR\n        );\n\n        let refHit = trace(refractRay_);\n        if (!refHit.hit) {\n            if (isHalfSpace && inMedium) {\n                let depthFade = exp(-totalDistance * 0.1);\n                return currentMediumColor * depthFade * scene.ambientColor.rgb * scene.ambientColor.a;\n            }\n            var skyColor = sampleSky(refractRay_.direction);\n            if (inMedium && totalDistance > 0.0) {\n                let absorption = exp(-totalDistance * 0.5);\n                skyColor = mix(skyColor * currentMediumColor, skyColor, absorption);\n            }\n            return skyColor;\n        }\n\n        if (inMedium) {\n            totalDistance += refHit.t;\n        }\n\n        let refEid = refHit.entityId;\n        let refracted = getData(refEid);\n        let refOpacity = refracted.baseColor.a;\n        let refIOR = refracted.pbr.z;\n\n        if (refIOR <= 1.0) {\n            let hitBaseColor = refracted.baseColor.rgb;\n            let hitMetallic = refracted.pbr.y;\n            let hitEmission = refracted.emission.rgb * refracted.emission.a;\n\n            let hitL = -scene.sunDirection.xyz;\n            let hitNdotL = max(dot(refHit.normal, hitL), 0.0);\n${shadowCheck}\n\n            let hitAmbient = scene.ambientColor.rgb * scene.ambientColor.a;\n            let hitSun = scene.sunColor.rgb * hitNdotL * hitShadow;\n            var hitDiffuse = hitBaseColor * (hitAmbient + hitSun) * (1.0 - hitMetallic);\n\n            if (totalDistance > 0.0) {\n                let absorption = exp(-totalDistance * 0.5);\n                hitDiffuse = mix(hitDiffuse * currentMediumColor, hitDiffuse, absorption);\n            }\n\n            var surfaceColor = applyHaze(hitDiffuse + hitEmission, refHit.t);\n\n            if (refOpacity >= 1.0) {\n                return surfaceColor;\n            }\n\n            var behindRay: Ray;\n            behindRay.origin = refHit.worldPos + refractRay_.direction * REFRACTION_EPSILON;\n            behindRay.direction = refractRay_.direction;\n            let behindHit = trace(behindRay);\n            var behindColor = sampleSky(refractRay_.direction);\n            if (behindHit.hit) {\n                let behind = getData(behindHit.entityId);\n                let behindBaseColor = behind.baseColor.rgb;\n                let behindMetallic = behind.pbr.y;\n                let behindEmission = behind.emission.rgb * behind.emission.a;\n                let behindNdotL = max(dot(behindHit.normal, hitL), 0.0);\n                let behindAmbient = scene.ambientColor.rgb * scene.ambientColor.a;\n                let behindSun = scene.sunColor.rgb * behindNdotL;\n                behindColor = applyHaze(behindBaseColor * (behindAmbient + behindSun) * (1.0 - behindMetallic) + behindEmission, behindHit.t);\n            }\n\n            return surfaceColor * refOpacity + behindColor * (1.0 - refOpacity);\n        }\n\n        if (!entering) {\n            inMedium = false;\n        } else {\n            inMedium = true;\n            currentMediumColor = refracted.baseColor.rgb;\n            totalDistance = 0.0;\n        }\n\n        currentPos = refHit.worldPos;\n        currentNormal = refHit.normal;\n        currentDir = refractRay_.direction;\n        currentIOR = refIOR;\n    }\n\n    if (isHalfSpace && inMedium) {\n        let depthFade = exp(-totalDistance * 0.1);\n        return currentMediumColor * depthFade * scene.ambientColor.rgb * scene.ambientColor.a;\n    }\n    var skyColor = sampleSky(currentDir);\n    if (inMedium && totalDistance > 0.0) {\n        let absorption = exp(-totalDistance * 0.5);\n        skyColor = mix(skyColor * currentMediumColor, skyColor, absorption);\n    }\n    return skyColor;\n}\n`;\n}\n\nfunction compileRefractionBranch(): string {\n    return /* wgsl */ `\n        let ior = d.pbr.z;\n        if (ior > 1.0 && scene.refractionDepth > 0u) {\n            let entering = dot(ray.direction, surface.normal) < 0.0;\n            let n = select(-surface.normal, surface.normal, entering);\n            let n1 = select(ior, 1.0, entering);\n            let n2 = select(1.0, ior, entering);\n            let cosI = abs(dot(ray.direction, n));\n            let fresnel = fresnelSchlickIOR(cosI, n1, n2);\n\n            let volumeType = getVolume(eid);\n            let refractedColor = traceRefraction(\n                surface.worldPos, surface.normal, ray.direction, ior,\n                surface.baseColor, volumeType, scene.refractionDepth\n            );\n\n            let contribution = opacity * remainingOpacity;\n            let refractContrib = (1.0 - fresnel) * contribution;\n            finalColor += applyHaze(refractedColor, hit.t) * refractContrib;\n\n            let litColor = dispatchLighting(surfaceId, surface, primary.direction);\n            finalColor += applyHaze(litColor, hit.t) * fresnel * contribution;\n\n            if (opacity >= 1.0) {\n                break;\n            }\n            remainingOpacity *= (1.0 - opacity);\n            if (remainingOpacity < 0.02) {\n                break;\n            }\n            ray.origin = hit.worldPos + ray.direction * TRANSPARENCY_EPSILON;\n            continue;\n        }\n`;\n}\n\nexport function compileForwardShader(surface: SurfaceData): string {\n    return compileUberShader([surface]);\n}\n","import type { SurfaceData } from \"../surface\";\nimport { SCENE_STRUCT_WGSL, WGSL_STRUCTS } from \"../surface/structs\";\nimport { compileVertexBody, WGSL_LIGHTING_CALC, SKY_WGSL, SKY_DIR_WGSL } from \"../surface/wgsl\";\n\nfunction compileSurfaceVariant(id: number, data: SurfaceData): string {\n    const vertexBody = compileVertexBody(data.vertex);\n    const fragmentBody = data.fragment ?? \"\";\n    const lit = data.lit !== false;\n\n    return `\nfn userVertexTransform_${id}(worldPos: vec3<f32>, normal: vec3<f32>, eid: u32) -> vec3<f32> {\n    ${vertexBody}\n}\n\nfn userFragment_${id}(surface: ptr<function, SurfaceData>, position: vec4<f32>) {\n    ${fragmentBody}\n}\n\nfn applyLighting_${id}(surface: SurfaceData) -> vec3<f32> {\n    ${\n        lit\n            ? `${WGSL_LIGHTING_CALC}\n    return surface.baseColor * lighting + surface.emission;`\n            : \"return surface.baseColor;\"\n    }\n}\n`;\n}\n\nfunction compileDispatchFunctions(surfaceCount: number): string {\n    const vertexCases = Array.from(\n        { length: surfaceCount },\n        (_, i) => `        case ${i}u: { return userVertexTransform_${i}(worldPos, normal, eid); }`\n    ).join(\"\\n\");\n\n    const fragmentCases = Array.from(\n        { length: surfaceCount },\n        (_, i) => `        case ${i}u: { userFragment_${i}(surface, position); }`\n    ).join(\"\\n\");\n\n    const lightingCases = Array.from(\n        { length: surfaceCount },\n        (_, i) => `        case ${i}u: { return applyLighting_${i}(surface); }`\n    ).join(\"\\n\");\n\n    return `\nfn dispatchVertexTransform(surfaceId: u32, worldPos: vec3<f32>, normal: vec3<f32>, eid: u32) -> vec3<f32> {\n    switch surfaceId {\n${vertexCases}\n        default: { return userVertexTransform_0(worldPos, normal, eid); }\n    }\n}\n\nfn dispatchFragment(surfaceId: u32, surface: ptr<function, SurfaceData>, position: vec4<f32>) {\n    switch surfaceId {\n${fragmentCases}\n        default: { userFragment_0(surface, position); }\n    }\n}\n\nfn dispatchLighting(surfaceId: u32, surface: SurfaceData) -> vec3<f32> {\n    switch surfaceId {\n${lightingCases}\n        default: { return applyLighting_0(surface); }\n    }\n}\n`;\n}\n\nexport function compileRasterShader(surfaces: SurfaceData[]): string {\n    const surfaceVariants = surfaces.map((s, i) => compileSurfaceVariant(i, s)).join(\"\\n\");\n    const dispatchFunctions = compileDispatchFunctions(surfaces.length);\n\n    return /* wgsl */ `\n${WGSL_STRUCTS}\n\n@group(0) @binding(8) var<storage, read> surfaceIds: array<u32>;\n\n${surfaceVariants}\n${dispatchFunctions}\n\n@vertex\nfn vs(input: VertexInput) -> VertexOutput {\n    let eid = entityIds[input.instance];\n    let world = matrices[eid];\n    let scaledPos = input.position * sizes[eid].xyz;\n    let baseWorldPos = (world * vec4<f32>(scaledPos, 1.0)).xyz;\n    let worldNormal = normalize((world * vec4<f32>(input.normal, 0.0)).xyz);\n    let surfaceId = surfaceIds[eid] & 0xFFu;\n    let finalWorldPos = dispatchVertexTransform(surfaceId, baseWorldPos, worldNormal, eid);\n    _ = shapes[eid];\n\n    var output: VertexOutput;\n    output.position = scene.viewProj * vec4<f32>(finalWorldPos, 1.0);\n    output.color = colors[eid];\n    output.worldNormal = worldNormal;\n    output.entityId = eid;\n    output.worldPos = finalWorldPos;\n    return output;\n}\n\n@fragment\nfn fs(input: VertexOutput) -> FragmentOutput {\n    let eid = input.entityId;\n    let pbrData = pbr[eid];\n    let emissionData = emission[eid];\n    let surfaceId = surfaceIds[eid] & 0xFFu;\n\n    var surface: SurfaceData;\n    surface.baseColor = input.color.rgb;\n    surface.roughness = pbrData.x;\n    surface.metallic = pbrData.y;\n    surface.emission = emissionData.rgb * emissionData.a;\n    surface.normal = normalize(input.worldNormal);\n    surface.worldPos = input.worldPos;\n\n    dispatchFragment(surfaceId, &surface, input.position);\n\n    let litColor = dispatchLighting(surfaceId, surface);\n\n    var output: FragmentOutput;\n    output.color = vec4<f32>(litColor, input.color.a);\n    output.entityId = input.entityId;\n    return output;\n}\n`;\n}\n\nexport async function createRasterPipeline(\n    device: GPUDevice,\n    surfaces: SurfaceData[],\n    colorFormat: GPUTextureFormat\n): Promise<GPURenderPipeline> {\n    const code = compileRasterShader(surfaces);\n    const module = device.createShaderModule({ code });\n\n    return device.createRenderPipelineAsync({\n        layout: \"auto\",\n        vertex: {\n            module,\n            entryPoint: \"vs\",\n            buffers: [\n                {\n                    arrayStride: 24,\n                    attributes: [\n                        { shaderLocation: 0, offset: 0, format: \"float32x3\" },\n                        { shaderLocation: 1, offset: 12, format: \"float32x3\" },\n                    ],\n                },\n            ],\n        },\n        fragment: {\n            module,\n            entryPoint: \"fs\",\n            targets: [{ format: colorFormat }, { format: \"r32uint\" }],\n        },\n        depthStencil: {\n            format: \"depth24plus\",\n            depthWriteEnabled: true,\n            depthCompare: \"less\",\n        },\n        primitive: {\n            topology: \"triangle-list\",\n            cullMode: \"back\",\n        },\n    });\n}\n\nexport function compileSkyShader(): string {\n    return /* wgsl */ `\n${SCENE_STRUCT_WGSL}\n\n@group(0) @binding(0) var<uniform> scene: Scene;\n\n${SKY_DIR_WGSL}\n${SKY_WGSL}\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n}\n\n@vertex\nfn vs(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var positions = array<vec2<f32>, 3>(\n        vec2(-1.0, -1.0),\n        vec2(3.0, -1.0),\n        vec2(-1.0, 3.0)\n    );\n    var output: VertexOutput;\n    output.position = vec4(positions[vertexIndex], 0.0, 1.0);\n    output.uv = (positions[vertexIndex] + 1.0) * 0.5;\n    output.uv.y = 1.0 - output.uv.y;\n    return output;\n}\n\n@fragment\nfn fs(input: VertexOutput) -> @location(0) vec4<f32> {\n    let dir = computeSkyDir(input.uv.x, input.uv.y);\n    let color = sampleSky(dir);\n    return vec4(color, 1.0);\n}\n`;\n}\n\nexport async function createSkyPipeline(\n    device: GPUDevice,\n    colorFormat: GPUTextureFormat\n): Promise<GPURenderPipeline> {\n    const code = compileSkyShader();\n    const module = device.createShaderModule({ code });\n\n    return device.createRenderPipelineAsync({\n        layout: \"auto\",\n        vertex: { module, entryPoint: \"vs\" },\n        fragment: {\n            module,\n            entryPoint: \"fs\",\n            targets: [{ format: colorFormat }],\n        },\n        depthStencil: {\n            format: \"depth24plus\",\n            depthWriteEnabled: false,\n            depthCompare: \"always\",\n        },\n        primitive: { topology: \"triangle-list\" },\n    });\n}\n","import type { ComputeNode, ExecutionContext } from \"../../compute\";\nimport type { SurfaceData } from \"../surface\";\nimport type { Batch } from \"../mesh\";\nimport { COLOR_FORMAT } from \"../scene\";\nimport { compileUberShader } from \"../shaders\";\nimport { createRasterPipeline, createSkyPipeline } from \"./raster\";\n\nexport interface ForwardConfig {\n    scene: GPUBuffer;\n    matrices: GPUBuffer;\n    colors: GPUBuffer;\n    sizes: GPUBuffer;\n    pbr: GPUBuffer;\n    emission: GPUBuffer;\n    shapes: GPUBuffer;\n    surfaces: GPUBuffer;\n    data: GPUBuffer;\n    getSurfaces: () => SurfaceData[];\n    getRaytracing: () => boolean;\n    getClearColor: () => { r: number; g: number; b: number };\n    getSky: () => boolean;\n    acquire?: (message?: string) => (() => void) | undefined;\n    batches: () => (Batch | null)[];\n    tlasNodes: GPUBuffer;\n    tlasInstanceIds: GPUBuffer;\n    blasNodes: GPUBuffer;\n    blasTriIds: GPUBuffer;\n    blasTriangles: GPUBuffer;\n    blasMeta: GPUBuffer;\n    instanceInverses: GPUBuffer;\n}\n\nexport type ForwardNode = ComputeNode;\n\nexport function createForwardNode(config: ForwardConfig): ForwardNode {\n    let rasterPipeline: GPURenderPipeline | null = null;\n    let rtPipeline: GPUComputePipeline | null = null;\n    let rtCompiling = false;\n    let skyPipeline: GPURenderPipeline | null = null;\n\n    function executeRT(ctx: ExecutionContext): void {\n        const { device, encoder } = ctx;\n\n        const colorView = ctx.getTextureView(\"color\");\n        const linearDepthView = ctx.getTextureView(\"linear-depth\");\n        const eidView = ctx.getTextureView(\"eid\");\n\n        if (!colorView || !linearDepthView || !eidView || !rtPipeline) {\n            return;\n        }\n\n        const bindGroup0 = device.createBindGroup({\n            layout: rtPipeline.getBindGroupLayout(0),\n            entries: [\n                { binding: 0, resource: { buffer: config.scene } },\n                { binding: 1, resource: { buffer: config.data } },\n                { binding: 2, resource: colorView },\n                { binding: 3, resource: linearDepthView },\n                { binding: 4, resource: eidView },\n            ],\n        });\n\n        const bindGroup1 = device.createBindGroup({\n            layout: rtPipeline.getBindGroupLayout(1),\n            entries: [\n                { binding: 0, resource: { buffer: config.tlasNodes } },\n                { binding: 1, resource: { buffer: config.tlasInstanceIds } },\n                { binding: 2, resource: { buffer: config.blasNodes } },\n                { binding: 3, resource: { buffer: config.blasTriIds } },\n                { binding: 4, resource: { buffer: config.blasTriangles } },\n                { binding: 5, resource: { buffer: config.blasMeta } },\n                { binding: 6, resource: { buffer: config.instanceInverses } },\n            ],\n        });\n\n        const colorTexture = ctx.getTexture(\"color\");\n        if (!colorTexture) return;\n\n        const width = colorTexture.width;\n        const height = colorTexture.height;\n\n        const pass = encoder.beginComputePass();\n        pass.setPipeline(rtPipeline);\n        pass.setBindGroup(0, bindGroup0);\n        pass.setBindGroup(1, bindGroup1);\n        pass.dispatchWorkgroups(Math.ceil(width / 8), Math.ceil(height / 8));\n        pass.end();\n    }\n\n    function executeRaster(ctx: ExecutionContext): void {\n        const { device, encoder } = ctx;\n\n        const colorView = ctx.getTextureView(\"color\");\n        const eidView = ctx.getTextureView(\"eid\");\n        const depthView = ctx.getTextureView(\"depth\");\n\n        if (!colorView || !eidView || !depthView || !rasterPipeline) {\n            return;\n        }\n\n        const batches = config.batches();\n        const colorTexture = ctx.getTexture(\"color\");\n        if (!colorTexture) return;\n\n        const clearColor = config.getClearColor();\n        const hasSky = config.getSky() && skyPipeline;\n\n        if (hasSky) {\n            const skyPass = encoder.beginRenderPass({\n                colorAttachments: [\n                    {\n                        view: colorView as GPUTextureView,\n                        clearValue: { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: 1 },\n                        loadOp: \"clear\" as const,\n                        storeOp: \"store\" as const,\n                    },\n                ],\n                depthStencilAttachment: {\n                    view: depthView as GPUTextureView,\n                    depthClearValue: 1.0,\n                    depthLoadOp: \"clear\" as const,\n                    depthStoreOp: \"store\" as const,\n                },\n            });\n\n            const skyBindGroup = device.createBindGroup({\n                layout: skyPipeline!.getBindGroupLayout(0),\n                entries: [{ binding: 0, resource: { buffer: config.scene } }],\n            });\n\n            skyPass.setPipeline(skyPipeline!);\n            skyPass.setBindGroup(0, skyBindGroup);\n            skyPass.draw(3);\n            skyPass.end();\n        }\n\n        const pass = encoder.beginRenderPass({\n            colorAttachments: [\n                {\n                    view: colorView as GPUTextureView,\n                    clearValue: { r: clearColor.r, g: clearColor.g, b: clearColor.b, a: 1 },\n                    loadOp: hasSky ? (\"load\" as const) : (\"clear\" as const),\n                    storeOp: \"store\" as const,\n                },\n                {\n                    view: eidView as GPUTextureView,\n                    clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    loadOp: \"clear\" as const,\n                    storeOp: \"store\" as const,\n                },\n            ],\n            depthStencilAttachment: {\n                view: depthView as GPUTextureView,\n                depthClearValue: 1.0,\n                depthLoadOp: hasSky ? (\"load\" as const) : (\"clear\" as const),\n                depthStoreOp: \"store\" as const,\n            },\n        });\n\n        pass.setPipeline(rasterPipeline);\n\n        for (const batch of batches) {\n            if (!batch || batch.count === 0) continue;\n\n            const batchBindGroup = device.createBindGroup({\n                layout: rasterPipeline.getBindGroupLayout(0),\n                entries: [\n                    { binding: 0, resource: { buffer: config.scene } },\n                    { binding: 1, resource: { buffer: batch.entityIds } },\n                    { binding: 2, resource: { buffer: config.matrices } },\n                    { binding: 3, resource: { buffer: config.colors } },\n                    { binding: 4, resource: { buffer: config.sizes } },\n                    { binding: 5, resource: { buffer: config.pbr } },\n                    { binding: 6, resource: { buffer: config.emission } },\n                    { binding: 7, resource: { buffer: config.shapes } },\n                    { binding: 8, resource: { buffer: config.surfaces } },\n                ],\n            });\n\n            pass.setBindGroup(0, batchBindGroup);\n            pass.setVertexBuffer(0, batch.buffers.vertex);\n            pass.setIndexBuffer(batch.buffers.index, \"uint16\");\n            pass.drawIndexed(batch.buffers.indexCount, batch.count);\n        }\n\n        pass.end();\n    }\n\n    return {\n        id: \"forward\",\n        inputs: [{ id: \"tlas-bvh-nodes\", access: \"read\" as const }],\n        outputs: [\n            { id: \"color\", access: \"write\" },\n            { id: \"linear-depth\", access: \"write\" },\n            { id: \"eid\", access: \"write\" },\n        ],\n\n        async prepare(device: GPUDevice) {\n            const surfaces = config.getSurfaces();\n            rasterPipeline = await createRasterPipeline(device, surfaces, COLOR_FORMAT);\n            skyPipeline = await createSkyPipeline(device, COLOR_FORMAT);\n\n            if (config.getRaytracing()) {\n                rtCompiling = true;\n                const release = config.acquire?.(\"compiling shaders\");\n                createRTPipeline(device, surfaces)\n                    .then((p) => {\n                        rtPipeline = p;\n                    })\n                    .finally(() => {\n                        rtCompiling = false;\n                        release?.();\n                    });\n            }\n        },\n\n        execute(ctx: ExecutionContext) {\n            const wantRT = config.getRaytracing();\n\n            if (wantRT && !rtPipeline && !rtCompiling) {\n                rtCompiling = true;\n                const release = config.acquire?.(\"compiling shaders\");\n                const surfaces = config.getSurfaces();\n                createRTPipeline(ctx.device, surfaces)\n                    .then((p) => {\n                        rtPipeline = p;\n                    })\n                    .finally(() => {\n                        rtCompiling = false;\n                        release?.();\n                    });\n            }\n\n            if (wantRT && rtPipeline) {\n                executeRT(ctx);\n            } else {\n                executeRaster(ctx);\n            }\n        },\n    };\n}\n\nexport function compileRTShader(surfaces: SurfaceData[]): string {\n    return compileUberShader(surfaces);\n}\n\nexport async function createRTPipeline(\n    device: GPUDevice,\n    surfaces: SurfaceData[]\n): Promise<GPUComputePipeline> {\n    const code = compileRTShader(surfaces);\n    const module = device.createShaderModule({ code });\n    return device.createComputePipelineAsync({\n        layout: \"auto\",\n        compute: { module, entryPoint: \"main\" },\n    });\n}\n\nexport { createRasterPipeline, compileRasterShader } from \"./raster\";\n","import type { ComputeNode, ExecutionContext } from \"../compute\";\nimport { SCENE_STRUCT_WGSL } from \"./shaders\";\n\nconst depthConvertShader = /* wgsl */ `\n${SCENE_STRUCT_WGSL}\n\n@group(0) @binding(0) var<uniform> scene: Scene;\n@group(0) @binding(1) var linearDepthTex: texture_2d<f32>;\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n}\n\n@vertex\nfn vs(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var positions = array<vec2<f32>, 3>(\n        vec2(-1.0, -1.0),\n        vec2(3.0, -1.0),\n        vec2(-1.0, 3.0)\n    );\n    var output: VertexOutput;\n    output.position = vec4(positions[vertexIndex], 0.0, 1.0);\n    output.uv = (positions[vertexIndex] + 1.0) * 0.5;\n    output.uv.y = 1.0 - output.uv.y;\n    return output;\n}\n\n@fragment\nfn fs(input: VertexOutput) -> @builtin(frag_depth) f32 {\n    let coords = vec2<i32>(input.position.xy);\n    let t = textureLoad(linearDepthTex, coords, 0).r;\n\n    let near = scene.near;\n    let far = scene.far;\n\n    if (t > far) {\n        return 1.0;\n    }\n\n    var ndcDepth: f32;\n    if (scene.cameraMode > 0.5) {\n        ndcDepth = (t - near) / (far - near);\n    } else {\n        ndcDepth = (far * (t - near)) / (t * (far - near));\n    }\n\n    return clamp(ndcDepth, 0.0, 1.0);\n}\n`;\n\nexport interface DepthConvertConfig {\n    scene: GPUBuffer;\n    getRaytracing?: () => boolean;\n}\n\nexport function createDepthConvertNode(config: DepthConvertConfig): ComputeNode {\n    let pipeline: GPURenderPipeline | null = null;\n\n    return {\n        id: \"depth-convert\",\n        inputs: [{ id: \"linear-depth\", access: \"read\" }],\n        outputs: [{ id: \"depth\", access: \"write\" }],\n\n        async prepare(device: GPUDevice) {\n            const module = device.createShaderModule({ code: depthConvertShader });\n            pipeline = await device.createRenderPipelineAsync({\n                layout: \"auto\",\n                vertex: { module, entryPoint: \"vs\" },\n                fragment: { module, entryPoint: \"fs\", targets: [] },\n                depthStencil: {\n                    format: \"depth24plus\",\n                    depthWriteEnabled: true,\n                    depthCompare: \"always\",\n                },\n                primitive: { topology: \"triangle-list\" },\n            });\n        },\n\n        execute(ctx: ExecutionContext) {\n            if (config.getRaytracing && !config.getRaytracing()) {\n                return;\n            }\n\n            const { device, encoder } = ctx;\n\n            const linearDepthView = ctx.getTextureView(\"linear-depth\");\n            const depthView = ctx.getTextureView(\"depth\");\n\n            if (!linearDepthView || !depthView) {\n                return;\n            }\n\n            const bindGroup = device.createBindGroup({\n                layout: pipeline!.getBindGroupLayout(0),\n                entries: [\n                    { binding: 0, resource: { buffer: config.scene } },\n                    { binding: 1, resource: linearDepthView },\n                ],\n            });\n\n            const pass = encoder.beginRenderPass({\n                colorAttachments: [],\n                depthStencilAttachment: {\n                    view: depthView,\n                    depthClearValue: 1.0,\n                    depthLoadOp: \"clear\",\n                    depthStoreOp: \"store\",\n                },\n            });\n            pass.setPipeline(pipeline!);\n            pass.setBindGroup(0, bindGroup);\n            pass.draw(3);\n            pass.end();\n        },\n    };\n}\n","import { resource, type State } from \"../../core\";\n\nexport enum Pass {\n    BeforeOverlay,\n    Overlay,\n    AfterOverlay,\n    BeforePost,\n    Post,\n    AfterPost,\n}\n\nexport interface DrawContext {\n    readonly device: GPUDevice;\n    readonly encoder: GPUCommandEncoder;\n    readonly format: GPUTextureFormat;\n    readonly width: number;\n    readonly height: number;\n\n    readonly sceneView: GPUTextureView;\n    readonly depthView: GPUTextureView;\n    readonly entityIdView: GPUTextureView;\n    readonly maskView: GPUTextureView;\n    readonly canvasView: GPUTextureView;\n\n    readonly inputView?: GPUTextureView;\n    readonly outputView?: GPUTextureView;\n}\n\nexport interface SharedPassContext {\n    readonly device: GPUDevice;\n    readonly format: GPUTextureFormat;\n    readonly maskFormat: GPUTextureFormat;\n}\n\nexport interface Draw {\n    readonly id: string;\n    readonly pass: Pass;\n    readonly order: number;\n    execute(ctx: DrawContext): void;\n    draw?(pass: GPURenderPassEncoder, ctx: SharedPassContext): void;\n}\n\nexport interface Draws {\n    draws: Map<string, Draw>;\n}\n\nexport const Draws = resource<Draws>(\"draws\");\n\nexport function registerDraw(state: State, draw: Draw): void {\n    const draws = Draws.from(state);\n    if (draws) {\n        draws.draws.set(draw.id, draw);\n    }\n}\n\nexport function unregisterDraw(state: State, id: string): void {\n    const draws = Draws.from(state);\n    if (draws) {\n        draws.draws.delete(id);\n    }\n}\n\nexport function getDrawsByPass(state: State, pass: Pass): Draw[] {\n    const draws = Draws.from(state);\n    if (!draws) return [];\n    return Array.from(draws.draws.values())\n        .filter((d) => d.pass === pass)\n        .sort((a, b) => a.order - b.order);\n}\n","import type { State } from \"../../core\";\nimport type { ComputeNode, ExecutionContext } from \"../compute\";\nimport { Pass, getDrawsByPass, type DrawContext } from \"./pass\";\n\nconst shader = /* wgsl */ `\nstruct VertexOutput {\n    @builtin(position) position: vec4f,\n    @location(0) uv: vec2f,\n}\n\nstruct Uniforms {\n    exposure: f32,\n    vignetteStrength: f32,\n    vignetteInner: f32,\n    vignetteOuter: f32,\n    texelSizeX: f32,\n    texelSizeY: f32,\n    flags: u32,\n    bloomIntensity: f32,\n    bloomThreshold: f32,\n    bloomRadius: f32,\n    quantizeBands: f32,\n    _pad: f32,\n}\n\n@group(0) @binding(0) var inputTexture: texture_2d<f32>;\n@group(0) @binding(1) var inputSampler: sampler;\n@group(0) @binding(2) var<uniform> uniforms: Uniforms;\n@group(0) @binding(3) var maskTexture: texture_2d<f32>;\n\nconst FLAG_TONEMAP: u32 = 1u;\nconst FLAG_FXAA: u32 = 2u;\nconst FLAG_VIGNETTE: u32 = 4u;\nconst FLAG_BLOOM: u32 = 8u;\nconst FLAG_QUANTIZE: u32 = 16u;\n\n@vertex\nfn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var positions = array<vec2f, 3>(\n        vec2f(-1.0, -1.0),\n        vec2f(3.0, -1.0),\n        vec2f(-1.0, 3.0)\n    );\n\n    let pos = positions[vertexIndex];\n\n    var output: VertexOutput;\n    output.position = vec4f(pos, 0.0, 1.0);\n    output.uv = (pos + 1.0) * 0.5;\n    output.uv.y = 1.0 - output.uv.y;\n    return output;\n}\n\nfn aces(x: vec3f) -> vec3f {\n    let a = 2.51;\n    let b = 0.03;\n    let c = 2.43;\n    let d = 0.59;\n    let e = 0.14;\n    return saturate((x * (a * x + b)) / (x * (c * x + d) + e));\n}\n\nfn luma(color: vec3f) -> f32 {\n    return dot(color, vec3f(0.299, 0.587, 0.114));\n}\n\nconst FXAA_REDUCE_MIN: f32 = 1.0 / 128.0;\nconst FXAA_REDUCE_MUL: f32 = 1.0 / 8.0;\nconst FXAA_SPAN_MAX: f32 = 8.0;\n\nfn applyFXAA(uv: vec2f, colorM: vec3f) -> vec3f {\n    let texelSize = vec2f(uniforms.texelSizeX, uniforms.texelSizeY);\n\n    let colorNW = textureSample(inputTexture, inputSampler, uv + vec2f(-1.0, -1.0) * texelSize).rgb;\n    let colorNE = textureSample(inputTexture, inputSampler, uv + vec2f(1.0, -1.0) * texelSize).rgb;\n    let colorSW = textureSample(inputTexture, inputSampler, uv + vec2f(-1.0, 1.0) * texelSize).rgb;\n    let colorSE = textureSample(inputTexture, inputSampler, uv + vec2f(1.0, 1.0) * texelSize).rgb;\n\n    let lumaM = luma(colorM);\n    let lumaNW = luma(colorNW);\n    let lumaNE = luma(colorNE);\n    let lumaSW = luma(colorSW);\n    let lumaSE = luma(colorSE);\n\n    let lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    let lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    var dir: vec2f;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    let dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * 0.25 * FXAA_REDUCE_MUL, FXAA_REDUCE_MIN);\n    let rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = clamp(dir * rcpDirMin, vec2f(-FXAA_SPAN_MAX), vec2f(FXAA_SPAN_MAX)) * texelSize;\n\n    let colorA = 0.5 * (\n        textureSample(inputTexture, inputSampler, uv + dir * (1.0 / 3.0 - 0.5)).rgb +\n        textureSample(inputTexture, inputSampler, uv + dir * (2.0 / 3.0 - 0.5)).rgb\n    );\n\n    let colorB = colorA * 0.5 + 0.25 * (\n        textureSample(inputTexture, inputSampler, uv + dir * -0.5).rgb +\n        textureSample(inputTexture, inputSampler, uv + dir * 0.5).rgb\n    );\n\n    let lumaB = luma(colorB);\n\n    if lumaB < lumaMin || lumaB > lumaMax {\n        return colorA;\n    }\n    return colorB;\n}\n\nfn applyVignette(color: vec3f, uv: vec2f) -> vec3f {\n    let center = vec2f(0.5, 0.5);\n    let dist = distance(uv, center);\n    let vignette = 1.0 - smoothstep(uniforms.vignetteInner, uniforms.vignetteOuter, dist) * uniforms.vignetteStrength;\n    return color * vignette;\n}\n\nfn sampleBloom(uv: vec2f) -> vec3f {\n    let texelSize = vec2f(uniforms.texelSizeX, uniforms.texelSizeY);\n    // Normalize to reference height (1080p) for resolution-independent bloom\n    let height = 1.0 / uniforms.texelSizeY;\n    let resolutionScale = height / 1080.0;\n    let spread = uniforms.bloomRadius * 4.0 * resolutionScale;\n    let threshold = uniforms.bloomThreshold;\n    let knee = 0.15;\n\n    var bloom = vec3f(0.0);\n    var totalWeight = 0.0;\n\n    // 9x9 kernel with gaussian weights\n    for (var y = -4; y <= 4; y++) {\n        for (var x = -4; x <= 4; x++) {\n            let offset = vec2f(f32(x), f32(y)) * texelSize * spread;\n            let dist2 = f32(x * x + y * y);\n            let weight = exp(-dist2 * 0.125);\n\n            let sampleColor = textureSample(inputTexture, inputSampler, uv + offset).rgb;\n            let brightness = max(max(sampleColor.r, sampleColor.g), sampleColor.b);\n            let soft = clamp((brightness - threshold + knee) / (2.0 * knee), 0.0, 1.0);\n            let contribution = soft * soft;\n\n            bloom += sampleColor * contribution * weight;\n            totalWeight += weight;\n        }\n    }\n\n    return bloom / totalWeight;\n}\n\nfn applyQuantize(color: vec3f) -> vec3f {\n    let bands = uniforms.quantizeBands;\n    return floor(color * bands + 0.5) / bands;\n}\n\n@fragment\nfn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n    var color = textureSample(inputTexture, inputSampler, input.uv).rgb;\n    let maskValue = textureSample(maskTexture, inputSampler, input.uv).r;\n\n    if (uniforms.flags & FLAG_FXAA) != 0u {\n        let fxaaColor = applyFXAA(input.uv, color);\n        color = select(fxaaColor, color, maskValue >= 0.5);\n    }\n\n    // Bloom applied before tonemapping\n    if (uniforms.flags & FLAG_BLOOM) != 0u {\n        let bloom = sampleBloom(input.uv);\n        color += bloom * uniforms.bloomIntensity;\n    }\n\n    if (uniforms.flags & FLAG_QUANTIZE) != 0u {\n        color = applyQuantize(color);\n    }\n\n    if (uniforms.flags & FLAG_TONEMAP) != 0u {\n        color = aces(color * uniforms.exposure);\n    }\n\n    if (uniforms.flags & FLAG_VIGNETTE) != 0u {\n        color = applyVignette(color, input.uv);\n    }\n\n    return vec4f(color, 1.0);\n}\n`;\n\nconst blitShader = /* wgsl */ `\nstruct VertexOutput {\n    @builtin(position) position: vec4f,\n    @location(0) uv: vec2f,\n}\n\n@group(0) @binding(0) var inputTexture: texture_2d<f32>;\n@group(0) @binding(1) var inputSampler: sampler;\n\n@vertex\nfn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var positions = array<vec2f, 3>(\n        vec2f(-1.0, -1.0),\n        vec2f(3.0, -1.0),\n        vec2f(-1.0, 3.0)\n    );\n\n    let pos = positions[vertexIndex];\n\n    var output: VertexOutput;\n    output.position = vec4f(pos, 0.0, 1.0);\n    output.uv = (pos + 1.0) * 0.5;\n    output.uv.y = 1.0 - output.uv.y;\n    return output;\n}\n\n@fragment\nfn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n    return textureSample(inputTexture, inputSampler, input.uv);\n}\n`;\n\nconst FLAG_TONEMAP = 1;\nconst FLAG_FXAA = 2;\nconst FLAG_VIGNETTE = 4;\nconst FLAG_BLOOM = 8;\nconst FLAG_QUANTIZE = 16;\n\nexport interface PostProcessUniforms {\n    tonemap: boolean;\n    exposure: number;\n    fxaa: boolean;\n    vignetteStrength: number;\n    vignetteInner: number;\n    vignetteOuter: number;\n    bloomIntensity: number;\n    bloomThreshold: number;\n    bloomRadius: number;\n    quantize: number;\n}\n\nexport interface PostProcessConfig {\n    state: State;\n    uniforms: PostProcessUniforms;\n    getRenderSize?: () => { width: number; height: number };\n}\n\nexport function createPostProcessNode(config: PostProcessConfig): ComputeNode {\n    let pipeline: GPURenderPipeline | null = null;\n    let blitPipeline: GPURenderPipeline | null = null;\n    let uniformBuffer: GPUBuffer | null = null;\n    let linearSampler: GPUSampler | null = null;\n    let nearestSampler: GPUSampler | null = null;\n\n    return {\n        id: \"postprocess\",\n        inputs: [\n            { id: \"color\", access: \"read\" },\n            { id: \"mask\", access: \"read\" },\n            { id: \"pingA\", access: \"read\" },\n            { id: \"pingB\", access: \"read\" },\n        ],\n        outputs: [{ id: \"framebuffer\", access: \"write\" }],\n\n        async prepare(device: GPUDevice) {\n            const format: GPUTextureFormat = \"bgra8unorm\";\n\n            const [mainModule, blitModule] = await Promise.all([\n                device.createShaderModule({ code: shader }),\n                device.createShaderModule({ code: blitShader }),\n            ]);\n\n            [pipeline, blitPipeline] = await Promise.all([\n                device.createRenderPipelineAsync({\n                    layout: \"auto\",\n                    vertex: { module: mainModule, entryPoint: \"vertexMain\" },\n                    fragment: {\n                        module: mainModule,\n                        entryPoint: \"fragmentMain\",\n                        targets: [{ format }],\n                    },\n                    primitive: { topology: \"triangle-list\" },\n                }),\n                device.createRenderPipelineAsync({\n                    layout: \"auto\",\n                    vertex: { module: blitModule, entryPoint: \"vertexMain\" },\n                    fragment: {\n                        module: blitModule,\n                        entryPoint: \"fragmentMain\",\n                        targets: [{ format }],\n                    },\n                    primitive: { topology: \"triangle-list\" },\n                }),\n            ]);\n\n            uniformBuffer = device.createBuffer({\n                size: 48,\n                usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n            });\n\n            linearSampler = device.createSampler({\n                magFilter: \"linear\",\n                minFilter: \"linear\",\n            });\n\n            nearestSampler = device.createSampler({\n                magFilter: \"nearest\",\n                minFilter: \"nearest\",\n            });\n        },\n\n        execute(ctx: ExecutionContext) {\n            const { device, encoder, canvasView, format, context } = ctx;\n            const width = context.canvas.width;\n            const height = context.canvas.height;\n            const colorView = ctx.getTextureView(\"color\")!;\n            const maskView = ctx.getTextureView(\"mask\")!;\n            const depthView = ctx.getTextureView(\"depth\")!;\n            const eidView = ctx.getTextureView(\"eid\")!;\n            const pingAView = ctx.getTextureView(\"pingA\")!;\n            const pingBView = ctx.getTextureView(\"pingB\")!;\n\n            const renderSize = config.getRenderSize?.();\n            const isUpscaling =\n                renderSize && (renderSize.width !== width || renderSize.height !== height);\n            const sampler = isUpscaling ? nearestSampler! : linearSampler!;\n\n            let currentInput = colorView;\n            let currentOutput = pingAView;\n            let pingPong = false;\n\n            const beforePostProcess = getDrawsByPass(config.state, Pass.BeforePost);\n            for (const contributor of beforePostProcess) {\n                const passCtx: DrawContext = {\n                    device,\n                    encoder,\n                    format,\n                    width,\n                    height,\n                    sceneView: colorView,\n                    depthView,\n                    entityIdView: eidView,\n                    maskView,\n                    canvasView,\n                    inputView: currentInput,\n                    outputView: currentOutput,\n                };\n                contributor.execute(passCtx);\n\n                currentInput = currentOutput;\n                currentOutput = pingPong ? pingAView : pingBView;\n                pingPong = !pingPong;\n            }\n\n            const postProcessContributors = getDrawsByPass(config.state, Pass.Post);\n            const hasBuiltinEffects =\n                config.uniforms.tonemap ||\n                config.uniforms.fxaa ||\n                config.uniforms.vignetteStrength > 0 ||\n                config.uniforms.bloomIntensity > 0 ||\n                config.uniforms.quantize > 0;\n\n            if (hasBuiltinEffects || postProcessContributors.length > 0) {\n                for (const contributor of postProcessContributors) {\n                    const passCtx: DrawContext = {\n                        device,\n                        encoder,\n                        format,\n                        width,\n                        height,\n                        sceneView: colorView,\n                        depthView,\n                        entityIdView: eidView,\n                        maskView,\n                        canvasView,\n                        inputView: currentInput,\n                        outputView: currentOutput,\n                    };\n                    contributor.execute(passCtx);\n\n                    currentInput = currentOutput;\n                    currentOutput = pingPong ? pingAView : pingBView;\n                    pingPong = !pingPong;\n                }\n\n                if (hasBuiltinEffects) {\n                    let flags = 0;\n                    if (config.uniforms.tonemap) flags |= FLAG_TONEMAP;\n                    if (config.uniforms.fxaa) flags |= FLAG_FXAA;\n                    if (config.uniforms.vignetteStrength > 0) flags |= FLAG_VIGNETTE;\n                    if (config.uniforms.bloomIntensity > 0) flags |= FLAG_BLOOM;\n                    if (config.uniforms.quantize > 0) flags |= FLAG_QUANTIZE;\n\n                    const data = new ArrayBuffer(48);\n                    const floats = new Float32Array(data);\n                    const uints = new Uint32Array(data);\n                    floats[0] = config.uniforms.exposure;\n                    floats[1] = config.uniforms.vignetteStrength;\n                    floats[2] = config.uniforms.vignetteInner;\n                    floats[3] = config.uniforms.vignetteOuter;\n                    floats[4] = 1.0 / width;\n                    floats[5] = 1.0 / height;\n                    uints[6] = flags;\n                    floats[7] = config.uniforms.bloomIntensity;\n                    floats[8] = config.uniforms.bloomThreshold;\n                    floats[9] = config.uniforms.bloomRadius;\n                    floats[10] = config.uniforms.quantize;\n\n                    device.queue.writeBuffer(uniformBuffer!, 0, data);\n\n                    const bindGroup = device.createBindGroup({\n                        layout: pipeline!.getBindGroupLayout(0),\n                        entries: [\n                            { binding: 0, resource: currentInput },\n                            { binding: 1, resource: sampler },\n                            { binding: 2, resource: { buffer: uniformBuffer! } },\n                            { binding: 3, resource: maskView },\n                        ],\n                    });\n\n                    const pass = encoder.beginRenderPass({\n                        colorAttachments: [\n                            {\n                                view: canvasView,\n                                loadOp: \"clear\" as const,\n                                storeOp: \"store\" as const,\n                                clearValue: { r: 0, g: 0, b: 0, a: 1 },\n                            },\n                        ],\n                    });\n\n                    pass.setPipeline(pipeline!);\n                    pass.setBindGroup(0, bindGroup);\n                    pass.draw(3);\n                    pass.end();\n                } else {\n                    const bindGroup = device.createBindGroup({\n                        layout: blitPipeline!.getBindGroupLayout(0),\n                        entries: [\n                            { binding: 0, resource: currentInput },\n                            { binding: 1, resource: sampler },\n                        ],\n                    });\n\n                    const pass = encoder.beginRenderPass({\n                        colorAttachments: [\n                            {\n                                view: canvasView,\n                                loadOp: \"clear\" as const,\n                                storeOp: \"store\" as const,\n                                clearValue: { r: 0, g: 0, b: 0, a: 1 },\n                            },\n                        ],\n                    });\n\n                    pass.setPipeline(blitPipeline!);\n                    pass.setBindGroup(0, bindGroup);\n                    pass.draw(3);\n                    pass.end();\n                }\n            } else {\n                const bindGroup = device.createBindGroup({\n                    layout: blitPipeline!.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: currentInput },\n                        { binding: 1, resource: sampler },\n                    ],\n                });\n\n                const pass = encoder.beginRenderPass({\n                    colorAttachments: [\n                        {\n                            view: canvasView,\n                            loadOp: \"clear\" as const,\n                            storeOp: \"store\" as const,\n                            clearValue: { r: 0, g: 0, b: 0, a: 1 },\n                        },\n                    ],\n                });\n\n                pass.setPipeline(blitPipeline!);\n                pass.setBindGroup(0, bindGroup);\n                pass.draw(3);\n                pass.end();\n            }\n\n            const afterPostProcess = getDrawsByPass(config.state, Pass.AfterPost);\n            for (const contributor of afterPostProcess) {\n                const passCtx: DrawContext = {\n                    device,\n                    encoder,\n                    format,\n                    width,\n                    height,\n                    sceneView: colorView,\n                    depthView,\n                    entityIdView: eidView,\n                    maskView,\n                    canvasView,\n                };\n                contributor.execute(passCtx);\n            }\n        },\n    };\n}\n","import type { State } from \"../../core\";\nimport type { ComputeNode, ExecutionContext } from \"../compute\";\nimport { COLOR_FORMAT, MASK_FORMAT } from \"./scene\";\nimport { Pass, getDrawsByPass, type DrawContext, type SharedPassContext } from \"./pass\";\n\nexport { MASK_FORMAT };\n\nexport interface OverlayNodeConfig {\n    state: State;\n}\n\nexport function createOverlayNode(config: OverlayNodeConfig): ComputeNode {\n    return {\n        id: \"overlay\",\n        inputs: [{ id: \"depth\", access: \"read\" }],\n        outputs: [\n            { id: \"color\", access: \"write\" },\n            { id: \"mask\", access: \"write\" },\n        ],\n\n        execute(ctx: ExecutionContext) {\n            const { device, encoder, format, context } = ctx;\n            const targetView = ctx.getTextureView(\"color\") ?? ctx.canvasView;\n            const depthView = ctx.getTextureView(\"depth\")!;\n            const maskView = ctx.getTextureView(\"mask\")!;\n            const eidView = ctx.getTextureView(\"eid\")!;\n\n            const drawCtx: DrawContext = {\n                device,\n                encoder,\n                format,\n                width: context.canvas.width,\n                height: context.canvas.height,\n                sceneView: targetView,\n                depthView,\n                entityIdView: eidView,\n                maskView,\n                canvasView: ctx.canvasView,\n            };\n\n            const beforeOverlays = getDrawsByPass(config.state, Pass.BeforeOverlay);\n            for (const draw of beforeOverlays) {\n                draw.execute(drawCtx);\n            }\n\n            const draws = getDrawsByPass(config.state, Pass.Overlay);\n            if (draws.length > 0) {\n                const pass = encoder.beginRenderPass({\n                    colorAttachments: [\n                        {\n                            view: targetView,\n                            loadOp: \"load\" as const,\n                            storeOp: \"store\" as const,\n                        },\n                        {\n                            view: maskView,\n                            clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                            loadOp: \"clear\" as const,\n                            storeOp: \"store\" as const,\n                        },\n                    ],\n                    depthStencilAttachment: {\n                        view: depthView,\n                        depthLoadOp: \"load\" as const,\n                        depthStoreOp: \"store\" as const,\n                    },\n                });\n\n                const sharedCtx: SharedPassContext = {\n                    device,\n                    format: COLOR_FORMAT,\n                    maskFormat: MASK_FORMAT,\n                };\n\n                for (const draw of draws) {\n                    if (draw.draw) {\n                        draw.draw(pass, sharedCtx);\n                    }\n                }\n\n                pass.end();\n            }\n\n            const afterOverlays = getDrawsByPass(config.state, Pass.AfterOverlay);\n            for (const draw of afterOverlays) {\n                draw.execute(drawCtx);\n            }\n        },\n    };\n}\n","import type { Vec3, BVHNode, MortonPair, AABB } from \"./structs\";\nimport { LEAF_FLAG, isLeaf, leafIndex } from \"./structs\";\nimport type { MeshData } from \"../mesh\";\n\nexport interface BLASTriangle {\n    v0: Vec3;\n    e1: Vec3;\n    e2: Vec3;\n    n0: Vec3;\n    n1: Vec3;\n    n2: Vec3;\n}\n\nexport interface BLASData {\n    nodes: BVHNode[];\n    sortedTriIds: number[];\n    aabbMin: Vec3;\n    aabbMax: Vec3;\n    triCount: number;\n}\n\nexport interface BLASMeta {\n    nodeOffset: number;\n    triIdOffset: number;\n    nodeCount: number;\n    triCount: number;\n}\n\nexport interface BLASAtlas {\n    blasData: Map<number, BLASData>;\n    nodesBuffer: GPUBuffer;\n    triIdsBuffer: GPUBuffer;\n    metaBuffer: GPUBuffer;\n    trianglesBuffer: GPUBuffer;\n    triangles: Map<number, BLASTriangle[]>;\n    shapeAABBs: GPUBuffer;\n}\n\nfunction vec3(x: number, y: number, z: number): Vec3 {\n    return { x, y, z };\n}\n\nfunction vec3Min(a: Vec3, b: Vec3): Vec3 {\n    return { x: Math.min(a.x, b.x), y: Math.min(a.y, b.y), z: Math.min(a.z, b.z) };\n}\n\nfunction vec3Max(a: Vec3, b: Vec3): Vec3 {\n    return { x: Math.max(a.x, b.x), y: Math.max(a.y, b.y), z: Math.max(a.z, b.z) };\n}\n\nfunction vec3Add(a: Vec3, b: Vec3): Vec3 {\n    return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };\n}\n\nfunction vec3Sub(a: Vec3, b: Vec3): Vec3 {\n    return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };\n}\n\nfunction vec3Scale(v: Vec3, s: number): Vec3 {\n    return { x: v.x * s, y: v.y * s, z: v.z * s };\n}\n\nfunction octEncode(n: Vec3): number {\n    const absSum = Math.abs(n.x) + Math.abs(n.y) + Math.abs(n.z);\n    let vx = n.x / absSum;\n    let vy = n.y / absSum;\n    const vz = n.z / absSum;\n    if (vz < 0) {\n        const signX = vx >= 0 ? 1 : -1;\n        const signY = vy >= 0 ? 1 : -1;\n        const newVx = (1 - Math.abs(vy)) * signX;\n        const newVy = (1 - Math.abs(vx)) * signY;\n        vx = newVx;\n        vy = newVy;\n    }\n    const x = Math.floor(Math.max(0, Math.min(65535, (vx * 0.5 + 0.5) * 65535)));\n    const y = Math.floor(Math.max(0, Math.min(65535, (vy * 0.5 + 0.5) * 65535)));\n    return ((y << 16) | x) >>> 0;\n}\n\nexport function extractShapeTriangles(mesh: MeshData): BLASTriangle[] {\n    const triangles: BLASTriangle[] = [];\n    const { vertices, indices, indexCount } = mesh;\n    const stride = 6;\n\n    for (let i = 0; i < indexCount; i += 3) {\n        const i0 = indices[i];\n        const i1 = indices[i + 1];\n        const i2 = indices[i + 2];\n\n        const v0 = vec3(\n            vertices[i0 * stride],\n            vertices[i0 * stride + 1],\n            vertices[i0 * stride + 2]\n        );\n        const v1 = vec3(\n            vertices[i1 * stride],\n            vertices[i1 * stride + 1],\n            vertices[i1 * stride + 2]\n        );\n        const v2 = vec3(\n            vertices[i2 * stride],\n            vertices[i2 * stride + 1],\n            vertices[i2 * stride + 2]\n        );\n\n        const n0 = vec3(\n            vertices[i0 * stride + 3],\n            vertices[i0 * stride + 4],\n            vertices[i0 * stride + 5]\n        );\n        const n1 = vec3(\n            vertices[i1 * stride + 3],\n            vertices[i1 * stride + 4],\n            vertices[i1 * stride + 5]\n        );\n        const n2 = vec3(\n            vertices[i2 * stride + 3],\n            vertices[i2 * stride + 4],\n            vertices[i2 * stride + 5]\n        );\n\n        triangles.push({\n            v0,\n            e1: vec3Sub(v1, v0),\n            e2: vec3Sub(v2, v0),\n            n0,\n            n1,\n            n2,\n        });\n    }\n\n    return triangles;\n}\n\nfunction computeBounds(triangles: BLASTriangle[]): AABB {\n    if (triangles.length === 0) {\n        return { min: vec3(0, 0, 0), max: vec3(0, 0, 0) };\n    }\n\n    let min = vec3(Infinity, Infinity, Infinity);\n    let max = vec3(-Infinity, -Infinity, -Infinity);\n\n    for (const tri of triangles) {\n        const v0 = tri.v0;\n        const v1 = vec3Add(v0, tri.e1);\n        const v2 = vec3Add(v0, tri.e2);\n        min = vec3Min(min, v0);\n        min = vec3Min(min, v1);\n        min = vec3Min(min, v2);\n        max = vec3Max(max, v0);\n        max = vec3Max(max, v1);\n        max = vec3Max(max, v2);\n    }\n\n    return { min, max };\n}\n\nfunction expandBits(v: number): number {\n    let x = v & 0x3ff;\n    x = (x | (x << 16)) & 0x030000ff;\n    x = (x | (x << 8)) & 0x0300f00f;\n    x = (x | (x << 4)) & 0x030c30c3;\n    x = (x | (x << 2)) & 0x09249249;\n    return x >>> 0;\n}\n\nfunction mortonCode3D(x: number, y: number, z: number): number {\n    return ((expandBits(x) << 2) | (expandBits(y) << 1) | expandBits(z)) >>> 0;\n}\n\nfunction computeMortonCode(centroid: Vec3, bounds: AABB): number {\n    const size = {\n        x: bounds.max.x - bounds.min.x,\n        y: bounds.max.y - bounds.min.y,\n        z: bounds.max.z - bounds.min.z,\n    };\n\n    const safeSize = {\n        x: Math.max(size.x, 1e-6),\n        y: Math.max(size.y, 1e-6),\n        z: Math.max(size.z, 1e-6),\n    };\n\n    const normalized = {\n        x: (centroid.x - bounds.min.x) / safeSize.x,\n        y: (centroid.y - bounds.min.y) / safeSize.y,\n        z: (centroid.z - bounds.min.z) / safeSize.z,\n    };\n\n    const clamped = {\n        x: Math.max(0, Math.min(1, normalized.x)),\n        y: Math.max(0, Math.min(1, normalized.y)),\n        z: Math.max(0, Math.min(1, normalized.z)),\n    };\n\n    const quantized = {\n        x: Math.floor(clamped.x * 1023),\n        y: Math.floor(clamped.y * 1023),\n        z: Math.floor(clamped.z * 1023),\n    };\n\n    return mortonCode3D(quantized.x, quantized.y, quantized.z);\n}\n\nfunction buildMortonPairs(triangles: BLASTriangle[], bounds: AABB): MortonPair[] {\n    return triangles.map((tri, i) => {\n        const centroid = vec3Add(tri.v0, vec3Scale(vec3Add(tri.e1, tri.e2), 1 / 3));\n        return {\n            code: computeMortonCode(centroid, bounds),\n            triangleId: i,\n        };\n    });\n}\n\nfunction radixSort(pairs: MortonPair[]): MortonPair[] {\n    const n = pairs.length;\n    if (n === 0) return [];\n\n    let input = [...pairs];\n    let output = new Array<MortonPair>(n);\n\n    for (let pass = 0; pass < 4; pass++) {\n        const bitOffset = pass * 8;\n        const histogram = new Array<number>(256).fill(0);\n\n        for (const pair of input) {\n            const digit = (pair.code >>> bitOffset) & 0xff;\n            histogram[digit]++;\n        }\n\n        let sum = 0;\n        for (let i = 0; i < 256; i++) {\n            const count = histogram[i];\n            histogram[i] = sum;\n            sum += count;\n        }\n\n        for (const pair of input) {\n            const digit = (pair.code >>> bitOffset) & 0xff;\n            output[histogram[digit]] = pair;\n            histogram[digit]++;\n        }\n\n        [input, output] = [output, input];\n    }\n\n    return input;\n}\n\nfunction clz32(x: number): number {\n    if (x === 0) return 32;\n    return Math.clz32(x >>> 0);\n}\n\nfunction delta(sortedPairs: MortonPair[], i: number, j: number): number {\n    const n = sortedPairs.length;\n    if (j < 0 || j >= n) {\n        return -1;\n    }\n    const codeI = sortedPairs[i].code >>> 0;\n    const codeJ = sortedPairs[j].code >>> 0;\n    if (codeI === codeJ) {\n        return clz32((i ^ j) >>> 0) + 32;\n    }\n    return clz32((codeI ^ codeJ) >>> 0);\n}\n\nfunction determineRange(sortedPairs: MortonPair[], i: number): [number, number] {\n    const n = sortedPairs.length;\n\n    if (i === 0) {\n        return [0, n - 1];\n    }\n\n    const deltaLeft = delta(sortedPairs, i, i - 1);\n    const deltaRight = delta(sortedPairs, i, i + 1);\n    const d = deltaRight > deltaLeft ? 1 : -1;\n\n    const deltaMin = Math.min(deltaLeft, deltaRight);\n\n    let lmax = 2;\n    while (delta(sortedPairs, i, i + lmax * d) > deltaMin) {\n        lmax *= 2;\n    }\n\n    let l = 0;\n    let t = Math.floor(lmax / 2);\n    while (t >= 1) {\n        if (delta(sortedPairs, i, i + (l + t) * d) > deltaMin) {\n            l += t;\n        }\n        t = Math.floor(t / 2);\n    }\n\n    const j = i + l * d;\n    const first = Math.min(i, j);\n    const last = Math.max(i, j);\n\n    return [first, last];\n}\n\nfunction findSplit(sortedPairs: MortonPair[], first: number, last: number): number {\n    const firstCode = sortedPairs[first].code >>> 0;\n    const lastCode = sortedPairs[last].code >>> 0;\n\n    if (firstCode === lastCode) {\n        return Math.floor((first + last) / 2);\n    }\n\n    const deltaNode = clz32((firstCode ^ lastCode) >>> 0);\n\n    let split = first;\n    let stride = last - first;\n\n    do {\n        stride = Math.floor((stride + 1) / 2);\n        const middle = split + stride;\n\n        if (middle < last) {\n            const splitCode = sortedPairs[middle].code >>> 0;\n            const splitDelta = clz32((firstCode ^ splitCode) >>> 0);\n\n            if (splitDelta > deltaNode) {\n                split = middle;\n            }\n        }\n    } while (stride > 1);\n\n    return split;\n}\n\nfunction buildKarrasTree(sortedPairs: MortonPair[]): {\n    nodes: BVHNode[];\n    parents: number[];\n} {\n    const n = sortedPairs.length;\n\n    if (n === 0) {\n        return { nodes: [], parents: [] };\n    }\n\n    if (n === 1) {\n        return { nodes: [], parents: [-1] };\n    }\n\n    const numInternal = n - 1;\n    const nodes: BVHNode[] = new Array(numInternal);\n    const parents: number[] = new Array(2 * n).fill(-1);\n\n    for (let i = 0; i < numInternal; i++) {\n        const [first, last] = determineRange(sortedPairs, i);\n        const gamma = findSplit(sortedPairs, first, last);\n\n        const leftIsLeaf = Math.min(first, last) === gamma;\n        const rightIsLeaf = Math.max(first, last) === gamma + 1;\n\n        let leftChild: number;\n        let rightChild: number;\n\n        if (leftIsLeaf) {\n            leftChild = (gamma | LEAF_FLAG) >>> 0;\n            parents[gamma] = i;\n        } else {\n            leftChild = gamma;\n            parents[n + gamma] = i;\n        }\n\n        if (rightIsLeaf) {\n            rightChild = ((gamma + 1) | LEAF_FLAG) >>> 0;\n            parents[gamma + 1] = i;\n        } else {\n            rightChild = gamma + 1;\n            parents[n + (gamma + 1)] = i;\n        }\n\n        nodes[i] = {\n            min: vec3(1e30, 1e30, 1e30),\n            max: vec3(-1e30, -1e30, -1e30),\n            leftChild,\n            rightChild,\n        };\n    }\n\n    return { nodes, parents };\n}\n\nfunction getTriangleBounds(tri: BLASTriangle): AABB {\n    const v0 = tri.v0;\n    const v1 = vec3Add(v0, tri.e1);\n    const v2 = vec3Add(v0, tri.e2);\n    const min = vec3Min(vec3Min(v0, v1), v2);\n    const max = vec3Max(vec3Max(v0, v1), v2);\n    return { min, max };\n}\n\nfunction propagateBounds(\n    nodes: BVHNode[],\n    triangles: BLASTriangle[],\n    pairs: MortonPair[],\n    parents: number[]\n): void {\n    const n = triangles.length;\n    if (n <= 1) return;\n\n    const boundsFlags = new Array(n - 1).fill(0);\n\n    for (let leafIdx = 0; leafIdx < n; leafIdx++) {\n        const tri = triangles[pairs[leafIdx].triangleId];\n\n        let current = leafIdx;\n        let isLeafNode = true;\n\n        for (let iter = 0; iter < 64; iter++) {\n            const parent = isLeafNode ? parents[current] : parents[n + current];\n\n            if (parent === -1 || parent === undefined) {\n                break;\n            }\n\n            const oldFlag = boundsFlags[parent];\n            boundsFlags[parent]++;\n\n            if (oldFlag === 0) {\n                break;\n            }\n\n            const node = nodes[parent];\n            const left = node.leftChild;\n            const right = node.rightChild;\n\n            let leftBounds: AABB;\n            let rightBounds: AABB;\n\n            if (isLeaf(left)) {\n                const leftTri = triangles[pairs[leafIndex(left)].triangleId];\n                leftBounds = getTriangleBounds(leftTri);\n            } else {\n                leftBounds = { min: nodes[left].min, max: nodes[left].max };\n            }\n\n            if (isLeaf(right)) {\n                const rightTri = triangles[pairs[leafIndex(right)].triangleId];\n                rightBounds = getTriangleBounds(rightTri);\n            } else {\n                rightBounds = { min: nodes[right].min, max: nodes[right].max };\n            }\n\n            nodes[parent].min = vec3Min(leftBounds.min, rightBounds.min);\n            nodes[parent].max = vec3Max(leftBounds.max, rightBounds.max);\n\n            current = parent;\n            isLeafNode = false;\n\n            if (parent === 0) {\n                break;\n            }\n        }\n    }\n}\n\nexport function buildShapeBLAS(triangles: BLASTriangle[]): BLASData {\n    const triCount = triangles.length;\n\n    if (triCount === 0) {\n        return {\n            nodes: [],\n            sortedTriIds: [],\n            aabbMin: vec3(0, 0, 0),\n            aabbMax: vec3(0, 0, 0),\n            triCount: 0,\n        };\n    }\n\n    const bounds = computeBounds(triangles);\n\n    if (triCount === 1) {\n        return {\n            nodes: [],\n            sortedTriIds: [0],\n            aabbMin: bounds.min,\n            aabbMax: bounds.max,\n            triCount: 1,\n        };\n    }\n\n    const pairs = buildMortonPairs(triangles, bounds);\n    const sortedPairs = radixSort(pairs);\n    const { nodes, parents } = buildKarrasTree(sortedPairs);\n\n    propagateBounds(nodes, triangles, sortedPairs, parents);\n\n    const sortedTriIds = sortedPairs.map((p) => p.triangleId);\n\n    const rootBounds = nodes.length > 0 ? { min: nodes[0].min, max: nodes[0].max } : bounds;\n\n    return {\n        nodes,\n        sortedTriIds,\n        aabbMin: rootBounds.min,\n        aabbMax: rootBounds.max,\n        triCount,\n    };\n}\n\nexport function validateBLASBounds(blas: BLASData, triangles: BLASTriangle[]): boolean {\n    if (blas.triCount === 0) return true;\n\n    const epsilon = 1e-5;\n\n    for (const tri of triangles) {\n        const v0 = tri.v0;\n        const v1 = vec3Add(v0, tri.e1);\n        const v2 = vec3Add(v0, tri.e2);\n\n        for (const v of [v0, v1, v2]) {\n            if (\n                v.x < blas.aabbMin.x - epsilon ||\n                v.y < blas.aabbMin.y - epsilon ||\n                v.z < blas.aabbMin.z - epsilon ||\n                v.x > blas.aabbMax.x + epsilon ||\n                v.y > blas.aabbMax.y + epsilon ||\n                v.z > blas.aabbMax.z + epsilon\n            ) {\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\nexport function validateBLASNodes(blas: BLASData): { valid: boolean; errors: string[] } {\n    const errors: string[] = [];\n\n    if (blas.triCount <= 1) {\n        return { valid: true, errors: [] };\n    }\n\n    const expectedNodes = blas.triCount - 1;\n    if (blas.nodes.length !== expectedNodes) {\n        errors.push(`Expected ${expectedNodes} nodes, got ${blas.nodes.length}`);\n    }\n\n    for (let i = 0; i < blas.nodes.length; i++) {\n        const node = blas.nodes[i];\n\n        if (node.min.x > node.max.x || node.min.y > node.max.y || node.min.z > node.max.z) {\n            errors.push(`Node ${i} has invalid bounds: min > max`);\n        }\n\n        const left = node.leftChild;\n        const right = node.rightChild;\n\n        if (isLeaf(left)) {\n            const idx = leafIndex(left);\n            if (idx >= blas.triCount) {\n                errors.push(`Node ${i} left child leaf index ${idx} >= triCount ${blas.triCount}`);\n            }\n        } else {\n            if (left >= blas.nodes.length) {\n                errors.push(`Node ${i} left child ${left} >= node count ${blas.nodes.length}`);\n            }\n        }\n\n        if (isLeaf(right)) {\n            const idx = leafIndex(right);\n            if (idx >= blas.triCount) {\n                errors.push(`Node ${i} right child leaf index ${idx} >= triCount ${blas.triCount}`);\n            }\n        } else {\n            if (right >= blas.nodes.length) {\n                errors.push(`Node ${i} right child ${right} >= node count ${blas.nodes.length}`);\n            }\n        }\n    }\n\n    return { valid: errors.length === 0, errors };\n}\n\nconst MAX_SHAPES = 16;\nconst TREE_NODE_SIZE = 32;\nconst BLAS_TRIANGLE_SIZE = 64;\n\nexport interface BLASMetaExtended {\n    nodeOffset: number;\n    triIdOffset: number;\n    triOffset: number;\n    triCount: number;\n}\n\nexport function createBLASAtlas(\n    device: GPUDevice,\n    getMesh: (id: number) => MeshData | undefined\n): BLASAtlas {\n    const blasData = new Map<number, BLASData>();\n    const trianglesMap = new Map<number, BLASTriangle[]>();\n    const metas: BLASMetaExtended[] = [];\n\n    let totalNodes = 0;\n    let totalTriIds = 0;\n    let totalTris = 0;\n\n    for (let shapeId = 0; shapeId < MAX_SHAPES; shapeId++) {\n        const mesh = getMesh(shapeId);\n        if (!mesh || mesh.indexCount === 0) {\n            metas.push({ nodeOffset: 0, triIdOffset: 0, triOffset: 0, triCount: 0 });\n            continue;\n        }\n\n        const triangles = extractShapeTriangles(mesh);\n        const blas = buildShapeBLAS(triangles);\n        blasData.set(shapeId, blas);\n        trianglesMap.set(shapeId, triangles);\n\n        metas.push({\n            nodeOffset: totalNodes,\n            triIdOffset: totalTriIds,\n            triOffset: totalTris,\n            triCount: blas.triCount,\n        });\n\n        totalNodes += blas.nodes.length;\n        totalTriIds += blas.sortedTriIds.length;\n        totalTris += triangles.length;\n    }\n\n    const nodesData = new Float32Array(Math.max(totalNodes * 8, 8));\n    const triIdsData = new Uint32Array(Math.max(totalTriIds, 1));\n    const metaData = new Uint32Array(MAX_SHAPES * 4);\n    const trianglesData = new Uint32Array(Math.max(totalTris * 16, 16));\n\n    let nodeOffset = 0;\n    let triIdOffset = 0;\n    let triOffset = 0;\n\n    for (let shapeId = 0; shapeId < MAX_SHAPES; shapeId++) {\n        const blas = blasData.get(shapeId);\n        const triangles = trianglesMap.get(shapeId);\n        if (!blas || !triangles) continue;\n\n        for (const node of blas.nodes) {\n            nodesData[nodeOffset * 8 + 0] = node.min.x;\n            nodesData[nodeOffset * 8 + 1] = node.min.y;\n            nodesData[nodeOffset * 8 + 2] = node.min.z;\n            nodesData[nodeOffset * 8 + 3] = new Float32Array(\n                new Uint32Array([node.leftChild]).buffer\n            )[0];\n            nodesData[nodeOffset * 8 + 4] = node.max.x;\n            nodesData[nodeOffset * 8 + 5] = node.max.y;\n            nodesData[nodeOffset * 8 + 6] = node.max.z;\n            nodesData[nodeOffset * 8 + 7] = new Float32Array(\n                new Uint32Array([node.rightChild]).buffer\n            )[0];\n            nodeOffset++;\n        }\n\n        for (const triId of blas.sortedTriIds) {\n            triIdsData[triIdOffset++] = triId;\n        }\n\n        for (const tri of triangles) {\n            const base = triOffset * 16;\n            const floatView = new Float32Array(trianglesData.buffer, base * 4, 16);\n            floatView[0] = tri.v0.x;\n            floatView[1] = tri.v0.y;\n            floatView[2] = tri.v0.z;\n            trianglesData[base + 3] = 0;\n            floatView[4] = tri.e1.x;\n            floatView[5] = tri.e1.y;\n            floatView[6] = tri.e1.z;\n            trianglesData[base + 7] = 0;\n            floatView[8] = tri.e2.x;\n            floatView[9] = tri.e2.y;\n            floatView[10] = tri.e2.z;\n            trianglesData[base + 11] = 0;\n            trianglesData[base + 12] = octEncode(tri.n0);\n            trianglesData[base + 13] = octEncode(tri.n1);\n            trianglesData[base + 14] = octEncode(tri.n2);\n            trianglesData[base + 15] = 0;\n            triOffset++;\n        }\n    }\n\n    for (let i = 0; i < metas.length; i++) {\n        metaData[i * 4 + 0] = metas[i].nodeOffset;\n        metaData[i * 4 + 1] = metas[i].triIdOffset;\n        metaData[i * 4 + 2] = metas[i].triOffset;\n        metaData[i * 4 + 3] = metas[i].triCount;\n    }\n\n    const nodesBuffer = device.createBuffer({\n        label: \"blas-nodes\",\n        size: Math.max(nodesData.byteLength, 32),\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(nodesBuffer, 0, nodesData);\n\n    const triIdsBuffer = device.createBuffer({\n        label: \"blas-triIds\",\n        size: Math.max(triIdsData.byteLength, 4),\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(triIdsBuffer, 0, triIdsData);\n\n    const metaBuffer = device.createBuffer({\n        label: \"blas-meta\",\n        size: metaData.byteLength,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(metaBuffer, 0, metaData);\n\n    const trianglesBuffer = device.createBuffer({\n        label: \"blas-triangles\",\n        size: Math.max(totalTris * BLAS_TRIANGLE_SIZE, BLAS_TRIANGLE_SIZE),\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(trianglesBuffer, 0, trianglesData);\n\n    const shapeAABBsData = new Float32Array(MAX_SHAPES * 8);\n    for (let shapeId = 0; shapeId < MAX_SHAPES; shapeId++) {\n        const blas = blasData.get(shapeId);\n        const offset = shapeId * 8;\n        if (blas) {\n            shapeAABBsData[offset + 0] = blas.aabbMin.x;\n            shapeAABBsData[offset + 1] = blas.aabbMin.y;\n            shapeAABBsData[offset + 2] = blas.aabbMin.z;\n            shapeAABBsData[offset + 3] = 0;\n            shapeAABBsData[offset + 4] = blas.aabbMax.x;\n            shapeAABBsData[offset + 5] = blas.aabbMax.y;\n            shapeAABBsData[offset + 6] = blas.aabbMax.z;\n            shapeAABBsData[offset + 7] = 0;\n        }\n    }\n\n    const shapeAABBs = device.createBuffer({\n        label: \"shape-aabbs\",\n        size: shapeAABBsData.byteLength,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(shapeAABBs, 0, shapeAABBsData);\n\n    return {\n        blasData,\n        nodesBuffer,\n        triIdsBuffer,\n        metaBuffer,\n        trianglesBuffer,\n        triangles: trianglesMap,\n        shapeAABBs,\n    };\n}\n","import type { ComputeNode, ExecutionContext } from \"../../compute\";\n\nconst WG_X = 16;\nconst WG_Y = 16;\nconst WG_SIZE = WG_X * WG_Y;\nconst ITEMS_PER_WG = 2 * WG_SIZE;\n\nconst blockSumShader = /* wgsl */ `\n@group(0) @binding(0) var<storage, read> input: array<u32>;\n@group(0) @binding(1) var<storage, read_write> localSums: array<u32>;\n@group(0) @binding(2) var<storage, read_write> blockSums: array<u32>;\n\noverride WG_COUNT: u32;\noverride BIT: u32;\noverride COUNT: u32;\n\nvar<workgroup> wgData: array<u32, 2 * (${WG_SIZE} + 1)>;\n\n@compute @workgroup_size(${WG_X}, ${WG_Y}, 1)\nfn main(\n    @builtin(workgroup_id) wid: vec3<u32>,\n    @builtin(num_workgroups) wdim: vec3<u32>,\n    @builtin(local_invocation_index) tid: u32,\n) {\n    let workgroup = wid.x + wid.y * wdim.x;\n    let base = workgroup * ${WG_SIZE}u;\n    let gid = base + tid;\n\n    let val = select(input[gid], 0u, gid >= COUNT);\n    let bits = (val >> BIT) & 0x3;\n\n    var sums = array<u32, 4>(0, 0, 0, 0);\n    var lastThread = 0xffffffffu;\n\n    if (workgroup < WG_COUNT) {\n        lastThread = min(${WG_SIZE}u, COUNT - base) - 1;\n    }\n\n    let stride = ${WG_SIZE}u + 1;\n    var swap = 0u;\n    var inOff = tid;\n    var outOff = tid + stride;\n\n    for (var b = 0u; b < 4; b++) {\n        let mask = select(0u, 1u, bits == b);\n        wgData[inOff + 1] = mask;\n        workgroupBarrier();\n\n        var sum = 0u;\n        for (var off = 1u; off < ${WG_SIZE}u; off *= 2) {\n            if (tid >= off) {\n                sum = wgData[inOff] + wgData[inOff - off];\n            } else {\n                sum = wgData[inOff];\n            }\n            wgData[outOff] = sum;\n            outOff = inOff;\n            swap = stride - swap;\n            inOff = tid + swap;\n            workgroupBarrier();\n        }\n\n        sums[b] = sum;\n\n        if (tid == lastThread) {\n            blockSums[b * WG_COUNT + workgroup] = sum + mask;\n        }\n\n        outOff = inOff;\n        swap = stride - swap;\n        inOff = tid + swap;\n    }\n\n    if (gid < COUNT) {\n        localSums[gid] = sums[bits];\n    }\n}\n`;\n\nconst reorderShader = /* wgsl */ `\n@group(0) @binding(0) var<storage, read> inKeys: array<u32>;\n@group(0) @binding(1) var<storage, read_write> outKeys: array<u32>;\n@group(0) @binding(2) var<storage, read> localSums: array<u32>;\n@group(0) @binding(3) var<storage, read> blockSums: array<u32>;\n@group(0) @binding(4) var<storage, read> inVals: array<u32>;\n@group(0) @binding(5) var<storage, read_write> outVals: array<u32>;\n\noverride WG_COUNT: u32;\noverride BIT: u32;\noverride COUNT: u32;\n\n@compute @workgroup_size(${WG_X}, ${WG_Y}, 1)\nfn main(\n    @builtin(workgroup_id) wid: vec3<u32>,\n    @builtin(num_workgroups) wdim: vec3<u32>,\n    @builtin(local_invocation_index) tid: u32,\n) {\n    let workgroup = wid.x + wid.y * wdim.x;\n    let gid = workgroup * ${WG_SIZE}u + tid;\n\n    if (gid >= COUNT) { return; }\n\n    let k = inKeys[gid];\n    let v = inVals[gid];\n    let bits = (k >> BIT) & 0x3;\n    let dst = blockSums[bits * WG_COUNT + workgroup] + localSums[gid];\n\n    outKeys[dst] = k;\n    outVals[dst] = v;\n}\n`;\n\nconst prefixSumShader = /* wgsl */ `\n@group(0) @binding(0) var<storage, read_write> data: array<u32>;\n@group(0) @binding(1) var<storage, read_write> blockSums: array<u32>;\n\noverride COUNT: u32;\n\nvar<workgroup> temp: array<u32, ${ITEMS_PER_WG * 2}>;\n\n@compute @workgroup_size(${WG_X}, ${WG_Y}, 1)\nfn scan(\n    @builtin(workgroup_id) wid: vec3<u32>,\n    @builtin(num_workgroups) wdim: vec3<u32>,\n    @builtin(local_invocation_index) tid: u32,\n) {\n    let workgroup = wid.x + wid.y * wdim.x;\n    let base = workgroup * ${WG_SIZE}u;\n    let gid = base + tid;\n    let eid = gid * 2;\n\n    temp[tid * 2] = select(data[eid], 0u, eid >= COUNT);\n    temp[tid * 2 + 1] = select(data[eid + 1], 0u, eid + 1 >= COUNT);\n\n    var offset = 1u;\n    for (var d = ${ITEMS_PER_WG}u >> 1; d > 0; d >>= 1) {\n        workgroupBarrier();\n        if (tid < d) {\n            let ai = offset * (tid * 2 + 1) - 1;\n            let bi = offset * (tid * 2 + 2) - 1;\n            temp[bi] += temp[ai];\n        }\n        offset *= 2;\n    }\n\n    if (tid == 0) {\n        blockSums[workgroup] = temp[${ITEMS_PER_WG}u - 1];\n        temp[${ITEMS_PER_WG}u - 1] = 0;\n    }\n\n    for (var d = 1u; d < ${ITEMS_PER_WG}u; d *= 2) {\n        offset >>= 1;\n        workgroupBarrier();\n        if (tid < d) {\n            let ai = offset * (tid * 2 + 1) - 1;\n            let bi = offset * (tid * 2 + 2) - 1;\n            let t = temp[ai];\n            temp[ai] = temp[bi];\n            temp[bi] += t;\n        }\n    }\n    workgroupBarrier();\n\n    if (eid < COUNT) { data[eid] = temp[tid * 2]; }\n    if (eid + 1 < COUNT) { data[eid + 1] = temp[tid * 2 + 1]; }\n}\n\n@compute @workgroup_size(${WG_X}, ${WG_Y}, 1)\nfn addBlocks(\n    @builtin(workgroup_id) wid: vec3<u32>,\n    @builtin(num_workgroups) wdim: vec3<u32>,\n    @builtin(local_invocation_index) tid: u32,\n) {\n    let workgroup = wid.x + wid.y * wdim.x;\n    let eid = (workgroup * ${WG_SIZE}u + tid) * 2;\n\n    if (eid >= COUNT) { return; }\n\n    let sum = blockSums[workgroup];\n    data[eid] += sum;\n    if (eid + 1 < COUNT) { data[eid + 1] += sum; }\n}\n`;\n\nfunction dispatchSize(device: GPUDevice, count: number): [number, number] {\n    const max = device.limits.maxComputeWorkgroupsPerDimension;\n    if (count <= max) return [count, 1];\n    const x = Math.ceil(Math.sqrt(count));\n    return [x, Math.ceil(count / x)];\n}\n\ninterface PrefixPass {\n    pipeline: GPUComputePipeline;\n    bindGroup: GPUBindGroup;\n    dispatch: [number, number];\n}\n\nclass PrefixSum {\n    private constructor(private passes: PrefixPass[]) {}\n\n    static async create(device: GPUDevice, data: GPUBuffer, count: number): Promise<PrefixSum> {\n        const passes: PrefixPass[] = [];\n        const module = device.createShaderModule({ code: prefixSumShader });\n        await PrefixSum.build(device, module, data, count, passes);\n        return new PrefixSum(passes);\n    }\n\n    private static async build(\n        device: GPUDevice,\n        module: GPUShaderModule,\n        data: GPUBuffer,\n        count: number,\n        passes: PrefixPass[]\n    ): Promise<void> {\n        const wgCount = Math.ceil(count / ITEMS_PER_WG);\n        const dispatch = dispatchSize(device, wgCount);\n\n        const blockSums = device.createBuffer({\n            size: Math.max(wgCount * 4, 4),\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        });\n\n        const layout = device.createBindGroupLayout({\n            entries: [\n                { binding: 0, visibility: GPUShaderStage.COMPUTE, buffer: { type: \"storage\" } },\n                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: \"storage\" } },\n            ],\n        });\n\n        const bindGroup = device.createBindGroup({\n            layout,\n            entries: [\n                { binding: 0, resource: { buffer: data } },\n                { binding: 1, resource: { buffer: blockSums } },\n            ],\n        });\n\n        const pipelineLayout = device.createPipelineLayout({ bindGroupLayouts: [layout] });\n\n        passes.push({\n            pipeline: await device.createComputePipelineAsync({\n                layout: pipelineLayout,\n                compute: { module, entryPoint: \"scan\", constants: { COUNT: count } },\n            }),\n            bindGroup,\n            dispatch,\n        });\n\n        if (wgCount > 1) {\n            await PrefixSum.build(device, module, blockSums, wgCount, passes);\n\n            passes.push({\n                pipeline: await device.createComputePipelineAsync({\n                    layout: pipelineLayout,\n                    compute: { module, entryPoint: \"addBlocks\", constants: { COUNT: count } },\n                }),\n                bindGroup,\n                dispatch,\n            });\n        }\n    }\n\n    dispatch(pass: GPUComputePassEncoder): void {\n        for (const p of this.passes) {\n            pass.setPipeline(p.pipeline);\n            pass.setBindGroup(0, p.bindGroup);\n            pass.dispatchWorkgroups(p.dispatch[0], p.dispatch[1], 1);\n        }\n    }\n}\n\ninterface RadixPass {\n    blockSum: { pipeline: GPUComputePipeline; bindGroup: GPUBindGroup };\n    reorder: { pipeline: GPUComputePipeline; bindGroup: GPUBindGroup };\n}\n\nclass RadixSort {\n    private constructor(\n        private passes: RadixPass[],\n        private prefixSum: PrefixSum,\n        private workgroups: [number, number]\n    ) {}\n\n    static async create(\n        device: GPUDevice,\n        keys: GPUBuffer,\n        values: GPUBuffer,\n        count: number\n    ): Promise<RadixSort> {\n        const wgCount = Math.ceil(count / WG_SIZE);\n        const workgroups = dispatchSize(device, wgCount);\n\n        const tmpKeys = device.createBuffer({\n            size: count * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        });\n        const tmpVals = device.createBuffer({\n            size: count * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        });\n        const localSums = device.createBuffer({\n            size: count * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        });\n        const blockSums = device.createBuffer({\n            size: 4 * wgCount * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        });\n\n        const prefixSum = await PrefixSum.create(device, blockSums, 4 * wgCount);\n\n        const blockSumModule = device.createShaderModule({ code: blockSumShader });\n        const reorderModule = device.createShaderModule({ code: reorderShader });\n\n        const blockSumLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: { type: \"read-only-storage\" },\n                },\n                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: \"storage\" } },\n                { binding: 2, visibility: GPUShaderStage.COMPUTE, buffer: { type: \"storage\" } },\n            ],\n        });\n\n        const reorderLayout = device.createBindGroupLayout({\n            entries: [\n                {\n                    binding: 0,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: { type: \"read-only-storage\" },\n                },\n                { binding: 1, visibility: GPUShaderStage.COMPUTE, buffer: { type: \"storage\" } },\n                {\n                    binding: 2,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: { type: \"read-only-storage\" },\n                },\n                {\n                    binding: 3,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: { type: \"read-only-storage\" },\n                },\n                {\n                    binding: 4,\n                    visibility: GPUShaderStage.COMPUTE,\n                    buffer: { type: \"read-only-storage\" },\n                },\n                { binding: 5, visibility: GPUShaderStage.COMPUTE, buffer: { type: \"storage\" } },\n            ],\n        });\n\n        const pipelinePromises: Promise<{\n            blockSum: GPUComputePipeline;\n            reorder: GPUComputePipeline;\n        }>[] = [];\n\n        for (let bit = 0; bit < 32; bit += 2) {\n            pipelinePromises.push(\n                (async () => {\n                    const [blockSumPipeline, reorderPipeline] = await Promise.all([\n                        device.createComputePipelineAsync({\n                            layout: device.createPipelineLayout({\n                                bindGroupLayouts: [blockSumLayout],\n                            }),\n                            compute: {\n                                module: blockSumModule,\n                                entryPoint: \"main\",\n                                constants: { WG_COUNT: wgCount, BIT: bit, COUNT: count },\n                            },\n                        }),\n                        device.createComputePipelineAsync({\n                            layout: device.createPipelineLayout({\n                                bindGroupLayouts: [reorderLayout],\n                            }),\n                            compute: {\n                                module: reorderModule,\n                                entryPoint: \"main\",\n                                constants: { WG_COUNT: wgCount, BIT: bit, COUNT: count },\n                            },\n                        }),\n                    ]);\n                    return { blockSum: blockSumPipeline, reorder: reorderPipeline };\n                })()\n            );\n        }\n\n        const pipelines = await Promise.all(pipelinePromises);\n        const passes: RadixPass[] = [];\n\n        for (let i = 0; i < 16; i++) {\n            const bit = i * 2;\n            const even = bit % 4 === 0;\n            const inK = even ? keys : tmpKeys;\n            const inV = even ? values : tmpVals;\n            const outK = even ? tmpKeys : keys;\n            const outV = even ? tmpVals : values;\n\n            passes.push({\n                blockSum: {\n                    pipeline: pipelines[i].blockSum,\n                    bindGroup: device.createBindGroup({\n                        layout: blockSumLayout,\n                        entries: [\n                            { binding: 0, resource: { buffer: inK } },\n                            { binding: 1, resource: { buffer: localSums } },\n                            { binding: 2, resource: { buffer: blockSums } },\n                        ],\n                    }),\n                },\n                reorder: {\n                    pipeline: pipelines[i].reorder,\n                    bindGroup: device.createBindGroup({\n                        layout: reorderLayout,\n                        entries: [\n                            { binding: 0, resource: { buffer: inK } },\n                            { binding: 1, resource: { buffer: outK } },\n                            { binding: 2, resource: { buffer: localSums } },\n                            { binding: 3, resource: { buffer: blockSums } },\n                            { binding: 4, resource: { buffer: inV } },\n                            { binding: 5, resource: { buffer: outV } },\n                        ],\n                    }),\n                },\n            });\n        }\n\n        return new RadixSort(passes, prefixSum, workgroups);\n    }\n\n    dispatch(pass: GPUComputePassEncoder): void {\n        const [x, y] = this.workgroups;\n        for (const p of this.passes) {\n            pass.setPipeline(p.blockSum.pipeline);\n            pass.setBindGroup(0, p.blockSum.bindGroup);\n            pass.dispatchWorkgroups(x, y, 1);\n\n            this.prefixSum.dispatch(pass);\n\n            pass.setPipeline(p.reorder.pipeline);\n            pass.setBindGroup(0, p.reorder.bindGroup);\n            pass.dispatchWorkgroups(x, y, 1);\n        }\n    }\n}\n\nexport interface RadixSortConfig {\n    keys: GPUBuffer;\n    values: GPUBuffer;\n    count: number;\n}\n\nexport function createRadixSort(device: GPUDevice, config: RadixSortConfig): Promise<RadixSort> {\n    return RadixSort.create(device, config.keys, config.values, config.count);\n}\n\nexport function createRadixSortNode(config: RadixSortConfig): ComputeNode {\n    let sort: RadixSort | null = null;\n\n    return {\n        id: \"radix-sort\",\n        inputs: [],\n        outputs: [],\n\n        async prepare(device: GPUDevice) {\n            sort = await createRadixSort(device, config);\n        },\n\n        execute(ctx: ExecutionContext) {\n            const pass = ctx.encoder.beginComputePass();\n            sort!.dispatch(pass);\n            pass.end();\n        },\n    };\n}\n","import { MAX_ENTITIES } from \"../../../core\";\nimport type { ComputeNode, ExecutionContext } from \"../../compute\";\nimport { createRadixSort } from \"./radix\";\nimport {\n    TREE_NODE_STRUCT_WGSL,\n    BVH_NODE_STRUCT_WGSL,\n    LEAF_FLAG_WGSL,\n    TREE_NODE_SIZE,\n    BVH_NODE_SIZE,\n} from \"./structs\";\n\nconst WORKGROUP_SIZE = 256;\nconst MAX_TREE_DEPTH = Math.ceil(Math.log2(MAX_ENTITIES)) + 1;\n\nexport interface TLASBuffers {\n    treeNodes: GPUBuffer;\n    bvhNodes: GPUBuffer;\n    mortonCodes: GPUBuffer;\n    instanceIds: GPUBuffer;\n    entityIds: GPUBuffer;\n    sceneBounds: GPUBuffer;\n    parentIndices: GPUBuffer;\n    boundsFlags: GPUBuffer;\n}\n\nexport function createTLASBuffers(device: GPUDevice): TLASBuffers {\n    return {\n        treeNodes: device.createBuffer({\n            label: \"tlas-tree-nodes\",\n            size: 2 * MAX_ENTITIES * TREE_NODE_SIZE,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        }),\n        bvhNodes: device.createBuffer({\n            label: \"tlas-bvh-nodes\",\n            size: MAX_ENTITIES * BVH_NODE_SIZE,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,\n        }),\n        mortonCodes: device.createBuffer({\n            label: \"tlas-morton-codes\",\n            size: MAX_ENTITIES * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        }),\n        instanceIds: device.createBuffer({\n            label: \"tlas-instance-ids\",\n            size: MAX_ENTITIES * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        }),\n        entityIds: device.createBuffer({\n            label: \"tlas-entity-ids\",\n            size: MAX_ENTITIES * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        }),\n        sceneBounds: device.createBuffer({\n            label: \"tlas-scene-bounds\",\n            size: 32,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n        }),\n        parentIndices: device.createBuffer({\n            label: \"tlas-parent-indices\",\n            size: 2 * MAX_ENTITIES * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST,\n        }),\n        boundsFlags: device.createBuffer({\n            label: \"tlas-bounds-flags\",\n            size: MAX_ENTITIES * 4,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n        }),\n    };\n}\n\nconst INSTANCE_AABB_STRUCT_WGSL = /* wgsl */ `\nstruct InstanceAABB {\n    minX: f32,\n    minY: f32,\n    minZ: f32,\n    _pad0: u32,\n    maxX: f32,\n    maxY: f32,\n    maxZ: f32,\n    _pad1: u32,\n}`;\n\nconst SCENE_BOUNDS_STRUCT_WGSL = /* wgsl */ `\nstruct SceneBounds {\n    minX: atomic<i32>,\n    minY: atomic<i32>,\n    minZ: atomic<i32>,\n    _pad0: u32,\n    maxX: atomic<i32>,\n    maxY: atomic<i32>,\n    maxZ: atomic<i32>,\n    _pad1: u32,\n}`;\n\nconst SCENE_BOUNDS_READ_STRUCT_WGSL = /* wgsl */ `\nstruct SceneBounds {\n    minX: i32,\n    minY: i32,\n    minZ: i32,\n    _pad0: u32,\n    maxX: i32,\n    maxY: i32,\n    maxZ: i32,\n    _pad1: u32,\n}`;\n\nconst FLOAT_INT_CONVERSION_WGSL = /* wgsl */ `\nfn floatToSortableInt(f: f32) -> i32 {\n    let bits = bitcast<i32>(f);\n    let mask = (bits >> 31) & 0x7FFFFFFF;\n    return bits ^ mask;\n}\n\nfn sortableIntToFloat(i: i32) -> f32 {\n    let mask = (i >> 31) & 0x7FFFFFFF;\n    return bitcast<f32>(i ^ mask);\n}`;\n\nconst MORTON_CODE_WGSL = /* wgsl */ `\nfn expandBits(v: u32) -> u32 {\n    var x = v & 0x3ffu;\n    x = (x | (x << 16u)) & 0x030000ffu;\n    x = (x | (x << 8u)) & 0x0300f00fu;\n    x = (x | (x << 4u)) & 0x030c30c3u;\n    x = (x | (x << 2u)) & 0x09249249u;\n    return x;\n}\n\nfn mortonCode(x: u32, y: u32, z: u32) -> u32 {\n    return (expandBits(x) << 2u) | (expandBits(y) << 1u) | expandBits(z);\n}`;\n\nconst CLZ_WGSL = /* wgsl */ `\nfn clz(x: u32) -> u32 {\n    if (x == 0u) { return 32u; }\n    var n = 0u;\n    var v = x;\n    if ((v & 0xffff0000u) == 0u) { n += 16u; v <<= 16u; }\n    if ((v & 0xff000000u) == 0u) { n += 8u; v <<= 8u; }\n    if ((v & 0xf0000000u) == 0u) { n += 4u; v <<= 4u; }\n    if ((v & 0xc0000000u) == 0u) { n += 2u; v <<= 2u; }\n    if ((v & 0x80000000u) == 0u) { n += 1u; }\n    return n;\n}`;\n\nconst LEAF_FUNCTIONS_WGSL = /* wgsl */ `\nfn isLeaf(child: u32) -> bool {\n    return (child & LEAF_FLAG) != 0u;\n}\n\nfn leafIndex(child: u32) -> u32 {\n    return child & ~LEAF_FLAG;\n}`;\n\nconst boundsShader = /* wgsl */ `\n${INSTANCE_AABB_STRUCT_WGSL}\n${SCENE_BOUNDS_STRUCT_WGSL}\n\n@group(0) @binding(0) var<storage, read> instanceAABBs: array<InstanceAABB>;\n@group(0) @binding(1) var<storage, read> instanceCount: array<u32>;\n@group(0) @binding(2) var<storage, read_write> sceneBounds: SceneBounds;\n@group(0) @binding(3) var<storage, read> entityIds: array<u32>;\n\nvar<workgroup> sharedMin: array<vec3<f32>, ${WORKGROUP_SIZE}>;\nvar<workgroup> sharedMax: array<vec3<f32>, ${WORKGROUP_SIZE}>;\n\n${FLOAT_INT_CONVERSION_WGSL}\n\n@compute @workgroup_size(${WORKGROUP_SIZE})\nfn main(\n    @builtin(global_invocation_id) gid: vec3<u32>,\n    @builtin(local_invocation_id) lid: vec3<u32>,\n) {\n    let count = instanceCount[0];\n    let tid = gid.x;\n    let localId = lid.x;\n\n    var localMin = vec3<f32>(1e30, 1e30, 1e30);\n    var localMax = vec3<f32>(-1e30, -1e30, -1e30);\n\n    if (tid < count) {\n        let eid = entityIds[tid];\n        let aabb = instanceAABBs[eid];\n        localMin = vec3<f32>(aabb.minX, aabb.minY, aabb.minZ);\n        localMax = vec3<f32>(aabb.maxX, aabb.maxY, aabb.maxZ);\n    }\n\n    sharedMin[localId] = localMin;\n    sharedMax[localId] = localMax;\n    workgroupBarrier();\n\n    for (var stride = ${WORKGROUP_SIZE}u / 2u; stride > 0u; stride >>= 1u) {\n        if (localId < stride) {\n            sharedMin[localId] = min(sharedMin[localId], sharedMin[localId + stride]);\n            sharedMax[localId] = max(sharedMax[localId], sharedMax[localId + stride]);\n        }\n        workgroupBarrier();\n    }\n\n    if (localId == 0u) {\n        let wgMin = sharedMin[0];\n        let wgMax = sharedMax[0];\n\n        atomicMin(&sceneBounds.minX, floatToSortableInt(wgMin.x));\n        atomicMin(&sceneBounds.minY, floatToSortableInt(wgMin.y));\n        atomicMin(&sceneBounds.minZ, floatToSortableInt(wgMin.z));\n        atomicMax(&sceneBounds.maxX, floatToSortableInt(wgMax.x));\n        atomicMax(&sceneBounds.maxY, floatToSortableInt(wgMax.y));\n        atomicMax(&sceneBounds.maxZ, floatToSortableInt(wgMax.z));\n    }\n}\n`;\n\nconst mortonShader = /* wgsl */ `\n${INSTANCE_AABB_STRUCT_WGSL}\n${SCENE_BOUNDS_READ_STRUCT_WGSL}\n\n@group(0) @binding(0) var<storage, read> instanceAABBs: array<InstanceAABB>;\n@group(0) @binding(1) var<storage, read> instanceCount: array<u32>;\n@group(0) @binding(2) var<storage, read> sceneBounds: SceneBounds;\n@group(0) @binding(3) var<storage, read_write> mortonCodes: array<u32>;\n@group(0) @binding(4) var<storage, read_write> instanceIds: array<u32>;\n@group(0) @binding(5) var<storage, read> entityIds: array<u32>;\n\n${FLOAT_INT_CONVERSION_WGSL}\n${MORTON_CODE_WGSL}\n\n@compute @workgroup_size(${WORKGROUP_SIZE})\nfn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n    let tid = gid.x;\n    if (tid >= ${MAX_ENTITIES}u) { return; }\n\n    let count = instanceCount[0];\n    if (tid >= count) {\n        mortonCodes[tid] = 0xFFFFFFFFu;\n        instanceIds[tid] = 0u;\n        return;\n    }\n\n    let eid = entityIds[tid];\n    let aabb = instanceAABBs[eid];\n    let centroid = vec3<f32>(\n        (aabb.minX + aabb.maxX) * 0.5,\n        (aabb.minY + aabb.maxY) * 0.5,\n        (aabb.minZ + aabb.maxZ) * 0.5\n    );\n\n    let boundsMin = vec3<f32>(\n        sortableIntToFloat(sceneBounds.minX),\n        sortableIntToFloat(sceneBounds.minY),\n        sortableIntToFloat(sceneBounds.minZ)\n    );\n    let boundsMax = vec3<f32>(\n        sortableIntToFloat(sceneBounds.maxX),\n        sortableIntToFloat(sceneBounds.maxY),\n        sortableIntToFloat(sceneBounds.maxZ)\n    );\n\n    let size = boundsMax - boundsMin;\n    let safeSize = max(size, vec3<f32>(1e-6, 1e-6, 1e-6));\n\n    let normalized = (centroid - boundsMin) / safeSize;\n    let clamped = clamp(normalized, vec3<f32>(0.0), vec3<f32>(1.0));\n\n    let quantized = vec3<u32>(clamped * 1023.0);\n\n    mortonCodes[tid] = mortonCode(quantized.x, quantized.y, quantized.z);\n    instanceIds[tid] = eid;\n}\n`;\n\nconst treeShader = /* wgsl */ `\n${TREE_NODE_STRUCT_WGSL}\n${LEAF_FLAG_WGSL}\n\n@group(0) @binding(0) var<storage, read> mortonCodes: array<u32>;\n@group(0) @binding(1) var<storage, read> instanceCount: array<u32>;\n@group(0) @binding(2) var<storage, read_write> treeNodes: array<TreeNode>;\n@group(0) @binding(3) var<storage, read_write> parentIndices: array<u32>;\n\n${CLZ_WGSL}\n\nfn delta(i: i32, j: i32, n: i32) -> i32 {\n    if (j < 0 || j >= n) {\n        return -1;\n    }\n    let codeI = mortonCodes[i];\n    let codeJ = mortonCodes[j];\n    if (codeI == codeJ) {\n        return i32(clz(u32(i) ^ u32(j))) + 32;\n    }\n    return i32(clz(codeI ^ codeJ));\n}\n\n@compute @workgroup_size(${WORKGROUP_SIZE})\nfn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n    let n = i32(instanceCount[0]);\n    let i = i32(gid.x);\n\n    if (i >= n - 1) {\n        return;\n    }\n\n    var first: i32;\n    var last: i32;\n\n    if (i == 0) {\n        first = 0;\n        last = n - 1;\n    } else {\n        let d = select(-1, 1, delta(i, i + 1, n) > delta(i, i - 1, n));\n\n        let deltaMin = delta(i, i - d, n);\n\n        var lmax = 2;\n        for (var iter = 0; iter < ${MAX_TREE_DEPTH}; iter++) {\n            if (delta(i, i + lmax * d, n) <= deltaMin) { break; }\n            lmax *= 2;\n        }\n\n        var l = 0;\n        var t = lmax / 2;\n        for (var iter2 = 0; iter2 < ${MAX_TREE_DEPTH}; iter2++) {\n            if (t < 1) { break; }\n            if (delta(i, i + (l + t) * d, n) > deltaMin) {\n                l += t;\n            }\n            t /= 2;\n        }\n\n        let j = i + l * d;\n        first = min(i, j);\n        last = max(i, j);\n    }\n\n    let firstCode = mortonCodes[first];\n    let lastCode = mortonCodes[last];\n\n    var gamma: i32;\n    if (firstCode == lastCode) {\n        gamma = (first + last) / 2;\n    } else {\n        let deltaNode = i32(clz(firstCode ^ lastCode));\n\n        var split = first;\n        var stride = last - first;\n\n        for (var iter3 = 0; iter3 < ${MAX_TREE_DEPTH}; iter3++) {\n            stride = (stride + 1) / 2;\n            let middle = split + stride;\n\n            if (middle < last) {\n                let splitCode = mortonCodes[middle];\n                let splitDelta = i32(clz(firstCode ^ splitCode));\n\n                if (splitDelta > deltaNode) {\n                    split = middle;\n                }\n            }\n\n            if (stride <= 1) {\n                break;\n            }\n        }\n\n        gamma = split;\n    }\n\n    let leftIsLeaf = first == gamma;\n    let rightIsLeaf = last == gamma + 1;\n\n    var node: TreeNode;\n    node.minX = 1e30;\n    node.minY = 1e30;\n    node.minZ = 1e30;\n    node.maxX = -1e30;\n    node.maxY = -1e30;\n    node.maxZ = -1e30;\n\n    if (leftIsLeaf) {\n        node.leftChild = u32(gamma) | LEAF_FLAG;\n        parentIndices[u32(gamma)] = u32(i);\n    } else {\n        node.leftChild = u32(gamma);\n        parentIndices[u32(n) + u32(gamma)] = u32(i);\n    }\n\n    if (rightIsLeaf) {\n        node.rightChild = u32(gamma + 1) | LEAF_FLAG;\n        parentIndices[u32(gamma + 1)] = u32(i);\n    } else {\n        node.rightChild = u32(gamma + 1);\n        parentIndices[u32(n) + u32(gamma + 1)] = u32(i);\n    }\n\n    treeNodes[i] = node;\n}\n`;\n\nconst propagateShader = /* wgsl */ `\n${INSTANCE_AABB_STRUCT_WGSL}\n${LEAF_FLAG_WGSL}\n\nconst BOUNDS_SENTINEL: u32 = 0x7f800000u;\n\n@group(0) @binding(0) var<storage, read> instanceAABBs: array<InstanceAABB>;\n@group(0) @binding(1) var<storage, read> instanceIds: array<u32>;\n@group(0) @binding(2) var<storage, read> instanceCount: array<u32>;\n@group(0) @binding(3) var<storage, read_write> bvhNodesRaw: array<atomic<u32>>;\n@group(0) @binding(4) var<storage, read_write> boundsFlags: array<atomic<u32>>;\n@group(0) @binding(5) var<storage, read> parentIndices: array<u32>;\n\n${LEAF_FUNCTIONS_WGSL}\n\nfn getInstanceBounds(leafIdx: u32) -> array<vec3<f32>, 2> {\n    let eid = instanceIds[leafIdx];\n    let aabb = instanceAABBs[eid];\n    return array<vec3<f32>, 2>(\n        vec3<f32>(aabb.minX, aabb.minY, aabb.minZ),\n        vec3<f32>(aabb.maxX, aabb.maxY, aabb.maxZ)\n    );\n}\n\nfn getParent(nodeIdx: u32, isLeafNode: bool, n: u32) -> u32 {\n    if (isLeafNode) {\n        return parentIndices[nodeIdx];\n    } else {\n        return parentIndices[n + nodeIdx];\n    }\n}\n\nfn nodeBase(idx: u32) -> u32 {\n    return idx * 8u;\n}\n\nfn readChildBounds(childIdx: u32) -> array<vec3<f32>, 2> {\n    let base = nodeBase(childIdx);\n    let minX = bitcast<f32>(atomicLoad(&bvhNodesRaw[base + 0u]));\n    let minY = bitcast<f32>(atomicLoad(&bvhNodesRaw[base + 1u]));\n    let minZ = bitcast<f32>(atomicLoad(&bvhNodesRaw[base + 2u]));\n    let maxX = bitcast<f32>(atomicLoad(&bvhNodesRaw[base + 4u]));\n    let maxY = bitcast<f32>(atomicLoad(&bvhNodesRaw[base + 5u]));\n    let maxZ = bitcast<f32>(atomicLoad(&bvhNodesRaw[base + 6u]));\n    return array<vec3<f32>, 2>(vec3(minX, minY, minZ), vec3(maxX, maxY, maxZ));\n}\n\nfn writeBounds(nodeIdx: u32, minB: vec3<f32>, maxB: vec3<f32>) {\n    let base = nodeBase(nodeIdx);\n    atomicStore(&bvhNodesRaw[base + 0u], bitcast<u32>(minB.x));\n    atomicStore(&bvhNodesRaw[base + 1u], bitcast<u32>(minB.y));\n    atomicStore(&bvhNodesRaw[base + 2u], bitcast<u32>(minB.z));\n    atomicStore(&bvhNodesRaw[base + 4u], bitcast<u32>(maxB.x));\n    atomicStore(&bvhNodesRaw[base + 5u], bitcast<u32>(maxB.y));\n    atomicStore(&bvhNodesRaw[base + 6u], bitcast<u32>(maxB.z));\n}\n\nfn readLeftChild(nodeIdx: u32) -> u32 {\n    return atomicLoad(&bvhNodesRaw[nodeBase(nodeIdx) + 3u]);\n}\n\nfn readRightChild(nodeIdx: u32) -> u32 {\n    return atomicLoad(&bvhNodesRaw[nodeBase(nodeIdx) + 7u]);\n}\n\nfn writeLeafBounds(leafIdx: u32, n: u32, minB: vec3<f32>, maxB: vec3<f32>) {\n    let leafNodeIdx = n - 1u + leafIdx;\n    let base = leafNodeIdx * 8u;\n    atomicStore(&bvhNodesRaw[base + 0u], bitcast<u32>(minB.x));\n    atomicStore(&bvhNodesRaw[base + 1u], bitcast<u32>(minB.y));\n    atomicStore(&bvhNodesRaw[base + 2u], bitcast<u32>(minB.z));\n    atomicStore(&bvhNodesRaw[base + 4u], bitcast<u32>(maxB.x));\n    atomicStore(&bvhNodesRaw[base + 5u], bitcast<u32>(maxB.y));\n    atomicStore(&bvhNodesRaw[base + 6u], bitcast<u32>(maxB.z));\n}\n\n@compute @workgroup_size(${WORKGROUP_SIZE})\nfn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n    let n = instanceCount[0];\n    let leafIdx = gid.x;\n\n    if (leafIdx >= n) {\n        return;\n    }\n\n    let bounds = getInstanceBounds(leafIdx);\n    writeLeafBounds(leafIdx, n, bounds[0], bounds[1]);\n\n    var current = leafIdx;\n    var isLeafNode = true;\n\n    for (var iter = 0u; iter < 64u; iter++) {\n        let parent = getParent(current, isLeafNode, n);\n\n        let oldFlag = atomicAdd(&boundsFlags[parent], 1u);\n        if (oldFlag == 0u) {\n            return;\n        }\n\n        let left = readLeftChild(parent);\n        let right = readRightChild(parent);\n\n        var leftMin: vec3<f32>;\n        var leftMax: vec3<f32>;\n        var rightMin: vec3<f32>;\n        var rightMax: vec3<f32>;\n\n        if (isLeaf(left)) {\n            let leftBounds = getInstanceBounds(leafIndex(left));\n            leftMin = leftBounds[0];\n            leftMax = leftBounds[1];\n        } else {\n            let leftBounds = readChildBounds(left);\n            leftMin = leftBounds[0];\n            leftMax = leftBounds[1];\n        }\n\n        if (isLeaf(right)) {\n            let rightBounds = getInstanceBounds(leafIndex(right));\n            rightMin = rightBounds[0];\n            rightMax = rightBounds[1];\n        } else {\n            let rightBounds = readChildBounds(right);\n            rightMin = rightBounds[0];\n            rightMax = rightBounds[1];\n        }\n\n        let newMin = min(leftMin, rightMin);\n        let newMax = max(leftMax, rightMax);\n\n        writeBounds(parent, newMin, newMax);\n\n        current = parent;\n        isLeafNode = false;\n\n        if (parent == 0u) {\n            break;\n        }\n    }\n}\n`;\n\nconst collapseShader = /* wgsl */ `\n${TREE_NODE_STRUCT_WGSL}\n${BVH_NODE_STRUCT_WGSL}\n${LEAF_FLAG_WGSL}\n\nconst INVALID_NODE: u32 = 0xFFFFFFFFu;\n\n@group(0) @binding(0) var<storage, read> treeNodes: array<TreeNode>;\n@group(0) @binding(1) var<storage, read> instanceCount: array<u32>;\n@group(0) @binding(2) var<storage, read> parentIndices: array<u32>;\n@group(0) @binding(3) var<storage, read_write> bvhNodes: array<BVHNode>;\n\nfn isLeaf(child: u32) -> bool {\n    return (child & LEAF_FLAG) != 0u;\n}\n\nfn leafIndex(child: u32) -> u32 {\n    return child & ~LEAF_FLAG;\n}\n\nfn getDepth(nodeIdx: u32, n: u32) -> u32 {\n    var depth = 0u;\n    var current = nodeIdx;\n    for (var iter = 0u; iter < ${MAX_TREE_DEPTH}u; iter++) {\n        if (current == 0u) { break; }\n        current = parentIndices[n + current];\n        depth++;\n    }\n    return depth;\n}\n\nfn getChildBounds(child: u32, n: u32) -> array<vec3<f32>, 2> {\n    if (isLeaf(child)) {\n        let leafNodeIdx = n - 1u + leafIndex(child);\n        let node = treeNodes[leafNodeIdx];\n        return array<vec3<f32>, 2>(\n            vec3<f32>(node.minX, node.minY, node.minZ),\n            vec3<f32>(node.maxX, node.maxY, node.maxZ)\n        );\n    } else {\n        let node = treeNodes[child];\n        return array<vec3<f32>, 2>(\n            vec3<f32>(node.minX, node.minY, node.minZ),\n            vec3<f32>(node.maxX, node.maxY, node.maxZ)\n        );\n    }\n}\n\n@compute @workgroup_size(${WORKGROUP_SIZE})\nfn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n    let n = instanceCount[0];\n    let nodeIdx = gid.x;\n\n    if (n == 1u) {\n        if (nodeIdx == 0u) {\n            var out: BVHNode;\n            out.child0 = 0u | LEAF_FLAG;\n            out.child1 = INVALID_NODE;\n            out.child2 = INVALID_NODE;\n            out.child3 = INVALID_NODE;\n\n            let bounds = getChildBounds(0u | LEAF_FLAG, n);\n            out.c0_minX = bounds[0].x; out.c0_minY = bounds[0].y; out.c0_minZ = bounds[0].z;\n            out.c0_maxX = bounds[1].x; out.c0_maxY = bounds[1].y; out.c0_maxZ = bounds[1].z;\n            out.c1_minX = 1e30; out.c1_minY = 1e30; out.c1_minZ = 1e30;\n            out.c1_maxX = -1e30; out.c1_maxY = -1e30; out.c1_maxZ = -1e30;\n            out.c2_minX = 1e30; out.c2_minY = 1e30; out.c2_minZ = 1e30;\n            out.c2_maxX = -1e30; out.c2_maxY = -1e30; out.c2_maxZ = -1e30;\n            out.c3_minX = 1e30; out.c3_minY = 1e30; out.c3_minZ = 1e30;\n            out.c3_maxX = -1e30; out.c3_maxY = -1e30; out.c3_maxZ = -1e30;\n\n            bvhNodes[0] = out;\n        }\n        return;\n    }\n\n    if (nodeIdx >= n - 1u) {\n        return;\n    }\n\n    let depth = getDepth(nodeIdx, n);\n    let node = treeNodes[nodeIdx];\n    let left = node.leftChild;\n    let right = node.rightChild;\n\n    var out: BVHNode;\n\n    out.child0 = INVALID_NODE;\n    out.child1 = INVALID_NODE;\n    out.child2 = INVALID_NODE;\n    out.child3 = INVALID_NODE;\n    out.c0_minX = 1e30; out.c0_minY = 1e30; out.c0_minZ = 1e30;\n    out.c0_maxX = -1e30; out.c0_maxY = -1e30; out.c0_maxZ = -1e30;\n    out.c1_minX = 1e30; out.c1_minY = 1e30; out.c1_minZ = 1e30;\n    out.c1_maxX = -1e30; out.c1_maxY = -1e30; out.c1_maxZ = -1e30;\n    out.c2_minX = 1e30; out.c2_minY = 1e30; out.c2_minZ = 1e30;\n    out.c2_maxX = -1e30; out.c2_maxY = -1e30; out.c2_maxZ = -1e30;\n    out.c3_minX = 1e30; out.c3_minY = 1e30; out.c3_minZ = 1e30;\n    out.c3_maxX = -1e30; out.c3_maxY = -1e30; out.c3_maxZ = -1e30;\n\n    if ((depth & 1u) != 0u) {\n        out.child0 = left;\n        let bounds0 = getChildBounds(left, n);\n        out.c0_minX = bounds0[0].x; out.c0_minY = bounds0[0].y; out.c0_minZ = bounds0[0].z;\n        out.c0_maxX = bounds0[1].x; out.c0_maxY = bounds0[1].y; out.c0_maxZ = bounds0[1].z;\n\n        out.child1 = right;\n        let bounds1 = getChildBounds(right, n);\n        out.c1_minX = bounds1[0].x; out.c1_minY = bounds1[0].y; out.c1_minZ = bounds1[0].z;\n        out.c1_maxX = bounds1[1].x; out.c1_maxY = bounds1[1].y; out.c1_maxZ = bounds1[1].z;\n\n        bvhNodes[nodeIdx] = out;\n        return;\n    }\n\n    if (isLeaf(left)) {\n        out.child0 = left;\n        let bounds = getChildBounds(left, n);\n        out.c0_minX = bounds[0].x; out.c0_minY = bounds[0].y; out.c0_minZ = bounds[0].z;\n        out.c0_maxX = bounds[1].x; out.c0_maxY = bounds[1].y; out.c0_maxZ = bounds[1].z;\n    } else {\n        let leftNode = treeNodes[left];\n        let ll = leftNode.leftChild;\n        let lr = leftNode.rightChild;\n\n        out.child0 = ll;\n        let bounds0 = getChildBounds(ll, n);\n        out.c0_minX = bounds0[0].x; out.c0_minY = bounds0[0].y; out.c0_minZ = bounds0[0].z;\n        out.c0_maxX = bounds0[1].x; out.c0_maxY = bounds0[1].y; out.c0_maxZ = bounds0[1].z;\n\n        out.child1 = lr;\n        let bounds1 = getChildBounds(lr, n);\n        out.c1_minX = bounds1[0].x; out.c1_minY = bounds1[0].y; out.c1_minZ = bounds1[0].z;\n        out.c1_maxX = bounds1[1].x; out.c1_maxY = bounds1[1].y; out.c1_maxZ = bounds1[1].z;\n    }\n\n    if (isLeaf(right)) {\n        out.child2 = right;\n        let bounds = getChildBounds(right, n);\n        out.c2_minX = bounds[0].x; out.c2_minY = bounds[0].y; out.c2_minZ = bounds[0].z;\n        out.c2_maxX = bounds[1].x; out.c2_maxY = bounds[1].y; out.c2_maxZ = bounds[1].z;\n    } else {\n        let rightNode = treeNodes[right];\n        let rl = rightNode.leftChild;\n        let rr = rightNode.rightChild;\n\n        out.child2 = rl;\n        let bounds2 = getChildBounds(rl, n);\n        out.c2_minX = bounds2[0].x; out.c2_minY = bounds2[0].y; out.c2_minZ = bounds2[0].z;\n        out.c2_maxX = bounds2[1].x; out.c2_maxY = bounds2[1].y; out.c2_maxZ = bounds2[1].z;\n\n        out.child3 = rr;\n        let bounds3 = getChildBounds(rr, n);\n        out.c3_minX = bounds3[0].x; out.c3_minY = bounds3[0].y; out.c3_minZ = bounds3[0].z;\n        out.c3_maxX = bounds3[1].x; out.c3_maxY = bounds3[1].y; out.c3_maxZ = bounds3[1].z;\n    }\n\n    bvhNodes[nodeIdx] = out;\n}\n`;\n\ninterface TLASPipelines {\n    bounds: GPUComputePipeline;\n    morton: GPUComputePipeline;\n    tree: GPUComputePipeline;\n    propagate: GPUComputePipeline;\n    collapse: GPUComputePipeline;\n}\n\ninterface TLASBindGroups {\n    bounds: GPUBindGroup;\n    morton: GPUBindGroup;\n    tree: GPUBindGroup;\n    propagate: GPUBindGroup;\n    collapse: GPUBindGroup;\n}\n\nexport interface TLASConfig {\n    instanceAABBs: GPUBuffer;\n    instanceCount: GPUBuffer;\n    tlas: TLASBuffers;\n    getEntityCount: () => number;\n}\n\nexport function createTLASNode(config: TLASConfig): ComputeNode {\n    let pipelines: TLASPipelines | null = null;\n    let bindGroups: TLASBindGroups | null = null;\n    let radixSort: Awaited<ReturnType<typeof createRadixSort>> | null = null;\n\n    return {\n        id: \"tlas\",\n        sync: true,\n        inputs: [\n            { id: \"instance-aabbs\", access: \"read\" },\n            { id: \"instance-count\", access: \"read\" },\n        ],\n        outputs: [\n            { id: \"tlas-bvh-nodes\", access: \"write\" },\n            { id: \"tlas-morton-codes\", access: \"write\" },\n            { id: \"tlas-instance-ids\", access: \"write\" },\n        ],\n\n        async prepare(device: GPUDevice) {\n            const [boundsModule, mortonModule, treeModule, propagateModule, collapseModule] =\n                await Promise.all([\n                    device.createShaderModule({ code: boundsShader }),\n                    device.createShaderModule({ code: mortonShader }),\n                    device.createShaderModule({ code: treeShader }),\n                    device.createShaderModule({ code: propagateShader }),\n                    device.createShaderModule({ code: collapseShader }),\n                ]);\n\n            const [bounds, morton, tree, propagate, collapse, sort] = await Promise.all([\n                device.createComputePipelineAsync({\n                    layout: \"auto\",\n                    compute: { module: boundsModule, entryPoint: \"main\" },\n                }),\n                device.createComputePipelineAsync({\n                    layout: \"auto\",\n                    compute: { module: mortonModule, entryPoint: \"main\" },\n                }),\n                device.createComputePipelineAsync({\n                    layout: \"auto\",\n                    compute: { module: treeModule, entryPoint: \"main\" },\n                }),\n                device.createComputePipelineAsync({\n                    layout: \"auto\",\n                    compute: { module: propagateModule, entryPoint: \"main\" },\n                }),\n                device.createComputePipelineAsync({\n                    layout: \"auto\",\n                    compute: { module: collapseModule, entryPoint: \"main\" },\n                }),\n                createRadixSort(device, {\n                    keys: config.tlas.mortonCodes,\n                    values: config.tlas.instanceIds,\n                    count: MAX_ENTITIES,\n                }),\n            ]);\n\n            pipelines = { bounds, morton, tree, propagate, collapse };\n            radixSort = sort;\n\n            bindGroups = {\n                bounds: device.createBindGroup({\n                    layout: pipelines.bounds.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: { buffer: config.instanceAABBs } },\n                        { binding: 1, resource: { buffer: config.instanceCount } },\n                        { binding: 2, resource: { buffer: config.tlas.sceneBounds } },\n                        { binding: 3, resource: { buffer: config.tlas.entityIds } },\n                    ],\n                }),\n                morton: device.createBindGroup({\n                    layout: pipelines.morton.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: { buffer: config.instanceAABBs } },\n                        { binding: 1, resource: { buffer: config.instanceCount } },\n                        { binding: 2, resource: { buffer: config.tlas.sceneBounds } },\n                        { binding: 3, resource: { buffer: config.tlas.mortonCodes } },\n                        { binding: 4, resource: { buffer: config.tlas.instanceIds } },\n                        { binding: 5, resource: { buffer: config.tlas.entityIds } },\n                    ],\n                }),\n                tree: device.createBindGroup({\n                    layout: pipelines.tree.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: { buffer: config.tlas.mortonCodes } },\n                        { binding: 1, resource: { buffer: config.instanceCount } },\n                        { binding: 2, resource: { buffer: config.tlas.treeNodes } },\n                        { binding: 3, resource: { buffer: config.tlas.parentIndices } },\n                    ],\n                }),\n                propagate: device.createBindGroup({\n                    layout: pipelines.propagate.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: { buffer: config.instanceAABBs } },\n                        { binding: 1, resource: { buffer: config.tlas.instanceIds } },\n                        { binding: 2, resource: { buffer: config.instanceCount } },\n                        { binding: 3, resource: { buffer: config.tlas.treeNodes } },\n                        { binding: 4, resource: { buffer: config.tlas.boundsFlags } },\n                        { binding: 5, resource: { buffer: config.tlas.parentIndices } },\n                    ],\n                }),\n                collapse: device.createBindGroup({\n                    layout: pipelines.collapse.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: { buffer: config.tlas.treeNodes } },\n                        { binding: 1, resource: { buffer: config.instanceCount } },\n                        { binding: 2, resource: { buffer: config.tlas.parentIndices } },\n                        { binding: 3, resource: { buffer: config.tlas.bvhNodes } },\n                    ],\n                }),\n            };\n        },\n\n        execute(ctx: ExecutionContext) {\n            const { device, encoder } = ctx;\n\n            const workgroups = Math.ceil(MAX_ENTITIES / WORKGROUP_SIZE);\n\n            const initBounds = new Int32Array([\n                0x7f7fffff, 0x7f7fffff, 0x7f7fffff, 0, 0x80800000, 0x80800000, 0x80800000, 0,\n            ]);\n            device.queue.writeBuffer(config.tlas.sceneBounds, 0, initBounds);\n\n            encoder.clearBuffer(config.tlas.boundsFlags);\n            encoder.clearBuffer(config.tlas.parentIndices);\n\n            const boundsPass = encoder.beginComputePass();\n            boundsPass.setPipeline(pipelines!.bounds);\n            boundsPass.setBindGroup(0, bindGroups!.bounds);\n            boundsPass.dispatchWorkgroups(workgroups);\n            boundsPass.end();\n\n            const mortonPass = encoder.beginComputePass();\n            mortonPass.setPipeline(pipelines!.morton);\n            mortonPass.setBindGroup(0, bindGroups!.morton);\n            mortonPass.dispatchWorkgroups(workgroups);\n            mortonPass.end();\n\n            const sortPass = encoder.beginComputePass();\n            radixSort!.dispatch(sortPass);\n            sortPass.end();\n\n            const treePass = encoder.beginComputePass();\n            treePass.setPipeline(pipelines!.tree);\n            treePass.setBindGroup(0, bindGroups!.tree);\n            treePass.dispatchWorkgroups(Math.ceil((MAX_ENTITIES - 1) / WORKGROUP_SIZE));\n            treePass.end();\n\n            const propagatePass = encoder.beginComputePass();\n            propagatePass.setPipeline(pipelines!.propagate);\n            propagatePass.setBindGroup(0, bindGroups!.propagate);\n            propagatePass.dispatchWorkgroups(workgroups);\n            propagatePass.end();\n\n            const collapsePass = encoder.beginComputePass();\n            collapsePass.setPipeline(pipelines!.collapse);\n            collapsePass.setBindGroup(0, bindGroups!.collapse);\n            collapsePass.dispatchWorkgroups(Math.ceil((MAX_ENTITIES - 1) / WORKGROUP_SIZE));\n            collapsePass.end();\n        },\n    };\n}\n","import type { ComputeNode, ExecutionContext } from \"../compute\";\n\nconst WORKGROUP_SIZE = 64;\n\nconst shader = /* wgsl */ `\nstruct ShapeAABB {\n    minX: f32,\n    minY: f32,\n    minZ: f32,\n    _pad0: u32,\n    maxX: f32,\n    maxY: f32,\n    maxZ: f32,\n    _pad1: u32,\n}\n\nstruct InstanceAABB {\n    minX: f32,\n    minY: f32,\n    minZ: f32,\n    _pad0: u32,\n    maxX: f32,\n    maxY: f32,\n    maxZ: f32,\n    _pad1: u32,\n}\n\n@group(0) @binding(0) var<storage, read> matrices: array<mat4x4<f32>>;\n@group(0) @binding(1) var<storage, read> sizes: array<vec4<f32>>;\n@group(0) @binding(2) var<storage, read> shapes: array<u32>;\n@group(0) @binding(3) var<storage, read> shapeAABBs: array<ShapeAABB>;\n@group(0) @binding(4) var<storage, read> entityCount: array<u32>;\n@group(0) @binding(5) var<storage, read_write> instanceAABBs: array<InstanceAABB>;\n@group(0) @binding(6) var<storage, read_write> instanceInverses: array<mat4x4<f32>>;\n\nfn scaleColumns(m: mat4x4<f32>, s: vec3<f32>) -> mat4x4<f32> {\n    return mat4x4<f32>(\n        m[0] * s.x,\n        m[1] * s.y,\n        m[2] * s.z,\n        m[3]\n    );\n}\n\nfn transformPoint(p: vec3<f32>, m: mat4x4<f32>) -> vec3<f32> {\n    return (m * vec4<f32>(p, 1.0)).xyz;\n}\n\nfn transformAABB(aabbMin: vec3<f32>, aabbMax: vec3<f32>, m: mat4x4<f32>) -> array<vec3<f32>, 2> {\n    let corners = array<vec3<f32>, 8>(\n        vec3<f32>(aabbMin.x, aabbMin.y, aabbMin.z),\n        vec3<f32>(aabbMin.x, aabbMin.y, aabbMax.z),\n        vec3<f32>(aabbMin.x, aabbMax.y, aabbMin.z),\n        vec3<f32>(aabbMin.x, aabbMax.y, aabbMax.z),\n        vec3<f32>(aabbMax.x, aabbMin.y, aabbMin.z),\n        vec3<f32>(aabbMax.x, aabbMin.y, aabbMax.z),\n        vec3<f32>(aabbMax.x, aabbMax.y, aabbMin.z),\n        vec3<f32>(aabbMax.x, aabbMax.y, aabbMax.z)\n    );\n\n    var newMin = vec3<f32>(1e30, 1e30, 1e30);\n    var newMax = vec3<f32>(-1e30, -1e30, -1e30);\n\n    for (var i = 0u; i < 8u; i++) {\n        let t = transformPoint(corners[i], m);\n        newMin = min(newMin, t);\n        newMax = max(newMax, t);\n    }\n\n    return array<vec3<f32>, 2>(newMin, newMax);\n}\n\nfn inverse4x4(m: mat4x4<f32>) -> mat4x4<f32> {\n    let m00 = m[0][0]; let m10 = m[0][1]; let m20 = m[0][2]; let m30 = m[0][3];\n    let m01 = m[1][0]; let m11 = m[1][1]; let m21 = m[1][2]; let m31 = m[1][3];\n    let m02 = m[2][0]; let m12 = m[2][1]; let m22 = m[2][2]; let m32 = m[2][3];\n    let m03 = m[3][0]; let m13 = m[3][1]; let m23 = m[3][2]; let m33 = m[3][3];\n\n    let c00 = m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13);\n    let c01 = -(m01 * (m22 * m33 - m32 * m23) - m21 * (m02 * m33 - m32 * m03) + m31 * (m02 * m23 - m22 * m03));\n    let c02 = m01 * (m12 * m33 - m32 * m13) - m11 * (m02 * m33 - m32 * m03) + m31 * (m02 * m13 - m12 * m03);\n    let c03 = -(m01 * (m12 * m23 - m22 * m13) - m11 * (m02 * m23 - m22 * m03) + m21 * (m02 * m13 - m12 * m03));\n\n    let c10 = -(m10 * (m22 * m33 - m32 * m23) - m20 * (m12 * m33 - m32 * m13) + m30 * (m12 * m23 - m22 * m13));\n    let c11 = m00 * (m22 * m33 - m32 * m23) - m20 * (m02 * m33 - m32 * m03) + m30 * (m02 * m23 - m22 * m03);\n    let c12 = -(m00 * (m12 * m33 - m32 * m13) - m10 * (m02 * m33 - m32 * m03) + m30 * (m02 * m13 - m12 * m03));\n    let c13 = m00 * (m12 * m23 - m22 * m13) - m10 * (m02 * m23 - m22 * m03) + m20 * (m02 * m13 - m12 * m03);\n\n    let c20 = m10 * (m21 * m33 - m31 * m23) - m20 * (m11 * m33 - m31 * m13) + m30 * (m11 * m23 - m21 * m13);\n    let c21 = -(m00 * (m21 * m33 - m31 * m23) - m20 * (m01 * m33 - m31 * m03) + m30 * (m01 * m23 - m21 * m03));\n    let c22 = m00 * (m11 * m33 - m31 * m13) - m10 * (m01 * m33 - m31 * m03) + m30 * (m01 * m13 - m11 * m03);\n    let c23 = -(m00 * (m11 * m23 - m21 * m13) - m10 * (m01 * m23 - m21 * m03) + m20 * (m01 * m13 - m11 * m03));\n\n    let c30 = -(m10 * (m21 * m32 - m31 * m22) - m20 * (m11 * m32 - m31 * m12) + m30 * (m11 * m22 - m21 * m12));\n    let c31 = m00 * (m21 * m32 - m31 * m22) - m20 * (m01 * m32 - m31 * m02) + m30 * (m01 * m22 - m21 * m02);\n    let c32 = -(m00 * (m11 * m32 - m31 * m12) - m10 * (m01 * m32 - m31 * m02) + m30 * (m01 * m12 - m11 * m02));\n    let c33 = m00 * (m11 * m22 - m21 * m12) - m10 * (m01 * m22 - m21 * m02) + m20 * (m01 * m12 - m11 * m02);\n\n    let det = m00 * c00 + m01 * c10 + m02 * c20 + m03 * c30;\n    let invDet = select(0.0, 1.0 / det, abs(det) > 1e-10);\n\n    return mat4x4<f32>(\n        vec4<f32>(c00, c10, c20, c30) * invDet,\n        vec4<f32>(c01, c11, c21, c31) * invDet,\n        vec4<f32>(c02, c12, c22, c32) * invDet,\n        vec4<f32>(c03, c13, c23, c33) * invDet\n    );\n}\n\n@compute @workgroup_size(${WORKGROUP_SIZE})\nfn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n    let eid = gid.x;\n    let count = entityCount[0];\n    if (eid >= count) { return; }\n\n    let shapeId = shapes[eid];\n    let shapeAABB = shapeAABBs[shapeId];\n    let matrix = matrices[eid];\n    let size = sizes[eid].xyz;\n\n    let hasZeroScale = size.x == 0.0 || size.y == 0.0 || size.z == 0.0;\n\n    if (hasZeroScale) {\n        var zeroAABB: InstanceAABB;\n        zeroAABB.minX = 0.0;\n        zeroAABB.minY = 0.0;\n        zeroAABB.minZ = 0.0;\n        zeroAABB._pad0 = 0u;\n        zeroAABB.maxX = 0.0;\n        zeroAABB.maxY = 0.0;\n        zeroAABB.maxZ = 0.0;\n        zeroAABB._pad1 = 0u;\n        instanceAABBs[eid] = zeroAABB;\n        instanceInverses[eid] = mat4x4<f32>();\n        return;\n    }\n\n    let scaledMatrix = scaleColumns(matrix, size);\n\n    let aabbMin = vec3<f32>(shapeAABB.minX, shapeAABB.minY, shapeAABB.minZ);\n    let aabbMax = vec3<f32>(shapeAABB.maxX, shapeAABB.maxY, shapeAABB.maxZ);\n    let worldAABB = transformAABB(aabbMin, aabbMax, scaledMatrix);\n\n    var outAABB: InstanceAABB;\n    outAABB.minX = worldAABB[0].x;\n    outAABB.minY = worldAABB[0].y;\n    outAABB.minZ = worldAABB[0].z;\n    outAABB._pad0 = 0u;\n    outAABB.maxX = worldAABB[1].x;\n    outAABB.maxY = worldAABB[1].y;\n    outAABB.maxZ = worldAABB[1].z;\n    outAABB._pad1 = 0u;\n    instanceAABBs[eid] = outAABB;\n\n    instanceInverses[eid] = inverse4x4(scaledMatrix);\n}\n`;\n\nexport interface InstanceConfig {\n    matrices: GPUBuffer;\n    sizes: GPUBuffer;\n    shapes: GPUBuffer;\n    shapeAABBs: GPUBuffer;\n    entityCount: GPUBuffer;\n    instanceAABBs: GPUBuffer;\n    instanceInverses: GPUBuffer;\n    getEntityCount: () => number;\n}\n\nexport function createInstanceNode(config: InstanceConfig): ComputeNode {\n    let pipeline: GPUComputePipeline | null = null;\n    let bindGroup: GPUBindGroup | null = null;\n\n    return {\n        id: \"instance\",\n        inputs: [],\n        outputs: [\n            { id: \"instance-aabbs\", access: \"write\" },\n            { id: \"instance-inverses\", access: \"write\" },\n        ],\n\n        async prepare(device: GPUDevice) {\n            const module = await device.createShaderModule({ code: shader });\n\n            pipeline = await device.createComputePipelineAsync({\n                layout: \"auto\",\n                compute: { module, entryPoint: \"main\" },\n            });\n\n            bindGroup = device.createBindGroup({\n                layout: pipeline.getBindGroupLayout(0),\n                entries: [\n                    { binding: 0, resource: { buffer: config.matrices } },\n                    { binding: 1, resource: { buffer: config.sizes } },\n                    { binding: 2, resource: { buffer: config.shapes } },\n                    { binding: 3, resource: { buffer: config.shapeAABBs } },\n                    { binding: 4, resource: { buffer: config.entityCount } },\n                    { binding: 5, resource: { buffer: config.instanceAABBs } },\n                    { binding: 6, resource: { buffer: config.instanceInverses } },\n                ],\n            });\n        },\n\n        execute(ctx: ExecutionContext) {\n            const workgroups = Math.ceil(config.getEntityCount() / WORKGROUP_SIZE);\n\n            const pass = ctx.encoder.beginComputePass();\n            pass.setPipeline(pipeline!);\n            pass.setBindGroup(0, bindGroup!);\n            pass.dispatchWorkgroups(workgroups);\n            pass.end();\n        },\n    };\n}\n","import type { ComputeNode, ExecutionContext } from \"../compute\";\n\nconst WORKGROUP_SIZE = 64;\n\nconst shader = /* wgsl */ `\nstruct Data {\n    baseColor: vec4<f32>,\n    pbr: vec4<f32>,\n    emission: vec4<f32>,\n    flags: u32,\n    _pad0: u32,\n    _pad1: u32,\n    _pad2: u32,\n}\n\n@group(0) @binding(0) var<storage, read> colors: array<vec4<f32>>;\n@group(0) @binding(1) var<storage, read> pbr: array<vec4<f32>>;\n@group(0) @binding(2) var<storage, read> emission: array<vec4<f32>>;\n@group(0) @binding(3) var<storage, read> surfaces: array<u32>;\n@group(0) @binding(4) var<storage, read> entityCount: array<u32>;\n@group(0) @binding(5) var<storage, read_write> data: array<Data>;\n\n@compute @workgroup_size(${WORKGROUP_SIZE})\nfn main(@builtin(global_invocation_id) gid: vec3<u32>) {\n    let eid = gid.x;\n    let count = entityCount[0];\n    if (eid >= count) { return; }\n\n    var d: Data;\n    d.baseColor = colors[eid];\n    d.pbr = pbr[eid];\n    d.emission = emission[eid];\n    d.flags = surfaces[eid];\n    d._pad0 = 0u;\n    d._pad1 = 0u;\n    d._pad2 = 0u;\n    data[eid] = d;\n}\n`;\n\nexport interface DataConfig {\n    colors: GPUBuffer;\n    pbr: GPUBuffer;\n    emission: GPUBuffer;\n    surfaces: GPUBuffer;\n    entityCount: GPUBuffer;\n    data: GPUBuffer;\n    getEntityCount: () => number;\n}\n\nexport function createDataNode(config: DataConfig): ComputeNode {\n    let pipeline: GPUComputePipeline | null = null;\n    let bindGroup: GPUBindGroup | null = null;\n\n    return {\n        id: \"data\",\n        inputs: [],\n        outputs: [{ id: \"data\", access: \"write\" }],\n\n        async prepare(device: GPUDevice) {\n            const module = device.createShaderModule({ code: shader });\n\n            pipeline = await device.createComputePipelineAsync({\n                layout: \"auto\",\n                compute: { module, entryPoint: \"main\" },\n            });\n\n            bindGroup = device.createBindGroup({\n                layout: pipeline.getBindGroupLayout(0),\n                entries: [\n                    { binding: 0, resource: { buffer: config.colors } },\n                    { binding: 1, resource: { buffer: config.pbr } },\n                    { binding: 2, resource: { buffer: config.emission } },\n                    { binding: 3, resource: { buffer: config.surfaces } },\n                    { binding: 4, resource: { buffer: config.entityCount } },\n                    { binding: 5, resource: { buffer: config.data } },\n                ],\n            });\n        },\n\n        execute(ctx: ExecutionContext) {\n            if (!pipeline || !bindGroup) return;\n\n            const workgroups = Math.ceil(config.getEntityCount() / WORKGROUP_SIZE);\n\n            const pass = ctx.encoder.beginComputePass();\n            pass.setPipeline(pipeline);\n            pass.setBindGroup(0, bindGroup);\n            pass.dispatchWorkgroups(workgroups);\n            pass.end();\n        },\n    };\n}\n","import { Not } from \"bitecs\";\nimport type { Plugin, State, System } from \"../../core\";\nimport { MAX_ENTITIES, resource } from \"../../core\";\nimport { Canvas, Compute, ComputePlugin } from \"../compute\";\nimport { WorldTransform } from \"../transforms\";\nimport { Activity } from \"../activity\";\nimport {\n    Camera,\n    Tonemap,\n    FXAA,\n    Raytracing,\n    Vignette,\n    Bloom,\n    Quantize,\n    Shadows,\n    Reflections,\n    Refractions,\n    Haze,\n    Sky,\n    Moon,\n    Stars,\n    Clouds,\n    Sun,\n    Viewport,\n    uploadCamera,\n} from \"./camera\";\nimport { AmbientLight, DirectionalLight, packLightUniforms } from \"./light\";\nimport {\n    Mesh,\n    MeshShapes,\n    MeshColors,\n    MeshSizes,\n    MeshPBR,\n    MeshEmission,\n    MeshVolumes,\n    collectBatches,\n    updateBatches,\n    MAX_BATCH_SLOTS,\n    type Batch,\n    type MeshBuffers,\n    type BatchEntities,\n    createShapeAtlas,\n} from \"./mesh\";\nimport { Surface, SurfaceIds, SurfaceType, getDefaultAllSurfaces } from \"./surface\";\nimport { createSceneBuffer, ensureTextures } from \"./scene\";\nimport { createIndirectBuffer } from \"./indirect\";\nimport { createForwardNode } from \"./forward\";\nimport { createDepthConvertNode } from \"./depth\";\nimport { createPostProcessNode, type PostProcessUniforms } from \"./postprocess\";\nimport { createOverlayNode } from \"./overlay\";\nimport { Draws } from \"./pass\";\nimport { createBLASAtlas, type BLASAtlas } from \"./bvh/blas\";\nimport { createTLASBuffers, createTLASNode, type TLASBuffers } from \"./bvh/tlas\";\nimport { getMesh } from \"./mesh\";\nimport { createInstanceNode } from \"./instance\";\nimport { createDataNode } from \"./data\";\n\nexport {\n    Camera,\n    CameraMode,\n    RenderMode,\n    Tonemap,\n    FXAA,\n    Raytracing,\n    Vignette,\n    Bloom,\n    Quantize,\n    Shadows,\n    Reflections,\n    Refractions,\n    Haze,\n    Sky,\n    Moon,\n    Stars,\n    Clouds,\n    Sun,\n    Viewport,\n} from \"./camera\";\nexport { AmbientLight, DirectionalLight } from \"./light\";\nexport { Mesh, MeshShape, Volume, mesh, getMesh, clearMeshes } from \"./mesh\";\nexport { createBox } from \"./mesh/box\";\nexport { createSphere } from \"./mesh/sphere\";\nexport { createPlane } from \"./mesh/plane\";\nexport type { MeshData } from \"./mesh\";\nexport { Surface, SurfaceType } from \"./surface\";\n\nexport { surface, compose } from \"./surface\";\nexport type { SurfaceData } from \"./surface\";\n\nexport { Pass, registerDraw, unregisterDraw, getDrawsByPass, Draws } from \"./pass\";\nexport type { Draw, DrawContext, SharedPassContext } from \"./pass\";\nexport { createForwardNode, compileRasterShader, compileRTShader } from \"./forward\";\nexport type { ForwardConfig, ForwardNode } from \"./forward\";\nexport { createDepthConvertNode } from \"./depth\";\nexport { createPostProcessNode } from \"./postprocess\";\nexport type { PostProcessUniforms } from \"./postprocess\";\nexport { createOverlayNode } from \"./overlay\";\n\nconst EntityIds = {\n    data: new Uint32Array(MAX_ENTITIES),\n};\n\nconst countBuffer = new Uint32Array(1);\n\nexport interface Render {\n    width: number;\n    height: number;\n    entityCount: number;\n    scene: GPUBuffer;\n    matrices: GPUBuffer;\n}\n\ninterface RenderState extends Render {\n    colors: GPUBuffer;\n    sizes: GPUBuffer;\n    pbr: GPUBuffer;\n    emission: GPUBuffer;\n    shapes: GPUBuffer;\n    surfaces: GPUBuffer;\n    data: GPUBuffer;\n    indirect: GPUBuffer;\n    batches: (Batch | null)[];\n    batchEntities: BatchEntities;\n    buffers: Map<number, MeshBuffers>;\n    postProcess: PostProcessUniforms;\n    meshVertices: GPUBuffer;\n    meshIndices: GPUBuffer;\n    meshMeta: GPUBuffer;\n    blasAtlas: BLASAtlas;\n    instanceAABBs: GPUBuffer;\n    instanceInverses: GPUBuffer;\n    entityCountBuffer: GPUBuffer;\n    instanceCount: GPUBuffer;\n    tlas: TLASBuffers;\n}\n\nexport const Render = resource<Render>(\"render\");\n\nfunction getRenderState(state: State): RenderState | undefined {\n    return Render.from(state) as RenderState | undefined;\n}\n\nconst RenderSystem: System = {\n    group: \"draw\",\n    first: true,\n\n    update(state: State) {\n        const render = getRenderState(state);\n        const compute = Compute.from(state);\n        const canvas = Canvas.from(state);\n        if (!render || !compute || !canvas) return;\n\n        const { device } = compute;\n        const { element, format } = canvas;\n        const { resources } = compute;\n        const { width, height } = element;\n\n        let renderWidth = width;\n        let renderHeight = height;\n\n        for (const eid of state.query([Camera])) {\n            if (Camera.active[eid]) {\n                if (state.hasComponent(eid, Viewport)) {\n                    const vw = Viewport.width[eid];\n                    const vh = Viewport.height[eid];\n                    if (vw > 0 && vh > 0) {\n                        renderWidth = vw;\n                        renderHeight = vh;\n                    } else if (vh > 0 && height > 0) {\n                        renderHeight = vh;\n                        renderWidth = Math.max(1, Math.round(vh * (width / height)));\n                    } else if (vw > 0 && width > 0) {\n                        renderWidth = vw;\n                        renderHeight = Math.max(1, Math.round(vw * (height / width)));\n                    }\n                }\n                break;\n            }\n        }\n\n        render.width = renderWidth;\n        render.height = renderHeight;\n\n        ensureTextures(\n            device,\n            format,\n            renderWidth,\n            renderHeight,\n            resources.textures,\n            resources.textureViews\n        );\n\n        render.entityCount = state.maxEid + 1;\n        const uploadCount = render.entityCount;\n\n        for (const eid of state.query([Camera])) {\n            if (Camera.active[eid]) {\n                const hasShadows = state.hasComponent(eid, Shadows);\n                const shadowSoftness = hasShadows ? Shadows.softness[eid] : 0;\n                const shadowSamples = hasShadows ? Math.max(1, Shadows.samples[eid]) : 0;\n\n                const hasReflections = state.hasComponent(eid, Reflections);\n                const reflectionDepth = hasReflections\n                    ? Math.min(4, Math.max(1, Reflections.depth[eid]))\n                    : 0;\n\n                const hasRefractions = state.hasComponent(eid, Refractions);\n                const refractionDepth = hasRefractions\n                    ? Math.min(4, Math.max(1, Refractions.depth[eid]))\n                    : 0;\n\n                const hasHaze = state.hasComponent(eid, Haze);\n                const hazeParams = hasHaze\n                    ? {\n                        density: Haze.density[eid],\n                        color: Haze.color[eid],\n                    }\n                    : undefined;\n\n                const hasSky = state.hasComponent(eid, Sky);\n                const skyParams = hasSky\n                    ? {\n                        zenith: Sky.zenith[eid],\n                        horizon: Sky.horizon[eid],\n                    }\n                    : undefined;\n\n                const hasMoon = state.hasComponent(eid, Moon);\n                const moonParams = hasMoon\n                    ? {\n                        phase: Moon.phase[eid],\n                        glow: Moon.glow[eid],\n                        azimuth: Moon.azimuth[eid],\n                        elevation: Moon.elevation[eid],\n                    }\n                    : undefined;\n\n                const hasStars = state.hasComponent(eid, Stars);\n                const starsParams = hasStars\n                    ? {\n                        intensity: Stars.intensity[eid],\n                        amount: Stars.amount[eid],\n                    }\n                    : undefined;\n\n                const hasClouds = state.hasComponent(eid, Clouds);\n                const cloudsParams = hasClouds\n                    ? {\n                        coverage: Clouds.coverage[eid],\n                        density: Clouds.density[eid],\n                        height: Clouds.height[eid],\n                        color: Clouds.color[eid],\n                    }\n                    : undefined;\n\n                const hasSun = state.hasComponent(eid, Sun);\n                const sunParams = hasSun\n                    ? {\n                        size: Sun.size[eid],\n                        glow: Sun.glow[eid],\n                        color: Sun.color[eid],\n                    }\n                    : undefined;\n\n                uploadCamera(\n                    device,\n                    render.scene,\n                    eid,\n                    renderWidth,\n                    renderHeight,\n                    shadowSoftness,\n                    shadowSamples,\n                    reflectionDepth,\n                    refractionDepth,\n                    uploadCount,\n                    hazeParams,\n                    skyParams,\n                    moonParams,\n                    starsParams,\n                    cloudsParams,\n                    sunParams\n                );\n\n                render.postProcess.tonemap = state.hasComponent(eid, Tonemap);\n                if (render.postProcess.tonemap) {\n                    render.postProcess.exposure = Tonemap.exposure[eid];\n                }\n                render.postProcess.fxaa = state.hasComponent(eid, FXAA);\n                if (state.hasComponent(eid, Vignette)) {\n                    render.postProcess.vignetteStrength = Vignette.strength[eid];\n                    render.postProcess.vignetteInner = Vignette.inner[eid];\n                    render.postProcess.vignetteOuter = Vignette.outer[eid];\n                } else {\n                    render.postProcess.vignetteStrength = 0;\n                }\n                if (state.hasComponent(eid, Bloom)) {\n                    render.postProcess.bloomIntensity = Bloom.intensity[eid];\n                    render.postProcess.bloomThreshold = Bloom.threshold[eid];\n                    render.postProcess.bloomRadius = Bloom.radius[eid];\n                } else {\n                    render.postProcess.bloomIntensity = 0;\n                    render.postProcess.bloomThreshold = 0.8;\n                    render.postProcess.bloomRadius = 0.5;\n                }\n                if (state.hasComponent(eid, Quantize)) {\n                    render.postProcess.quantize = Quantize.bands[eid];\n                } else {\n                    render.postProcess.quantize = 0;\n                }\n                break;\n            }\n        }\n\n        let ambientData = { color: 0x888888, intensity: 1.0 };\n        let directionalData = {\n            color: 0xffffff,\n            intensity: 1.0,\n            directionX: -0.5,\n            directionY: -1.0,\n            directionZ: -0.5,\n        };\n\n        for (const eid of state.query([AmbientLight])) {\n            ambientData = {\n                color: AmbientLight.color[eid],\n                intensity: AmbientLight.intensity[eid],\n            };\n            break;\n        }\n\n        for (const eid of state.query([DirectionalLight])) {\n            directionalData = {\n                color: DirectionalLight.color[eid],\n                intensity: DirectionalLight.intensity[eid],\n                directionX: DirectionalLight.directionX[eid],\n                directionY: DirectionalLight.directionY[eid],\n                directionZ: DirectionalLight.directionZ[eid],\n            };\n            break;\n        }\n\n        const lightUniforms = packLightUniforms(ambientData, directionalData);\n        device.queue.writeBuffer(render.scene, 128, lightUniforms as Float32Array<ArrayBuffer>);\n\n        device.queue.writeBuffer(\n            render.matrices,\n            0,\n            WorldTransform.data as Float32Array<ArrayBuffer>,\n            0,\n            uploadCount * 16\n        );\n\n        const meshEntities = state.query([Mesh, WorldTransform]);\n        device.queue.writeBuffer(render.colors, 0, MeshColors.data, 0, uploadCount * 4);\n        device.queue.writeBuffer(render.sizes, 0, MeshSizes.data, 0, uploadCount * 4);\n        device.queue.writeBuffer(render.pbr, 0, MeshPBR.data, 0, uploadCount * 4);\n        device.queue.writeBuffer(render.emission, 0, MeshEmission.data, 0, uploadCount * 4);\n        device.queue.writeBuffer(render.shapes, 0, MeshShapes.data, 0, uploadCount);\n        countBuffer[0] = uploadCount;\n        device.queue.writeBuffer(render.entityCountBuffer, 0, countBuffer);\n\n        let meshCount = 0;\n        for (const eid of meshEntities) {\n            EntityIds.data[meshCount] = eid;\n            meshCount++;\n        }\n        device.queue.writeBuffer(\n            render.tlas.entityIds,\n            0,\n            EntityIds.data,\n            0,\n            Math.max(meshCount, 1)\n        );\n        countBuffer[0] = meshCount;\n        device.queue.writeBuffer(render.instanceCount, 0, countBuffer);\n\n        for (const eid of state.query([Surface])) {\n            const surfaceType = Surface.type[eid] & 0xff;\n            const volume = (MeshVolumes.data[eid] ?? 0) & 0xf;\n            const shapeId = (Mesh.shape[eid] ?? 0) & 0xffff;\n            SurfaceIds.data[eid] = surfaceType | (volume << 8) | (shapeId << 16);\n        }\n        device.queue.writeBuffer(render.surfaces, 0, SurfaceIds.data, 0, uploadCount);\n\n        collectBatches(\n            meshEntities,\n            (eid) => Surface.type[eid] ?? SurfaceType.Default,\n            render.batchEntities\n        );\n        updateBatches(device, render.batchEntities, render, render.indirect);\n    },\n};\n\nconst DefaultSurfaceSystem: System = {\n    group: \"setup\",\n    update(state: State) {\n        for (const eid of state.query([Mesh, Not(Surface)])) {\n            state.addComponent(eid, Surface);\n        }\n    },\n};\n\nexport const RenderPlugin: Plugin = {\n    systems: [DefaultSurfaceSystem, RenderSystem],\n    components: {\n        Camera,\n        Mesh,\n        Surface,\n        AmbientLight,\n        DirectionalLight,\n        Tonemap,\n        FXAA,\n        Raytracing,\n        Vignette,\n        Bloom,\n        Quantize,\n        Shadows,\n        Reflections,\n        Refractions,\n        Haze,\n        Sky,\n        Moon,\n        Stars,\n        Clouds,\n        Sun,\n        Viewport,\n    },\n    dependencies: [ComputePlugin],\n\n    async initialize(state: State, onProgress?: (progress: number) => void) {\n        const compute = Compute.from(state);\n        if (!compute) return;\n\n        const { device } = compute;\n\n        const createPropertyBuffer = (size: number, label?: string) =>\n            device.createBuffer({\n                label: label ?? \"property\",\n                size,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n            });\n\n        const shapeAtlas = createShapeAtlas(device);\n        const blasAtlas = createBLASAtlas(device, getMesh);\n\n        const renderState: RenderState = {\n            scene: createSceneBuffer(device),\n            matrices: createPropertyBuffer(MAX_ENTITIES * 64, \"matrices\"),\n            colors: createPropertyBuffer(MAX_ENTITIES * 16, \"colors\"),\n            sizes: createPropertyBuffer(MAX_ENTITIES * 16, \"sizes\"),\n            pbr: createPropertyBuffer(MAX_ENTITIES * 16, \"pbr\"),\n            emission: createPropertyBuffer(MAX_ENTITIES * 16, \"emission\"),\n            shapes: createPropertyBuffer(MAX_ENTITIES * 4, \"shapes\"),\n            surfaces: createPropertyBuffer(MAX_ENTITIES * 4, \"surfaces\"),\n            data: createPropertyBuffer(MAX_ENTITIES * 64, \"data\"),\n            indirect: createIndirectBuffer(device, MAX_BATCH_SLOTS),\n            batches: Array(MAX_BATCH_SLOTS).fill(null),\n            batchEntities: Array(MAX_BATCH_SLOTS).fill(null),\n            buffers: new Map(),\n            entityCount: 1,\n            postProcess: {\n                tonemap: false,\n                exposure: 1.0,\n                fxaa: true,\n                vignetteStrength: 0,\n                vignetteInner: 0.4,\n                vignetteOuter: 0.8,\n                bloomIntensity: 0,\n                bloomThreshold: 0.8,\n                bloomRadius: 0.5,\n                quantize: 0,\n            },\n            meshVertices: shapeAtlas.vertices,\n            meshIndices: shapeAtlas.indices,\n            meshMeta: shapeAtlas.meta,\n            blasAtlas,\n            instanceAABBs: createPropertyBuffer(MAX_ENTITIES * 32, \"instanceAABBs\"),\n            instanceInverses: createPropertyBuffer(MAX_ENTITIES * 64, \"instanceInverses\"),\n            entityCountBuffer: device.createBuffer({\n                label: \"entityCount\",\n                size: 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n            }),\n            instanceCount: device.createBuffer({\n                label: \"instanceCount\",\n                size: 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n            }),\n            tlas: createTLASBuffers(device),\n            width: 0,\n            height: 0,\n        };\n\n        state.setResource(Render, renderState);\n\n        const drawState: Draws = {\n            draws: new Map(),\n        };\n        state.setResource(Draws, drawState);\n\n        const instanceNode = createInstanceNode({\n            matrices: renderState.matrices,\n            sizes: renderState.sizes,\n            shapes: renderState.shapes,\n            shapeAABBs: renderState.blasAtlas.shapeAABBs,\n            entityCount: renderState.entityCountBuffer,\n            instanceAABBs: renderState.instanceAABBs,\n            instanceInverses: renderState.instanceInverses,\n            getEntityCount: () => renderState.entityCount,\n        });\n        compute.graph.add(instanceNode);\n\n        const dataNode = createDataNode({\n            colors: renderState.colors,\n            pbr: renderState.pbr,\n            emission: renderState.emission,\n            surfaces: renderState.surfaces,\n            entityCount: renderState.entityCountBuffer,\n            data: renderState.data,\n            getEntityCount: () => renderState.entityCount,\n        });\n        compute.graph.add(dataNode);\n\n        const tlasNode = createTLASNode({\n            instanceAABBs: renderState.instanceAABBs,\n            instanceCount: renderState.instanceCount,\n            tlas: renderState.tlas,\n            getEntityCount: () => renderState.entityCount,\n        });\n        compute.graph.add(tlasNode);\n\n        const getRaytracing = () => {\n            for (const eid of state.query([Camera])) {\n                if (Camera.active[eid]) {\n                    return state.hasComponent(eid, Raytracing);\n                }\n            }\n            return false;\n        };\n\n        const getClearColor = () => {\n            for (const eid of state.query([Camera])) {\n                if (Camera.active[eid]) {\n                    const packed = Camera.clearColor[eid];\n                    return {\n                        r: ((packed >> 16) & 0xff) / 255,\n                        g: ((packed >> 8) & 0xff) / 255,\n                        b: (packed & 0xff) / 255,\n                    };\n                }\n            }\n            return { r: 0, g: 0, b: 0 };\n        };\n\n        const getSky = () => {\n            for (const eid of state.query([Camera])) {\n                if (Camera.active[eid]) {\n                    return state.hasComponent(eid, Sky);\n                }\n            }\n            return false;\n        };\n\n        const forwardNode = createForwardNode({\n            scene: renderState.scene,\n            matrices: renderState.matrices,\n            colors: renderState.colors,\n            sizes: renderState.sizes,\n            pbr: renderState.pbr,\n            emission: renderState.emission,\n            shapes: renderState.shapes,\n            surfaces: renderState.surfaces,\n            data: renderState.data,\n            getSurfaces: getDefaultAllSurfaces,\n            getRaytracing,\n            getClearColor,\n            getSky,\n            acquire: (message) => Activity.from(state)?.acquire(message),\n            batches: () => renderState.batches,\n            tlasNodes: renderState.tlas.bvhNodes,\n            tlasInstanceIds: renderState.tlas.instanceIds,\n            blasNodes: renderState.blasAtlas.nodesBuffer,\n            blasTriIds: renderState.blasAtlas.triIdsBuffer,\n            blasTriangles: renderState.blasAtlas.trianglesBuffer,\n            blasMeta: renderState.blasAtlas.metaBuffer,\n            instanceInverses: renderState.instanceInverses,\n        });\n        compute.graph.add(forwardNode);\n\n        compute.graph.add(\n            createDepthConvertNode({\n                scene: renderState.scene,\n                getRaytracing,\n            })\n        );\n\n        compute.graph.add(createOverlayNode({ state }));\n\n        compute.graph.add(\n            createPostProcessNode({\n                state,\n                uniforms: renderState.postProcess,\n                getRenderSize: () => ({\n                    width: renderState.width,\n                    height: renderState.height,\n                }),\n            })\n        );\n\n        onProgress?.(1);\n    },\n\n    async warm(state: State, onProgress?: (progress: number) => void) {\n        const compute = Compute.from(state);\n        if (!compute) return;\n\n        await compute.graph.prepare(compute.device, (done, total) => {\n            onProgress?.(done / total);\n        });\n    },\n};\n","import type { Loading } from \"../../core/builder\";\nexport type { Loading };\n\ninterface Theme {\n    bg: string;\n    track: string;\n    bar: string;\n}\n\nconst dark: Theme = { bg: \"#1a1a1a\", track: \"#333\", bar: \"#E8A86B\" };\nconst light: Theme = { bg: \"#f5f5f5\", track: \"#ddd\", bar: \"#B87654\" };\n\nconst LOGO_SVG = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 285 80\">\n  <defs>\n    <radialGradient id=\"baseGradient\" cx=\"35%\" cy=\"30%\" r=\"70%\" fx=\"25%\" fy=\"20%\">\n      <stop offset=\"0%\" stop-color=\"#F5D4B8\"/>\n      <stop offset=\"45%\" stop-color=\"#E8A86B\"/>\n      <stop offset=\"100%\" stop-color=\"#B87654\"/>\n    </radialGradient>\n  </defs>\n  <g id=\"Icon\" transform=\"rotate(35 40 40)\">\n    <path id=\"Background\" d=\"M40,2 C44,10 66,28 66,46 C66,60 48,70 40,78 C32,70 14,60 14,46 C14,28 36,10 40,2 Z\" fill=\"#E8A86B\"/>\n    <path id=\"CloveLeft\" d=\"M40,6 C37,14 22,28 20,44 C20,52 28,62 36,70 C34,58 26,46 26,38 C26,26 38,12 40,6 Z\" fill=\"#D49560\"/>\n    <path id=\"CloveRight\" d=\"M40,6 C43,14 58,28 60,44 C60,52 52,62 44,70 C46,58 54,46 54,38 C54,26 42,12 40,6 Z\" fill=\"#D49560\"/>\n    <path id=\"CenterCrease\" d=\"M40,8 C40,20 40,50 40,72\" stroke=\"#6B4230\" stroke-width=\"1\" stroke-opacity=\"0.4\" fill=\"none\" stroke-linecap=\"round\"/>\n    <path id=\"BottomEdge\" d=\"M40,78 C48,70 66,60 66,46 C61,58 44,70 40,73 Z\" fill=\"#D49560\"/>\n    <path id=\"Outline\" d=\"M40,2 C44,10 66,28 66,46 C66,60 48,70 40,78 C32,70 14,60 14,46 C14,28 36,10 40,2 Z\" fill=\"none\" stroke=\"#6B4230\" stroke-width=\"2\"/>\n  </g>\n  <g id=\"Text\" transform=\"translate(80 59)\">\n    <path d=\"M13.37 0.73Q10.88 0.73 8.47 0.07Q6.06 -0.58 4.02 -1.75Q1.97 -2.93 0.52 -4.52L5.54 -9.63Q6.96 -8.09 8.87 -7.26Q10.79 -6.44 13.05 -6.44Q14.62 -6.44 15.44 -6.89Q16.27 -7.34 16.27 -8.18Q16.27 -9.22 15.27 -9.77Q14.27 -10.32 12.7 -10.74Q11.14 -11.17 9.4 -11.7Q7.66 -12.24 6.08 -13.17Q4.5 -14.09 3.51 -15.73Q2.52 -17.37 2.52 -19.95Q2.52 -22.65 3.92 -24.66Q5.31 -26.68 7.86 -27.83Q10.41 -28.97 13.86 -28.97Q17.43 -28.97 20.49 -27.74Q23.55 -26.51 25.46 -24.04L20.42 -18.94Q19.08 -20.5 17.43 -21.16Q15.78 -21.81 14.18 -21.81Q12.67 -21.81 11.93 -21.36Q11.19 -20.91 11.19 -20.13Q11.19 -19.23 12.18 -18.7Q13.17 -18.18 14.73 -17.78Q16.3 -17.37 18.02 -16.81Q19.75 -16.24 21.32 -15.24Q22.88 -14.24 23.87 -12.59Q24.85 -10.93 24.85 -8.29Q24.85 -4.15 21.75 -1.71Q18.65 0.73 13.37 0.73Z M48.31 0V-16.04Q48.31 -18.27 46.95 -19.62Q45.59 -20.97 43.48 -20.97Q42.04 -20.97 40.93 -20.36Q39.82 -19.75 39.19 -18.63Q38.57 -17.52 38.57 -16.04L35.12 -17.72Q35.12 -21.05 36.53 -23.53Q37.93 -26.01 40.42 -27.39Q42.91 -28.77 46.15 -28.77Q49.45 -28.77 51.94 -27.39Q54.43 -26.01 55.81 -23.61Q57.19 -21.2 57.19 -18.04V0ZM29.7 0V-42.11H38.57V0Z M74.65 0.58Q70.76 0.58 67.7 -1.33Q64.64 -3.25 62.89 -6.55Q61.13 -9.86 61.13 -14.07Q61.13 -18.3 62.89 -21.62Q64.64 -24.94 67.7 -26.85Q70.76 -28.77 74.65 -28.77Q77.49 -28.77 79.78 -27.67Q82.07 -26.56 83.51 -24.62Q84.94 -22.68 85.14 -20.18V-8Q84.94 -5.51 83.52 -3.57Q82.1 -1.62 79.79 -0.52Q77.49 0.58 74.65 0.58ZM76.44 -7.42Q79.29 -7.42 81.03 -9.29Q82.77 -11.17 82.77 -14.09Q82.77 -16.07 81.98 -17.56Q81.2 -19.05 79.78 -19.91Q78.36 -20.76 76.47 -20.76Q74.62 -20.76 73.2 -19.91Q71.78 -19.05 70.95 -17.55Q70.12 -16.04 70.12 -14.09Q70.12 -12.15 70.93 -10.64Q71.75 -9.13 73.18 -8.28Q74.62 -7.42 76.44 -7.42ZM82.39 0V-7.57L83.72 -14.44L82.39 -21.26V-28.19H91.12V0Z M97.38 0V-42.11H106.26V0Z M112.52 0V-42.11H121.39V0Z M141.23 0.64Q136.85 0.64 133.36 -1.31Q129.86 -3.25 127.83 -6.61Q125.8 -9.98 125.8 -14.15Q125.8 -18.33 127.82 -21.63Q129.83 -24.94 133.33 -26.88Q136.82 -28.83 141.2 -28.83Q145.61 -28.83 149.09 -26.9Q152.57 -24.97 154.6 -21.65Q156.63 -18.33 156.63 -14.15Q156.63 -9.98 154.61 -6.61Q152.6 -3.25 149.12 -1.31Q145.64 0.64 141.23 0.64ZM141.2 -7.42Q143.12 -7.42 144.56 -8.27Q146.02 -9.11 146.81 -10.63Q147.61 -12.15 147.61 -14.12Q147.61 -16.1 146.78 -17.59Q145.96 -19.08 144.54 -19.92Q143.12 -20.76 141.2 -20.76Q139.34 -20.76 137.9 -19.91Q136.45 -19.05 135.63 -17.56Q134.82 -16.07 134.82 -14.09Q134.82 -12.15 135.63 -10.63Q136.45 -9.11 137.9 -8.27Q139.34 -7.42 141.2 -7.42Z M165.07 0V-39.85H173.94V0ZM158.69 -20.65V-28.19H180.32V-20.65Z\" fill=\"#3D2415\" transform=\"translate(2.5 3)\"/>\n    <path d=\"M13.37 0.73Q10.88 0.73 8.47 0.07Q6.06 -0.58 4.02 -1.75Q1.97 -2.93 0.52 -4.52L5.54 -9.63Q6.96 -8.09 8.87 -7.26Q10.79 -6.44 13.05 -6.44Q14.62 -6.44 15.44 -6.89Q16.27 -7.34 16.27 -8.18Q16.27 -9.22 15.27 -9.77Q14.27 -10.32 12.7 -10.74Q11.14 -11.17 9.4 -11.7Q7.66 -12.24 6.08 -13.17Q4.5 -14.09 3.51 -15.73Q2.52 -17.37 2.52 -19.95Q2.52 -22.65 3.92 -24.66Q5.31 -26.68 7.86 -27.83Q10.41 -28.97 13.86 -28.97Q17.43 -28.97 20.49 -27.74Q23.55 -26.51 25.46 -24.04L20.42 -18.94Q19.08 -20.5 17.43 -21.16Q15.78 -21.81 14.18 -21.81Q12.67 -21.81 11.93 -21.36Q11.19 -20.91 11.19 -20.13Q11.19 -19.23 12.18 -18.7Q13.17 -18.18 14.73 -17.78Q16.3 -17.37 18.02 -16.81Q19.75 -16.24 21.32 -15.24Q22.88 -14.24 23.87 -12.59Q24.85 -10.93 24.85 -8.29Q24.85 -4.15 21.75 -1.71Q18.65 0.73 13.37 0.73Z M48.31 0V-16.04Q48.31 -18.27 46.95 -19.62Q45.59 -20.97 43.48 -20.97Q42.04 -20.97 40.93 -20.36Q39.82 -19.75 39.19 -18.63Q38.57 -17.52 38.57 -16.04L35.12 -17.72Q35.12 -21.05 36.53 -23.53Q37.93 -26.01 40.42 -27.39Q42.91 -28.77 46.15 -28.77Q49.45 -28.77 51.94 -27.39Q54.43 -26.01 55.81 -23.61Q57.19 -21.2 57.19 -18.04V0ZM29.7 0V-42.11H38.57V0Z M74.65 0.58Q70.76 0.58 67.7 -1.33Q64.64 -3.25 62.89 -6.55Q61.13 -9.86 61.13 -14.07Q61.13 -18.3 62.89 -21.62Q64.64 -24.94 67.7 -26.85Q70.76 -28.77 74.65 -28.77Q77.49 -28.77 79.78 -27.67Q82.07 -26.56 83.51 -24.62Q84.94 -22.68 85.14 -20.18V-8Q84.94 -5.51 83.52 -3.57Q82.1 -1.62 79.79 -0.52Q77.49 0.58 74.65 0.58ZM76.44 -7.42Q79.29 -7.42 81.03 -9.29Q82.77 -11.17 82.77 -14.09Q82.77 -16.07 81.98 -17.56Q81.2 -19.05 79.78 -19.91Q78.36 -20.76 76.47 -20.76Q74.62 -20.76 73.2 -19.91Q71.78 -19.05 70.95 -17.55Q70.12 -16.04 70.12 -14.09Q70.12 -12.15 70.93 -10.64Q71.75 -9.13 73.18 -8.28Q74.62 -7.42 76.44 -7.42ZM82.39 0V-7.57L83.72 -14.44L82.39 -21.26V-28.19H91.12V0Z M97.38 0V-42.11H106.26V0Z M112.52 0V-42.11H121.39V0Z M141.23 0.64Q136.85 0.64 133.36 -1.31Q129.86 -3.25 127.83 -6.61Q125.8 -9.98 125.8 -14.15Q125.8 -18.33 127.82 -21.63Q129.83 -24.94 133.33 -26.88Q136.82 -28.83 141.2 -28.83Q145.61 -28.83 149.09 -26.9Q152.57 -24.97 154.6 -21.65Q156.63 -18.33 156.63 -14.15Q156.63 -9.98 154.61 -6.61Q152.6 -3.25 149.12 -1.31Q145.64 0.64 141.23 0.64ZM141.2 -7.42Q143.12 -7.42 144.56 -8.27Q146.02 -9.11 146.81 -10.63Q147.61 -12.15 147.61 -14.12Q147.61 -16.1 146.78 -17.59Q145.96 -19.08 144.54 -19.92Q143.12 -20.76 141.2 -20.76Q139.34 -20.76 137.9 -19.91Q136.45 -19.05 135.63 -17.56Q134.82 -16.07 134.82 -14.09Q134.82 -12.15 135.63 -10.63Q136.45 -9.11 137.9 -8.27Q139.34 -7.42 141.2 -7.42Z M165.07 0V-39.85H173.94V0ZM158.69 -20.65V-28.19H180.32V-20.65Z\" fill=\"none\" stroke=\"#6B4230\" stroke-width=\"3.5\" stroke-linejoin=\"round\"/>\n    <path d=\"M13.37 0.73Q10.88 0.73 8.47 0.07Q6.06 -0.58 4.02 -1.75Q1.97 -2.93 0.52 -4.52L5.54 -9.63Q6.96 -8.09 8.87 -7.26Q10.79 -6.44 13.05 -6.44Q14.62 -6.44 15.44 -6.89Q16.27 -7.34 16.27 -8.18Q16.27 -9.22 15.27 -9.77Q14.27 -10.32 12.7 -10.74Q11.14 -11.17 9.4 -11.7Q7.66 -12.24 6.08 -13.17Q4.5 -14.09 3.51 -15.73Q2.52 -17.37 2.52 -19.95Q2.52 -22.65 3.92 -24.66Q5.31 -26.68 7.86 -27.83Q10.41 -28.97 13.86 -28.97Q17.43 -28.97 20.49 -27.74Q23.55 -26.51 25.46 -24.04L20.42 -18.94Q19.08 -20.5 17.43 -21.16Q15.78 -21.81 14.18 -21.81Q12.67 -21.81 11.93 -21.36Q11.19 -20.91 11.19 -20.13Q11.19 -19.23 12.18 -18.7Q13.17 -18.18 14.73 -17.78Q16.3 -17.37 18.02 -16.81Q19.75 -16.24 21.32 -15.24Q22.88 -14.24 23.87 -12.59Q24.85 -10.93 24.85 -8.29Q24.85 -4.15 21.75 -1.71Q18.65 0.73 13.37 0.73Z M48.31 0V-16.04Q48.31 -18.27 46.95 -19.62Q45.59 -20.97 43.48 -20.97Q42.04 -20.97 40.93 -20.36Q39.82 -19.75 39.19 -18.63Q38.57 -17.52 38.57 -16.04L35.12 -17.72Q35.12 -21.05 36.53 -23.53Q37.93 -26.01 40.42 -27.39Q42.91 -28.77 46.15 -28.77Q49.45 -28.77 51.94 -27.39Q54.43 -26.01 55.81 -23.61Q57.19 -21.2 57.19 -18.04V0ZM29.7 0V-42.11H38.57V0Z M74.65 0.58Q70.76 0.58 67.7 -1.33Q64.64 -3.25 62.89 -6.55Q61.13 -9.86 61.13 -14.07Q61.13 -18.3 62.89 -21.62Q64.64 -24.94 67.7 -26.85Q70.76 -28.77 74.65 -28.77Q77.49 -28.77 79.78 -27.67Q82.07 -26.56 83.51 -24.62Q84.94 -22.68 85.14 -20.18V-8Q84.94 -5.51 83.52 -3.57Q82.1 -1.62 79.79 -0.52Q77.49 0.58 74.65 0.58ZM76.44 -7.42Q79.29 -7.42 81.03 -9.29Q82.77 -11.17 82.77 -14.09Q82.77 -16.07 81.98 -17.56Q81.2 -19.05 79.78 -19.91Q78.36 -20.76 76.47 -20.76Q74.62 -20.76 73.2 -19.91Q71.78 -19.05 70.95 -17.55Q70.12 -16.04 70.12 -14.09Q70.12 -12.15 70.93 -10.64Q71.75 -9.13 73.18 -8.28Q74.62 -7.42 76.44 -7.42ZM82.39 0V-7.57L83.72 -14.44L82.39 -21.26V-28.19H91.12V0Z M97.38 0V-42.11H106.26V0Z M112.52 0V-42.11H121.39V0Z M141.23 0.64Q136.85 0.64 133.36 -1.31Q129.86 -3.25 127.83 -6.61Q125.8 -9.98 125.8 -14.15Q125.8 -18.33 127.82 -21.63Q129.83 -24.94 133.33 -26.88Q136.82 -28.83 141.2 -28.83Q145.61 -28.83 149.09 -26.9Q152.57 -24.97 154.6 -21.65Q156.63 -18.33 156.63 -14.15Q156.63 -9.98 154.61 -6.61Q152.6 -3.25 149.12 -1.31Q145.64 0.64 141.23 0.64ZM141.2 -7.42Q143.12 -7.42 144.56 -8.27Q146.02 -9.11 146.81 -10.63Q147.61 -12.15 147.61 -14.12Q147.61 -16.1 146.78 -17.59Q145.96 -19.08 144.54 -19.92Q143.12 -20.76 141.2 -20.76Q139.34 -20.76 137.9 -19.91Q136.45 -19.05 135.63 -17.56Q134.82 -16.07 134.82 -14.09Q134.82 -12.15 135.63 -10.63Q136.45 -9.11 137.9 -8.27Q139.34 -7.42 141.2 -7.42Z M165.07 0V-39.85H173.94V0ZM158.69 -20.65V-28.19H180.32V-20.65Z\" fill=\"#E8A86B\"/>\n  </g>\n</svg>`;\n\nfunction createOverlay(canvas: HTMLCanvasElement, bg: string): HTMLDivElement {\n    const overlay = document.createElement(\"div\");\n    overlay.style.cssText = `\n        position: absolute;\n        inset: 0;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background: ${bg};\n        z-index: 10000;\n    `;\n\n    const parent = canvas.parentElement;\n    if (parent) {\n        if (getComputedStyle(parent).position === \"static\") {\n            parent.style.position = \"relative\";\n        }\n        parent.appendChild(overlay);\n    }\n\n    return overlay;\n}\n\nfunction createProgressBar(theme: Theme): { track: HTMLDivElement; bar: HTMLDivElement } {\n    const track = document.createElement(\"div\");\n    track.style.cssText = `\n        width: 228px;\n        height: 4px;\n        background: ${theme.track};\n        border-radius: 2px;\n        overflow: hidden;\n    `;\n\n    const bar = document.createElement(\"div\");\n    bar.style.cssText = `\n        width: 0%;\n        height: 100%;\n        background: ${theme.bar};\n        transition: width 0.15s ease-out;\n    `;\n    track.appendChild(bar);\n\n    return { track, bar };\n}\n\nfunction shallotLoading(canvas: HTMLCanvasElement, theme: Theme): Loading {\n    let overlay: HTMLDivElement | null = null;\n    let bar: HTMLDivElement | null = null;\n\n    return {\n        show() {\n            overlay = createOverlay(canvas, theme.bg);\n\n            const logo = document.createElement(\"div\");\n            logo.innerHTML = LOGO_SVG;\n            logo.style.cssText = \"width: 228px; height: 64px; margin-bottom: 24px;\";\n            overlay.appendChild(logo);\n\n            const progressBar = createProgressBar(theme);\n            bar = progressBar.bar;\n            overlay.appendChild(progressBar.track);\n\n            return () => {\n                overlay?.remove();\n                overlay = null;\n                bar = null;\n            };\n        },\n\n        update(progress) {\n            if (bar) bar.style.width = `${progress * 100}%`;\n        },\n    };\n}\n\nfunction minimalLoading(canvas: HTMLCanvasElement, theme: Theme): Loading {\n    let overlay: HTMLDivElement | null = null;\n    let bar: HTMLDivElement | null = null;\n\n    return {\n        show() {\n            overlay = createOverlay(canvas, theme.bg);\n            const progressBar = createProgressBar(theme);\n            bar = progressBar.bar;\n            overlay.appendChild(progressBar.track);\n\n            return () => {\n                overlay?.remove();\n                overlay = null;\n                bar = null;\n            };\n        },\n\n        update(progress) {\n            if (bar) bar.style.width = `${progress * 100}%`;\n        },\n    };\n}\n\nexport const shallotDark = (canvas: HTMLCanvasElement): Loading => shallotLoading(canvas, dark);\nexport const shallotLight = (canvas: HTMLCanvasElement): Loading => shallotLoading(canvas, light);\nexport const minimalDark = (canvas: HTMLCanvasElement): Loading => minimalLoading(canvas, dark);\nexport const minimalLight = (canvas: HTMLCanvasElement): Loading => minimalLoading(canvas, light);\n\nexport { shallotDark as canvasLoading };\n","import { StateBuilder, type Plugin } from \"../core/builder\";\nimport { TransformsPlugin } from \"./transforms\";\nimport { InputPlugin } from \"./input\";\nimport { ComputePlugin, initCanvas } from \"./compute\";\nimport { RenderPlugin } from \"./render\";\nimport { ActivityPlugin, spinnerDark } from \"./activity\";\nimport { shallotDark } from \"./loading\";\n\nexport const DEFAULT_PLUGINS: readonly Plugin[] = [\n    ActivityPlugin,\n    TransformsPlugin,\n    InputPlugin,\n    ComputePlugin,\n    RenderPlugin,\n];\n\nStateBuilder.defaultPlugins = DEFAULT_PLUGINS;\nStateBuilder.initCanvas = initCanvas;\nStateBuilder.defaultLoading = shallotDark;\nActivityPlugin.spinner = spinnerDark;\n","import { setTraits } from \"../../core/component\";\nimport { clamp, lookAt, type State, type System, type Plugin } from \"../../core\";\nimport { Transform } from \"../../standard/transforms\";\nimport { Inputs, InputPlugin, type Mouse } from \"../../standard/input\";\nimport { Camera, CameraMode } from \"../../standard/render/camera\";\n\nconst Tau = Math.PI * 2;\n\nexport const OrbitButton = {\n    Left: 0,\n    Middle: 1,\n    Right: 2,\n} as const;\n\nexport const Orbit = {\n    target: [] as number[],\n    yaw: [] as number[],\n    pitch: [] as number[],\n    distance: [] as number[],\n    targetYaw: [] as number[],\n    targetPitch: [] as number[],\n    targetDistance: [] as number[],\n    minPitch: [] as number[],\n    maxPitch: [] as number[],\n    minDistance: [] as number[],\n    maxDistance: [] as number[],\n    minSize: [] as number[],\n    maxSize: [] as number[],\n    targetSize: [] as number[],\n    smoothness: [] as number[],\n    sensitivity: [] as number[],\n    zoomSpeed: [] as number[],\n    button: [] as number[],\n};\n\nsetTraits(Orbit, {\n    defaults: () => ({\n        target: 0,\n        yaw: 0,\n        pitch: Math.PI / 6,\n        distance: 8,\n        targetYaw: 0,\n        targetPitch: Math.PI / 6,\n        targetDistance: 10,\n        minPitch: -Math.PI / 2 + 0.01,\n        maxPitch: Math.PI / 2 - 0.01,\n        minDistance: 1,\n        maxDistance: 25,\n        minSize: 0.5,\n        maxSize: 50,\n        targetSize: 5,\n        smoothness: 0.3,\n        sensitivity: 0.005,\n        zoomSpeed: 0.025,\n        button: OrbitButton.Left,\n    }),\n});\n\nfunction smoothLerp(smoothness: number, dt: number): number {\n    const s = Math.max(0, Math.min(1, smoothness));\n    return 1 - Math.pow(1 - s, dt * 60);\n}\n\nfunction normalizeAngle(a: number): number {\n    return ((a % Tau) + Tau) % Tau;\n}\n\nfunction angleDiff(from: number, to: number): number {\n    const diff = normalizeAngle(to - from);\n    return diff > Math.PI ? diff - Tau : diff;\n}\n\nfunction isOrbitButton(mouse: Readonly<Mouse>, button: number): boolean {\n    if (button === OrbitButton.Left) return mouse.left;\n    if (button === OrbitButton.Middle) return mouse.middle;\n    return mouse.right;\n}\n\nexport const OrbitSystem: System = {\n    group: \"simulation\",\n\n    update(state: State) {\n        const input = Inputs.from(state);\n        const dt = state.time.deltaTime;\n\n        for (const eid of state.query([Orbit, Transform])) {\n            const sensitivity = Orbit.sensitivity[eid];\n            const zoomSpeed = Orbit.zoomSpeed[eid];\n            const minPitch = Orbit.minPitch[eid];\n            const maxPitch = Orbit.maxPitch[eid];\n            const smoothness = Orbit.smoothness[eid];\n\n            const hasCamera = state.hasComponent(eid, Camera);\n            const isOrtho = hasCamera && Camera.mode[eid] === CameraMode.Orthographic;\n\n            if (input && isOrbitButton(input.mouse, Orbit.button[eid])) {\n                Orbit.targetYaw[eid] -= input.mouse.deltaX * sensitivity;\n                Orbit.targetPitch[eid] = clamp(\n                    Orbit.targetPitch[eid] + input.mouse.deltaY * sensitivity,\n                    minPitch,\n                    maxPitch\n                );\n            }\n\n            if (input && input.mouse.scroll !== 0) {\n                if (isOrtho) {\n                    const currentSize = Orbit.targetSize[eid];\n                    const sizeScale = Math.max(0.1, currentSize * 0.08);\n                    const zoomDelta = input.mouse.scroll * zoomSpeed * sizeScale;\n                    Orbit.targetSize[eid] = clamp(\n                        currentSize + zoomDelta,\n                        Orbit.minSize[eid],\n                        Orbit.maxSize[eid]\n                    );\n                } else {\n                    const currentDistance = Orbit.targetDistance[eid];\n                    const distanceScale = Math.max(0.3, currentDistance * 0.08);\n                    const zoomDelta = input.mouse.scroll * zoomSpeed * distanceScale;\n                    Orbit.targetDistance[eid] = clamp(\n                        currentDistance + zoomDelta,\n                        Orbit.minDistance[eid],\n                        Orbit.maxDistance[eid]\n                    );\n                }\n            }\n\n            const t = smoothLerp(smoothness, dt);\n            Orbit.yaw[eid] += angleDiff(Orbit.yaw[eid], Orbit.targetYaw[eid]) * t;\n            Orbit.pitch[eid] += (Orbit.targetPitch[eid] - Orbit.pitch[eid]) * t;\n            Orbit.distance[eid] += (Orbit.targetDistance[eid] - Orbit.distance[eid]) * t;\n\n            if (isOrtho) {\n                const currentSize = Camera.size[eid];\n                const targetSize = Orbit.targetSize[eid];\n                Camera.size[eid] = currentSize + (targetSize - currentSize) * t;\n            }\n\n            const yaw = Orbit.yaw[eid];\n            const pitch = Orbit.pitch[eid];\n            const distance = Orbit.distance[eid];\n\n            let targetX = 0,\n                targetY = 0,\n                targetZ = 0;\n            const targetEid = Orbit.target[eid];\n            if (targetEid && state.hasComponent(targetEid, Transform)) {\n                targetX = Transform.posX[targetEid];\n                targetY = Transform.posY[targetEid];\n                targetZ = Transform.posZ[targetEid];\n            }\n\n            const camX = targetX + distance * Math.cos(pitch) * Math.sin(yaw);\n            const camY = targetY + distance * Math.sin(pitch);\n            const camZ = targetZ + distance * Math.cos(pitch) * Math.cos(yaw);\n\n            Transform.posX[eid] = camX;\n            Transform.posY[eid] = camY;\n            Transform.posZ[eid] = camZ;\n\n            const rotation = lookAt(camX, camY, camZ, targetX, targetY, targetZ);\n            Transform.quatX[eid] = rotation.x;\n            Transform.quatY[eid] = rotation.y;\n            Transform.quatZ[eid] = rotation.z;\n            Transform.quatW[eid] = rotation.w;\n        }\n    },\n};\n\nexport const OrbitPlugin: Plugin = {\n    systems: [OrbitSystem],\n    components: { Orbit },\n    dependencies: [InputPlugin],\n};\n","import {\n    MAX_ENTITIES,\n    resource,\n    createFieldProxy,\n    type Plugin,\n    type State,\n    type System,\n    type FieldProxy,\n} from \"../../core\";\nimport { setTraits } from \"../../core/component\";\nimport { Compute, ComputePlugin, createEntityIdBuffer } from \"../../standard/compute\";\nimport {\n    Render,\n    RenderPlugin,\n    Pass,\n    registerDraw,\n    type Draw,\n    type SharedPassContext,\n} from \"../../standard/render\";\nimport { DEPTH_FORMAT } from \"../../standard/render/scene\";\nimport { SCENE_STRUCT_WGSL } from \"../../standard/render/shaders\";\nimport { Transform } from \"../../standard/transforms\";\n\nexport const LineData = {\n    data: new Float32Array(MAX_ENTITIES * 12),\n};\n\nfunction packedColorProxy(data: Float32Array, stride: number, offset: number): FieldProxy {\n    function getValue(eid: number): number {\n        const o = eid * stride + offset;\n        const r = Math.round(data[o] * 255);\n        const g = Math.round(data[o + 1] * 255);\n        const b = Math.round(data[o + 2] * 255);\n        return (r << 16) | (g << 8) | b;\n    }\n\n    function setValue(eid: number, value: number): void {\n        const o = eid * stride + offset;\n        data[o] = ((value >> 16) & 0xff) / 255;\n        data[o + 1] = ((value >> 8) & 0xff) / 255;\n        data[o + 2] = (value & 0xff) / 255;\n        data[o + 3] = 1;\n    }\n\n    return new Proxy([] as unknown as FieldProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nconst data = LineData.data;\n\nexport const Line: {\n    offsetX: FieldProxy;\n    offsetY: FieldProxy;\n    offsetZ: FieldProxy;\n    thickness: FieldProxy;\n    visible: FieldProxy;\n    opacity: FieldProxy;\n    color: FieldProxy;\n    colorR: FieldProxy;\n    colorG: FieldProxy;\n    colorB: FieldProxy;\n} = {\n    offsetX: createFieldProxy(data, 12, 0),\n    offsetY: createFieldProxy(data, 12, 1),\n    offsetZ: createFieldProxy(data, 12, 2),\n    thickness: createFieldProxy(data, 12, 3),\n    visible: createFieldProxy(data, 12, 4),\n    opacity: createFieldProxy(data, 12, 7),\n    color: packedColorProxy(data, 12, 8),\n    colorR: createFieldProxy(data, 12, 8),\n    colorG: createFieldProxy(data, 12, 9),\n    colorB: createFieldProxy(data, 12, 10),\n};\n\nsetTraits(Line, {\n    defaults: () => ({\n        offsetX: 1,\n        offsetY: 0,\n        offsetZ: 0,\n        thickness: 2,\n        visible: 1,\n        opacity: 1,\n        color: 0xffffff,\n    }),\n});\n\nexport interface LinesConfig {\n    scene: GPUBuffer;\n    lines: GPUBuffer;\n    entityIds: GPUBuffer;\n    matrices: GPUBuffer;\n    getCount: () => number;\n}\n\nexport const lineShader = /* wgsl */ `\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) color: vec4<f32>,\n    @location(1) dist: f32,\n    @location(2) halfWidth: f32,\n}\n\n${SCENE_STRUCT_WGSL}\n\nstruct LineData {\n    offset: vec3<f32>,\n    thickness: f32,\n    visible: f32,\n    _pad1: f32,\n    _pad2: f32,\n    opacity: f32,\n    color: vec4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> scene: Scene;\n@group(0) @binding(1) var<storage, read> entityIds: array<u32>;\n@group(0) @binding(2) var<storage, read> lines: array<LineData>;\n@group(0) @binding(3) var<storage, read> matrices: array<mat4x4<f32>>;\n\n@vertex\nfn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VertexOutput {\n    let eid = entityIds[iid];\n    let line = lines[eid];\n    let transform = matrices[eid];\n\n    let start = transform[3].xyz;\n    let rotation = mat3x3<f32>(transform[0].xyz, transform[1].xyz, transform[2].xyz);\n    let end = start + rotation * line.offset;\n\n    let startClip = scene.viewProj * vec4(start, 1.0);\n    let endClip = scene.viewProj * vec4(end, 1.0);\n\n    let startNDC = startClip.xy / startClip.w;\n    let endNDC = endClip.xy / endClip.w;\n\n    let dir = endNDC - startNDC;\n    let len = length(dir);\n    let normDir = select(vec2(1.0, 0.0), dir / len, len > 0.0001);\n\n    let scale = scene.viewport.y / 1080.0;\n    let halfWidth = line.thickness * 0.5 * scale;\n    let aaPadding = 1.0;\n    let totalHalf = halfWidth + aaPadding;\n    let perpNDC = vec2(-normDir.y, normDir.x) * totalHalf * 2.0 / scene.viewport;\n\n    var pos: vec2<f32>;\n    var t: f32;\n    var edge: f32;\n    switch vid {\n        case 0u: { pos = startNDC - perpNDC; t = 0.0; edge = -1.0; }\n        case 1u: { pos = startNDC + perpNDC; t = 0.0; edge = 1.0; }\n        case 2u: { pos = endNDC + perpNDC; t = 1.0; edge = 1.0; }\n        case 3u: { pos = startNDC - perpNDC; t = 0.0; edge = -1.0; }\n        case 4u: { pos = endNDC + perpNDC; t = 1.0; edge = 1.0; }\n        case 5u: { pos = endNDC - perpNDC; t = 1.0; edge = -1.0; }\n        default: { pos = startNDC; t = 0.0; edge = 0.0; }\n    }\n\n    let depth = mix(startClip.z / startClip.w, endClip.z / endClip.w, t);\n\n    let pixelDist = edge * totalHalf;\n\n    var out: VertexOutput;\n    out.position = vec4(pos, depth, 1.0);\n    out.color = vec4(line.color.rgb, line.color.a * line.opacity);\n    out.dist = pixelDist;\n    out.halfWidth = halfWidth;\n    return out;\n}\n\nstruct FragmentOutput {\n    @location(0) color: vec4<f32>,\n    @location(1) mask: f32,\n}\n\n@fragment\nfn fs(input: VertexOutput) -> FragmentOutput {\n    let dist = abs(input.dist);\n    let aaWidth = fwidth(input.dist);\n    let aa = 1.0 - smoothstep(input.halfWidth - aaWidth, input.halfWidth + aaWidth, dist);\n    var out: FragmentOutput;\n    out.color = vec4(input.color.rgb, input.color.a * aa);\n    out.mask = select(0.0, 1.0, aa > 0.01);\n    return out;\n}\n`;\n\nexport function createLinesPipeline(\n    device: GPUDevice,\n    format: GPUTextureFormat,\n    maskFormat: GPUTextureFormat\n): GPURenderPipeline {\n    const module = device.createShaderModule({ code: lineShader });\n\n    return device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n            module,\n            entryPoint: \"vs\",\n        },\n        fragment: {\n            module,\n            entryPoint: \"fs\",\n            targets: [\n                {\n                    format,\n                    blend: {\n                        color: {\n                            srcFactor: \"src-alpha\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                        alpha: {\n                            srcFactor: \"one\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                    },\n                },\n                {\n                    format: maskFormat,\n                    writeMask: GPUColorWrite.RED,\n                },\n            ],\n        },\n        primitive: {\n            topology: \"triangle-list\",\n        },\n        depthStencil: {\n            format: DEPTH_FORMAT,\n            depthCompare: \"less\",\n            depthWriteEnabled: false,\n        },\n    });\n}\n\nfunction createLinesDraw(config: LinesConfig): Draw {\n    let pipeline: GPURenderPipeline | null = null;\n    let bindGroup: GPUBindGroup | null = null;\n\n    return {\n        id: \"lines\",\n        pass: Pass.Overlay,\n        order: 0,\n\n        execute() {},\n\n        draw(pass: GPURenderPassEncoder, ctx: SharedPassContext) {\n            const count = config.getCount();\n            if (count === 0) return;\n\n            if (!pipeline) {\n                pipeline = createLinesPipeline(ctx.device, ctx.format, ctx.maskFormat);\n            }\n\n            if (!bindGroup) {\n                bindGroup = ctx.device.createBindGroup({\n                    layout: pipeline.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: { buffer: config.scene } },\n                        { binding: 1, resource: { buffer: config.entityIds } },\n                        { binding: 2, resource: { buffer: config.lines } },\n                        { binding: 3, resource: { buffer: config.matrices } },\n                    ],\n                });\n            }\n\n            pass.setPipeline(pipeline);\n            pass.setBindGroup(0, bindGroup);\n            pass.draw(6, count);\n        },\n    };\n}\n\nexport interface Lines {\n    buffer: GPUBuffer;\n    entityIds: GPUBuffer;\n    count: number;\n}\n\nexport const Lines = resource<Lines>(\"lines\");\n\nconst entityIdArray = new Uint32Array(MAX_ENTITIES);\n\nconst LinesSystem: System = {\n    group: \"draw\",\n\n    update(state: State) {\n        const compute = Compute.from(state);\n        const lines = Lines.from(state);\n        if (!compute || !lines) return;\n\n        const { device } = compute;\n\n        let count = 0;\n        for (const eid of state.query([Line, Transform])) {\n            if (!Line.visible[eid]) continue;\n            entityIdArray[count++] = eid;\n        }\n\n        const uploadCount = state.maxEid + 1;\n        device.queue.writeBuffer(lines.buffer, 0, LineData.data, 0, uploadCount * 12);\n        device.queue.writeBuffer(lines.entityIds, 0, entityIdArray, 0, count);\n        lines.count = count;\n    },\n};\n\nexport const LinesPlugin: Plugin = {\n    systems: [LinesSystem],\n    components: { Line },\n    dependencies: [ComputePlugin, RenderPlugin],\n\n    initialize(state: State) {\n        const compute = Compute.from(state);\n        const render = Render.from(state);\n        if (!compute || !render) return;\n\n        const { device } = compute;\n\n        const linesState: Lines = {\n            buffer: device.createBuffer({\n                label: \"lines\",\n                size: MAX_ENTITIES * 12 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            }),\n            entityIds: createEntityIdBuffer(device, MAX_ENTITIES),\n            count: 0,\n        };\n\n        state.setResource(Lines, linesState);\n\n        registerDraw(\n            state,\n            createLinesDraw({\n                scene: render.scene,\n                lines: linesState.buffer,\n                entityIds: linesState.entityIds,\n                matrices: render.matrices,\n                getCount: () => linesState.count,\n            })\n        );\n    },\n};\n","import {\n    MAX_ENTITIES,\n    resource,\n    createFieldProxy,\n    type Plugin,\n    type State,\n    type System,\n    type FieldProxy,\n} from \"../../core\";\nimport { setTraits } from \"../../core/component\";\nimport { Compute, ComputePlugin, createEntityIdBuffer } from \"../../standard/compute\";\nimport {\n    Render,\n    RenderPlugin,\n    Pass,\n    registerDraw,\n    type Draw,\n    type SharedPassContext,\n} from \"../../standard/render\";\nimport { DEPTH_FORMAT } from \"../../standard/render/scene\";\nimport { SCENE_STRUCT_WGSL } from \"../../standard/render/shaders\";\nimport { Transform } from \"../../standard/transforms\";\nimport { Line, Lines, LinesPlugin } from \"../lines\";\n\nexport const ArrowData = {\n    data: new Float32Array(MAX_ENTITIES * 4),\n};\n\nconst data = ArrowData.data;\n\nexport const Arrow: {\n    start: FieldProxy;\n    end: FieldProxy;\n    size: FieldProxy;\n} = {\n    start: createFieldProxy(data, 4, 0),\n    end: createFieldProxy(data, 4, 1),\n    size: createFieldProxy(data, 4, 2),\n};\n\nsetTraits(Arrow, {\n    defaults: () => ({\n        start: 0,\n        end: 1,\n        size: 1,\n    }),\n});\n\nexport interface ArrowsConfig {\n    scene: GPUBuffer;\n    arrows: GPUBuffer;\n    lines: GPUBuffer;\n    matrices: GPUBuffer;\n    entityIds: GPUBuffer;\n    getCount: () => number;\n}\n\nconst END_FLAG = 0x80000000;\n\nexport const arrowShader = /* wgsl */ `\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) color: vec4<f32>,\n}\n\n${SCENE_STRUCT_WGSL}\n\nstruct ArrowData {\n    start: f32,\n    end: f32,\n    size: f32,\n    _pad: f32,\n}\n\nstruct LineData {\n    offset: vec3<f32>,\n    thickness: f32,\n    visible: f32,\n    _pad1: f32,\n    _pad2: f32,\n    opacity: f32,\n    color: vec4<f32>,\n}\n\nconst END_FLAG: u32 = 0x80000000u;\n\n@group(0) @binding(0) var<uniform> scene: Scene;\n@group(0) @binding(1) var<storage, read> entityIds: array<u32>;\n@group(0) @binding(2) var<storage, read> arrows: array<ArrowData>;\n@group(0) @binding(3) var<storage, read> lines: array<LineData>;\n@group(0) @binding(4) var<storage, read> matrices: array<mat4x4<f32>>;\n\n@vertex\nfn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VertexOutput {\n    let packed = entityIds[iid];\n    let isEnd = (packed & END_FLAG) != 0u;\n    let eid = packed & ~END_FLAG;\n\n    let arrow = arrows[eid];\n    let line = lines[eid];\n    let transform = matrices[eid];\n\n    let scale = length(transform[0].xyz);\n\n    let start = transform[3].xyz;\n    let rotation = mat3x3<f32>(transform[0].xyz, transform[1].xyz, transform[2].xyz);\n    let end = start + rotation * line.offset;\n\n    let startClip = scene.viewProj * vec4(start, 1.0);\n    let endClip = scene.viewProj * vec4(end, 1.0);\n\n    let startScreen = (startClip.xy / startClip.w) * scene.viewport * 0.5;\n    let endScreen = (endClip.xy / endClip.w) * scene.viewport * 0.5;\n\n    let anchorScreen = select(startScreen, endScreen, isEnd);\n    let anchorDepth = select(startClip.z / startClip.w, endClip.z / endClip.w, isEnd);\n\n    let dir = endScreen - startScreen;\n    let len = length(dir);\n    let normDir = select(vec2(1.0, 0.0), dir / len, len > 0.0001);\n    let perp = vec2(-normDir.y, normDir.x);\n\n    let arrowDir = select(-normDir, normDir, isEnd);\n\n    let viewportScale = scene.viewport.y / 1080.0;\n    let arrowLengthPx = arrow.size * line.thickness * 4.0 * scale * viewportScale;\n    let arrowWidthPx = arrow.size * line.thickness * 2.0 * scale * viewportScale;\n\n    var posScreen: vec2<f32>;\n    switch vid {\n        case 0u: { posScreen = anchorScreen; }\n        case 1u: { posScreen = anchorScreen - arrowDir * arrowLengthPx + perp * arrowWidthPx; }\n        case 2u: { posScreen = anchorScreen - arrowDir * arrowLengthPx - perp * arrowWidthPx; }\n        default: { posScreen = anchorScreen; }\n    }\n\n    let pos = posScreen / (scene.viewport * 0.5);\n\n    var out: VertexOutput;\n    out.position = vec4(pos, anchorDepth, 1.0);\n    out.color = vec4(line.color.rgb, line.color.a * line.opacity);\n    return out;\n}\n\nstruct FragmentOutput {\n    @location(0) color: vec4<f32>,\n    @location(1) mask: f32,\n}\n\n@fragment\nfn fs(input: VertexOutput) -> FragmentOutput {\n    var out: FragmentOutput;\n    out.color = input.color;\n    out.mask = 1.0;\n    return out;\n}\n`;\n\nexport function createArrowsPipeline(\n    device: GPUDevice,\n    format: GPUTextureFormat,\n    maskFormat: GPUTextureFormat\n): GPURenderPipeline {\n    const module = device.createShaderModule({ code: arrowShader });\n\n    return device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n            module,\n            entryPoint: \"vs\",\n        },\n        fragment: {\n            module,\n            entryPoint: \"fs\",\n            targets: [\n                {\n                    format,\n                    blend: {\n                        color: {\n                            srcFactor: \"src-alpha\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                        alpha: {\n                            srcFactor: \"one\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                    },\n                },\n                {\n                    format: maskFormat,\n                    writeMask: GPUColorWrite.RED,\n                },\n            ],\n        },\n        primitive: {\n            topology: \"triangle-list\",\n        },\n        depthStencil: {\n            format: DEPTH_FORMAT,\n            depthCompare: \"less\",\n            depthWriteEnabled: false,\n        },\n    });\n}\n\nfunction createArrowsDraw(config: ArrowsConfig): Draw {\n    let pipeline: GPURenderPipeline | null = null;\n    let bindGroup: GPUBindGroup | null = null;\n\n    return {\n        id: \"arrows\",\n        pass: Pass.Overlay,\n        order: 1,\n\n        execute() {},\n\n        draw(pass: GPURenderPassEncoder, ctx: SharedPassContext) {\n            const count = config.getCount();\n            if (count === 0) return;\n\n            if (!pipeline) {\n                pipeline = createArrowsPipeline(ctx.device, ctx.format, ctx.maskFormat);\n            }\n\n            if (!bindGroup) {\n                bindGroup = ctx.device.createBindGroup({\n                    layout: pipeline.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: { buffer: config.scene } },\n                        { binding: 1, resource: { buffer: config.entityIds } },\n                        { binding: 2, resource: { buffer: config.arrows } },\n                        { binding: 3, resource: { buffer: config.lines } },\n                        { binding: 4, resource: { buffer: config.matrices } },\n                    ],\n                });\n            }\n\n            pass.setPipeline(pipeline);\n            pass.setBindGroup(0, bindGroup);\n            pass.draw(3, count);\n        },\n    };\n}\n\nexport interface Arrows {\n    buffer: GPUBuffer;\n    entityIds: GPUBuffer;\n    count: number;\n}\n\nexport const Arrows = resource<Arrows>(\"arrows\");\n\nconst arrowEntityIdArray = new Uint32Array(MAX_ENTITIES * 2);\n\nconst ArrowsSystem: System = {\n    group: \"draw\",\n\n    update(state: State) {\n        const compute = Compute.from(state);\n        const arrows = Arrows.from(state);\n        const lines = Lines.from(state);\n        if (!compute || !arrows || !lines) return;\n\n        const { device } = compute;\n\n        let count = 0;\n        for (const eid of state.query([Arrow, Line, Transform])) {\n            if (!Line.visible[eid]) continue;\n\n            if (Arrow.start[eid]) {\n                arrowEntityIdArray[count++] = eid;\n            }\n            if (Arrow.end[eid]) {\n                arrowEntityIdArray[count++] = eid | END_FLAG;\n            }\n        }\n\n        const uploadCount = state.maxEid + 1;\n        device.queue.writeBuffer(arrows.buffer, 0, ArrowData.data, 0, uploadCount * 4);\n        device.queue.writeBuffer(arrows.entityIds, 0, arrowEntityIdArray, 0, count);\n        arrows.count = count;\n    },\n};\n\nexport const ArrowsPlugin: Plugin = {\n    systems: [ArrowsSystem],\n    components: { Arrow },\n    dependencies: [ComputePlugin, RenderPlugin, LinesPlugin],\n\n    initialize(state: State) {\n        const compute = Compute.from(state);\n        const render = Render.from(state);\n        const lines = Lines.from(state);\n        if (!compute || !render || !lines) return;\n\n        const { device } = compute;\n\n        const arrowsState: Arrows = {\n            buffer: device.createBuffer({\n                label: \"arrows\",\n                size: MAX_ENTITIES * 4 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            }),\n            entityIds: createEntityIdBuffer(device, MAX_ENTITIES * 2),\n            count: 0,\n        };\n\n        state.setResource(Arrows, arrowsState);\n\n        registerDraw(\n            state,\n            createArrowsDraw({\n                scene: render.scene,\n                arrows: arrowsState.buffer,\n                lines: lines.buffer,\n                matrices: render.matrices,\n                entityIds: arrowsState.entityIds,\n                getCount: () => arrowsState.count,\n            })\n        );\n    },\n};\n","export interface Font {\n    unitsPerEm: number;\n    ascender: number;\n    descender: number;\n    lineGap: number;\n    glyphPath(char: string): string | null;\n    glyphBounds(char: string): [number, number, number, number] | null;\n    advance(char: string): number;\n    kerning(left: string, right: string): number;\n}\n\ninterface TableEntry {\n    offset: number;\n    length: number;\n}\n\ninterface Reader {\n    data: DataView;\n    offset: number;\n}\n\nfunction u8(r: Reader): number {\n    return r.data.getUint8(r.offset++);\n}\n\nfunction i16(r: Reader): number {\n    const v = r.data.getInt16(r.offset);\n    r.offset += 2;\n    return v;\n}\n\nfunction u16(r: Reader): number {\n    const v = r.data.getUint16(r.offset);\n    r.offset += 2;\n    return v;\n}\n\nfunction u32(r: Reader): number {\n    const v = r.data.getUint32(r.offset);\n    r.offset += 4;\n    return v;\n}\n\nfunction tag(r: Reader): string {\n    return String.fromCharCode(u8(r), u8(r), u8(r), u8(r));\n}\n\nfunction seek(r: Reader, offset: number): void {\n    r.offset = offset;\n}\n\nfunction parseTables(r: Reader): Map<string, TableEntry> {\n    const tables = new Map<string, TableEntry>();\n    seek(r, 0);\n\n    const sfntVersion = tag(r);\n    if (sfntVersion !== \"\\x00\\x01\\x00\\x00\" && sfntVersion !== \"OTTO\" && sfntVersion !== \"true\") {\n        throw new Error(\"Not a valid TTF/OTF font\");\n    }\n\n    const numTables = u16(r);\n    u16(r);\n    u16(r);\n    u16(r);\n\n    for (let i = 0; i < numTables; i++) {\n        const name = tag(r);\n        u32(r);\n        const offset = u32(r);\n        const length = u32(r);\n        tables.set(name, { offset, length });\n    }\n\n    return tables;\n}\n\nfunction parseHead(r: Reader, table: TableEntry): { unitsPerEm: number; indexToLocFormat: number } {\n    seek(r, table.offset + 18);\n    const unitsPerEm = u16(r);\n    seek(r, table.offset + 50);\n    const indexToLocFormat = i16(r);\n    return { unitsPerEm, indexToLocFormat };\n}\n\nfunction parseHhea(r: Reader, table: TableEntry): { ascender: number; descender: number; lineGap: number; numHMetrics: number } {\n    seek(r, table.offset + 4);\n    const ascender = i16(r);\n    const descender = i16(r);\n    const lineGap = i16(r);\n    seek(r, table.offset + 34);\n    const numHMetrics = u16(r);\n    return { ascender, descender, lineGap, numHMetrics };\n}\n\nfunction parseHmtx(r: Reader, table: TableEntry, numHMetrics: number, numGlyphs: number): { advances: Uint16Array } {\n    const advances = new Uint16Array(numGlyphs);\n    seek(r, table.offset);\n\n    let lastAdvance = 0;\n    for (let i = 0; i < numHMetrics; i++) {\n        lastAdvance = u16(r);\n        advances[i] = lastAdvance;\n        i16(r);\n    }\n    for (let i = numHMetrics; i < numGlyphs; i++) {\n        advances[i] = lastAdvance;\n    }\n\n    return { advances };\n}\n\nfunction parseMaxp(r: Reader, table: TableEntry): number {\n    seek(r, table.offset + 4);\n    return u16(r);\n}\n\nfunction parseLoca(r: Reader, table: TableEntry, numGlyphs: number, indexToLocFormat: number): Uint32Array {\n    const offsets = new Uint32Array(numGlyphs + 1);\n    seek(r, table.offset);\n\n    if (indexToLocFormat === 0) {\n        for (let i = 0; i <= numGlyphs; i++) {\n            offsets[i] = u16(r) * 2;\n        }\n    } else {\n        for (let i = 0; i <= numGlyphs; i++) {\n            offsets[i] = u32(r);\n        }\n    }\n\n    return offsets;\n}\n\nfunction parseCmap(r: Reader, table: TableEntry): Map<number, number> {\n    const charToGlyph = new Map<number, number>();\n    seek(r, table.offset);\n\n    u16(r);\n    const numSubtables = u16(r);\n\n    let format4Offset = -1;\n    let format12Offset = -1;\n\n    for (let i = 0; i < numSubtables; i++) {\n        const platformId = u16(r);\n        const encodingId = u16(r);\n        const offset = u32(r);\n\n        if (platformId === 3 && encodingId === 1) format4Offset = table.offset + offset;\n        if (platformId === 3 && encodingId === 10) format12Offset = table.offset + offset;\n        if (platformId === 0 && encodingId === 3) format4Offset = table.offset + offset;\n        if (platformId === 0 && encodingId === 4) format12Offset = table.offset + offset;\n    }\n\n    if (format12Offset !== -1) {\n        seek(r, format12Offset);\n        const format = u16(r);\n        if (format === 12) {\n            u16(r);\n            u32(r);\n            u32(r);\n            const numGroups = u32(r);\n            for (let i = 0; i < numGroups; i++) {\n                const startCode = u32(r);\n                const endCode = u32(r);\n                const startGlyph = u32(r);\n                for (let c = startCode; c <= endCode; c++) {\n                    charToGlyph.set(c, startGlyph + (c - startCode));\n                }\n            }\n            return charToGlyph;\n        }\n    }\n\n    if (format4Offset !== -1) {\n        seek(r, format4Offset);\n        const format = u16(r);\n        if (format === 4) {\n            u16(r);\n            u16(r);\n            const segCount = u16(r) / 2;\n            u16(r);\n            u16(r);\n            u16(r);\n\n            const endCodes: number[] = [];\n            for (let i = 0; i < segCount; i++) endCodes.push(u16(r));\n            u16(r);\n\n            const startCodes: number[] = [];\n            for (let i = 0; i < segCount; i++) startCodes.push(u16(r));\n\n            const idDeltas: number[] = [];\n            for (let i = 0; i < segCount; i++) idDeltas.push(i16(r));\n\n            const idRangeOffsetPos = r.offset;\n            const idRangeOffsets: number[] = [];\n            for (let i = 0; i < segCount; i++) idRangeOffsets.push(u16(r));\n\n            for (let i = 0; i < segCount; i++) {\n                const start = startCodes[i];\n                const end = endCodes[i];\n                const delta = idDeltas[i];\n                const rangeOffset = idRangeOffsets[i];\n\n                if (end === 0xffff) continue;\n\n                for (let c = start; c <= end; c++) {\n                    let glyphId: number;\n                    if (rangeOffset === 0) {\n                        glyphId = (c + delta) & 0xffff;\n                    } else {\n                        const glyphIdOffset = idRangeOffsetPos + i * 2 + rangeOffset + (c - start) * 2;\n                        seek(r, glyphIdOffset);\n                        glyphId = u16(r);\n                        if (glyphId !== 0) {\n                            glyphId = (glyphId + delta) & 0xffff;\n                        }\n                    }\n                    if (glyphId !== 0) {\n                        charToGlyph.set(c, glyphId);\n                    }\n                }\n            }\n        }\n    }\n\n    return charToGlyph;\n}\n\nfunction parseKern(r: Reader, table: TableEntry): Map<number, number> {\n    const kerning = new Map<number, number>();\n    seek(r, table.offset);\n\n    const version = u16(r);\n    if (version === 0) {\n        const numSubtables = u16(r);\n        for (let t = 0; t < numSubtables; t++) {\n            u16(r);\n            u16(r);\n            const coverage = u16(r);\n            const format = coverage >> 8;\n\n            if (format === 0) {\n                const numPairs = u16(r);\n                u16(r);\n                u16(r);\n                u16(r);\n\n                for (let i = 0; i < numPairs; i++) {\n                    const left = u16(r);\n                    const right = u16(r);\n                    const value = i16(r);\n                    kerning.set((left << 16) | right, value);\n                }\n            }\n        }\n    } else if (version === 1) {\n        u16(r);\n        const numSubtables = u32(r);\n        for (let t = 0; t < numSubtables; t++) {\n            const subtableLength = u32(r);\n            const coverage = u16(r);\n            const format = coverage & 0xff;\n\n            if (format === 0) {\n                const numPairs = u16(r);\n                u16(r);\n                u16(r);\n                u16(r);\n\n                for (let i = 0; i < numPairs; i++) {\n                    const left = u16(r);\n                    const right = u16(r);\n                    const value = i16(r);\n                    kerning.set((left << 16) | right, value);\n                }\n            } else {\n                seek(r, r.offset + subtableLength - 8);\n            }\n        }\n    }\n\n    return kerning;\n}\n\nconst ON_CURVE = 1;\nconst X_SHORT = 2;\nconst Y_SHORT = 4;\nconst REPEAT = 8;\nconst X_SAME = 16;\nconst Y_SAME = 32;\n\nfunction parseGlyph(r: Reader, glyfOffset: number, loca: Uint32Array, glyphId: number): { path: string; bounds: [number, number, number, number] } | null {\n    const start = loca[glyphId];\n    const end = loca[glyphId + 1];\n    if (start === end) return null;\n\n    seek(r, glyfOffset + start);\n    const numContours = i16(r);\n    const xMin = i16(r);\n    const yMin = i16(r);\n    const xMax = i16(r);\n    const yMax = i16(r);\n\n    if (numContours < 0) {\n        return parseCompositeGlyph(r, glyfOffset, loca);\n    }\n\n    const endPts: number[] = [];\n    for (let i = 0; i < numContours; i++) {\n        endPts.push(u16(r));\n    }\n\n    const numPoints = endPts.length > 0 ? endPts[endPts.length - 1] + 1 : 0;\n    const instructionLength = u16(r);\n    seek(r, r.offset + instructionLength);\n\n    const flags: number[] = [];\n    while (flags.length < numPoints) {\n        const flag = u8(r);\n        flags.push(flag);\n        if (flag & REPEAT) {\n            const repeat = u8(r);\n            for (let i = 0; i < repeat; i++) flags.push(flag);\n        }\n    }\n\n    const xs: number[] = [];\n    let x = 0;\n    for (let i = 0; i < numPoints; i++) {\n        const flag = flags[i];\n        if (flag & X_SHORT) {\n            const dx = u8(r);\n            x += flag & X_SAME ? dx : -dx;\n        } else if (!(flag & X_SAME)) {\n            x += i16(r);\n        }\n        xs.push(x);\n    }\n\n    const ys: number[] = [];\n    let y = 0;\n    for (let i = 0; i < numPoints; i++) {\n        const flag = flags[i];\n        if (flag & Y_SHORT) {\n            const dy = u8(r);\n            y += flag & Y_SAME ? dy : -dy;\n        } else if (!(flag & Y_SAME)) {\n            y += i16(r);\n        }\n        ys.push(y);\n    }\n\n    let path = \"\";\n    let contourStart = 0;\n\n    for (let c = 0; c < numContours; c++) {\n        const contourEnd = endPts[c];\n        const points: { x: number; y: number; on: boolean }[] = [];\n\n        for (let i = contourStart; i <= contourEnd; i++) {\n            points.push({ x: xs[i], y: ys[i], on: !!(flags[i] & ON_CURVE) });\n        }\n\n        if (points.length === 0) {\n            contourStart = contourEnd + 1;\n            continue;\n        }\n\n        let firstOn = 0;\n        while (firstOn < points.length && !points[firstOn].on) firstOn++;\n\n        if (firstOn === points.length) {\n            const mid = { x: (points[0].x + points[1].x) / 2, y: (points[0].y + points[1].y) / 2, on: true };\n            points.unshift(mid);\n            firstOn = 0;\n        }\n\n        const reordered = [...points.slice(firstOn), ...points.slice(0, firstOn)];\n        path += `M${reordered[0].x},${reordered[0].y}`;\n\n        let i = 1;\n        while (i < reordered.length) {\n            const p = reordered[i];\n            if (p.on) {\n                path += `L${p.x},${p.y}`;\n                i++;\n            } else {\n                const next = reordered[(i + 1) % reordered.length];\n                if (next.on) {\n                    path += `Q${p.x},${p.y},${next.x},${next.y}`;\n                    i += 2;\n                } else {\n                    const midX = (p.x + next.x) / 2;\n                    const midY = (p.y + next.y) / 2;\n                    path += `Q${p.x},${p.y},${midX},${midY}`;\n                    i++;\n                }\n            }\n        }\n\n        if (!reordered[reordered.length - 1].on) {\n            const last = reordered[reordered.length - 1];\n            path += `Q${last.x},${last.y},${reordered[0].x},${reordered[0].y}`;\n        }\n\n        path += \"Z\";\n        contourStart = contourEnd + 1;\n    }\n\n    return { path, bounds: [xMin, yMin, xMax, yMax] };\n}\n\nfunction parseCompositeGlyph(r: Reader, glyfOffset: number, loca: Uint32Array): { path: string; bounds: [number, number, number, number] } | null {\n    let path = \"\";\n    let xMin = Infinity, yMin = Infinity, xMax = -Infinity, yMax = -Infinity;\n    let hasMore = true;\n\n    while (hasMore) {\n        const flags = u16(r);\n        const glyphIndex = u16(r);\n\n        let dx = 0, dy = 0;\n        let a = 1, b = 0, c = 0, d = 1;\n\n        if (flags & 1) {\n            dx = i16(r);\n            dy = i16(r);\n        } else {\n            dx = (r.data.getInt8(r.offset++) + r.data.getInt8(r.offset++)) / 2;\n            dy = 0;\n        }\n\n        if (flags & 8) {\n            a = d = i16(r) / 16384;\n        } else if (flags & 64) {\n            a = i16(r) / 16384;\n            d = i16(r) / 16384;\n        } else if (flags & 128) {\n            a = i16(r) / 16384;\n            b = i16(r) / 16384;\n            c = i16(r) / 16384;\n            d = i16(r) / 16384;\n        }\n\n        const savedOffset = r.offset;\n        const component = parseGlyph(r, glyfOffset, loca, glyphIndex);\n        r.offset = savedOffset;\n\n        if (component) {\n            const transformed = transformPath(component.path, a, b, c, d, dx, dy);\n            path += transformed;\n            xMin = Math.min(xMin, component.bounds[0] * a + component.bounds[1] * b + dx);\n            yMin = Math.min(yMin, component.bounds[0] * c + component.bounds[1] * d + dy);\n            xMax = Math.max(xMax, component.bounds[2] * a + component.bounds[3] * b + dx);\n            yMax = Math.max(yMax, component.bounds[2] * c + component.bounds[3] * d + dy);\n        }\n\n        hasMore = !!(flags & 32);\n    }\n\n    if (path === \"\") return null;\n    return { path, bounds: [xMin, yMin, xMax, yMax] };\n}\n\nfunction transformPath(path: string, a: number, b: number, c: number, d: number, dx: number, dy: number): string {\n    return path.replace(/(-?\\d+(?:\\.\\d+)?),(-?\\d+(?:\\.\\d+)?)/g, (_, x, y) => {\n        const nx = parseFloat(x) * a + parseFloat(y) * b + dx;\n        const ny = parseFloat(x) * c + parseFloat(y) * d + dy;\n        return `${nx},${ny}`;\n    });\n}\n\nexport function parseFont(buffer: ArrayBuffer): Font {\n    const r: Reader = { data: new DataView(buffer), offset: 0 };\n    const tables = parseTables(r);\n\n    const headTable = tables.get(\"head\");\n    const hheaTable = tables.get(\"hhea\");\n    const hmtxTable = tables.get(\"hmtx\");\n    const maxpTable = tables.get(\"maxp\");\n    const cmapTable = tables.get(\"cmap\");\n    const locaTable = tables.get(\"loca\");\n    const glyfTable = tables.get(\"glyf\");\n    const kernTable = tables.get(\"kern\");\n\n    if (!headTable || !hheaTable || !hmtxTable || !maxpTable || !cmapTable || !locaTable || !glyfTable) {\n        throw new Error(\"Missing required font tables\");\n    }\n\n    const head = parseHead(r, headTable);\n    const hhea = parseHhea(r, hheaTable);\n    const numGlyphs = parseMaxp(r, maxpTable);\n    const hmtx = parseHmtx(r, hmtxTable, hhea.numHMetrics, numGlyphs);\n    const loca = parseLoca(r, locaTable, numGlyphs, head.indexToLocFormat);\n    const cmap = parseCmap(r, cmapTable);\n    const kern = kernTable ? parseKern(r, kernTable) : new Map<number, number>();\n\n    const glyphCache = new Map<number, { path: string; bounds: [number, number, number, number] } | null>();\n    const glyfOffset = glyfTable.offset;\n\n    function getGlyphId(char: string): number {\n        return cmap.get(char.codePointAt(0) ?? 0) ?? 0;\n    }\n\n    function getGlyph(glyphId: number): { path: string; bounds: [number, number, number, number] } | null {\n        if (glyphCache.has(glyphId)) return glyphCache.get(glyphId)!;\n        const glyph = parseGlyph(r, glyfOffset, loca, glyphId);\n        glyphCache.set(glyphId, glyph);\n        return glyph;\n    }\n\n    return {\n        unitsPerEm: head.unitsPerEm,\n        ascender: hhea.ascender,\n        descender: hhea.descender,\n        lineGap: hhea.lineGap,\n\n        glyphPath(char: string): string | null {\n            const glyph = getGlyph(getGlyphId(char));\n            return glyph?.path ?? null;\n        },\n\n        glyphBounds(char: string): [number, number, number, number] | null {\n            const glyph = getGlyph(getGlyphId(char));\n            return glyph?.bounds ?? null;\n        },\n\n        advance(char: string): number {\n            return hmtx.advances[getGlyphId(char)] ?? 0;\n        },\n\n        kerning(left: string, right: string): number {\n            const l = getGlyphId(left);\n            const r = getGlyphId(right);\n            return kern.get((l << 16) | r) ?? 0;\n        },\n    };\n}\n\nexport async function loadFont(url: string): Promise<Font> {\n    const response = await fetch(url);\n    if (!response.ok) throw new Error(`Failed to load font: ${response.statusText}`);\n    return parseFont(await response.arrayBuffer());\n}\n","interface LineSegment {\n    x1: number;\n    y1: number;\n    x2: number;\n    y2: number;\n}\n\nfunction pointOnQuadraticBezier(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    t: number\n): { x: number; y: number } {\n    const t2 = 1 - t;\n    return {\n        x: t2 * t2 * x0 + 2 * t2 * t * x1 + t * t * x2,\n        y: t2 * t2 * y0 + 2 * t2 * t * y1 + t * t * y2,\n    };\n}\n\nfunction pointOnCubicBezier(\n    x0: number,\n    y0: number,\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    x3: number,\n    y3: number,\n    t: number\n): { x: number; y: number } {\n    const t2 = 1 - t;\n    return {\n        x: t2 * t2 * t2 * x0 + 3 * t2 * t2 * t * x1 + 3 * t2 * t * t * x2 + t * t * t * x3,\n        y: t2 * t2 * t2 * y0 + 3 * t2 * t2 * t * y1 + 3 * t2 * t * t * y2 + t * t * t * y3,\n    };\n}\n\nexport function segmentPath(pathString: string, curvePoints = 16): LineSegment[] {\n    const segments: LineSegment[] = [];\n    const segmentRE = /([MLQCZ])([^MLQCZ]*)/g;\n    let match: RegExpExecArray | null;\n    let firstX = 0,\n        firstY = 0,\n        prevX = 0,\n        prevY = 0;\n\n    while ((match = segmentRE.exec(pathString))) {\n        const args = match[2]\n            .trim()\n            .split(/[,\\s]+/)\n            .filter((s) => s)\n            .map((v) => parseFloat(v));\n\n        switch (match[1]) {\n            case \"M\":\n                prevX = firstX = args[0];\n                prevY = firstY = args[1];\n                break;\n            case \"L\":\n                if (args[0] !== prevX || args[1] !== prevY) {\n                    segments.push({ x1: prevX, y1: prevY, x2: args[0], y2: args[1] });\n                }\n                prevX = args[0];\n                prevY = args[1];\n                break;\n            case \"Q\": {\n                let curveX = prevX;\n                let curveY = prevY;\n                for (let i = 1; i < curvePoints; i++) {\n                    const pt = pointOnQuadraticBezier(\n                        prevX,\n                        prevY,\n                        args[0],\n                        args[1],\n                        args[2],\n                        args[3],\n                        i / (curvePoints - 1)\n                    );\n                    segments.push({ x1: curveX, y1: curveY, x2: pt.x, y2: pt.y });\n                    curveX = pt.x;\n                    curveY = pt.y;\n                }\n                prevX = args[2];\n                prevY = args[3];\n                break;\n            }\n            case \"C\": {\n                let curveX = prevX;\n                let curveY = prevY;\n                for (let i = 1; i < curvePoints; i++) {\n                    const pt = pointOnCubicBezier(\n                        prevX,\n                        prevY,\n                        args[0],\n                        args[1],\n                        args[2],\n                        args[3],\n                        args[4],\n                        args[5],\n                        i / (curvePoints - 1)\n                    );\n                    segments.push({ x1: curveX, y1: curveY, x2: pt.x, y2: pt.y });\n                    curveX = pt.x;\n                    curveY = pt.y;\n                }\n                prevX = args[4];\n                prevY = args[5];\n                break;\n            }\n            case \"Z\":\n                if (prevX !== firstX || prevY !== firstY) {\n                    segments.push({ x1: prevX, y1: prevY, x2: firstX, y2: firstY });\n                }\n                prevX = firstX;\n                prevY = firstY;\n                break;\n        }\n    }\n\n    return segments;\n}\n\nconst distanceShader = /* wgsl */ `\nstruct Uniforms {\n    glyphBounds: vec4<f32>,\n    maxDistance: f32,\n    exponent: f32,\n    _pad: vec2<f32>,\n}\n\n@group(0) @binding(0) var<uniform> uniforms: Uniforms;\n@group(0) @binding(1) var<storage, read> segments: array<vec4<f32>>;\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) glyphXY: vec2<f32>,\n    @location(1) @interpolate(flat) segmentIdx: u32,\n}\n\n@vertex\nfn vs_distance(\n    @builtin(vertex_index) vid: u32,\n    @builtin(instance_index) segmentIdx: u32\n) -> VertexOutput {\n    let uv = vec2<f32>(\n        f32((vid << 1u) & 2u),\n        f32(vid & 2u)\n    );\n\n    var out: VertexOutput;\n    out.position = vec4<f32>(uv * 2.0 - 1.0, 0.0, 1.0);\n    out.glyphXY = mix(uniforms.glyphBounds.xy, uniforms.glyphBounds.zw, uv);\n    out.segmentIdx = segmentIdx;\n    return out;\n}\n\n@fragment\nfn fs_distance(input: VertexOutput) -> @location(0) vec4<f32> {\n    let seg = segments[input.segmentIdx];\n    let p = input.glyphXY;\n\n    let lineDir = seg.zw - seg.xy;\n    let lenSq = dot(lineDir, lineDir);\n    let t = select(0.0, clamp(dot(p - seg.xy, lineDir) / lenSq, 0.0, 1.0), lenSq > 0.0);\n    let closest = seg.xy + t * lineDir;\n    let dist = distance(p, closest);\n\n    let val = pow(1.0 - clamp(dist / uniforms.maxDistance, 0.0, 1.0), uniforms.exponent) * 0.5;\n\n    let crosses = (seg.y > p.y) != (seg.w > p.y);\n    let crossX = (seg.z - seg.x) * (p.y - seg.y) / (seg.w - seg.y) + seg.x;\n    let crossingUp = crosses && (p.x < crossX) && (seg.y < seg.w);\n    let crossingDown = crosses && (p.x < crossX) && (seg.y > seg.w);\n\n    return vec4<f32>(\n        select(0.0, 1.0/255.0, crossingUp),\n        select(0.0, 1.0/255.0, crossingDown),\n        0.0,\n        val\n    );\n}\n`;\n\nconst finalizeShader = /* wgsl */ `\n@group(0) @binding(0) var intermediate: texture_2d<f32>;\n@group(0) @binding(1) var samp: sampler;\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n}\n\n@vertex\nfn vs_finalize(@builtin(vertex_index) vid: u32) -> VertexOutput {\n    let uv = vec2<f32>(\n        f32((vid << 1u) & 2u),\n        f32(vid & 2u)\n    );\n\n    var out: VertexOutput;\n    out.position = vec4<f32>(uv * 2.0 - 1.0, 0.0, 1.0);\n    out.uv = uv;\n    return out;\n}\n\n@fragment\nfn fs_finalize(input: VertexOutput) -> @location(0) vec4<f32> {\n    let color = textureSample(intermediate, samp, input.uv);\n    let inside = color.r != color.g;\n    let val = select(color.a, 1.0 - color.a, inside);\n    return vec4<f32>(val, val, val, val);\n}\n`;\n\nexport interface SDFGeneratorConfig {\n    device: GPUDevice;\n    sdfSize?: number;\n    exponent?: number;\n    curveSubdivisions?: number;\n}\n\nexport class SDFGenerator {\n    private device: GPUDevice;\n    private sdfSize: number;\n    private exponent: number;\n    private curveSubdivisions: number;\n\n    private distancePipeline: GPURenderPipeline | null = null;\n    private finalizePipeline: GPURenderPipeline | null = null;\n\n    private uniformBuffer: GPUBuffer;\n    private segmentBuffer: GPUBuffer;\n    private intermediateTexture: GPUTexture | null = null;\n    private sampler: GPUSampler;\n\n    private maxSegments = 4096;\n\n    constructor(config: SDFGeneratorConfig) {\n        this.device = config.device;\n        this.sdfSize = config.sdfSize ?? 64;\n        this.exponent = config.exponent ?? 9;\n        this.curveSubdivisions = config.curveSubdivisions ?? 16;\n\n        this.uniformBuffer = this.device.createBuffer({\n            size: 32,\n            usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n        });\n\n        this.segmentBuffer = this.device.createBuffer({\n            size: this.maxSegments * 16,\n            usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n        });\n\n        this.sampler = this.device.createSampler({\n            magFilter: \"nearest\",\n            minFilter: \"nearest\",\n        });\n    }\n\n    private ensurePipelines(): void {\n        if (this.distancePipeline) return;\n\n        const distanceModule = this.device.createShaderModule({ code: distanceShader });\n\n        this.distancePipeline = this.device.createRenderPipeline({\n            layout: \"auto\",\n            vertex: {\n                module: distanceModule,\n                entryPoint: \"vs_distance\",\n            },\n            fragment: {\n                module: distanceModule,\n                entryPoint: \"fs_distance\",\n                targets: [\n                    {\n                        format: \"rgba8unorm\",\n                        blend: {\n                            color: {\n                                srcFactor: \"one\",\n                                dstFactor: \"one\",\n                                operation: \"add\",\n                            },\n                            alpha: {\n                                srcFactor: \"one\",\n                                dstFactor: \"one\",\n                                operation: \"max\",\n                            },\n                        },\n                    },\n                ],\n            },\n            primitive: {\n                topology: \"triangle-list\",\n            },\n        });\n\n        const finalizeModule = this.device.createShaderModule({ code: finalizeShader });\n\n        this.finalizePipeline = this.device.createRenderPipeline({\n            layout: \"auto\",\n            vertex: {\n                module: finalizeModule,\n                entryPoint: \"vs_finalize\",\n            },\n            fragment: {\n                module: finalizeModule,\n                entryPoint: \"fs_finalize\",\n                targets: [{ format: \"r8unorm\" }],\n            },\n            primitive: {\n                topology: \"triangle-list\",\n            },\n        });\n    }\n\n    private ensureIntermediateTexture(): void {\n        if (this.intermediateTexture) return;\n\n        this.intermediateTexture = this.device.createTexture({\n            size: { width: this.sdfSize, height: this.sdfSize },\n            format: \"rgba8unorm\",\n            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n        });\n    }\n\n    generate(\n        path: string,\n        bounds: [number, number, number, number],\n        outputTexture: GPUTexture,\n        outputX: number,\n        outputY: number\n    ): void {\n        this.ensurePipelines();\n        this.ensureIntermediateTexture();\n\n        const segments = segmentPath(path, this.curveSubdivisions);\n        if (segments.length === 0) return;\n        if (segments.length > this.maxSegments) {\n            console.warn(`Too many segments (${segments.length}), truncating to ${this.maxSegments}`);\n            segments.length = this.maxSegments;\n        }\n\n        const [xMin, yMin, xMax, yMax] = bounds;\n        const maxDist = Math.max(xMax - xMin, yMax - yMin) / 2;\n\n        const uniformData = new Float32Array([xMin, yMin, xMax, yMax, maxDist, this.exponent, 0, 0]);\n        this.device.queue.writeBuffer(this.uniformBuffer, 0, uniformData);\n\n        const segmentData = new Float32Array(segments.length * 4);\n        for (let i = 0; i < segments.length; i++) {\n            const seg = segments[i];\n            segmentData[i * 4 + 0] = seg.x1;\n            segmentData[i * 4 + 1] = seg.y1;\n            segmentData[i * 4 + 2] = seg.x2;\n            segmentData[i * 4 + 3] = seg.y2;\n        }\n        this.device.queue.writeBuffer(this.segmentBuffer, 0, segmentData);\n\n        const encoder = this.device.createCommandEncoder();\n\n        const distanceBindGroup = this.device.createBindGroup({\n            layout: this.distancePipeline!.getBindGroupLayout(0),\n            entries: [\n                { binding: 0, resource: { buffer: this.uniformBuffer } },\n                { binding: 1, resource: { buffer: this.segmentBuffer } },\n            ],\n        });\n\n        const distancePass = encoder.beginRenderPass({\n            colorAttachments: [\n                {\n                    view: this.intermediateTexture!.createView(),\n                    clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                    loadOp: \"clear\",\n                    storeOp: \"store\",\n                },\n            ],\n        });\n\n        distancePass.setPipeline(this.distancePipeline!);\n        distancePass.setBindGroup(0, distanceBindGroup);\n        distancePass.draw(3, segments.length);\n        distancePass.end();\n\n        const finalizeBindGroup = this.device.createBindGroup({\n            layout: this.finalizePipeline!.getBindGroupLayout(0),\n            entries: [\n                { binding: 0, resource: this.intermediateTexture!.createView() },\n                { binding: 1, resource: this.sampler },\n            ],\n        });\n\n        const outputView = outputTexture.createView({\n            baseMipLevel: 0,\n            mipLevelCount: 1,\n            baseArrayLayer: 0,\n            arrayLayerCount: 1,\n        });\n\n        const finalizePass = encoder.beginRenderPass({\n            colorAttachments: [\n                {\n                    view: outputView,\n                    loadOp: \"load\",\n                    storeOp: \"store\",\n                },\n            ],\n        });\n\n        finalizePass.setViewport(outputX, outputY, this.sdfSize, this.sdfSize, 0, 1);\n        finalizePass.setScissorRect(outputX, outputY, this.sdfSize, this.sdfSize);\n        finalizePass.setPipeline(this.finalizePipeline!);\n        finalizePass.setBindGroup(0, finalizeBindGroup);\n        finalizePass.draw(3);\n        finalizePass.end();\n\n        this.device.queue.submit([encoder.finish()]);\n    }\n\n    destroy(): void {\n        this.uniformBuffer.destroy();\n        this.segmentBuffer.destroy();\n        this.intermediateTexture?.destroy();\n    }\n}\n","import { type Font, loadFont } from \"./font\";\nimport { SDFGenerator } from \"./sdf\";\nimport {\n    MAX_ENTITIES,\n    resource,\n    registerPostLoadHook,\n    createFieldProxy,\n    type Plugin,\n    type State,\n    type System,\n    type PostLoadContext,\n    type FieldProxy,\n} from \"../../core\";\nimport { setTraits } from \"../../core/component\";\nimport { Compute, ComputePlugin } from \"../../standard/compute\";\nimport {\n    Render,\n    RenderPlugin,\n    Pass,\n    registerDraw,\n    type Draw,\n    type SharedPassContext,\n} from \"../../standard/render\";\nimport { DEPTH_FORMAT } from \"../../standard/render/scene\";\nimport { SCENE_STRUCT_WGSL } from \"../../standard/render/shaders\";\nimport { Transform } from \"../../standard/transforms\";\n\nconst MAX_GLYPHS = 50000;\nconst GLYPH_FLOATS = 16;\nconst SDF_SIZE = 96;\nconst SDF_EXPONENT = 9;\nconst fontUrls: string[] = [];\nconst loadedFonts: (Font | null)[] = [];\n\nexport const DEFAULT_FONT =\n    \"https://fonts.gstatic.com/s/inter/v20/UcCO3FwrK3iLTeHuS_nVMrMxCp50SjIw2boKoduKmMEVuLyfMZg.ttf\";\n\nexport function font(url: string): number {\n    const id = fontUrls.length;\n    fontUrls.push(url);\n    loadedFonts.push(null);\n    return id;\n}\n\nexport function getFont(id: number): Font | null {\n    return loadedFonts[id] ?? null;\n}\n\nexport function resetFonts(): void {\n    fontUrls.length = 0;\n    loadedFonts.length = 0;\n}\n\nasync function loadFonts(): Promise<void> {\n    await Promise.all(\n        fontUrls.map(async (url, id) => {\n            loadedFonts[id] = await loadFont(url);\n        })\n    );\n}\n\nexport const TextData = {\n    data: new Float32Array(MAX_ENTITIES * 12),\n    fonts: new Uint32Array(MAX_ENTITIES),\n};\n\nconst data = TextData.data;\nconst fonts = TextData.fonts;\n\nfunction packedColorProxy(data: Float32Array, stride: number, offset: number): FieldProxy {\n    function getValue(eid: number): number {\n        const o = eid * stride + offset;\n        const r = Math.round(data[o] * 255);\n        const g = Math.round(data[o + 1] * 255);\n        const b = Math.round(data[o + 2] * 255);\n        return (r << 16) | (g << 8) | b;\n    }\n\n    function setValue(eid: number, value: number): void {\n        const o = eid * stride + offset;\n        data[o] = ((value >> 16) & 0xff) / 255;\n        data[o + 1] = ((value >> 8) & 0xff) / 255;\n        data[o + 2] = (value & 0xff) / 255;\n        data[o + 3] = 1;\n    }\n\n    return new Proxy([] as unknown as FieldProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nconst textContent = new Map<number, string>();\n\ninterface TextContentProxy {\n    [eid: number]: string | undefined;\n}\n\nfunction contentProxy(): TextContentProxy {\n    return new Proxy({} as TextContentProxy, {\n        get(_, prop) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return textContent.get(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            if (value === undefined || value === null) {\n                textContent.delete(eid);\n            } else {\n                textContent.set(eid, value);\n            }\n            return true;\n        },\n    });\n}\n\nexport const Text = {\n    content: contentProxy(),\n    font: fonts,\n    fontSize: createFieldProxy(data, 12, 0),\n    opacity: createFieldProxy(data, 12, 1),\n    visible: createFieldProxy(data, 12, 2),\n    anchorX: createFieldProxy(data, 12, 3),\n    anchorY: createFieldProxy(data, 12, 4),\n    color: packedColorProxy(data, 12, 8),\n    colorR: createFieldProxy(data, 12, 8),\n    colorG: createFieldProxy(data, 12, 9),\n    colorB: createFieldProxy(data, 12, 10),\n};\n\ninterface PendingText {\n    readonly eid: number;\n    readonly content: string;\n}\n\nlet pendingTextContent: PendingText[] = [];\n\nfunction parseTextAttrs(attrs: Record<string, string>): Record<string, string> {\n    if (attrs._value) {\n        const parsed: Record<string, string> = {};\n        for (const part of attrs._value.split(\";\")) {\n            const colonIdx = part.indexOf(\":\");\n            if (colonIdx === -1) continue;\n            const key = part.slice(0, colonIdx).trim();\n            const value = part.slice(colonIdx + 1).trim();\n            if (key && value) parsed[key] = value;\n        }\n        return parsed;\n    }\n    return attrs;\n}\n\nfunction finalizePendingText(_state: State, _context: PostLoadContext): void {\n    for (const pending of pendingTextContent) {\n        Text.content[pending.eid] = pending.content;\n    }\n    pendingTextContent = [];\n}\n\nsetTraits(Text, {\n    defaults: () => ({\n        font: 0,\n        fontSize: 1,\n        opacity: 1,\n        visible: 1,\n        anchorX: 0,\n        anchorY: 0,\n        color: 0xffffff,\n    }),\n    adapter: (attrs: Record<string, string>, eid: number) => {\n        const parsed = parseTextAttrs(attrs);\n        const result: Record<string, number> = {};\n\n        if (parsed.content) {\n            pendingTextContent.push({ eid, content: parsed.content });\n        }\n\n        if (parsed.font) result.font = parseInt(parsed.font, 10);\n        if (parsed[\"font-size\"]) result.fontSize = parseFloat(parsed[\"font-size\"]);\n        if (parsed.fontSize) result.fontSize = parseFloat(parsed.fontSize);\n        if (parsed.opacity) result.opacity = parseFloat(parsed.opacity);\n        if (parsed.visible) result.visible = parseFloat(parsed.visible);\n        if (parsed[\"anchor-x\"]) result.anchorX = parseFloat(parsed[\"anchor-x\"]);\n        if (parsed.anchorX) result.anchorX = parseFloat(parsed.anchorX);\n        if (parsed[\"anchor-y\"]) result.anchorY = parseFloat(parsed[\"anchor-y\"]);\n        if (parsed.anchorY) result.anchorY = parseFloat(parsed.anchorY);\n        if (parsed.color) {\n            const colorStr = parsed.color;\n            if (colorStr.startsWith(\"0x\") || colorStr.startsWith(\"0X\")) {\n                result.color = parseInt(colorStr, 16);\n            } else if (colorStr.startsWith(\"#\")) {\n                result.color = parseInt(colorStr.slice(1), 16);\n            } else {\n                result.color = parseInt(colorStr, 10);\n            }\n        }\n\n        return result;\n    },\n});\n\ninterface GlyphMetrics {\n    width: number;\n    height: number;\n    glyphWidth: number;\n    glyphHeight: number;\n    glyphTop: number;\n    glyphLeft: number;\n    advance: number;\n    u0: number;\n    v0: number;\n    u1: number;\n    v1: number;\n}\n\ninterface GlyphAtlas {\n    texture: GPUTexture;\n    textureView: GPUTextureView;\n    width: number;\n    height: number;\n    glyphs: Map<string, GlyphMetrics>;\n    rowHeight: number;\n    cursorX: number;\n    cursorY: number;\n    font: Font;\n    sdfGenerator: SDFGenerator;\n}\n\nfunction createGlyphAtlas(device: GPUDevice, font: Font): GlyphAtlas {\n    const width = 2048;\n    const height = 2048;\n\n    const texture = device.createTexture({\n        size: { width, height },\n        format: \"r8unorm\",\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.RENDER_ATTACHMENT,\n        label: \"glyphAtlas\",\n    });\n\n    const sdfGenerator = new SDFGenerator({\n        device,\n        sdfSize: SDF_SIZE,\n        exponent: SDF_EXPONENT,\n        curveSubdivisions: 24,\n    });\n\n    return {\n        texture,\n        textureView: texture.createView(),\n        width,\n        height,\n        glyphs: new Map(),\n        rowHeight: 0,\n        cursorX: 0,\n        cursorY: 0,\n        font,\n        sdfGenerator,\n    };\n}\n\nfunction ensureGlyph(atlas: GlyphAtlas, char: string): GlyphMetrics | null {\n    const existing = atlas.glyphs.get(char);\n    if (existing) return existing;\n\n    const path = atlas.font.glyphPath(char);\n    const bounds = atlas.font.glyphBounds(char);\n    const advance = atlas.font.advance(char);\n\n    if (!path || !bounds) return null;\n\n    const [xMin, yMin, xMax, yMax] = bounds;\n    const unitsPerEm = atlas.font.unitsPerEm;\n\n    const padding = unitsPerEm * 0.1;\n    const paddedBounds: [number, number, number, number] = [\n        xMin - padding,\n        yMin - padding,\n        xMax + padding,\n        yMax + padding,\n    ];\n\n    const glyphWidth = paddedBounds[2] - paddedBounds[0];\n    const glyphHeight = paddedBounds[3] - paddedBounds[1];\n\n    if (atlas.cursorX + SDF_SIZE > atlas.width) {\n        atlas.cursorX = 0;\n        atlas.cursorY += atlas.rowHeight;\n        atlas.rowHeight = 0;\n    }\n\n    if (atlas.cursorY + SDF_SIZE > atlas.height) {\n        throw new Error(\"Glyph atlas full\");\n    }\n\n    atlas.sdfGenerator.generate(path, paddedBounds, atlas.texture, atlas.cursorX, atlas.cursorY);\n\n    const metrics: GlyphMetrics = {\n        width: SDF_SIZE,\n        height: SDF_SIZE,\n        glyphWidth: glyphWidth / unitsPerEm,\n        glyphHeight: glyphHeight / unitsPerEm,\n        glyphTop: paddedBounds[3] / unitsPerEm,\n        glyphLeft: paddedBounds[0] / unitsPerEm,\n        advance: advance / unitsPerEm,\n        u0: atlas.cursorX / atlas.width,\n        v0: atlas.cursorY / atlas.height,\n        u1: (atlas.cursorX + SDF_SIZE) / atlas.width,\n        v1: (atlas.cursorY + SDF_SIZE) / atlas.height,\n    };\n\n    atlas.glyphs.set(char, metrics);\n    atlas.cursorX += SDF_SIZE;\n    atlas.rowHeight = Math.max(atlas.rowHeight, SDF_SIZE);\n\n    return metrics;\n}\n\nfunction ensureString(atlas: GlyphAtlas, text: string): void {\n    for (const char of text) {\n        ensureGlyph(atlas, char);\n    }\n}\n\ninterface LayoutGlyph {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    texelWidth: number;\n    texelHeight: number;\n    u0: number;\n    v0: number;\n    u1: number;\n    v1: number;\n}\n\ninterface LayoutResult {\n    glyphs: LayoutGlyph[];\n    width: number;\n    height: number;\n}\n\nfunction layoutText(text: string, atlas: GlyphAtlas, fontSize: number): LayoutResult {\n    const glyphs: LayoutGlyph[] = [];\n    const scale = fontSize;\n\n    let cursorX = 0;\n    let maxHeight = 0;\n    let prevChar: string | null = null;\n\n    for (const char of text) {\n        const metrics = atlas.glyphs.get(char);\n        if (!metrics) continue;\n\n        if (prevChar) {\n            cursorX += atlas.font.kerning(prevChar, char) / atlas.font.unitsPerEm * scale;\n        }\n\n        const glyphW = metrics.glyphWidth * scale;\n        const glyphH = metrics.glyphHeight * scale;\n        const advance = metrics.advance * scale;\n\n        const x = cursorX + metrics.glyphLeft * scale;\n        const y = (metrics.glyphTop - metrics.glyphHeight) * scale;\n\n        glyphs.push({\n            x,\n            y,\n            width: glyphW,\n            height: glyphH,\n            texelWidth: metrics.width,\n            texelHeight: metrics.height,\n            u0: metrics.u0,\n            v0: metrics.v0,\n            u1: metrics.u1,\n            v1: metrics.v1,\n        });\n\n        cursorX += advance;\n        maxHeight = Math.max(maxHeight, glyphH);\n        prevChar = char;\n    }\n\n    return {\n        glyphs,\n        width: cursorX,\n        height: maxHeight,\n    };\n}\n\nconst textShader = /* wgsl */ `\n${SCENE_STRUCT_WGSL}\n\nstruct GlyphInstance {\n    posX: f32,\n    posY: f32,\n    posZ: f32,\n    entityId: u32,\n    width: f32,\n    height: f32,\n    texelWidth: f32,\n    texelHeight: f32,\n    u0: f32,\n    v0: f32,\n    u1: f32,\n    v1: f32,\n    color: vec4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> scene: Scene;\n@group(0) @binding(1) var<storage, read> glyphs: array<GlyphInstance>;\n@group(0) @binding(2) var atlasTexture: texture_2d<f32>;\n@group(0) @binding(3) var atlasSampler: sampler;\n@group(0) @binding(4) var<storage, read> matrices: array<mat4x4<f32>>;\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n    @location(1) color: vec4<f32>,\n    @location(2) localUV: vec2<f32>,\n    @location(3) glyphDimensions: vec2<f32>,\n}\n\n@vertex\nfn vs(@builtin(vertex_index) vid: u32) -> VertexOutput {\n    let glyphIdx = vid / 6u;\n    let cornerIdx = vid % 6u;\n\n    let glyph = glyphs[glyphIdx];\n\n    var localPos: vec2<f32>;\n    var uv: vec2<f32>;\n\n    switch cornerIdx {\n        case 0u: {\n            localPos = vec2(0.0, 0.0);\n            uv = vec2(glyph.u0, glyph.v0);\n        }\n        case 1u: {\n            localPos = vec2(1.0, 0.0);\n            uv = vec2(glyph.u1, glyph.v0);\n        }\n        case 2u: {\n            localPos = vec2(1.0, 1.0);\n            uv = vec2(glyph.u1, glyph.v1);\n        }\n        case 3u: {\n            localPos = vec2(0.0, 0.0);\n            uv = vec2(glyph.u0, glyph.v0);\n        }\n        case 4u: {\n            localPos = vec2(1.0, 1.0);\n            uv = vec2(glyph.u1, glyph.v1);\n        }\n        case 5u: {\n            localPos = vec2(0.0, 1.0);\n            uv = vec2(glyph.u0, glyph.v1);\n        }\n        default: {\n            localPos = vec2(0.0);\n            uv = vec2(0.0);\n        }\n    }\n\n    let localPos3 = vec3(\n        glyph.posX + localPos.x * glyph.width,\n        glyph.posY + localPos.y * glyph.height,\n        glyph.posZ\n    );\n\n    let transform = matrices[glyph.entityId];\n    let worldPos = transform * vec4(localPos3, 1.0);\n\n    var out: VertexOutput;\n    out.position = scene.viewProj * worldPos;\n    out.uv = uv;\n    out.color = glyph.color;\n    out.localUV = localPos;\n    out.glyphDimensions = vec2(glyph.width, glyph.height);\n    return out;\n}\n\nstruct FragmentOutput {\n    @location(0) color: vec4<f32>,\n    @location(1) mask: f32,\n}\n\nconst SDF_EXPONENT: f32 = 9.0;\n\nfn sdfToSignedDistance(sdfValue: f32, maxDimension: f32) -> f32 {\n    let alpha = select(sdfValue, 1.0 - sdfValue, sdfValue > 0.5);\n    let absDist = (1.0 - pow(2.0 * alpha, 1.0 / SDF_EXPONENT)) * maxDimension;\n    return absDist * select(1.0, -1.0, sdfValue > 0.5);\n}\n\n@fragment\nfn fs(input: VertexOutput) -> FragmentOutput {\n    let sdfValue = textureSample(atlasTexture, atlasSampler, input.uv).r;\n\n    // Decode SDF to signed distance (negative = inside, positive = outside)\n    let maxDimension = max(input.glyphDimensions.x, input.glyphDimensions.y);\n    let signedDist = sdfToSignedDistance(sdfValue, maxDimension);\n\n    // Screen-space AA distance from UV derivatives\n    let aaDist = length(fwidth(input.localUV * input.glyphDimensions)) * 0.5;\n\n    // Smoothstep with adaptive band\n    let alpha = smoothstep(aaDist, -aaDist, signedDist);\n\n    // Dilate mask by FXAA span (8 pixels) to prevent edge bleeding\n    let fxaaSpan = aaDist * 8.0;\n    let inMaskRegion = signedDist < fxaaSpan;\n\n    // Only discard if outside both visible region and mask region\n    if alpha < 0.01 && !inMaskRegion {\n        discard;\n    }\n\n    var out: FragmentOutput;\n    out.color = vec4(input.color.rgb, input.color.a * alpha);\n    out.mask = select(0.0, 1.0, inMaskRegion);\n    return out;\n}\n`;\n\nfunction createTextPipeline(\n    device: GPUDevice,\n    format: GPUTextureFormat,\n    maskFormat: GPUTextureFormat\n): GPURenderPipeline {\n    const module = device.createShaderModule({ code: textShader });\n\n    return device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n            module,\n            entryPoint: \"vs\",\n        },\n        fragment: {\n            module,\n            entryPoint: \"fs\",\n            targets: [\n                {\n                    format,\n                    blend: {\n                        color: {\n                            srcFactor: \"src-alpha\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                        alpha: {\n                            srcFactor: \"one\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                    },\n                },\n                {\n                    format: maskFormat,\n                    writeMask: GPUColorWrite.RED,\n                },\n            ],\n        },\n        primitive: {\n            topology: \"triangle-list\",\n            cullMode: \"none\",\n        },\n        depthStencil: {\n            format: DEPTH_FORMAT,\n            depthCompare: \"less\",\n            depthWriteEnabled: false,\n        },\n    });\n}\n\nexport interface TextConfig {\n    scene: GPUBuffer;\n    glyphs: GPUBuffer;\n    atlas: GPUTextureView;\n    sampler: GPUSampler;\n    matrices: GPUBuffer;\n    fontIndex: number;\n    getRange: () => { start: number; count: number };\n}\n\nfunction createTextDraw(config: TextConfig): Draw {\n    let pipeline: GPURenderPipeline | null = null;\n    let bindGroup: GPUBindGroup | null = null;\n\n    return {\n        id: `text-${config.fontIndex}`,\n        pass: Pass.Overlay,\n        order: 2 + config.fontIndex,\n\n        execute() {},\n\n        draw(pass: GPURenderPassEncoder, ctx: SharedPassContext) {\n            const { start, count } = config.getRange();\n            if (count === 0) return;\n\n            if (!pipeline) {\n                pipeline = createTextPipeline(ctx.device, ctx.format, ctx.maskFormat);\n            }\n\n            if (!bindGroup) {\n                bindGroup = ctx.device.createBindGroup({\n                    layout: pipeline.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: { buffer: config.scene } },\n                        { binding: 1, resource: { buffer: config.glyphs } },\n                        { binding: 2, resource: config.atlas },\n                        { binding: 3, resource: config.sampler },\n                        { binding: 4, resource: { buffer: config.matrices } },\n                    ],\n                });\n            }\n\n            pass.setPipeline(pipeline);\n            pass.setBindGroup(0, bindGroup);\n            pass.draw(count * 6, 1, start * 6, 0);\n        },\n    };\n}\n\nexport interface FontRange {\n    start: number;\n    count: number;\n}\n\nexport interface Glyphs {\n    atlases: GlyphAtlas[];\n    sampler: GPUSampler;\n    buffer: GPUBuffer;\n    staging: Float32Array;\n    ranges: FontRange[];\n}\n\nexport const Glyphs = resource<Glyphs>(\"glyphs\");\n\ninterface PendingGlyph {\n    eid: number;\n    fontId: number;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    texelWidth: number;\n    texelHeight: number;\n    u0: number;\n    v0: number;\n    u1: number;\n    v1: number;\n    r: number;\n    g: number;\n    b: number;\n    a: number;\n}\n\nconst TextSystem: System = {\n    group: \"draw\",\n\n    update(state: State) {\n        const compute = Compute.from(state);\n        const text = Glyphs.from(state);\n        if (!compute || !text) return;\n\n        const { device } = compute;\n        const { atlases, staging, ranges } = text;\n        const stagingU32 = new Uint32Array(staging.buffer);\n\n        const glyphsByFont: PendingGlyph[][] = atlases.map(() => []);\n\n        for (const eid of state.query([Text, Transform])) {\n            if (!Text.visible[eid]) continue;\n\n            const content = textContent.get(eid);\n            if (!content) continue;\n\n            const fontId = Text.font[eid];\n            const atlas = atlases[fontId] ?? atlases[0];\n            const actualFontId = atlases[fontId] ? fontId : 0;\n            if (!atlas) continue;\n\n            ensureString(atlas, content);\n\n            const fontSize = Text.fontSize[eid];\n            const layout = layoutText(content, atlas, fontSize);\n\n            const anchorX = Text.anchorX[eid];\n            const anchorY = Text.anchorY[eid];\n            const offsetX = -layout.width * anchorX;\n            const offsetY = -layout.height * anchorY;\n\n            const color = Text.color[eid];\n            const r = ((color >> 16) & 0xff) / 255;\n            const g = ((color >> 8) & 0xff) / 255;\n            const b = (color & 0xff) / 255;\n            const a = Text.opacity[eid];\n\n            for (const glyph of layout.glyphs) {\n                glyphsByFont[actualFontId].push({\n                    eid,\n                    fontId: actualFontId,\n                    x: offsetX + glyph.x,\n                    y: offsetY + glyph.y,\n                    width: glyph.width,\n                    height: glyph.height,\n                    texelWidth: glyph.texelWidth,\n                    texelHeight: glyph.texelHeight,\n                    u0: glyph.u0,\n                    v0: glyph.v0,\n                    u1: glyph.u1,\n                    v1: glyph.v1,\n                    r,\n                    g,\n                    b,\n                    a,\n                });\n            }\n        }\n\n        let glyphCount = 0;\n        for (let fontIdx = 0; fontIdx < atlases.length; fontIdx++) {\n            const fontGlyphs = glyphsByFont[fontIdx];\n            ranges[fontIdx].start = glyphCount;\n            ranges[fontIdx].count = fontGlyphs.length;\n\n            for (const glyph of fontGlyphs) {\n                if (glyphCount >= MAX_GLYPHS) break;\n\n                const offset = glyphCount * GLYPH_FLOATS;\n\n                staging[offset + 0] = glyph.x;\n                staging[offset + 1] = glyph.y;\n                staging[offset + 2] = 0;\n                stagingU32[offset + 3] = glyph.eid;\n\n                staging[offset + 4] = glyph.width;\n                staging[offset + 5] = glyph.height;\n                staging[offset + 6] = glyph.texelWidth;\n                staging[offset + 7] = glyph.texelHeight;\n\n                staging[offset + 8] = glyph.u0;\n                staging[offset + 9] = glyph.v0;\n                staging[offset + 10] = glyph.u1;\n                staging[offset + 11] = glyph.v1;\n\n                staging[offset + 12] = glyph.r;\n                staging[offset + 13] = glyph.g;\n                staging[offset + 14] = glyph.b;\n                staging[offset + 15] = glyph.a;\n\n                glyphCount++;\n            }\n        }\n\n        if (glyphCount > 0) {\n            device.queue.writeBuffer(\n                text.buffer,\n                0,\n                staging.buffer,\n                0,\n                glyphCount * GLYPH_FLOATS * 4\n            );\n        }\n    },\n};\n\nexport const TextPlugin: Plugin = {\n    systems: [TextSystem],\n    components: { Text },\n    dependencies: [ComputePlugin, RenderPlugin],\n\n    async initialize(state: State) {\n        registerPostLoadHook(finalizePendingText);\n\n        const compute = Compute.from(state);\n        const render = Render.from(state);\n        if (!compute || !render) return;\n\n        if (fontUrls.length === 0) {\n            font(DEFAULT_FONT);\n        }\n\n        try {\n            await loadFonts();\n        } catch (e) {\n            console.warn(\"[TextPlugin] Failed to load fonts:\", e);\n            return;\n        }\n\n        const { device } = compute;\n\n        const atlases: GlyphAtlas[] = [];\n        for (const loadedFont of loadedFonts) {\n            if (loadedFont) {\n                atlases.push(createGlyphAtlas(device, loadedFont));\n            }\n        }\n\n        if (atlases.length === 0) {\n            return;\n        }\n\n        const sampler = device.createSampler({\n            magFilter: \"linear\",\n            minFilter: \"linear\",\n        });\n\n        const ranges: FontRange[] = atlases.map(() => ({ start: 0, count: 0 }));\n\n        const textState: Glyphs = {\n            atlases,\n            sampler,\n            buffer: device.createBuffer({\n                label: \"glyphs\",\n                size: MAX_GLYPHS * GLYPH_FLOATS * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            }),\n            staging: new Float32Array(MAX_GLYPHS * GLYPH_FLOATS),\n            ranges,\n        };\n\n        state.setResource(Glyphs, textState);\n\n        for (let i = 0; i < atlases.length; i++) {\n            const fontIndex = i;\n            registerDraw(\n                state,\n                createTextDraw({\n                    scene: render.scene,\n                    glyphs: textState.buffer,\n                    atlas: atlases[i].textureView,\n                    sampler,\n                    matrices: render.matrices,\n                    fontIndex,\n                    getRange: () => ranges[fontIndex],\n                })\n            );\n        }\n    },\n};\n","import { MAX_ENTITIES, resource } from \"../../core\";\nimport { setTraits, type FieldAccessor } from \"../../core/component\";\nimport type { Plugin, State, System } from \"../../core\";\nimport { Canvas, Compute, type ComputeNode, type ExecutionContext } from \"../../standard/compute\";\n\nexport type PhysicsConfig = {\n    springConstant: number;\n    damping: number;\n    bounds: { min: number; max: number };\n    targetThreshold: number;\n};\n\nexport const DEFAULT_PHYSICS_CONFIG: PhysicsConfig = {\n    springConstant: 0.72,\n    damping: 0.046,\n    bounds: { min: -20, max: 120 },\n    targetThreshold: 5,\n};\n\nexport type Bubble = {\n    x: number;\n    y: number;\n    vx: number;\n    vy: number;\n    targetX: number;\n    targetY: number;\n    color: string;\n};\n\nexport type GradientConfig = {\n    color1: string;\n    color2: string;\n};\n\nexport type BubbleConfig = {\n    size: number;\n    blur: number;\n};\n\nexport type TextureConfig = {\n    enabled: boolean;\n    fineNoise: number;\n    mediumNoise: number;\n    coarseNoise: number;\n    largeScale: number;\n    fiberIntensity: number;\n    opacity: number;\n};\n\nexport type OverlayConfig = {\n    enabled: boolean;\n    color: string;\n};\n\nexport const DEFAULT_GRADIENT_CONFIG: GradientConfig = {\n    color1: \"#0bff06\",\n    color2: \"#00a4ae\",\n};\n\nexport const DEFAULT_BUBBLE_CONFIG: BubbleConfig = {\n    size: 75,\n    blur: 10,\n};\n\nexport const DEFAULT_TEXTURE_CONFIG: TextureConfig = {\n    enabled: true,\n    fineNoise: 0.2,\n    mediumNoise: 0.2,\n    coarseNoise: 0.1,\n    largeScale: 0.35,\n    fiberIntensity: 0.15,\n    opacity: 0.4,\n};\n\nexport const DEFAULT_OVERLAY_CONFIG: OverlayConfig = {\n    enabled: true,\n    color: \"#65FD00\",\n};\n\ntype RGBA = [number, number, number, number];\ntype RGB = [number, number, number];\n\nfunction hashString(str: string): number {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash;\n    }\n    return Math.abs(hash);\n}\n\nfunction hashStringToU32(str: string): number {\n    let hash = 0;\n    for (let i = 0; i < str.length; i++) {\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash >>> 0;\n    }\n    return hash;\n}\n\nfunction createSeededRandom(seed: number): () => number {\n    let value = seed;\n    return () => {\n        value = (value * 9301 + 49297) % 233280;\n        return value / 233280;\n    };\n}\n\nfunction generateHslColor(random: () => number): string {\n    const h = Math.floor(random() * 360);\n    const s = 70 + Math.floor(random() * 30);\n    const l = 50 + Math.floor(random() * 20);\n    return `hsl(${h}, ${s}%, ${l}%)`;\n}\n\nfunction generateAngle(key: string): number {\n    const hash = hashString(key + \"_gradient\");\n    const random = createSeededRandom(hash);\n    return Math.floor(random() * 360);\n}\n\nfunction generateBubbles(\n    key: string,\n    count: number = 4,\n    physics: PhysicsConfig = DEFAULT_PHYSICS_CONFIG\n): Bubble[] {\n    const seed = hashString(key);\n    const random = createSeededRandom(seed);\n    const range = physics.bounds.max - physics.bounds.min;\n\n    const bubbles: Bubble[] = [];\n    for (let i = 0; i < count; i++) {\n        const x = physics.bounds.min + random() * range;\n        const y = physics.bounds.min + random() * range;\n        const color = generateHslColor(random);\n        const vx = (random() - 0.5) * 18;\n        const vy = (random() - 0.5) * 18;\n        const targetX = physics.bounds.min + random() * range;\n        const targetY = physics.bounds.min + random() * range;\n        bubbles.push({ x, y, color, vx, vy, targetX, targetY });\n    }\n    return bubbles;\n}\n\nfunction clamp(value: number, min: number, max: number): number {\n    return Math.min(Math.max(value, min), max);\n}\n\nfunction distance(x1: number, y1: number, x2: number, y2: number): number {\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nfunction stepBubble(\n    bubble: Bubble,\n    dt: number,\n    physics: PhysicsConfig = DEFAULT_PHYSICS_CONFIG\n): Bubble {\n    let { x, y, vx, vy, targetX, targetY, color } = bubble;\n\n    vx += (targetX - x) * physics.springConstant * dt;\n    vy += (targetY - y) * physics.springConstant * dt;\n\n    const dampingFactor = Math.pow(physics.damping, dt);\n    vx *= dampingFactor;\n    vy *= dampingFactor;\n\n    x += vx * dt;\n    y += vy * dt;\n\n    x = clamp(x, physics.bounds.min, physics.bounds.max);\n    y = clamp(y, physics.bounds.min, physics.bounds.max);\n\n    return { x, y, vx, vy, targetX, targetY, color };\n}\n\nfunction updateBubbleTarget(\n    bubble: Bubble,\n    random: () => number,\n    physics: PhysicsConfig = DEFAULT_PHYSICS_CONFIG\n): Bubble {\n    if (distance(bubble.x, bubble.y, bubble.targetX, bubble.targetY) < physics.targetThreshold) {\n        const range = physics.bounds.max - physics.bounds.min;\n        return {\n            ...bubble,\n            targetX: physics.bounds.min + random() * range,\n            targetY: physics.bounds.min + random() * range,\n        };\n    }\n    return bubble;\n}\n\nfunction bubblesMoved(bubbles: Bubble[], threshold: number = 0.001): boolean {\n    return bubbles.some((b) => Math.abs(b.vx) > threshold || Math.abs(b.vy) > threshold);\n}\n\nexport function setBubbleTarget(bubble: Bubble, targetX: number, targetY: number): Bubble {\n    return { ...bubble, targetX, targetY };\n}\n\nexport function applyBubbleImpulse(bubble: Bubble, impulseX: number, impulseY: number): Bubble {\n    return { ...bubble, vx: bubble.vx + impulseX, vy: bubble.vy + impulseY };\n}\n\nexport function setBubblePosition(bubble: Bubble, x: number, y: number): Bubble {\n    return { ...bubble, x, y };\n}\n\nexport function findNearestBubble(bubbles: Bubble[], x: number, y: number): number {\n    if (bubbles.length === 0) return -1;\n\n    let nearestIdx = 0;\n    let nearestDist = distance(bubbles[0].x, bubbles[0].y, x, y);\n\n    for (let i = 1; i < bubbles.length; i++) {\n        const dist = distance(bubbles[i].x, bubbles[i].y, x, y);\n        if (dist < nearestDist) {\n            nearestDist = dist;\n            nearestIdx = i;\n        }\n    }\n\n    return nearestIdx;\n}\n\nexport function screenToGradientSpace(\n    screenX: number,\n    screenY: number,\n    canvasWidth: number,\n    canvasHeight: number\n): { x: number; y: number } {\n    return {\n        x: (screenX / canvasWidth) * 100,\n        y: (screenY / canvasHeight) * 100,\n    };\n}\n\nfunction parseColor(color: string): RGBA {\n    color = color.trim();\n\n    if (color.startsWith(\"#\")) {\n        return parseHexColor(color);\n    }\n\n    if (color.startsWith(\"rgb\")) {\n        return parseRgbColor(color);\n    }\n\n    if (color.startsWith(\"hsl\")) {\n        return parseHslColor(color);\n    }\n\n    if (color === \"transparent\") {\n        return [0, 0, 0, 0];\n    }\n\n    return [0, 0, 0, 255];\n}\n\nfunction parseHexColor(hex: string): RGBA {\n    hex = hex.replace(\"#\", \"\");\n\n    if (hex.length === 3) {\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];\n    }\n\n    if (hex.length === 4) {\n        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];\n    }\n\n    const r = parseInt(hex.slice(0, 2), 16);\n    const g = parseInt(hex.slice(2, 4), 16);\n    const b = parseInt(hex.slice(4, 6), 16);\n    const a = hex.length === 8 ? parseInt(hex.slice(6, 8), 16) : 255;\n\n    return [r, g, b, a];\n}\n\nfunction parseRgbColor(rgb: string): RGBA {\n    const match = rgb.match(/rgba?\\(([^)]+)\\)/);\n    if (!match) return [0, 0, 0, 255];\n\n    const parts = match[1].split(\",\").map((s) => s.trim());\n    const r = parseInt(parts[0], 10);\n    const g = parseInt(parts[1], 10);\n    const b = parseInt(parts[2], 10);\n    const a = parts[3] !== undefined ? Math.round(parseFloat(parts[3]) * 255) : 255;\n\n    return [r, g, b, a];\n}\n\nfunction hslToRgb(h: number, s: number, l: number): RGB {\n    h = ((h % 360) + 360) % 360;\n    h /= 360;\n\n    if (s === 0) {\n        const gray = Math.round(l * 255);\n        return [gray, gray, gray];\n    }\n\n    const hue2rgb = (p: number, q: number, t: number): number => {\n        if (t < 0) t += 1;\n        if (t > 1) t -= 1;\n        if (t < 1 / 6) return p + (q - p) * 6 * t;\n        if (t < 1 / 2) return q;\n        if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n        return p;\n    };\n\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n\n    return [\n        Math.round(hue2rgb(p, q, h + 1 / 3) * 255),\n        Math.round(hue2rgb(p, q, h) * 255),\n        Math.round(hue2rgb(p, q, h - 1 / 3) * 255),\n    ];\n}\n\nfunction parseHslColor(hsl: string): RGBA {\n    const match = hsl.match(/hsla?\\(([^)]+)\\)/);\n    if (!match) return [0, 0, 0, 255];\n\n    const parts = match[1].split(\",\").map((s) => s.trim());\n    const h = parseInt(parts[0], 10);\n    const s = parseInt(parts[1], 10) / 100;\n    const l = parseInt(parts[2], 10) / 100;\n    const a = parts[3] !== undefined ? Math.round(parseFloat(parts[3]) * 255) : 255;\n\n    const [r, g, b] = hslToRgb(h, s, l);\n    return [r, g, b, a];\n}\n\nconst STRIDE = 16;\nconst GradientData = {\n    data: new Float32Array(MAX_ENTITIES * STRIDE),\n};\n\nconst seeds = new Map<number, string>();\nconst color1s = new Map<number, string>();\nconst color2s = new Map<number, string>();\nconst overlayColors = new Map<number, string>();\n\ninterface GradientProxy extends Array<number>, FieldAccessor {}\n\nfunction floatProxy(offset: number): GradientProxy {\n    const data = GradientData.data;\n\n    function getValue(eid: number): number {\n        return data[eid * STRIDE + offset];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * STRIDE + offset] = value;\n    }\n\n    return new Proxy([] as unknown as GradientProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\ninterface StringProxy {\n    [eid: number]: string | undefined;\n}\n\nfunction stringProxy(map: Map<number, string>): StringProxy {\n    return new Proxy({} as StringProxy, {\n        get(_, prop) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return map.get(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            if (value === undefined || value === null) {\n                map.delete(eid);\n            } else {\n                map.set(eid, value);\n            }\n            return true;\n        },\n    });\n}\n\nexport const Gradient = {\n    seed: stringProxy(seeds),\n    color1: stringProxy(color1s),\n    color2: stringProxy(color2s),\n    overlayColor: stringProxy(overlayColors),\n    angle: floatProxy(0),\n    enabled: floatProxy(1),\n    bubbleSize: floatProxy(2),\n    bubbleBlur: floatProxy(3),\n    textureEnabled: floatProxy(4),\n    textureOpacity: floatProxy(5),\n    overlayEnabled: floatProxy(6),\n    bubbleCount: floatProxy(7),\n    springConstant: floatProxy(8),\n    damping: floatProxy(9),\n    boundsMin: floatProxy(10),\n    boundsMax: floatProxy(11),\n};\n\nsetTraits(Gradient, {\n    defaults: () => ({\n        enabled: 1,\n        bubbleSize: DEFAULT_BUBBLE_CONFIG.size,\n        bubbleBlur: DEFAULT_BUBBLE_CONFIG.blur,\n        textureEnabled: 1,\n        textureOpacity: DEFAULT_TEXTURE_CONFIG.opacity,\n        overlayEnabled: 1,\n        bubbleCount: 4,\n        springConstant: DEFAULT_PHYSICS_CONFIG.springConstant,\n        damping: DEFAULT_PHYSICS_CONFIG.damping,\n        boundsMin: DEFAULT_PHYSICS_CONFIG.bounds.min,\n        boundsMax: DEFAULT_PHYSICS_CONFIG.bounds.max,\n    }),\n});\n\nexport interface Gradients {\n    bubbles: Map<number, Bubble[]>;\n    randoms: Map<number, () => number>;\n    width: number;\n    height: number;\n    compositePipeline: GPURenderPipeline | null;\n    compositeBindGroup: GPUBindGroup | null;\n    compositeBindGroupLayout: GPUBindGroupLayout | null;\n    compositeUniformBuffer: GPUBuffer | null;\n    gradientAngle: number;\n    gradientColor1: [number, number, number, number];\n    gradientColor2: [number, number, number, number];\n    textureSeed: number;\n    textureEnabled: boolean;\n    fineNoise: number;\n    mediumNoise: number;\n    coarseNoise: number;\n    largeScale: number;\n    fiberIntensity: number;\n    textureOpacity: number;\n    overlayColor: [number, number, number, number];\n    bubbleUniformData: Float32Array | null;\n    bubbleRadius: number;\n    blurRadius: number;\n    bubbleCount: number;\n}\n\nexport const Gradients = resource<Gradients>(\"gradient\");\n\nexport function clearGradientState(state: State): void {\n    const res = Gradients.from(state);\n    if (!res) return;\n    res.bubbles.clear();\n    res.randoms.clear();\n}\n\nexport function getBubbles(state: State, eid: number): Bubble[] | undefined {\n    const res = Gradients.from(state);\n    if (!res) return undefined;\n    return res.bubbles.get(eid);\n}\n\nexport function setBubbles(state: State, eid: number, bubbles: Bubble[]): void {\n    const res = Gradients.from(state);\n    if (!res) return;\n    res.bubbles.set(eid, bubbles);\n}\n\nexport function updateBubble(\n    state: State,\n    eid: number,\n    index: number,\n    updater: (bubble: Bubble) => Bubble\n): void {\n    const res = Gradients.from(state);\n    if (!res) return;\n    const bubbles = res.bubbles.get(eid);\n    if (!bubbles || index < 0 || index >= bubbles.length) return;\n    bubbles[index] = updater(bubbles[index]);\n}\n\nconst COMPOSITE_SHADER = /* wgsl */ `\nstruct CompositeUniforms {\n    overlayColor: vec4f,\n    color1: vec4f,\n    color2: vec4f,\n    b0_pos: vec2f,\n    _b0_pad: vec2f,\n    b0_color: vec4f,\n    b1_pos: vec2f,\n    _b1_pad: vec2f,\n    b1_color: vec4f,\n    b2_pos: vec2f,\n    _b2_pad: vec2f,\n    b2_color: vec4f,\n    b3_pos: vec2f,\n    _b3_pad: vec2f,\n    b3_color: vec4f,\n    textureSeed: u32,\n    textureEnabled: u32,\n    fineNoise: f32,\n    mediumNoise: f32,\n    coarseNoise: f32,\n    largeScale: f32,\n    fiberIntensity: f32,\n    textureOpacity: f32,\n    size: vec2f,\n    angle: f32,\n    bubbleRadius: f32,\n    blurRadius: f32,\n    bubbleCount: u32,\n    _pad: vec2f,\n}\n\nstruct VertexOutput {\n    @builtin(position) position: vec4f,\n    @location(0) uv: vec2f,\n}\n\n@vertex\nfn vs(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var positions = array<vec2f, 6>(\n        vec2f(-1.0, -1.0),\n        vec2f( 1.0, -1.0),\n        vec2f(-1.0,  1.0),\n        vec2f(-1.0,  1.0),\n        vec2f( 1.0, -1.0),\n        vec2f( 1.0,  1.0),\n    );\n\n    var uvs = array<vec2f, 6>(\n        vec2f(0.0, 1.0),\n        vec2f(1.0, 1.0),\n        vec2f(0.0, 0.0),\n        vec2f(0.0, 0.0),\n        vec2f(1.0, 1.0),\n        vec2f(1.0, 0.0),\n    );\n\n    var output: VertexOutput;\n    output.position = vec4f(positions[vertexIndex], 0.0, 1.0);\n    output.uv = uvs[vertexIndex];\n    return output;\n}\n\n@group(0) @binding(0) var<uniform> uniforms: CompositeUniforms;\n\nfn pcgHash(input: u32) -> u32 {\n    var state = input * 747796405u + 2891336453u;\n    var word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    return (word >> 22u) ^ word;\n}\n\nfn noise3(seed: u32) -> vec3f {\n    let h = pcgHash(seed);\n    return vec3f(\n        f32(h & 0x3FFu) / 1023.0,\n        f32((h >> 10u) & 0x3FFu) / 1023.0,\n        f32((h >> 20u) & 0x3FFu) / 1023.0\n    );\n}\n\nfn generateTexture(uv: vec2f) -> f32 {\n    if (uniforms.textureEnabled == 0u) { return 0.0; }\n\n    let x = uv.x * uniforms.size.x;\n    let y = uv.y * uniforms.size.y;\n    let pixelSeed = pcgHash(uniforms.textureSeed ^ (u32(x) + u32(y) * 65536u));\n    let noise = noise3(pixelSeed);\n\n    let fineNoise = noise.x * uniforms.fineNoise;\n    let mediumNoise = noise.y * uniforms.mediumNoise;\n    let coarseNoise = noise.z * uniforms.coarseNoise;\n\n    let largeScaleX = sin(x * 0.005) * cos(y * 0.003);\n    let largeScaleY = cos(x * 0.003) * sin(y * 0.007);\n    let largeScale = (largeScaleX + largeScaleY) * uniforms.largeScale;\n\n    let fiberX = sin(x * 0.02) * uniforms.fiberIntensity;\n    let fiberY = sin(y * 0.015) * uniforms.fiberIntensity;\n    let fiber = (fiberX + fiberY) * 0.1;\n\n    return clamp(fineNoise + mediumNoise + coarseNoise + largeScale + fiber, 0.0, 1.0) * uniforms.textureOpacity;\n}\n\nfn lum(c: vec3f) -> f32 {\n    return 0.3 * c.r + 0.59 * c.g + 0.11 * c.b;\n}\n\nfn clipColor(c: vec3f) -> vec3f {\n    let l = lum(c);\n    let n = min(min(c.r, c.g), c.b);\n    let x = max(max(c.r, c.g), c.b);\n\n    var result = c;\n    if (n < 0.0) {\n        result = vec3f(l) + ((c - vec3f(l)) * l) / (l - n);\n    }\n    if (x > 1.0) {\n        result = vec3f(l) + ((c - vec3f(l)) * (1.0 - l)) / (x - l);\n    }\n    return result;\n}\n\nfn setLum(c: vec3f, l: f32) -> vec3f {\n    let d = l - lum(c);\n    return clipColor(c + vec3f(d));\n}\n\nfn sat(c: vec3f) -> f32 {\n    return max(max(c.r, c.g), c.b) - min(min(c.r, c.g), c.b);\n}\n\nfn setSat(c: vec3f, s: f32) -> vec3f {\n    let cmin = min(min(c.r, c.g), c.b);\n    let cmax = max(max(c.r, c.g), c.b);\n\n    if (cmax == cmin) {\n        return vec3f(0.0);\n    }\n\n    var result = vec3f(0.0);\n    let range = cmax - cmin;\n\n    result.r = (c.r - cmin) * s / range;\n    result.g = (c.g - cmin) * s / range;\n    result.b = (c.b - cmin) * s / range;\n\n    return result;\n}\n\nfn hueBlend(base: vec3f, blend: vec3f) -> vec3f {\n    let withSat = setSat(blend, sat(base));\n    return setLum(withSat, lum(base));\n}\n\nfn overlayBlend(base: f32, blend: f32) -> f32 {\n    if (base < 0.5) {\n        return 2.0 * base * blend;\n    }\n    return 1.0 - 2.0 * (1.0 - base) * (1.0 - blend);\n}\n\nfn differenceBlend(base: vec3f, blend: vec3f) -> vec3f {\n    return abs(base - blend);\n}\n\nfn alphaOver(dst: vec4f, src: vec4f) -> vec4f {\n    if (src.a <= 0.001) { return dst; }\n    let outAlpha = src.a + dst.a * (1.0 - src.a);\n    if (outAlpha <= 0.0) { return dst; }\n    return vec4f(\n        (src.rgb * src.a + dst.rgb * dst.a * (1.0 - src.a)) / outAlpha,\n        outAlpha\n    );\n}\n\nfn processBubble(pixelPos: vec2f, pos: vec2f, color: vec4f, twoSigmaSq: f32) -> vec4f {\n    let bubbleCenter = pos * uniforms.size;\n    let dist = distance(pixelPos, bubbleCenter);\n    let alpha = color.a * exp(-(dist * dist) / twoSigmaSq);\n    return vec4f(color.rgb, alpha);\n}\n\nfn generateBubbles(uv: vec2f) -> vec4f {\n    let pixelPos = uv * uniforms.size;\n    let effectiveRadius = uniforms.bubbleRadius + uniforms.blurRadius;\n    let sigma = effectiveRadius / 3.0;\n    let twoSigmaSq = 2.0 * sigma * sigma;\n\n    var result = vec4f(0.0);\n\n    if (uniforms.bubbleCount > 0u) {\n        let b0 = processBubble(pixelPos, uniforms.b0_pos, uniforms.b0_color, twoSigmaSq);\n        result = alphaOver(result, b0);\n    }\n    if (uniforms.bubbleCount > 1u) {\n        let b1 = processBubble(pixelPos, uniforms.b1_pos, uniforms.b1_color, twoSigmaSq);\n        result = alphaOver(result, b1);\n    }\n    if (uniforms.bubbleCount > 2u) {\n        let b2 = processBubble(pixelPos, uniforms.b2_pos, uniforms.b2_color, twoSigmaSq);\n        result = alphaOver(result, b2);\n    }\n    if (uniforms.bubbleCount > 3u) {\n        let b3 = processBubble(pixelPos, uniforms.b3_pos, uniforms.b3_color, twoSigmaSq);\n        result = alphaOver(result, b3);\n    }\n\n    return result;\n}\n\nfn generateGradient(uv: vec2f) -> vec3f {\n    let rad = uniforms.angle * 3.14159265 / 180.0;\n    let cos_a = cos(rad);\n    let sin_a = sin(rad);\n\n    let cx = uniforms.size.x / 2.0;\n    let cy = uniforms.size.y / 2.0;\n    let size = min(uniforms.size.x, uniforms.size.y);\n\n    let px = uv.x * uniforms.size.x;\n    let py = uv.y * uniforms.size.y;\n    let dx = px - cx;\n    let dy = py - cy;\n\n    let projected = (dx * cos_a + dy * sin_a) / size + 0.5;\n    let t = clamp(projected, 0.0, 1.0);\n\n    return mix(uniforms.color1.rgb, uniforms.color2.rgb, t);\n}\n\n@fragment\nfn fs(input: VertexOutput) -> @location(0) vec4f {\n    let gradient = generateGradient(input.uv);\n    let bubble = generateBubbles(input.uv);\n\n    var result = gradient;\n\n    let bubbleAlpha = bubble.a;\n    if (bubbleAlpha > 0.0) {\n        let blended = hueBlend(result, bubble.rgb);\n        result = mix(result, blended, bubbleAlpha);\n    }\n\n    let textureAlpha = generateTexture(input.uv);\n    if (textureAlpha > 0.0) {\n        let blended = vec3f(\n            overlayBlend(result.r, 1.0),\n            overlayBlend(result.g, 1.0),\n            overlayBlend(result.b, 1.0)\n        );\n        result = mix(result, blended, textureAlpha);\n    }\n\n    let overlayAlpha = uniforms.overlayColor.a;\n    if (overlayAlpha > 0.0) {\n        let blended = differenceBlend(result, uniforms.overlayColor.rgb);\n        result = mix(result, blended, overlayAlpha);\n    }\n\n    return vec4f(result, 1.0);\n}\n`;\n\nfunction createCompositeNode(res: Gradients): ComputeNode {\n    return {\n        id: \"gradient\",\n        inputs: [],\n        outputs: [{ id: \"scene\", access: \"write\" }],\n\n        execute(ctx: ExecutionContext) {\n            if (res.width === 0 || res.height === 0) return;\n            if (!res.bubbleUniformData) return;\n\n            if (!res.compositeUniformBuffer) {\n                res.compositeUniformBuffer = ctx.device.createBuffer({\n                    label: \"composite-uniforms\",\n                    size: 240,\n                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n                });\n            }\n\n            if (!res.compositeBindGroupLayout) {\n                res.compositeBindGroupLayout = ctx.device.createBindGroupLayout({\n                    entries: [\n                        {\n                            binding: 0,\n                            visibility: GPUShaderStage.FRAGMENT,\n                            buffer: { type: \"uniform\" },\n                        },\n                    ],\n                });\n            }\n\n            if (!res.compositePipeline) {\n                const module = ctx.device.createShaderModule({ code: COMPOSITE_SHADER });\n                res.compositePipeline = ctx.device.createRenderPipeline({\n                    layout: ctx.device.createPipelineLayout({\n                        bindGroupLayouts: [res.compositeBindGroupLayout],\n                    }),\n                    vertex: { module, entryPoint: \"vs\" },\n                    fragment: {\n                        module,\n                        entryPoint: \"fs\",\n                        targets: [{ format: ctx.format }],\n                    },\n                });\n            }\n\n            if (!res.compositeBindGroup) {\n                res.compositeBindGroup = ctx.device.createBindGroup({\n                    layout: res.compositeBindGroupLayout,\n                    entries: [{ binding: 0, resource: { buffer: res.compositeUniformBuffer } }],\n                });\n            }\n\n            const uniformData = new Float32Array(60);\n\n            uniformData[0] = res.overlayColor[0];\n            uniformData[1] = res.overlayColor[1];\n            uniformData[2] = res.overlayColor[2];\n            uniformData[3] = res.overlayColor[3];\n            uniformData[4] = res.gradientColor1[0];\n            uniformData[5] = res.gradientColor1[1];\n            uniformData[6] = res.gradientColor1[2];\n            uniformData[7] = res.gradientColor1[3];\n            uniformData[8] = res.gradientColor2[0];\n            uniformData[9] = res.gradientColor2[1];\n            uniformData[10] = res.gradientColor2[2];\n            uniformData[11] = res.gradientColor2[3];\n\n            for (let i = 0; i < 4; i++) {\n                const srcOffset = i * 8;\n                const dstOffset = 12 + i * 8;\n                uniformData[dstOffset + 0] = res.bubbleUniformData[srcOffset + 0];\n                uniformData[dstOffset + 1] = res.bubbleUniformData[srcOffset + 1];\n                uniformData[dstOffset + 4] = res.bubbleUniformData[srcOffset + 4];\n                uniformData[dstOffset + 5] = res.bubbleUniformData[srcOffset + 5];\n                uniformData[dstOffset + 6] = res.bubbleUniformData[srcOffset + 6];\n                uniformData[dstOffset + 7] = res.bubbleUniformData[srcOffset + 7];\n            }\n\n            const u32View = new Uint32Array(uniformData.buffer);\n            u32View[44] = res.textureSeed;\n            u32View[45] = res.textureEnabled ? 1 : 0;\n            uniformData[46] = res.fineNoise;\n            uniformData[47] = res.mediumNoise;\n            uniformData[48] = res.coarseNoise;\n            uniformData[49] = res.largeScale;\n            uniformData[50] = res.fiberIntensity;\n            uniformData[51] = res.textureOpacity;\n            uniformData[52] = res.width;\n            uniformData[53] = res.height;\n            uniformData[54] = res.gradientAngle;\n            uniformData[55] = res.bubbleRadius;\n            uniformData[56] = res.blurRadius;\n            u32View[57] = res.bubbleCount;\n\n            ctx.queue.writeBuffer(res.compositeUniformBuffer, 0, uniformData);\n\n            const pass = ctx.encoder.beginRenderPass({\n                colorAttachments: [\n                    {\n                        view: ctx.canvasView,\n                        loadOp: \"clear\",\n                        storeOp: \"store\",\n                        clearValue: { r: 0, g: 0, b: 0, a: 1 },\n                    },\n                ],\n            });\n\n            pass.setPipeline(res.compositePipeline);\n            pass.setBindGroup(0, res.compositeBindGroup);\n            pass.draw(6);\n            pass.end();\n        },\n    };\n}\n\nexport const GradientSystem: System = {\n    group: \"simulation\",\n\n    update(state: State) {\n        const compute = Compute.from(state);\n        const res = Gradients.from(state);\n        const canvas = Canvas.from(state);\n        if (!compute || !res || !canvas) return;\n\n        const { element } = canvas;\n        if (res.width !== element.width || res.height !== element.height) {\n            res.width = element.width;\n            res.height = element.height;\n        }\n\n        for (const eid of state.query([Gradient])) {\n            if (!Gradient.enabled[eid]) continue;\n\n            const bubbleCount = Math.min(\n                4,\n                Math.max(1, Math.floor(Gradient.bubbleCount[eid] || 4))\n            );\n            const physics: PhysicsConfig = {\n                springConstant:\n                    Gradient.springConstant[eid] || DEFAULT_PHYSICS_CONFIG.springConstant,\n                damping: Gradient.damping[eid] || DEFAULT_PHYSICS_CONFIG.damping,\n                bounds: {\n                    min: Gradient.boundsMin[eid] ?? DEFAULT_PHYSICS_CONFIG.bounds.min,\n                    max: Gradient.boundsMax[eid] ?? DEFAULT_PHYSICS_CONFIG.bounds.max,\n                },\n                targetThreshold: DEFAULT_PHYSICS_CONFIG.targetThreshold,\n            };\n\n            let b = res.bubbles.get(eid);\n            const seed = Gradient.seed[eid] || String(eid);\n\n            if (!b || b.length !== bubbleCount) {\n                b = generateBubbles(seed, bubbleCount, physics);\n                res.bubbles.set(eid, b);\n                res.randoms.set(eid, createSeededRandom(hashString(seed + \"-runtime\")));\n            }\n\n            const random = res.randoms.get(eid)!;\n            const dt = state.time.deltaTime;\n            for (let i = 0; i < b.length; i++) {\n                b[i] = updateBubbleTarget(stepBubble(b[i], dt, physics), random, physics);\n            }\n\n            if (!bubblesMoved(b)) continue;\n\n            res.bubbleCount = bubbleCount;\n            const angle = Gradient.angle[eid] || generateAngle(seed);\n            const gradientColor1 = Gradient.color1[eid] || DEFAULT_GRADIENT_CONFIG.color1;\n            const gradientColor2 = Gradient.color2[eid] || DEFAULT_GRADIENT_CONFIG.color2;\n\n            const color1 = parseColor(gradientColor1);\n            const color2 = parseColor(gradientColor2);\n            res.gradientAngle = angle;\n            res.gradientColor1 = [\n                color1[0] / 255,\n                color1[1] / 255,\n                color1[2] / 255,\n                color1[3] / 255,\n            ];\n            res.gradientColor2 = [\n                color2[0] / 255,\n                color2[1] / 255,\n                color2[2] / 255,\n                color2[3] / 255,\n            ];\n\n            const bubbleSize = Gradient.bubbleSize[eid] ?? DEFAULT_BUBBLE_CONFIG.size;\n            const bubbleBlur = Gradient.bubbleBlur[eid] ?? DEFAULT_BUBBLE_CONFIG.blur;\n\n            const bubbleUniformData = new Float32Array(4 * 8);\n            for (let i = 0; i < b.length; i++) {\n                const offset = i * 8;\n                bubbleUniformData[offset + 0] = b[i].x / 100;\n                bubbleUniformData[offset + 1] = b[i].y / 100;\n                const color = parseColor(b[i].color);\n                bubbleUniformData[offset + 4] = color[0] / 255;\n                bubbleUniformData[offset + 5] = color[1] / 255;\n                bubbleUniformData[offset + 6] = color[2] / 255;\n                bubbleUniformData[offset + 7] = color[3] / 255;\n            }\n            res.bubbleUniformData = bubbleUniformData;\n            res.bubbleRadius = (bubbleSize / 100) * Math.min(res.width, res.height);\n            res.blurRadius = (bubbleBlur / 100) * Math.min(res.width, res.height);\n\n            const textureEnabled = Gradient.textureEnabled[eid] !== 0;\n            res.textureEnabled = textureEnabled;\n            if (textureEnabled) {\n                res.textureSeed = hashStringToU32(seed + \"_texture\");\n                res.textureOpacity = Gradient.textureOpacity[eid] || DEFAULT_TEXTURE_CONFIG.opacity;\n                res.fineNoise = DEFAULT_TEXTURE_CONFIG.fineNoise;\n                res.mediumNoise = DEFAULT_TEXTURE_CONFIG.mediumNoise;\n                res.coarseNoise = DEFAULT_TEXTURE_CONFIG.coarseNoise;\n                res.largeScale = DEFAULT_TEXTURE_CONFIG.largeScale;\n                res.fiberIntensity = DEFAULT_TEXTURE_CONFIG.fiberIntensity;\n            }\n\n            const overlayEnabled = Gradient.overlayEnabled[eid] !== 0;\n            if (overlayEnabled) {\n                const overlayColor = parseColor(\n                    Gradient.overlayColor[eid] || DEFAULT_OVERLAY_CONFIG.color\n                );\n                res.overlayColor = [\n                    overlayColor[0] / 255,\n                    overlayColor[1] / 255,\n                    overlayColor[2] / 255,\n                    overlayColor[3] / 255,\n                ];\n            } else {\n                res.overlayColor = [0, 0, 0, 0];\n            }\n        }\n    },\n};\n\nexport const GradientPlugin: Plugin = {\n    systems: [GradientSystem],\n    components: { Gradient },\n\n    initialize(state: State) {\n        const gradientState: Gradients = {\n            bubbles: new Map(),\n            randoms: new Map(),\n            width: 0,\n            height: 0,\n            compositePipeline: null,\n            compositeBindGroup: null,\n            compositeBindGroupLayout: null,\n            compositeUniformBuffer: null,\n            gradientAngle: 0,\n            gradientColor1: [0, 0, 0, 1],\n            gradientColor2: [0, 0, 0, 1],\n            textureSeed: 0,\n            textureEnabled: true,\n            fineNoise: DEFAULT_TEXTURE_CONFIG.fineNoise,\n            mediumNoise: DEFAULT_TEXTURE_CONFIG.mediumNoise,\n            coarseNoise: DEFAULT_TEXTURE_CONFIG.coarseNoise,\n            largeScale: DEFAULT_TEXTURE_CONFIG.largeScale,\n            fiberIntensity: DEFAULT_TEXTURE_CONFIG.fiberIntensity,\n            textureOpacity: DEFAULT_TEXTURE_CONFIG.opacity,\n            overlayColor: [0, 0, 0, 0],\n            bubbleUniformData: null,\n            bubbleRadius: 0,\n            blurRadius: 0,\n            bubbleCount: 4,\n        };\n\n        state.setResource(Gradients, gradientState);\n\n        const compute = Compute.from(state);\n        if (compute) {\n            compute.graph.add(createCompositeNode(gradientState));\n        }\n    },\n};\n","import { Pair } from 'bitecs';\nimport {\n  setTraits,\n  Sequence,\n  SequenceState,\n  Tween,\n  TweenState,\n  ChildOf,\n  type State,\n  type System,\n  type Plugin,\n} from '@multiplekex/shallot';\n\nexport const StepController = {\n  step: [] as number[],\n  target: [] as number[],\n  max: [] as number[],\n};\n\nsetTraits(StepController, {\n  defaults: () => ({ step: 0, target: 0, max: 0 }),\n});\n\nexport const StepTransition = {\n  from: [] as number[],\n  to: [] as number[],\n};\n\nsetTraits(StepTransition, {\n  defaults: () => ({ from: 0, to: 0 }),\n});\n\nexport const TokenIndex = {\n  index: [] as number[],\n  group: [] as number[],\n};\n\nsetTraits(TokenIndex, {\n  defaults: () => ({ index: 0, group: 0 }),\n});\n\nfunction createStepControllerSystem(): System {\n  let isTransitioning = false;\n\n  return {\n    group: 'simulation',\n    update(state: State) {\n      if (isTransitioning) return;\n\n      for (const eid of state.query([StepController])) {\n        const current = StepController.step[eid];\n        const target = StepController.target[eid];\n\n        if (current !== target) {\n          isTransitioning = true;\n\n          for (const seqEid of state.query([Sequence])) {\n            if (Sequence.state[seqEid] === SequenceState.PLAYING) {\n              Sequence.state[seqEid] = SequenceState.COMPLETE;\n            }\n          }\n\n          state.step(0);\n\n          for (const seqEid of state.query([Sequence])) {\n            Sequence.state[seqEid] = SequenceState.IDLE;\n            Sequence.elapsed[seqEid] = 0;\n            for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\n              Tween.state[childEid] = TweenState.IDLE;\n              Tween.elapsed[childEid] = 0;\n            }\n          }\n\n          for (const seqEid of state.query([Sequence, StepTransition])) {\n            if (StepTransition.from[seqEid] === current && StepTransition.to[seqEid] === target) {\n              Sequence.state[seqEid] = SequenceState.PLAYING;\n              break;\n            }\n          }\n\n          StepController.step[eid] = target;\n          isTransitioning = false;\n        }\n      }\n    },\n  };\n}\n\nexport function createStepPlugin(): Plugin {\n  return {\n    components: { StepController, StepTransition, TokenIndex },\n    systems: [createStepControllerSystem()],\n  };\n}\n","import type { State } from '@multiplekex/shallot';\nimport { StepController } from './step-plugin';\n\nexport interface StepContent {\n  title: string;\n  description: string;\n}\n\nexport interface StepUIOptions {\n  steps: StepContent[];\n  getStep: () => number;\n  setStep: (step: number) => void;\n}\n\nexport interface StepUIElements {\n  btnPrev: HTMLButtonElement | null;\n  btnNext: HTMLButtonElement | null;\n  counter: HTMLElement | null;\n  title: HTMLElement | null;\n  description: HTMLElement | null;\n}\n\nexport function findStepElements(container: HTMLElement | string): StepUIElements {\n  const root = typeof container === 'string' ? document.querySelector(container) : container;\n  if (!root) {\n    return { btnPrev: null, btnNext: null, counter: null, title: null, description: null };\n  }\n\n  return {\n    btnPrev: root.querySelector('.btn-prev') as HTMLButtonElement | null,\n    btnNext: root.querySelector('.btn-next') as HTMLButtonElement | null,\n    counter: root.querySelector('.step-counter'),\n    title: root.querySelector('.step-title'),\n    description: root.querySelector('.step-description'),\n  };\n}\n\nexport function setupStepUI(elements: StepUIElements, options: StepUIOptions): () => void {\n  const { steps, getStep, setStep } = options;\n  const maxStep = steps.length - 1;\n\n  const stepInfo = elements.title?.parentElement;\n  if (stepInfo) {\n    let maxHeight = 0;\n    for (const step of steps) {\n      if (elements.title) elements.title.textContent = step.title;\n      if (elements.description) elements.description.innerHTML = step.description;\n      maxHeight = Math.max(maxHeight, stepInfo.offsetHeight);\n    }\n    stepInfo.style.minHeight = `${maxHeight}px`;\n  }\n\n  function updateDisplay(): void {\n    const currentStep = getStep();\n    const { btnPrev, btnNext, counter, title, description } = elements;\n    const content = steps[currentStep];\n\n    if (btnPrev) btnPrev.disabled = currentStep <= 0;\n    if (btnNext) btnNext.disabled = currentStep >= maxStep;\n    if (counter) counter.textContent = `Step ${currentStep + 1} of ${steps.length}`;\n    if (title) title.textContent = content?.title ?? '';\n    if (description) description.innerHTML = content?.description ?? '';\n  }\n\n  const handlePrev = () => setStep(getStep() - 1);\n  const handleNext = () => setStep(getStep() + 1);\n  const handleKeydown = (e: KeyboardEvent) => {\n    if (e.key === 'ArrowLeft') setStep(getStep() - 1);\n    if (e.key === 'ArrowRight') setStep(getStep() + 1);\n  };\n\n  elements.btnPrev?.addEventListener('click', handlePrev);\n  elements.btnNext?.addEventListener('click', handleNext);\n  document.addEventListener('keydown', handleKeydown);\n\n  // Poll for changes to keep UI in sync with source of truth\n  const interval = setInterval(updateDisplay, 50);\n  updateDisplay();\n\n  return () => {\n    clearInterval(interval);\n    elements.btnPrev?.removeEventListener('click', handlePrev);\n    elements.btnNext?.removeEventListener('click', handleNext);\n    document.removeEventListener('keydown', handleKeydown);\n  };\n}\n\nexport function connectStepControls(\n  canvas: HTMLCanvasElement,\n  state: State,\n  steps: StepContent[],\n  onStepChange?: (step: number) => void\n): () => void {\n  const controllers = [...state.query([StepController])];\n  const controllerEid = controllers[0];\n\n  if (controllerEid === undefined) {\n    return () => {};\n  }\n\n  const maxStep = steps.length - 1;\n\n  const getStep = () => StepController.target[controllerEid];\n  const setStep = (step: number) => {\n    const clamped = Math.max(0, Math.min(maxStep, step));\n    StepController.target[controllerEid] = clamped;\n    onStepChange?.(clamped);\n  };\n  const setStepImmediate = (step: number) => {\n    const clamped = Math.max(0, Math.min(maxStep, step));\n    StepController.step[controllerEid] = clamped;\n    StepController.target[controllerEid] = clamped;\n    onStepChange?.(clamped);\n  };\n\n  const elements = findStepElements(document.body);\n  const dispose = setupStepUI(elements, { steps, getStep, setStep });\n\n  canvas.__controllerEid__ = controllerEid;\n  canvas.__getStep__ = getStep;\n  canvas.__setStep__ = setStep;\n  canvas.__setStepImmediate__ = setStepImmediate;\n  canvas.__maxStep__ = maxStep;\n\n  return dispose;\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport function assert(x) {\n    if (!x) {\n        throw new Error('Assertion failed.');\n    }\n}\nexport const normalizeRotation = (rotation) => {\n    const mappedRotation = (rotation % 360 + 360) % 360;\n    if (mappedRotation === 0 || mappedRotation === 90 || mappedRotation === 180 || mappedRotation === 270) {\n        return mappedRotation;\n    }\n    else {\n        throw new Error(`Invalid rotation ${rotation}.`);\n    }\n};\nexport const last = (arr) => {\n    return arr && arr[arr.length - 1];\n};\nexport const isU32 = (value) => {\n    return value >= 0 && value < 2 ** 32;\n};\nexport class Bitstream {\n    constructor(bytes) {\n        this.bytes = bytes;\n        /** Current offset in bits. */\n        this.pos = 0;\n    }\n    seekToByte(byteOffset) {\n        this.pos = 8 * byteOffset;\n    }\n    readBit() {\n        const byteIndex = Math.floor(this.pos / 8);\n        const byte = this.bytes[byteIndex] ?? 0;\n        const bitIndex = 0b111 - (this.pos & 0b111);\n        const bit = (byte & (1 << bitIndex)) >> bitIndex;\n        this.pos++;\n        return bit;\n    }\n    readBits(n) {\n        if (n === 1) {\n            return this.readBit();\n        }\n        let result = 0;\n        for (let i = 0; i < n; i++) {\n            result <<= 1;\n            result |= this.readBit();\n        }\n        return result;\n    }\n    writeBits(n, value) {\n        const end = this.pos + n;\n        for (let i = this.pos; i < end; i++) {\n            const byteIndex = Math.floor(i / 8);\n            let byte = this.bytes[byteIndex];\n            const bitIndex = 0b111 - (i & 0b111);\n            byte &= ~(1 << bitIndex);\n            byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n            this.bytes[byteIndex] = byte;\n        }\n        this.pos = end;\n    }\n    ;\n    readAlignedByte() {\n        // Ensure we're byte-aligned\n        if (this.pos % 8 !== 0) {\n            throw new Error('Bitstream is not byte-aligned.');\n        }\n        const byteIndex = this.pos / 8;\n        const byte = this.bytes[byteIndex] ?? 0;\n        this.pos += 8;\n        return byte;\n    }\n    skipBits(n) {\n        this.pos += n;\n    }\n    getBitsLeft() {\n        return this.bytes.length * 8 - this.pos;\n    }\n    clone() {\n        const clone = new Bitstream(this.bytes);\n        clone.pos = this.pos;\n        return clone;\n    }\n}\n/** Reads an exponential-Golomb universal code from a Bitstream.  */\nexport const readExpGolomb = (bitstream) => {\n    let leadingZeroBits = 0;\n    while (bitstream.readBits(1) === 0 && leadingZeroBits < 32) {\n        leadingZeroBits++;\n    }\n    if (leadingZeroBits >= 32) {\n        throw new Error('Invalid exponential-Golomb code.');\n    }\n    const result = (1 << leadingZeroBits) - 1 + bitstream.readBits(leadingZeroBits);\n    return result;\n};\n/** Reads a signed exponential-Golomb universal code from a Bitstream. */\nexport const readSignedExpGolomb = (bitstream) => {\n    const codeNum = readExpGolomb(bitstream);\n    return ((codeNum & 1) === 0)\n        ? -(codeNum >> 1)\n        : ((codeNum + 1) >> 1);\n};\nexport const writeBits = (bytes, start, end, value) => {\n    for (let i = start; i < end; i++) {\n        const byteIndex = Math.floor(i / 8);\n        let byte = bytes[byteIndex];\n        const bitIndex = 0b111 - (i & 0b111);\n        byte &= ~(1 << bitIndex);\n        byte |= ((value & (1 << (end - i - 1))) >> (end - i - 1)) << bitIndex;\n        bytes[byteIndex] = byte;\n    }\n};\nexport const toUint8Array = (source) => {\n    if (source.constructor === Uint8Array) { // We want a true Uint8Array, not something that extends it like Buffer\n        return source;\n    }\n    else if (ArrayBuffer.isView(source)) {\n        return new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n    }\n    else {\n        return new Uint8Array(source);\n    }\n};\nexport const toDataView = (source) => {\n    if (source.constructor === DataView) {\n        return source;\n    }\n    else if (ArrayBuffer.isView(source)) {\n        return new DataView(source.buffer, source.byteOffset, source.byteLength);\n    }\n    else {\n        return new DataView(source);\n    }\n};\nexport const textDecoder = /* #__PURE__ */ new TextDecoder();\nexport const textEncoder = /* #__PURE__ */ new TextEncoder();\nexport const isIso88591Compatible = (text) => {\n    for (let i = 0; i < text.length; i++) {\n        const code = text.charCodeAt(i);\n        if (code > 255) {\n            return false;\n        }\n    }\n    return true;\n};\nconst invertObject = (object) => {\n    return Object.fromEntries(Object.entries(object).map(([key, value]) => [value, key]));\n};\n// For the color space mappings, see Rec. ITU-T H.273.\nexport const COLOR_PRIMARIES_MAP = {\n    bt709: 1, // ITU-R BT.709\n    bt470bg: 5, // ITU-R BT.470BG\n    smpte170m: 6, // ITU-R BT.601 525 - SMPTE 170M\n    bt2020: 9, // ITU-R BT.202\n    smpte432: 12, // SMPTE EG 432-1\n};\nexport const COLOR_PRIMARIES_MAP_INVERSE = /* #__PURE__ */ invertObject(COLOR_PRIMARIES_MAP);\nexport const TRANSFER_CHARACTERISTICS_MAP = {\n    'bt709': 1, // ITU-R BT.709\n    'smpte170m': 6, // SMPTE 170M\n    'linear': 8, // Linear transfer characteristics\n    'iec61966-2-1': 13, // IEC 61966-2-1\n    'pq': 16, // Rec. ITU-R BT.2100-2 perceptual quantization (PQ) system\n    'hlg': 18, // Rec. ITU-R BT.2100-2 hybrid loggamma (HLG) system\n};\nexport const TRANSFER_CHARACTERISTICS_MAP_INVERSE = /* #__PURE__ */ invertObject(TRANSFER_CHARACTERISTICS_MAP);\nexport const MATRIX_COEFFICIENTS_MAP = {\n    'rgb': 0, // Identity\n    'bt709': 1, // ITU-R BT.709\n    'bt470bg': 5, // ITU-R BT.470BG\n    'smpte170m': 6, // SMPTE 170M\n    'bt2020-ncl': 9, // ITU-R BT.2020-2 (non-constant luminance)\n};\nexport const MATRIX_COEFFICIENTS_MAP_INVERSE = /* #__PURE__ */ invertObject(MATRIX_COEFFICIENTS_MAP);\nexport const colorSpaceIsComplete = (colorSpace) => {\n    return (!!colorSpace\n        && !!colorSpace.primaries\n        && !!colorSpace.transfer\n        && !!colorSpace.matrix\n        && colorSpace.fullRange !== undefined);\n};\nexport const isAllowSharedBufferSource = (x) => {\n    return (x instanceof ArrayBuffer\n        || (typeof SharedArrayBuffer !== 'undefined' && x instanceof SharedArrayBuffer)\n        || ArrayBuffer.isView(x));\n};\nexport class AsyncMutex {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n        this.pending = 0;\n    }\n    async acquire() {\n        let resolver;\n        const nextPromise = new Promise((resolve) => {\n            let resolved = false;\n            resolver = () => {\n                if (resolved) {\n                    return;\n                }\n                resolve();\n                this.pending--;\n                resolved = true;\n            };\n        });\n        const currentPromiseAlias = this.currentPromise;\n        this.currentPromise = nextPromise;\n        this.pending++;\n        await currentPromiseAlias;\n        return resolver;\n    }\n}\nexport const bytesToHexString = (bytes) => {\n    return [...bytes].map(x => x.toString(16).padStart(2, '0')).join('');\n};\nexport const reverseBitsU32 = (x) => {\n    x = ((x >> 1) & 0x55555555) | ((x & 0x55555555) << 1);\n    x = ((x >> 2) & 0x33333333) | ((x & 0x33333333) << 2);\n    x = ((x >> 4) & 0x0f0f0f0f) | ((x & 0x0f0f0f0f) << 4);\n    x = ((x >> 8) & 0x00ff00ff) | ((x & 0x00ff00ff) << 8);\n    x = ((x >> 16) & 0x0000ffff) | ((x & 0x0000ffff) << 16);\n    return x >>> 0; // Ensure it's treated as an unsigned 32-bit integer\n};\n/** Returns the smallest index i such that val[i] === key, or -1 if no such index exists. */\nexport const binarySearchExact = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + high) >> 1;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal === key) {\n            ans = mid;\n            high = mid - 1; // Continue searching left to find the lowest index\n        }\n        else if (midVal < key) {\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Returns the largest index i such that val[i] <= key, or -1 if no such index exists. */\nexport const binarySearchLessOrEqual = (arr, key, valueGetter) => {\n    let low = 0;\n    let high = arr.length - 1;\n    let ans = -1;\n    while (low <= high) {\n        const mid = (low + (high - low + 1) / 2) | 0;\n        const midVal = valueGetter(arr[mid]);\n        if (midVal <= key) {\n            ans = mid;\n            low = mid + 1;\n        }\n        else {\n            high = mid - 1;\n        }\n    }\n    return ans;\n};\n/** Assumes the array is already sorted. */\nexport const insertSorted = (arr, item, valueGetter) => {\n    const insertionIndex = binarySearchLessOrEqual(arr, valueGetter(item), valueGetter);\n    arr.splice(insertionIndex + 1, 0, item); // This even behaves correctly for the -1 case\n};\nexport const promiseWithResolvers = () => {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej) => {\n        resolve = res;\n        reject = rej;\n    });\n    return { promise, resolve: resolve, reject: reject };\n};\nexport const removeItem = (arr, item) => {\n    const index = arr.indexOf(item);\n    if (index !== -1) {\n        arr.splice(index, 1);\n    }\n};\nexport const findLast = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return arr[i];\n        }\n    }\n    return undefined;\n};\nexport const findLastIndex = (arr, predicate) => {\n    for (let i = arr.length - 1; i >= 0; i--) {\n        if (predicate(arr[i])) {\n            return i;\n        }\n    }\n    return -1;\n};\nexport const toAsyncIterator = async function* (source) {\n    if (Symbol.iterator in source) {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.iterator]();\n    }\n    else {\n        // @ts-expect-error Trust me\n        yield* source[Symbol.asyncIterator]();\n    }\n};\nexport const validateAnyIterable = (iterable) => {\n    if (!(Symbol.iterator in iterable) && !(Symbol.asyncIterator in iterable)) {\n        throw new TypeError('Argument must be an iterable or async iterable.');\n    }\n};\nexport const assertNever = (x) => {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new Error(`Unexpected value: ${x}`);\n};\nexport const getUint24 = (view, byteOffset, littleEndian) => {\n    const byte1 = view.getUint8(byteOffset);\n    const byte2 = view.getUint8(byteOffset + 1);\n    const byte3 = view.getUint8(byteOffset + 2);\n    if (littleEndian) {\n        return byte1 | (byte2 << 8) | (byte3 << 16);\n    }\n    else {\n        return (byte1 << 16) | (byte2 << 8) | byte3;\n    }\n};\nexport const getInt24 = (view, byteOffset, littleEndian) => {\n    // The left shift pushes the most significant bit into the sign bit region, and the subsequent right shift\n    // then correctly interprets the sign bit.\n    return getUint24(view, byteOffset, littleEndian) << 8 >> 8;\n};\nexport const setUint24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit unsigned range (0 to 16777215)\n    value = value >>> 0; // Convert to unsigned 32-bit\n    value = value & 0xFFFFFF; // Mask to 24 bits\n    if (littleEndian) {\n        view.setUint8(byteOffset, value & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, (value >>> 16) & 0xFF);\n    }\n    else {\n        view.setUint8(byteOffset, (value >>> 16) & 0xFF);\n        view.setUint8(byteOffset + 1, (value >>> 8) & 0xFF);\n        view.setUint8(byteOffset + 2, value & 0xFF);\n    }\n};\nexport const setInt24 = (view, byteOffset, value, littleEndian) => {\n    // Ensure the value is within 24-bit signed range (-8388608 to 8388607)\n    value = clamp(value, -8388608, 8388607);\n    // Convert negative values to their 24-bit representation\n    if (value < 0) {\n        value = (value + 0x1000000) & 0xFFFFFF;\n    }\n    setUint24(view, byteOffset, value, littleEndian);\n};\nexport const setInt64 = (view, byteOffset, value, littleEndian) => {\n    if (littleEndian) {\n        view.setUint32(byteOffset + 0, value, true);\n        view.setInt32(byteOffset + 4, Math.floor(value / 2 ** 32), true);\n    }\n    else {\n        view.setInt32(byteOffset + 0, Math.floor(value / 2 ** 32), true);\n        view.setUint32(byteOffset + 4, value, true);\n    }\n};\n/**\n * Calls a function on each value spat out by an async generator. The reason for writing this manually instead of\n * using a generator function is that the generator function queues return() calls - here, we forward them immediately.\n */\nexport const mapAsyncGenerator = (generator, map) => {\n    return {\n        async next() {\n            const result = await generator.next();\n            if (result.done) {\n                return { value: undefined, done: true };\n            }\n            else {\n                return { value: map(result.value), done: false };\n            }\n        },\n        return() {\n            return generator.return();\n        },\n        throw(error) {\n            return generator.throw(error);\n        },\n        [Symbol.asyncIterator]() {\n            return this;\n        },\n    };\n};\nexport const clamp = (value, min, max) => {\n    return Math.max(min, Math.min(max, value));\n};\nexport const UNDETERMINED_LANGUAGE = 'und';\nexport const roundIfAlmostInteger = (value) => {\n    const rounded = Math.round(value);\n    if (Math.abs(value / rounded - 1) < 10 * Number.EPSILON) {\n        return rounded;\n    }\n    else {\n        return value;\n    }\n};\nexport const roundToMultiple = (value, multiple) => {\n    return Math.round(value / multiple) * multiple;\n};\nexport const floorToMultiple = (value, multiple) => {\n    return Math.floor(value / multiple) * multiple;\n};\nexport const ilog = (x) => {\n    let ret = 0;\n    while (x) {\n        ret++;\n        x >>= 1;\n    }\n    return ret;\n};\nconst ISO_639_2_REGEX = /^[a-z]{3}$/;\nexport const isIso639Dash2LanguageCode = (x) => {\n    return ISO_639_2_REGEX.test(x);\n};\n// Since the result will be truncated, add a bit of eps to compensate for floating point errors\nexport const SECOND_TO_MICROSECOND_FACTOR = 1e6 * (1 + Number.EPSILON);\n/**\n * Merges two RequestInit objects with special handling for headers.\n * Headers are merged case-insensitively, but original casing is preserved.\n * init2 headers take precedence and will override case-insensitive matches from init1.\n */\nexport const mergeRequestInit = (init1, init2) => {\n    const merged = { ...init1, ...init2 };\n    // Special handling for headers\n    if (init1.headers || init2.headers) {\n        const headers1 = init1.headers ? normalizeHeaders(init1.headers) : {};\n        const headers2 = init2.headers ? normalizeHeaders(init2.headers) : {};\n        const mergedHeaders = { ...headers1 };\n        // For each header in headers2, check if a case-insensitive match exists in mergedHeaders\n        Object.entries(headers2).forEach(([key2, value2]) => {\n            const existingKey = Object.keys(mergedHeaders).find(key1 => key1.toLowerCase() === key2.toLowerCase());\n            if (existingKey) {\n                delete mergedHeaders[existingKey];\n            }\n            mergedHeaders[key2] = value2;\n        });\n        merged.headers = mergedHeaders;\n    }\n    return merged;\n};\n/** Normalizes HeadersInit to a Record<string, string> format. */\nconst normalizeHeaders = (headers) => {\n    if (headers instanceof Headers) {\n        const result = {};\n        headers.forEach((value, key) => {\n            result[key] = value;\n        });\n        return result;\n    }\n    if (Array.isArray(headers)) {\n        const result = {};\n        headers.forEach(([key, value]) => {\n            result[key] = value;\n        });\n        return result;\n    }\n    return headers;\n};\nexport const retriedFetch = async (fetchFn, url, requestInit, getRetryDelay, shouldStop) => {\n    let attempts = 0;\n    while (true) {\n        try {\n            return await fetchFn(url, requestInit);\n        }\n        catch (error) {\n            if (shouldStop()) {\n                throw error;\n            }\n            attempts++;\n            const retryDelayInSeconds = getRetryDelay(attempts, error, url);\n            if (retryDelayInSeconds === null) {\n                throw error;\n            }\n            console.error('Retrying failed fetch. Error:', error);\n            if (!Number.isFinite(retryDelayInSeconds) || retryDelayInSeconds < 0) {\n                throw new TypeError('Retry delay must be a non-negative finite number.');\n            }\n            if (retryDelayInSeconds > 0) {\n                await new Promise(resolve => setTimeout(resolve, 1000 * retryDelayInSeconds));\n            }\n            if (shouldStop()) {\n                throw error;\n            }\n        }\n    }\n};\nexport const computeRationalApproximation = (x, maxDenominator) => {\n    // Handle negative numbers\n    const sign = x < 0 ? -1 : 1;\n    x = Math.abs(x);\n    let prevNumerator = 0, prevDenominator = 1;\n    let currNumerator = 1, currDenominator = 0;\n    // Continued fraction algorithm\n    let remainder = x;\n    while (true) {\n        const integer = Math.floor(remainder);\n        // Calculate next convergent\n        const nextNumerator = integer * currNumerator + prevNumerator;\n        const nextDenominator = integer * currDenominator + prevDenominator;\n        if (nextDenominator > maxDenominator) {\n            return {\n                numerator: sign * currNumerator,\n                denominator: currDenominator,\n            };\n        }\n        prevNumerator = currNumerator;\n        prevDenominator = currDenominator;\n        currNumerator = nextNumerator;\n        currDenominator = nextDenominator;\n        remainder = 1 / (remainder - integer);\n        // Guard against precision issues\n        if (!isFinite(remainder)) {\n            break;\n        }\n    }\n    return {\n        numerator: sign * currNumerator,\n        denominator: currDenominator,\n    };\n};\nexport class CallSerializer {\n    constructor() {\n        this.currentPromise = Promise.resolve();\n    }\n    call(fn) {\n        return this.currentPromise = this.currentPromise.then(fn);\n    }\n}\nlet isWebKitCache = null;\nexport const isWebKit = () => {\n    if (isWebKitCache !== null) {\n        return isWebKitCache;\n    }\n    // This even returns true for WebKit-wrapping browsers such as Chrome on iOS\n    return isWebKitCache = !!(typeof navigator !== 'undefined'\n        && (navigator.vendor?.match(/apple/i)\n            // Or, in workers:\n            || (/AppleWebKit/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent))\n            || /\\b(iPad|iPhone|iPod)\\b/.test(navigator.userAgent)));\n};\nlet isFirefoxCache = null;\nexport const isFirefox = () => {\n    if (isFirefoxCache !== null) {\n        return isFirefoxCache;\n    }\n    return isFirefoxCache = typeof navigator !== 'undefined' && navigator.userAgent?.includes('Firefox');\n};\nlet isChromiumCache = null;\nexport const isChromium = () => {\n    if (isChromiumCache !== null) {\n        return isChromiumCache;\n    }\n    return isChromiumCache = !!(typeof navigator !== 'undefined'\n        && (navigator.vendor?.includes('Google Inc') || /Chrome/.test(navigator.userAgent)));\n};\nlet chromiumVersionCache = null;\nexport const getChromiumVersion = () => {\n    if (chromiumVersionCache !== null) {\n        return chromiumVersionCache;\n    }\n    if (typeof navigator === 'undefined') {\n        return null;\n    }\n    const match = /\\bChrome\\/(\\d+)/.exec(navigator.userAgent);\n    if (!match) {\n        return null;\n    }\n    return chromiumVersionCache = Number(match[1]);\n};\n/** Acts like `??` except the condition is -1 and not null/undefined. */\nexport const coalesceIndex = (a, b) => {\n    return a !== -1 ? a : b;\n};\nexport const closedIntervalsOverlap = (startA, endA, startB, endB) => {\n    return startA <= endB && startB <= endA;\n};\nexport const keyValueIterator = function* (object) {\n    for (const key in object) {\n        const value = object[key];\n        if (value === undefined) {\n            continue;\n        }\n        yield { key, value };\n    }\n};\nexport const imageMimeTypeToExtension = (mimeType) => {\n    switch (mimeType.toLowerCase()) {\n        case 'image/jpeg':\n        case 'image/jpg':\n            return '.jpg';\n        case 'image/png':\n            return '.png';\n        case 'image/gif':\n            return '.gif';\n        case 'image/webp':\n            return '.webp';\n        case 'image/bmp':\n            return '.bmp';\n        case 'image/svg+xml':\n            return '.svg';\n        case 'image/tiff':\n            return '.tiff';\n        case 'image/avif':\n            return '.avif';\n        case 'image/x-icon':\n        case 'image/vnd.microsoft.icon':\n            return '.ico';\n        default:\n            return null;\n    }\n};\nexport const base64ToBytes = (base64) => {\n    const decoded = atob(base64);\n    const bytes = new Uint8Array(decoded.length);\n    for (let i = 0; i < decoded.length; i++) {\n        bytes[i] = decoded.charCodeAt(i);\n    }\n    return bytes;\n};\nexport const bytesToBase64 = (bytes) => {\n    let string = '';\n    for (let i = 0; i < bytes.length; i++) {\n        string += String.fromCharCode(bytes[i]);\n    }\n    return btoa(string);\n};\nexport const uint8ArraysAreEqual = (a, b) => {\n    if (a.length !== b.length) {\n        return false;\n    }\n    for (let i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) {\n            return false;\n        }\n    }\n    return true;\n};\nexport const polyfillSymbolDispose = () => {\n    // https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-2.html\n    // @ts-expect-error Readonly\n    Symbol.dispose ??= Symbol('Symbol.dispose');\n};\nexport const isNumber = (x) => {\n    return typeof x === 'number' && !Number.isNaN(x);\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Image data with additional metadata.\n *\n * @group Metadata tags\n * @public\n */\nexport class RichImageData {\n    /** Creates a new {@link RichImageData}. */\n    constructor(\n    /** The raw image data. */\n    data, \n    /** An RFC 6838 MIME type (e.g. image/jpeg, image/png, etc.) */\n    mimeType) {\n        this.data = data;\n        this.mimeType = mimeType;\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (typeof mimeType !== 'string') {\n            throw new TypeError('mimeType must be a string.');\n        }\n    }\n}\n/**\n * A file attached to a media file.\n *\n * @group Metadata tags\n * @public\n */\nexport class AttachedFile {\n    /** Creates a new {@link AttachedFile}. */\n    constructor(\n    /** The raw file data. */\n    data, \n    /** An RFC 6838 MIME type (e.g. image/jpeg, image/png, font/ttf, etc.) */\n    mimeType, \n    /** The name of the file. */\n    name, \n    /** A description of the file. */\n    description) {\n        this.data = data;\n        this.mimeType = mimeType;\n        this.name = name;\n        this.description = description;\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (mimeType !== undefined && typeof mimeType !== 'string') {\n            throw new TypeError('mimeType, when provided, must be a string.');\n        }\n        if (name !== undefined && typeof name !== 'string') {\n            throw new TypeError('name, when provided, must be a string.');\n        }\n        if (description !== undefined && typeof description !== 'string') {\n            throw new TypeError('description, when provided, must be a string.');\n        }\n    }\n}\n;\nexport const validateMetadataTags = (tags) => {\n    if (!tags || typeof tags !== 'object') {\n        throw new TypeError('tags must be an object.');\n    }\n    if (tags.title !== undefined && typeof tags.title !== 'string') {\n        throw new TypeError('tags.title, when provided, must be a string.');\n    }\n    if (tags.description !== undefined && typeof tags.description !== 'string') {\n        throw new TypeError('tags.description, when provided, must be a string.');\n    }\n    if (tags.artist !== undefined && typeof tags.artist !== 'string') {\n        throw new TypeError('tags.artist, when provided, must be a string.');\n    }\n    if (tags.album !== undefined && typeof tags.album !== 'string') {\n        throw new TypeError('tags.album, when provided, must be a string.');\n    }\n    if (tags.albumArtist !== undefined && typeof tags.albumArtist !== 'string') {\n        throw new TypeError('tags.albumArtist, when provided, must be a string.');\n    }\n    if (tags.trackNumber !== undefined && (!Number.isInteger(tags.trackNumber) || tags.trackNumber <= 0)) {\n        throw new TypeError('tags.trackNumber, when provided, must be a positive integer.');\n    }\n    if (tags.tracksTotal !== undefined\n        && (!Number.isInteger(tags.tracksTotal) || tags.tracksTotal <= 0)) {\n        throw new TypeError('tags.tracksTotal, when provided, must be a positive integer.');\n    }\n    if (tags.discNumber !== undefined && (!Number.isInteger(tags.discNumber) || tags.discNumber <= 0)) {\n        throw new TypeError('tags.discNumber, when provided, must be a positive integer.');\n    }\n    if (tags.discsTotal !== undefined\n        && (!Number.isInteger(tags.discsTotal) || tags.discsTotal <= 0)) {\n        throw new TypeError('tags.discsTotal, when provided, must be a positive integer.');\n    }\n    if (tags.genre !== undefined && typeof tags.genre !== 'string') {\n        throw new TypeError('tags.genre, when provided, must be a string.');\n    }\n    if (tags.date !== undefined && (!(tags.date instanceof Date) || Number.isNaN(tags.date.getTime()))) {\n        throw new TypeError('tags.date, when provided, must be a valid Date.');\n    }\n    if (tags.lyrics !== undefined && typeof tags.lyrics !== 'string') {\n        throw new TypeError('tags.lyrics, when provided, must be a string.');\n    }\n    if (tags.images !== undefined) {\n        if (!Array.isArray(tags.images)) {\n            throw new TypeError('tags.images, when provided, must be an array.');\n        }\n        for (const image of tags.images) {\n            if (!image || typeof image !== 'object') {\n                throw new TypeError('Each image in tags.images must be an object.');\n            }\n            if (!(image.data instanceof Uint8Array)) {\n                throw new TypeError('Each image.data must be a Uint8Array.');\n            }\n            if (typeof image.mimeType !== 'string') {\n                throw new TypeError('Each image.mimeType must be a string.');\n            }\n            if (!['coverFront', 'coverBack', 'unknown'].includes(image.kind)) {\n                throw new TypeError('Each image.kind must be \\'coverFront\\', \\'coverBack\\', or \\'unknown\\'.');\n            }\n        }\n    }\n    if (tags.comment !== undefined && typeof tags.comment !== 'string') {\n        throw new TypeError('tags.comment, when provided, must be a string.');\n    }\n    if (tags.raw !== undefined) {\n        if (!tags.raw || typeof tags.raw !== 'object') {\n            throw new TypeError('tags.raw, when provided, must be an object.');\n        }\n        for (const value of Object.values(tags.raw)) {\n            if (value !== null\n                && typeof value !== 'string'\n                && !(value instanceof Uint8Array)\n                && !(value instanceof RichImageData)\n                && !(value instanceof AttachedFile)) {\n                throw new TypeError('Each value in tags.raw must be a string, Uint8Array, RichImageData, AttachedFile, or null.');\n            }\n        }\n    }\n};\nexport const metadataTagsAreEmpty = (tags) => {\n    return tags.title === undefined\n        && tags.description === undefined\n        && tags.artist === undefined\n        && tags.album === undefined\n        && tags.albumArtist === undefined\n        && tags.trackNumber === undefined\n        && tags.tracksTotal === undefined\n        && tags.discNumber === undefined\n        && tags.discsTotal === undefined\n        && tags.genre === undefined\n        && tags.date === undefined\n        && tags.lyrics === undefined\n        && (!tags.images || tags.images.length === 0)\n        && tags.comment === undefined\n        && (tags.raw === undefined || Object.keys(tags.raw).length === 0);\n};\nexport const DEFAULT_TRACK_DISPOSITION = {\n    default: true,\n    forced: false,\n    original: false,\n    commentary: false,\n    hearingImpaired: false,\n    visuallyImpaired: false,\n};\nexport const validateTrackDisposition = (disposition) => {\n    if (!disposition || typeof disposition !== 'object') {\n        throw new TypeError('disposition must be an object.');\n    }\n    if (disposition.default !== undefined && typeof disposition.default !== 'boolean') {\n        throw new TypeError('disposition.default must be a boolean.');\n    }\n    if (disposition.forced !== undefined && typeof disposition.forced !== 'boolean') {\n        throw new TypeError('disposition.forced must be a boolean.');\n    }\n    if (disposition.original !== undefined && typeof disposition.original !== 'boolean') {\n        throw new TypeError('disposition.original must be a boolean.');\n    }\n    if (disposition.commentary !== undefined && typeof disposition.commentary !== 'boolean') {\n        throw new TypeError('disposition.commentary must be a boolean.');\n    }\n    if (disposition.hearingImpaired !== undefined && typeof disposition.hearingImpaired !== 'boolean') {\n        throw new TypeError('disposition.hearingImpaired must be a boolean.');\n    }\n    if (disposition.visuallyImpaired !== undefined && typeof disposition.visuallyImpaired !== 'boolean') {\n        throw new TypeError('disposition.visuallyImpaired must be a boolean.');\n    }\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream, COLOR_PRIMARIES_MAP, MATRIX_COEFFICIENTS_MAP, TRANSFER_CHARACTERISTICS_MAP, assert, bytesToHexString, isAllowSharedBufferSource, last, reverseBitsU32, toDataView, } from './misc.js';\n/**\n * List of known video codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const VIDEO_CODECS = [\n    'avc',\n    'hevc',\n    'vp9',\n    'av1',\n    'vp8',\n];\n/**\n * List of known PCM (uncompressed) audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const PCM_AUDIO_CODECS = [\n    'pcm-s16', // We don't prefix 'le' so we're compatible with the WebCodecs-registered PCM codec strings\n    'pcm-s16be',\n    'pcm-s24',\n    'pcm-s24be',\n    'pcm-s32',\n    'pcm-s32be',\n    'pcm-f32',\n    'pcm-f32be',\n    'pcm-f64',\n    'pcm-f64be',\n    'pcm-u8',\n    'pcm-s8',\n    'ulaw',\n    'alaw',\n];\n/**\n * List of known compressed audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const NON_PCM_AUDIO_CODECS = [\n    'aac',\n    'opus',\n    'mp3',\n    'vorbis',\n    'flac',\n];\n/**\n * List of known audio codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const AUDIO_CODECS = [\n    ...NON_PCM_AUDIO_CODECS,\n    ...PCM_AUDIO_CODECS,\n];\n/**\n * List of known subtitle codecs, ordered by encoding preference.\n * @group Codecs\n * @public\n */\nexport const SUBTITLE_CODECS = [\n    'webvtt',\n]; // TODO add the rest\n// https://en.wikipedia.org/wiki/Advanced_Video_Coding\nexport const AVC_LEVEL_TABLE = [\n    { maxMacroblocks: 99, maxBitrate: 64000, maxDpbMbs: 396, level: 0x0A }, // Level 1\n    { maxMacroblocks: 396, maxBitrate: 192000, maxDpbMbs: 900, level: 0x0B }, // Level 1.1\n    { maxMacroblocks: 396, maxBitrate: 384000, maxDpbMbs: 2376, level: 0x0C }, // Level 1.2\n    { maxMacroblocks: 396, maxBitrate: 768000, maxDpbMbs: 2376, level: 0x0D }, // Level 1.3\n    { maxMacroblocks: 396, maxBitrate: 2000000, maxDpbMbs: 2376, level: 0x14 }, // Level 2\n    { maxMacroblocks: 792, maxBitrate: 4000000, maxDpbMbs: 4752, level: 0x15 }, // Level 2.1\n    { maxMacroblocks: 1620, maxBitrate: 4000000, maxDpbMbs: 8100, level: 0x16 }, // Level 2.2\n    { maxMacroblocks: 1620, maxBitrate: 10000000, maxDpbMbs: 8100, level: 0x1E }, // Level 3\n    { maxMacroblocks: 3600, maxBitrate: 14000000, maxDpbMbs: 18000, level: 0x1F }, // Level 3.1\n    { maxMacroblocks: 5120, maxBitrate: 20000000, maxDpbMbs: 20480, level: 0x20 }, // Level 3.2\n    { maxMacroblocks: 8192, maxBitrate: 20000000, maxDpbMbs: 32768, level: 0x28 }, // Level 4\n    { maxMacroblocks: 8192, maxBitrate: 50000000, maxDpbMbs: 32768, level: 0x29 }, // Level 4.1\n    { maxMacroblocks: 8704, maxBitrate: 50000000, maxDpbMbs: 34816, level: 0x2A }, // Level 4.2\n    { maxMacroblocks: 22080, maxBitrate: 135000000, maxDpbMbs: 110400, level: 0x32 }, // Level 5\n    { maxMacroblocks: 36864, maxBitrate: 240000000, maxDpbMbs: 184320, level: 0x33 }, // Level 5.1\n    { maxMacroblocks: 36864, maxBitrate: 240000000, maxDpbMbs: 184320, level: 0x34 }, // Level 5.2\n    { maxMacroblocks: 139264, maxBitrate: 240000000, maxDpbMbs: 696320, level: 0x3C }, // Level 6\n    { maxMacroblocks: 139264, maxBitrate: 480000000, maxDpbMbs: 696320, level: 0x3D }, // Level 6.1\n    { maxMacroblocks: 139264, maxBitrate: 800000000, maxDpbMbs: 696320, level: 0x3E }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/High_Efficiency_Video_Coding\nconst HEVC_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 128000, tier: 'L', level: 30 }, // Level 1 (Low Tier)\n    { maxPictureSize: 122880, maxBitrate: 1500000, tier: 'L', level: 60 }, // Level 2 (Low Tier)\n    { maxPictureSize: 245760, maxBitrate: 3000000, tier: 'L', level: 63 }, // Level 2.1 (Low Tier)\n    { maxPictureSize: 552960, maxBitrate: 6000000, tier: 'L', level: 90 }, // Level 3 (Low Tier)\n    { maxPictureSize: 983040, maxBitrate: 10000000, tier: 'L', level: 93 }, // Level 3.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 12000000, tier: 'L', level: 120 }, // Level 4 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 30000000, tier: 'H', level: 120 }, // Level 4 (High Tier)\n    { maxPictureSize: 2228224, maxBitrate: 20000000, tier: 'L', level: 123 }, // Level 4.1 (Low Tier)\n    { maxPictureSize: 2228224, maxBitrate: 50000000, tier: 'H', level: 123 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 25000000, tier: 'L', level: 150 }, // Level 5 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 150 }, // Level 5 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'L', level: 153 }, // Level 5.1 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 153 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'L', level: 156 }, // Level 5.2 (Low Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 156 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'L', level: 180 }, // Level 6 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 180 }, // Level 6 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 120000000, tier: 'L', level: 183 }, // Level 6.1 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 183 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'L', level: 186 }, // Level 6.2 (Low Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 186 }, // Level 6.2 (High Tier)\n];\n// https://en.wikipedia.org/wiki/VP9\nexport const VP9_LEVEL_TABLE = [\n    { maxPictureSize: 36864, maxBitrate: 200000, level: 10 }, // Level 1\n    { maxPictureSize: 73728, maxBitrate: 800000, level: 11 }, // Level 1.1\n    { maxPictureSize: 122880, maxBitrate: 1800000, level: 20 }, // Level 2\n    { maxPictureSize: 245760, maxBitrate: 3600000, level: 21 }, // Level 2.1\n    { maxPictureSize: 552960, maxBitrate: 7200000, level: 30 }, // Level 3\n    { maxPictureSize: 983040, maxBitrate: 12000000, level: 31 }, // Level 3.1\n    { maxPictureSize: 2228224, maxBitrate: 18000000, level: 40 }, // Level 4\n    { maxPictureSize: 2228224, maxBitrate: 30000000, level: 41 }, // Level 4.1\n    { maxPictureSize: 8912896, maxBitrate: 60000000, level: 50 }, // Level 5\n    { maxPictureSize: 8912896, maxBitrate: 120000000, level: 51 }, // Level 5.1\n    { maxPictureSize: 8912896, maxBitrate: 180000000, level: 52 }, // Level 5.2\n    { maxPictureSize: 35651584, maxBitrate: 180000000, level: 60 }, // Level 6\n    { maxPictureSize: 35651584, maxBitrate: 240000000, level: 61 }, // Level 6.1\n    { maxPictureSize: 35651584, maxBitrate: 480000000, level: 62 }, // Level 6.2\n];\n// https://en.wikipedia.org/wiki/AV1\nconst AV1_LEVEL_TABLE = [\n    { maxPictureSize: 147456, maxBitrate: 1500000, tier: 'M', level: 0 }, // Level 2.0 (Main Tier)\n    { maxPictureSize: 278784, maxBitrate: 3000000, tier: 'M', level: 1 }, // Level 2.1 (Main Tier)\n    { maxPictureSize: 665856, maxBitrate: 6000000, tier: 'M', level: 4 }, // Level 3.0 (Main Tier)\n    { maxPictureSize: 1065024, maxBitrate: 10000000, tier: 'M', level: 5 }, // Level 3.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 12000000, tier: 'M', level: 8 }, // Level 4.0 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 30000000, tier: 'H', level: 8 }, // Level 4.0 (High Tier)\n    { maxPictureSize: 2359296, maxBitrate: 20000000, tier: 'M', level: 9 }, // Level 4.1 (Main Tier)\n    { maxPictureSize: 2359296, maxBitrate: 50000000, tier: 'H', level: 9 }, // Level 4.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 30000000, tier: 'M', level: 12 }, // Level 5.0 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 100000000, tier: 'H', level: 12 }, // Level 5.0 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 40000000, tier: 'M', level: 13 }, // Level 5.1 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 160000000, tier: 'H', level: 13 }, // Level 5.1 (High Tier)\n    { maxPictureSize: 8912896, maxBitrate: 60000000, tier: 'M', level: 14 }, // Level 5.2 (Main Tier)\n    { maxPictureSize: 8912896, maxBitrate: 240000000, tier: 'H', level: 14 }, // Level 5.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 15 }, // Level 5.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 15 }, // Level 5.3 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 60000000, tier: 'M', level: 16 }, // Level 6.0 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 240000000, tier: 'H', level: 16 }, // Level 6.0 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 100000000, tier: 'M', level: 17 }, // Level 6.1 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 480000000, tier: 'H', level: 17 }, // Level 6.1 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 18 }, // Level 6.2 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 18 }, // Level 6.2 (High Tier)\n    { maxPictureSize: 35651584, maxBitrate: 160000000, tier: 'M', level: 19 }, // Level 6.3 (Main Tier)\n    { maxPictureSize: 35651584, maxBitrate: 800000000, tier: 'H', level: 19 }, // Level 6.3 (High Tier)\n];\nconst VP9_DEFAULT_SUFFIX = '.01.01.01.01.00';\nconst AV1_DEFAULT_SUFFIX = '.0.110.01.01.01.0';\nexport const buildVideoCodecString = (codec, width, height, bitrate) => {\n    if (codec === 'avc') {\n        const profileIndication = 0x64; // High Profile\n        const totalMacroblocks = Math.ceil(width / 16) * Math.ceil(height / 16);\n        // Determine the level based on the table\n        const levelInfo = AVC_LEVEL_TABLE.find(level => totalMacroblocks <= level.maxMacroblocks && bitrate <= level.maxBitrate) ?? last(AVC_LEVEL_TABLE);\n        const levelIndication = levelInfo ? levelInfo.level : 0;\n        const hexProfileIndication = profileIndication.toString(16).padStart(2, '0');\n        const hexProfileCompatibility = '00';\n        const hexLevelIndication = levelIndication.toString(16).padStart(2, '0');\n        return `avc1.${hexProfileIndication}${hexProfileCompatibility}${hexLevelIndication}`;\n    }\n    else if (codec === 'hevc') {\n        const profilePrefix = ''; // Profile space 0\n        const profileIdc = 1; // Main Profile\n        const compatibilityFlags = '6'; // Taken from the example in ISO 14496-15\n        const pictureSize = width * height;\n        const levelInfo = HEVC_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(HEVC_LEVEL_TABLE);\n        const constraintFlags = 'B0'; // Progressive source flag\n        return 'hev1.'\n            + `${profilePrefix}${profileIdc}.`\n            + `${compatibilityFlags}.`\n            + `${levelInfo.tier}${levelInfo.level}.`\n            + `${constraintFlags}`;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        const profile = '00'; // Profile 0\n        const pictureSize = width * height;\n        const levelInfo = VP9_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(VP9_LEVEL_TABLE);\n        const bitDepth = '08'; // 8-bit\n        return `vp09.${profile}.${levelInfo.level.toString().padStart(2, '0')}.${bitDepth}`;\n    }\n    else if (codec === 'av1') {\n        const profile = 0; // Main Profile, single digit\n        const pictureSize = width * height;\n        const levelInfo = AV1_LEVEL_TABLE.find(level => pictureSize <= level.maxPictureSize && bitrate <= level.maxBitrate) ?? last(AV1_LEVEL_TABLE);\n        const level = levelInfo.level.toString().padStart(2, '0');\n        const bitDepth = '08'; // 8-bit\n        return `av01.${profile}.${level}${levelInfo.tier}.${bitDepth}`;\n    }\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const generateVp9CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://www.webmproject.org/docs/container/#vp9-codec-feature-metadata-codecprivate\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1;\n    return [\n        1, 1, profile,\n        2, 1, level,\n        3, 1, bitDepth,\n        4, 1, chromaSubsampling,\n    ];\n};\nexport const generateAv1CodecConfigurationFromCodecString = (codecString) => {\n    // Reference: https://aomediacodec.github.io/av1-isobmff/\n    const parts = codecString.split('.'); // We can derive the required values from the codec string\n    const marker = 1;\n    const version = 1;\n    const firstByte = (marker << 7) + version;\n    const profile = Number(parts[1]);\n    const levelAndTier = parts[2];\n    const level = Number(levelAndTier.slice(0, -1));\n    const secondByte = (profile << 5) + level;\n    const tier = levelAndTier.slice(-1) === 'H' ? 1 : 0;\n    const bitDepth = Number(parts[3]);\n    const highBitDepth = bitDepth === 8 ? 0 : 1;\n    const twelveBit = 0;\n    const monochrome = parts[4] ? Number(parts[4]) : 0;\n    const chromaSubsamplingX = parts[5] ? Number(parts[5][0]) : 1;\n    const chromaSubsamplingY = parts[5] ? Number(parts[5][1]) : 1;\n    const chromaSamplePosition = parts[5] ? Number(parts[5][2]) : 0; // CSP_UNKNOWN\n    const thirdByte = (tier << 7)\n        + (highBitDepth << 6)\n        + (twelveBit << 5)\n        + (monochrome << 4)\n        + (chromaSubsamplingX << 3)\n        + (chromaSubsamplingY << 2)\n        + chromaSamplePosition;\n    const initialPresentationDelayPresent = 0; // Should be fine\n    const fourthByte = initialPresentationDelayPresent;\n    return [firstByte, secondByte, thirdByte, fourthByte];\n};\nexport const extractVideoCodecString = (trackInfo) => {\n    const { codec, codecDescription, colorSpace, avcCodecInfo, hevcCodecInfo, vp9CodecInfo, av1CodecInfo } = trackInfo;\n    if (codec === 'avc') {\n        assert(trackInfo.avcType !== null);\n        if (avcCodecInfo) {\n            const bytes = new Uint8Array([\n                avcCodecInfo.avcProfileIndication,\n                avcCodecInfo.profileCompatibility,\n                avcCodecInfo.avcLevelIndication,\n            ]);\n            return `avc${trackInfo.avcType}.${bytesToHexString(bytes)}`;\n        }\n        if (!codecDescription || codecDescription.byteLength < 4) {\n            throw new TypeError('AVC decoder description is not provided or is not at least 4 bytes long.');\n        }\n        return `avc${trackInfo.avcType}.${bytesToHexString(codecDescription.subarray(1, 4))}`;\n    }\n    else if (codec === 'hevc') {\n        let generalProfileSpace;\n        let generalProfileIdc;\n        let compatibilityFlags;\n        let generalTierFlag;\n        let generalLevelIdc;\n        let constraintFlags;\n        if (hevcCodecInfo) {\n            generalProfileSpace = hevcCodecInfo.generalProfileSpace;\n            generalProfileIdc = hevcCodecInfo.generalProfileIdc;\n            compatibilityFlags = reverseBitsU32(hevcCodecInfo.generalProfileCompatibilityFlags);\n            generalTierFlag = hevcCodecInfo.generalTierFlag;\n            generalLevelIdc = hevcCodecInfo.generalLevelIdc;\n            constraintFlags = [...hevcCodecInfo.generalConstraintIndicatorFlags];\n        }\n        else {\n            if (!codecDescription || codecDescription.byteLength < 23) {\n                throw new TypeError('HEVC decoder description is not provided or is not at least 23 bytes long.');\n            }\n            const view = toDataView(codecDescription);\n            const profileByte = view.getUint8(1);\n            generalProfileSpace = (profileByte >> 6) & 0x03;\n            generalProfileIdc = profileByte & 0x1F;\n            compatibilityFlags = reverseBitsU32(view.getUint32(2));\n            generalTierFlag = (profileByte >> 5) & 0x01;\n            generalLevelIdc = view.getUint8(12);\n            constraintFlags = [];\n            for (let i = 0; i < 6; i++) {\n                constraintFlags.push(view.getUint8(6 + i));\n            }\n        }\n        let codecString = 'hev1.';\n        codecString += ['', 'A', 'B', 'C'][generalProfileSpace] + generalProfileIdc;\n        codecString += '.';\n        codecString += compatibilityFlags.toString(16).toUpperCase();\n        codecString += '.';\n        codecString += generalTierFlag === 0 ? 'L' : 'H';\n        codecString += generalLevelIdc;\n        while (constraintFlags.length > 0 && constraintFlags[constraintFlags.length - 1] === 0) {\n            constraintFlags.pop();\n        }\n        if (constraintFlags.length > 0) {\n            codecString += '.';\n            codecString += constraintFlags.map(x => x.toString(16).toUpperCase()).join('.');\n        }\n        return codecString;\n    }\n    else if (codec === 'vp8') {\n        return 'vp8'; // Easy, this one\n    }\n    else if (codec === 'vp9') {\n        if (!vp9CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `vp09.00.${level.toString().padStart(2, '0')}.08`;\n        }\n        const profile = vp9CodecInfo.profile.toString().padStart(2, '0');\n        const level = vp9CodecInfo.level.toString().padStart(2, '0');\n        const bitDepth = vp9CodecInfo.bitDepth.toString().padStart(2, '0');\n        const chromaSubsampling = vp9CodecInfo.chromaSubsampling.toString().padStart(2, '0');\n        const colourPrimaries = vp9CodecInfo.colourPrimaries.toString().padStart(2, '0');\n        const transferCharacteristics = vp9CodecInfo.transferCharacteristics.toString().padStart(2, '0');\n        const matrixCoefficients = vp9CodecInfo.matrixCoefficients.toString().padStart(2, '0');\n        const videoFullRangeFlag = vp9CodecInfo.videoFullRangeFlag.toString().padStart(2, '0');\n        let string = `vp09.${profile}.${level}.${bitDepth}.${chromaSubsampling}`;\n        string += `.${colourPrimaries}.${transferCharacteristics}.${matrixCoefficients}.${videoFullRangeFlag}`;\n        if (string.endsWith(VP9_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -VP9_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    else if (codec === 'av1') {\n        if (!av1CodecInfo) {\n            // Calculate level based on dimensions\n            const pictureSize = trackInfo.width * trackInfo.height;\n            let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n            for (const entry of VP9_LEVEL_TABLE) {\n                if (pictureSize <= entry.maxPictureSize) {\n                    level = entry.level;\n                    break;\n                }\n            }\n            // We don't really know better, so let's return a general-purpose, common codec string and hope for the best\n            return `av01.0.${level.toString().padStart(2, '0')}M.08`;\n        }\n        // https://aomediacodec.github.io/av1-isobmff/#codecsparam\n        const profile = av1CodecInfo.profile; // Single digit\n        const level = av1CodecInfo.level.toString().padStart(2, '0');\n        const tier = av1CodecInfo.tier ? 'H' : 'M';\n        const bitDepth = av1CodecInfo.bitDepth.toString().padStart(2, '0');\n        const monochrome = av1CodecInfo.monochrome ? '1' : '0';\n        const chromaSubsampling = 100 * av1CodecInfo.chromaSubsamplingX\n            + 10 * av1CodecInfo.chromaSubsamplingY\n            + 1 * (av1CodecInfo.chromaSubsamplingX && av1CodecInfo.chromaSubsamplingY\n                ? av1CodecInfo.chromaSamplePosition\n                : 0);\n        // The defaults are 1 (ITU-R BT.709)\n        const colorPrimaries = colorSpace?.primaries ? COLOR_PRIMARIES_MAP[colorSpace.primaries] : 1;\n        const transferCharacteristics = colorSpace?.transfer ? TRANSFER_CHARACTERISTICS_MAP[colorSpace.transfer] : 1;\n        const matrixCoefficients = colorSpace?.matrix ? MATRIX_COEFFICIENTS_MAP[colorSpace.matrix] : 1;\n        const videoFullRangeFlag = colorSpace?.fullRange ? 1 : 0;\n        let string = `av01.${profile}.${level}${tier}.${bitDepth}`;\n        string += `.${monochrome}.${chromaSubsampling.toString().padStart(3, '0')}`;\n        string += `.${colorPrimaries.toString().padStart(2, '0')}`;\n        string += `.${transferCharacteristics.toString().padStart(2, '0')}`;\n        string += `.${matrixCoefficients.toString().padStart(2, '0')}`;\n        string += `.${videoFullRangeFlag}`;\n        if (string.endsWith(AV1_DEFAULT_SUFFIX)) {\n            string = string.slice(0, -AV1_DEFAULT_SUFFIX.length);\n        }\n        return string;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const buildAudioCodecString = (codec, numberOfChannels, sampleRate) => {\n    if (codec === 'aac') {\n        // If stereo or higher channels and lower sample rate, likely using HE-AAC v2 with PS\n        if (numberOfChannels >= 2 && sampleRate <= 24000) {\n            return 'mp4a.40.29'; // HE-AAC v2 (AAC LC + SBR + PS)\n        }\n        // If sample rate is low, likely using HE-AAC v1 with SBR\n        if (sampleRate <= 24000) {\n            return 'mp4a.40.5'; // HE-AAC v1 (AAC LC + SBR)\n        }\n        // Default to standard AAC-LC for higher sample rates\n        return 'mp4a.40.2'; // AAC-LC\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const extractAudioCodecString = (trackInfo) => {\n    const { codec, codecDescription, aacCodecInfo } = trackInfo;\n    if (codec === 'aac') {\n        if (!aacCodecInfo) {\n            throw new TypeError('AAC codec info must be provided.');\n        }\n        if (aacCodecInfo.isMpeg2) {\n            return 'mp4a.67';\n        }\n        else {\n            let objectType;\n            if (aacCodecInfo.objectType !== null) {\n                objectType = aacCodecInfo.objectType;\n            }\n            else {\n                const audioSpecificConfig = parseAacAudioSpecificConfig(codecDescription);\n                objectType = audioSpecificConfig.objectType;\n            }\n            return `mp4a.40.${objectType}`;\n        }\n    }\n    else if (codec === 'mp3') {\n        return 'mp3';\n    }\n    else if (codec === 'opus') {\n        return 'opus';\n    }\n    else if (codec === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codec === 'flac') {\n        return 'flac';\n    }\n    else if (codec && PCM_AUDIO_CODECS.includes(codec)) {\n        return codec;\n    }\n    throw new TypeError(`Unhandled codec '${codec}'.`);\n};\nexport const aacFrequencyTable = [\n    96000, 88200, 64000, 48000, 44100, 32000,\n    24000, 22050, 16000, 12000, 11025, 8000, 7350,\n];\nexport const aacChannelMap = [-1, 1, 2, 3, 4, 5, 6, 8];\nexport const parseAacAudioSpecificConfig = (bytes) => {\n    if (!bytes || bytes.byteLength < 2) {\n        throw new TypeError('AAC description must be at least 2 bytes long.');\n    }\n    const bitstream = new Bitstream(bytes);\n    let objectType = bitstream.readBits(5);\n    if (objectType === 31) {\n        objectType = 32 + bitstream.readBits(6);\n    }\n    const frequencyIndex = bitstream.readBits(4);\n    let sampleRate = null;\n    if (frequencyIndex === 15) {\n        sampleRate = bitstream.readBits(24);\n    }\n    else {\n        if (frequencyIndex < aacFrequencyTable.length) {\n            sampleRate = aacFrequencyTable[frequencyIndex];\n        }\n    }\n    const channelConfiguration = bitstream.readBits(4);\n    let numberOfChannels = null;\n    if (channelConfiguration >= 1 && channelConfiguration <= 7) {\n        numberOfChannels = aacChannelMap[channelConfiguration];\n    }\n    return {\n        objectType,\n        frequencyIndex,\n        sampleRate,\n        channelConfiguration,\n        numberOfChannels,\n    };\n};\nexport const buildAacAudioSpecificConfig = (config) => {\n    let frequencyIndex = aacFrequencyTable.indexOf(config.sampleRate);\n    let customSampleRate = null;\n    if (frequencyIndex === -1) {\n        frequencyIndex = 15;\n        customSampleRate = config.sampleRate;\n    }\n    const channelConfiguration = aacChannelMap.indexOf(config.numberOfChannels);\n    if (channelConfiguration === -1) {\n        throw new TypeError(`Unsupported number of channels: ${config.numberOfChannels}`);\n    }\n    let bitCount = 5 + 4 + 4;\n    if (config.objectType >= 32) {\n        bitCount += 6;\n    }\n    if (frequencyIndex === 15) {\n        bitCount += 24;\n    }\n    const byteCount = Math.ceil(bitCount / 8);\n    const bytes = new Uint8Array(byteCount);\n    const bitstream = new Bitstream(bytes);\n    if (config.objectType < 32) {\n        bitstream.writeBits(5, config.objectType);\n    }\n    else {\n        bitstream.writeBits(5, 31);\n        bitstream.writeBits(6, config.objectType - 32);\n    }\n    bitstream.writeBits(4, frequencyIndex);\n    if (frequencyIndex === 15) {\n        bitstream.writeBits(24, customSampleRate);\n    }\n    bitstream.writeBits(4, channelConfiguration);\n    return bytes;\n};\nexport const OPUS_SAMPLE_RATE = 48_000;\nconst PCM_CODEC_REGEX = /^pcm-([usf])(\\d+)+(be)?$/;\nexport const parsePcmCodec = (codec) => {\n    assert(PCM_AUDIO_CODECS.includes(codec));\n    if (codec === 'ulaw') {\n        return { dataType: 'ulaw', sampleSize: 1, littleEndian: true, silentValue: 255 };\n    }\n    else if (codec === 'alaw') {\n        return { dataType: 'alaw', sampleSize: 1, littleEndian: true, silentValue: 213 };\n    }\n    const match = PCM_CODEC_REGEX.exec(codec);\n    assert(match);\n    let dataType;\n    if (match[1] === 'u') {\n        dataType = 'unsigned';\n    }\n    else if (match[1] === 's') {\n        dataType = 'signed';\n    }\n    else {\n        dataType = 'float';\n    }\n    const sampleSize = (Number(match[2]) / 8);\n    const littleEndian = match[3] !== 'be';\n    const silentValue = codec === 'pcm-u8' ? 2 ** 7 : 0;\n    return { dataType, sampleSize, littleEndian, silentValue };\n};\nexport const inferCodecFromCodecString = (codecString) => {\n    // Video codecs\n    if (codecString.startsWith('avc1') || codecString.startsWith('avc3')) {\n        return 'avc';\n    }\n    else if (codecString.startsWith('hev1') || codecString.startsWith('hvc1')) {\n        return 'hevc';\n    }\n    else if (codecString === 'vp8') {\n        return 'vp8';\n    }\n    else if (codecString.startsWith('vp09')) {\n        return 'vp9';\n    }\n    else if (codecString.startsWith('av01')) {\n        return 'av1';\n    }\n    // Audio codecs\n    if (codecString.startsWith('mp4a.40') || codecString === 'mp4a.67') {\n        return 'aac';\n    }\n    else if (codecString === 'mp3'\n        || codecString === 'mp4a.69'\n        || codecString === 'mp4a.6B'\n        || codecString === 'mp4a.6b') {\n        return 'mp3';\n    }\n    else if (codecString === 'opus') {\n        return 'opus';\n    }\n    else if (codecString === 'vorbis') {\n        return 'vorbis';\n    }\n    else if (codecString === 'flac') {\n        return 'flac';\n    }\n    else if (codecString === 'ulaw') {\n        return 'ulaw';\n    }\n    else if (codecString === 'alaw') {\n        return 'alaw';\n    }\n    else if (PCM_CODEC_REGEX.test(codecString)) {\n        return codecString;\n    }\n    // Subtitle codecs\n    if (codecString === 'webvtt') {\n        return 'webvtt';\n    }\n    return null;\n};\nexport const getVideoEncoderConfigExtension = (codec) => {\n    if (codec === 'avc') {\n        return {\n            avc: {\n                format: 'avc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    else if (codec === 'hevc') {\n        return {\n            hevc: {\n                format: 'hevc', // Ensure the format is not Annex B\n            },\n        };\n    }\n    return {};\n};\nexport const getAudioEncoderConfigExtension = (codec) => {\n    if (codec === 'aac') {\n        return {\n            aac: {\n                format: 'aac', // Ensure the format is not ADTS\n            },\n        };\n    }\n    else if (codec === 'opus') {\n        return {\n            opus: {\n                format: 'opus',\n            },\n        };\n    }\n    return {};\n};\nconst VALID_VIDEO_CODEC_STRING_PREFIXES = ['avc1', 'avc3', 'hev1', 'hvc1', 'vp8', 'vp09', 'av01'];\nconst AVC_CODEC_STRING_REGEX = /^(avc1|avc3)\\.[0-9a-fA-F]{6}$/;\nconst HEVC_CODEC_STRING_REGEX = /^(hev1|hvc1)\\.(?:[ABC]?\\d+)\\.[0-9a-fA-F]{1,8}\\.[LH]\\d+(?:\\.[0-9a-fA-F]{1,2}){0,6}$/;\nconst VP9_CODEC_STRING_REGEX = /^vp09(?:\\.\\d{2}){3}(?:(?:\\.\\d{2}){5})?$/;\nconst AV1_CODEC_STRING_REGEX = /^av01\\.\\d\\.\\d{2}[MH]\\.\\d{2}(?:\\.\\d\\.\\d{3}\\.\\d{2}\\.\\d{2}\\.\\d{2}\\.\\d)?$/;\nexport const validateVideoChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Video chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Video chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Video chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Video chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_VIDEO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedWidth) || metadata.decoderConfig.codedWidth <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.codedHeight) || metadata.decoderConfig.codedHeight <= 0) {\n        throw new TypeError('Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!isAllowSharedBufferSource(metadata.decoderConfig.description)) {\n            throw new TypeError('Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.colorSpace !== undefined) {\n        const { colorSpace } = metadata.decoderConfig;\n        if (typeof colorSpace !== 'object') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace, when provided, must be an object.');\n        }\n        const primariesValues = Object.keys(COLOR_PRIMARIES_MAP);\n        if (colorSpace.primaries != null && !primariesValues.includes(colorSpace.primaries)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of`\n                + ` ${primariesValues.join(', ')}.`);\n        }\n        const transferValues = Object.keys(TRANSFER_CHARACTERISTICS_MAP);\n        if (colorSpace.transfer != null && !transferValues.includes(colorSpace.transfer)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of`\n                + ` ${transferValues.join(', ')}.`);\n        }\n        const matrixValues = Object.keys(MATRIX_COEFFICIENTS_MAP);\n        if (colorSpace.matrix != null && !matrixValues.includes(colorSpace.matrix)) {\n            throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of`\n                + ` ${matrixValues.join(', ')}.`);\n        }\n        if (colorSpace.fullRange != null && typeof colorSpace.fullRange !== 'boolean') {\n            throw new TypeError('Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('avc1') || metadata.decoderConfig.codec.startsWith('avc3')) {\n        // AVC-specific validation\n        if (!AVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as'\n                + ' specified in Section 3.4 of RFC 6381.');\n        }\n        // `description` may or may not be set, depending on if the format is AVCC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-avc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('hev1') || metadata.decoderConfig.codec.startsWith('hvc1')) {\n        // HEVC-specific validation\n        if (!HEVC_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as'\n                + ' specified in Section E.3 of ISO 14496-15.');\n        }\n        // `description` may or may not be set, depending on if the format is HEVC or Annex B, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-hevc-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp8')) {\n        // VP8-specific validation\n        if (metadata.decoderConfig.codec !== 'vp8') {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be \"vp8\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vp09')) {\n        // VP9-specific validation\n        if (!VP9_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://www.webmproject.org/vp9/mp4/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('av01')) {\n        // AV1-specific validation\n        if (!AV1_CODEC_STRING_REGEX.test(metadata.decoderConfig.codec)) {\n            throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as'\n                + ' specified in Section \"Codecs Parameter String\" of https://aomediacodec.github.io/av1-isobmff/.');\n        }\n    }\n};\nconst VALID_AUDIO_CODEC_STRING_PREFIXES = ['mp4a', 'mp3', 'opus', 'vorbis', 'flac', 'ulaw', 'alaw', 'pcm'];\nexport const validateAudioChunkMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Audio chunk metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Audio chunk metadata must be an object.');\n    }\n    if (!metadata.decoderConfig) {\n        throw new TypeError('Audio chunk metadata must include a decoder configuration.');\n    }\n    if (typeof metadata.decoderConfig !== 'object') {\n        throw new TypeError('Audio chunk metadata decoder configuration must be an object.');\n    }\n    if (typeof metadata.decoderConfig.codec !== 'string') {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a codec string.');\n    }\n    if (!VALID_AUDIO_CODEC_STRING_PREFIXES.some(prefix => metadata.decoderConfig.codec.startsWith(prefix))) {\n        throw new TypeError('Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in'\n            + ' the WebCodecs Codec Registry.');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.sampleRate) || metadata.decoderConfig.sampleRate <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).');\n    }\n    if (!Number.isInteger(metadata.decoderConfig.numberOfChannels) || metadata.decoderConfig.numberOfChannels <= 0) {\n        throw new TypeError('Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).');\n    }\n    if (metadata.decoderConfig.description !== undefined) {\n        if (!isAllowSharedBufferSource(metadata.decoderConfig.description)) {\n            throw new TypeError('Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an'\n                + ' ArrayBuffer view.');\n        }\n    }\n    if (metadata.decoderConfig.codec.startsWith('mp4a')\n        // These three refer to MP3:\n        && metadata.decoderConfig.codec !== 'mp4a.69'\n        && metadata.decoderConfig.codec !== 'mp4a.6B'\n        && metadata.decoderConfig.codec !== 'mp4a.6b') {\n        // AAC-specific validation\n        const validStrings = ['mp4a.40.2', 'mp4a.40.02', 'mp4a.40.5', 'mp4a.40.05', 'mp4a.40.29', 'mp4a.67'];\n        if (!validStrings.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as'\n                + ' specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.');\n        }\n        // `description` may or may not be set, depending on if the format is AAC or ADTS, so don't perform any\n        // validation for it.\n        // https://www.w3.org/TR/webcodecs-aac-codec-registration\n    }\n    else if (metadata.decoderConfig.codec.startsWith('mp3') || metadata.decoderConfig.codec.startsWith('mp4a')) {\n        // MP3-specific validation\n        if (metadata.decoderConfig.codec !== 'mp3'\n            && metadata.decoderConfig.codec !== 'mp4a.69'\n            && metadata.decoderConfig.codec !== 'mp4a.6B'\n            && metadata.decoderConfig.codec !== 'mp4a.6b') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be \"mp3\", \"mp4a.69\" or'\n                + ' \"mp4a.6B\".');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('opus')) {\n        // Opus-specific validation\n        if (metadata.decoderConfig.codec !== 'opus') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be \"opus\".');\n        }\n        if (metadata.decoderConfig.description && metadata.decoderConfig.description.byteLength < 18) {\n            // Description is optional for Opus per-spec, so we shouldn't enforce it\n            throw new TypeError('Audio chunk metadata decoder configuration description, when specified, is expected to be an'\n                + ' Identification Header as specified in Section 5.1 of RFC 7845.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('vorbis')) {\n        // Vorbis-specific validation\n        if (metadata.decoderConfig.codec !== 'vorbis') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be \"vorbis\".');\n        }\n        if (!metadata.decoderConfig.description) {\n            throw new TypeError('Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('flac')) {\n        // FLAC-specific validation\n        if (metadata.decoderConfig.codec !== 'flac') {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be \"flac\".');\n        }\n        const minDescriptionSize = 4 + 4 + 34; // 'fLaC' + metadata block header + STREAMINFO block\n        if (!metadata.decoderConfig.description || metadata.decoderConfig.description.byteLength < minDescriptionSize) {\n            throw new TypeError('Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to'\n                + ' adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.');\n        }\n    }\n    else if (metadata.decoderConfig.codec.startsWith('pcm')\n        || metadata.decoderConfig.codec.startsWith('ulaw')\n        || metadata.decoderConfig.codec.startsWith('alaw')) {\n        // PCM-specific validation\n        if (!PCM_AUDIO_CODECS.includes(metadata.decoderConfig.codec)) {\n            throw new TypeError('Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM'\n                + ` codecs (${PCM_AUDIO_CODECS.join(', ')}).`);\n        }\n    }\n};\nexport const validateSubtitleMetadata = (metadata) => {\n    if (!metadata) {\n        throw new TypeError('Subtitle metadata must be provided.');\n    }\n    if (typeof metadata !== 'object') {\n        throw new TypeError('Subtitle metadata must be an object.');\n    }\n    if (!metadata.config) {\n        throw new TypeError('Subtitle metadata must include a config object.');\n    }\n    if (typeof metadata.config !== 'object') {\n        throw new TypeError('Subtitle metadata config must be an object.');\n    }\n    if (typeof metadata.config.description !== 'string') {\n        throw new TypeError('Subtitle metadata config description must be a string.');\n    }\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AVC_LEVEL_TABLE, VP9_LEVEL_TABLE } from './codec.js';\nimport { assert, assertNever, base64ToBytes, Bitstream, bytesToBase64, keyValueIterator, getUint24, last, readExpGolomb, readSignedExpGolomb, textDecoder, textEncoder, toDataView, toUint8Array, getChromiumVersion, isChromium, setUint24, } from './misc.js';\n// References for AVC/HEVC code:\n// ISO 14496-15\n// Rec. ITU-T H.264\n// Rec. ITU-T H.265\n// https://stackoverflow.com/questions/24884827\nexport var AvcNalUnitType;\n(function (AvcNalUnitType) {\n    AvcNalUnitType[AvcNalUnitType[\"NON_IDR_SLICE\"] = 1] = \"NON_IDR_SLICE\";\n    AvcNalUnitType[AvcNalUnitType[\"SLICE_DPA\"] = 2] = \"SLICE_DPA\";\n    AvcNalUnitType[AvcNalUnitType[\"SLICE_DPB\"] = 3] = \"SLICE_DPB\";\n    AvcNalUnitType[AvcNalUnitType[\"SLICE_DPC\"] = 4] = \"SLICE_DPC\";\n    AvcNalUnitType[AvcNalUnitType[\"IDR\"] = 5] = \"IDR\";\n    AvcNalUnitType[AvcNalUnitType[\"SEI\"] = 6] = \"SEI\";\n    AvcNalUnitType[AvcNalUnitType[\"SPS\"] = 7] = \"SPS\";\n    AvcNalUnitType[AvcNalUnitType[\"PPS\"] = 8] = \"PPS\";\n    AvcNalUnitType[AvcNalUnitType[\"AUD\"] = 9] = \"AUD\";\n    AvcNalUnitType[AvcNalUnitType[\"SPS_EXT\"] = 13] = \"SPS_EXT\";\n})(AvcNalUnitType || (AvcNalUnitType = {}));\nexport var HevcNalUnitType;\n(function (HevcNalUnitType) {\n    HevcNalUnitType[HevcNalUnitType[\"RASL_N\"] = 8] = \"RASL_N\";\n    HevcNalUnitType[HevcNalUnitType[\"RASL_R\"] = 9] = \"RASL_R\";\n    HevcNalUnitType[HevcNalUnitType[\"BLA_W_LP\"] = 16] = \"BLA_W_LP\";\n    HevcNalUnitType[HevcNalUnitType[\"RSV_IRAP_VCL23\"] = 23] = \"RSV_IRAP_VCL23\";\n    HevcNalUnitType[HevcNalUnitType[\"VPS_NUT\"] = 32] = \"VPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"SPS_NUT\"] = 33] = \"SPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"PPS_NUT\"] = 34] = \"PPS_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"AUD_NUT\"] = 35] = \"AUD_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"PREFIX_SEI_NUT\"] = 39] = \"PREFIX_SEI_NUT\";\n    HevcNalUnitType[HevcNalUnitType[\"SUFFIX_SEI_NUT\"] = 40] = \"SUFFIX_SEI_NUT\";\n})(HevcNalUnitType || (HevcNalUnitType = {}));\nexport const iterateNalUnitsInAnnexB = function* (packetData) {\n    let i = 0;\n    let nalStart = -1;\n    while (i < packetData.length - 2) {\n        const zeroIndex = packetData.indexOf(0, i);\n        if (zeroIndex === -1 || zeroIndex >= packetData.length - 2) {\n            break;\n        }\n        i = zeroIndex;\n        let startCodeLength = 0;\n        // Check for 4-byte start code (0x00000001)\n        if (i + 3 < packetData.length\n            && packetData[i + 1] === 0\n            && packetData[i + 2] === 0\n            && packetData[i + 3] === 1) {\n            startCodeLength = 4;\n        }\n        else if (packetData[i + 1] === 0 && packetData[i + 2] === 1) {\n            // Check for 3-byte start code (0x000001)\n            startCodeLength = 3;\n        }\n        if (startCodeLength === 0) {\n            i++;\n            continue;\n        }\n        // If we had a previous NAL unit, yield it\n        if (nalStart !== -1 && i > nalStart) {\n            yield {\n                offset: nalStart,\n                length: i - nalStart,\n            };\n        }\n        nalStart = i + startCodeLength;\n        i = nalStart;\n    }\n    // Yield the last NAL unit if there is one\n    if (nalStart !== -1 && nalStart < packetData.length) {\n        yield {\n            offset: nalStart,\n            length: packetData.length - nalStart,\n        };\n    }\n};\nexport const iterateNalUnitsInLengthPrefixed = function* (packetData, lengthSize) {\n    let offset = 0;\n    const dataView = new DataView(packetData.buffer, packetData.byteOffset, packetData.byteLength);\n    while (offset + lengthSize <= packetData.length) {\n        let nalUnitLength;\n        if (lengthSize === 1) {\n            nalUnitLength = dataView.getUint8(offset);\n        }\n        else if (lengthSize === 2) {\n            nalUnitLength = dataView.getUint16(offset, false);\n        }\n        else if (lengthSize === 3) {\n            nalUnitLength = getUint24(dataView, offset, false);\n        }\n        else {\n            assert(lengthSize === 4);\n            nalUnitLength = dataView.getUint32(offset, false);\n        }\n        offset += lengthSize;\n        yield {\n            offset,\n            length: nalUnitLength,\n        };\n        offset += nalUnitLength;\n    }\n};\nexport const iterateAvcNalUnits = (packetData, decoderConfig) => {\n    if (decoderConfig.description) {\n        const bytes = toUint8Array(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[4] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return iterateNalUnitsInLengthPrefixed(packetData, lengthSize);\n    }\n    else {\n        return iterateNalUnitsInAnnexB(packetData);\n    }\n};\nexport const extractNalUnitTypeForAvc = (byte) => {\n    return byte & 0x1F;\n};\nconst removeEmulationPreventionBytes = (data) => {\n    const result = [];\n    const len = data.length;\n    for (let i = 0; i < len; i++) {\n        // Look for the 0x000003 pattern\n        if (i + 2 < len && data[i] === 0x00 && data[i + 1] === 0x00 && data[i + 2] === 0x03) {\n            result.push(0x00, 0x00); // Push the first two bytes\n            i += 2; // Skip the 0x03 byte\n        }\n        else {\n            result.push(data[i]);\n        }\n    }\n    return new Uint8Array(result);\n};\nconst ANNEX_B_START_CODE = new Uint8Array([0, 0, 0, 1]);\nexport const concatNalUnitsInAnnexB = (nalUnits) => {\n    const totalLength = nalUnits.reduce((a, b) => a + ANNEX_B_START_CODE.byteLength + b.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const nalUnit of nalUnits) {\n        result.set(ANNEX_B_START_CODE, offset);\n        offset += ANNEX_B_START_CODE.byteLength;\n        result.set(nalUnit, offset);\n        offset += nalUnit.byteLength;\n    }\n    return result;\n};\nexport const concatNalUnitsInLengthPrefixed = (nalUnits, lengthSize) => {\n    const totalLength = nalUnits.reduce((a, b) => a + lengthSize + b.byteLength, 0);\n    const result = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const nalUnit of nalUnits) {\n        const dataView = new DataView(result.buffer, result.byteOffset, result.byteLength);\n        switch (lengthSize) {\n            case 1:\n                dataView.setUint8(offset, nalUnit.byteLength);\n                break;\n            case 2:\n                dataView.setUint16(offset, nalUnit.byteLength, false);\n                break;\n            case 3:\n                setUint24(dataView, offset, nalUnit.byteLength, false);\n                break;\n            case 4:\n                dataView.setUint32(offset, nalUnit.byteLength, false);\n                break;\n        }\n        offset += lengthSize;\n        result.set(nalUnit, offset);\n        offset += nalUnit.byteLength;\n    }\n    return result;\n};\nexport const concatAvcNalUnits = (nalUnits, decoderConfig) => {\n    if (decoderConfig.description) {\n        // Stream is length-prefixed. Let's extract the size of the length prefix from the decoder config\n        const bytes = toUint8Array(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[4] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return concatNalUnitsInLengthPrefixed(nalUnits, lengthSize);\n    }\n    else {\n        // Stream is in Annex B format\n        return concatNalUnitsInAnnexB(nalUnits);\n    }\n};\n/** Builds an AvcDecoderConfigurationRecord from an AVC packet in Annex B format. */\nexport const extractAvcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const spsUnits = [];\n        const ppsUnits = [];\n        const spsExtUnits = [];\n        for (const loc of iterateNalUnitsInAnnexB(packetData)) {\n            const nalUnit = packetData.subarray(loc.offset, loc.offset + loc.length);\n            const type = extractNalUnitTypeForAvc(nalUnit[0]);\n            if (type === AvcNalUnitType.SPS) {\n                spsUnits.push(nalUnit);\n            }\n            else if (type === AvcNalUnitType.PPS) {\n                ppsUnits.push(nalUnit);\n            }\n            else if (type === AvcNalUnitType.SPS_EXT) {\n                spsExtUnits.push(nalUnit);\n            }\n        }\n        if (spsUnits.length === 0) {\n            return null;\n        }\n        if (ppsUnits.length === 0) {\n            return null;\n        }\n        // Let's get the first SPS for profile and level information\n        const spsData = spsUnits[0];\n        const spsInfo = parseAvcSps(spsData);\n        assert(spsInfo !== null);\n        const hasExtendedData = spsInfo.profileIdc === 100\n            || spsInfo.profileIdc === 110\n            || spsInfo.profileIdc === 122\n            || spsInfo.profileIdc === 144;\n        return {\n            configurationVersion: 1,\n            avcProfileIndication: spsInfo.profileIdc,\n            profileCompatibility: spsInfo.constraintFlags,\n            avcLevelIndication: spsInfo.levelIdc,\n            lengthSizeMinusOne: 3, // Typically 4 bytes for length field\n            sequenceParameterSets: spsUnits,\n            pictureParameterSets: ppsUnits,\n            chromaFormat: hasExtendedData ? spsInfo.chromaFormatIdc : null,\n            bitDepthLumaMinus8: hasExtendedData ? spsInfo.bitDepthLumaMinus8 : null,\n            bitDepthChromaMinus8: hasExtendedData ? spsInfo.bitDepthChromaMinus8 : null,\n            sequenceParameterSetExt: hasExtendedData ? spsExtUnits : null,\n        };\n    }\n    catch (error) {\n        console.error('Error building AVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\n/** Serializes an AvcDecoderConfigurationRecord into the format specified in Section 5.3.3.1 of ISO 14496-15. */\nexport const serializeAvcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    // Write header\n    bytes.push(record.configurationVersion);\n    bytes.push(record.avcProfileIndication);\n    bytes.push(record.profileCompatibility);\n    bytes.push(record.avcLevelIndication);\n    bytes.push(0xFC | (record.lengthSizeMinusOne & 0x03)); // Reserved bits (6) + lengthSizeMinusOne (2)\n    // Reserved bits (3) + numOfSequenceParameterSets (5)\n    bytes.push(0xE0 | (record.sequenceParameterSets.length & 0x1F));\n    // Write SPS\n    for (const sps of record.sequenceParameterSets) {\n        const length = sps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(sps[i]);\n        }\n    }\n    bytes.push(record.pictureParameterSets.length);\n    // Write PPS\n    for (const pps of record.pictureParameterSets) {\n        const length = pps.byteLength;\n        bytes.push(length >> 8); // High byte\n        bytes.push(length & 0xFF); // Low byte\n        for (let i = 0; i < length; i++) {\n            bytes.push(pps[i]);\n        }\n    }\n    if (record.avcProfileIndication === 100\n        || record.avcProfileIndication === 110\n        || record.avcProfileIndication === 122\n        || record.avcProfileIndication === 144) {\n        assert(record.chromaFormat !== null);\n        assert(record.bitDepthLumaMinus8 !== null);\n        assert(record.bitDepthChromaMinus8 !== null);\n        assert(record.sequenceParameterSetExt !== null);\n        bytes.push(0xFC | (record.chromaFormat & 0x03)); // Reserved bits + chroma_format\n        bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07)); // Reserved bits + bit_depth_luma_minus8\n        bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07)); // Reserved bits + bit_depth_chroma_minus8\n        bytes.push(record.sequenceParameterSetExt.length);\n        // Write SPS Ext\n        for (const spsExt of record.sequenceParameterSetExt) {\n            const length = spsExt.byteLength;\n            bytes.push(length >> 8); // High byte\n            bytes.push(length & 0xFF); // Low byte\n            for (let i = 0; i < length; i++) {\n                bytes.push(spsExt[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\n/** Deserializes an AvcDecoderConfigurationRecord from the format specified in Section 5.3.3.1 of ISO 14496-15. */\nexport const deserializeAvcDecoderConfigurationRecord = (data) => {\n    try {\n        const view = toDataView(data);\n        let offset = 0;\n        // Read header\n        const configurationVersion = view.getUint8(offset++);\n        const avcProfileIndication = view.getUint8(offset++);\n        const profileCompatibility = view.getUint8(offset++);\n        const avcLevelIndication = view.getUint8(offset++);\n        const lengthSizeMinusOne = view.getUint8(offset++) & 0x03;\n        const numOfSequenceParameterSets = view.getUint8(offset++) & 0x1F;\n        // Read SPS\n        const sequenceParameterSets = [];\n        for (let i = 0; i < numOfSequenceParameterSets; i++) {\n            const length = view.getUint16(offset, false);\n            offset += 2;\n            sequenceParameterSets.push(data.subarray(offset, offset + length));\n            offset += length;\n        }\n        const numOfPictureParameterSets = view.getUint8(offset++);\n        // Read PPS\n        const pictureParameterSets = [];\n        for (let i = 0; i < numOfPictureParameterSets; i++) {\n            const length = view.getUint16(offset, false);\n            offset += 2;\n            pictureParameterSets.push(data.subarray(offset, offset + length));\n            offset += length;\n        }\n        const record = {\n            configurationVersion,\n            avcProfileIndication,\n            profileCompatibility,\n            avcLevelIndication,\n            lengthSizeMinusOne,\n            sequenceParameterSets,\n            pictureParameterSets,\n            chromaFormat: null,\n            bitDepthLumaMinus8: null,\n            bitDepthChromaMinus8: null,\n            sequenceParameterSetExt: null,\n        };\n        // Check if there are extended profile fields\n        if ((avcProfileIndication === 100\n            || avcProfileIndication === 110\n            || avcProfileIndication === 122\n            || avcProfileIndication === 144)\n            && offset + 4 <= data.length) {\n            const chromaFormat = view.getUint8(offset++) & 0x03;\n            const bitDepthLumaMinus8 = view.getUint8(offset++) & 0x07;\n            const bitDepthChromaMinus8 = view.getUint8(offset++) & 0x07;\n            const numOfSequenceParameterSetExt = view.getUint8(offset++);\n            record.chromaFormat = chromaFormat;\n            record.bitDepthLumaMinus8 = bitDepthLumaMinus8;\n            record.bitDepthChromaMinus8 = bitDepthChromaMinus8;\n            // Read SPS Ext\n            const sequenceParameterSetExt = [];\n            for (let i = 0; i < numOfSequenceParameterSetExt; i++) {\n                const length = view.getUint16(offset, false);\n                offset += 2;\n                sequenceParameterSetExt.push(data.subarray(offset, offset + length));\n                offset += length;\n            }\n            record.sequenceParameterSetExt = sequenceParameterSetExt;\n        }\n        return record;\n    }\n    catch (error) {\n        console.error('Error deserializing AVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\n/** Parses an AVC SPS (Sequence Parameter Set) to extract basic information. */\nexport const parseAvcSps = (sps) => {\n    try {\n        const bitstream = new Bitstream(removeEmulationPreventionBytes(sps));\n        bitstream.skipBits(1); // forbidden_zero_bit\n        bitstream.skipBits(2); // nal_ref_idc\n        const nalUnitType = bitstream.readBits(5);\n        if (nalUnitType !== 7) { // SPS NAL unit type is 7\n            return null;\n        }\n        const profileIdc = bitstream.readAlignedByte();\n        const constraintFlags = bitstream.readAlignedByte();\n        const levelIdc = bitstream.readAlignedByte();\n        readExpGolomb(bitstream); // seq_parameter_set_id\n        // \"When chroma_format_idc is not present, it shall be inferred to be equal to 1 (4:2:0 chroma format).\"\n        let chromaFormatIdc = 1;\n        // \"When bit_depth_luma_minus8 is not present, it shall be inferred to be equal to 0.\"\"\n        let bitDepthLumaMinus8 = 0;\n        // \"When bit_depth_chroma_minus8 is not present, it shall be inferred to be equal to 0.\"\n        let bitDepthChromaMinus8 = 0;\n        // \"When separate_colour_plane_flag is not present, it shall be inferred to be equal to 0.\"\n        let separateColourPlaneFlag = 0;\n        // Handle high profile chroma_format_idc\n        if (profileIdc === 100\n            || profileIdc === 110\n            || profileIdc === 122\n            || profileIdc === 244\n            || profileIdc === 44\n            || profileIdc === 83\n            || profileIdc === 86\n            || profileIdc === 118\n            || profileIdc === 128) {\n            chromaFormatIdc = readExpGolomb(bitstream);\n            if (chromaFormatIdc === 3) {\n                separateColourPlaneFlag = bitstream.readBits(1);\n            }\n            bitDepthLumaMinus8 = readExpGolomb(bitstream);\n            bitDepthChromaMinus8 = readExpGolomb(bitstream);\n            bitstream.skipBits(1); // qpprime_y_zero_transform_bypass_flag\n            const seqScalingMatrixPresentFlag = bitstream.readBits(1);\n            if (seqScalingMatrixPresentFlag) {\n                for (let i = 0; i < (chromaFormatIdc !== 3 ? 8 : 12); i++) {\n                    const seqScalingListPresentFlag = bitstream.readBits(1);\n                    if (seqScalingListPresentFlag) {\n                        const sizeOfScalingList = i < 6 ? 16 : 64;\n                        let lastScale = 8;\n                        let nextScale = 8;\n                        for (let j = 0; j < sizeOfScalingList; j++) {\n                            if (nextScale !== 0) {\n                                const deltaScale = readSignedExpGolomb(bitstream);\n                                nextScale = (lastScale + deltaScale + 256) % 256;\n                            }\n                            lastScale = nextScale === 0 ? lastScale : nextScale;\n                        }\n                    }\n                }\n            }\n        }\n        readExpGolomb(bitstream); // log2_max_frame_num_minus4\n        const picOrderCntType = readExpGolomb(bitstream);\n        if (picOrderCntType === 0) {\n            readExpGolomb(bitstream); // log2_max_pic_order_cnt_lsb_minus4\n        }\n        else if (picOrderCntType === 1) {\n            bitstream.skipBits(1); // delta_pic_order_always_zero_flag\n            readSignedExpGolomb(bitstream); // offset_for_non_ref_pic\n            readSignedExpGolomb(bitstream); // offset_for_top_to_bottom_field\n            const numRefFramesInPicOrderCntCycle = readExpGolomb(bitstream);\n            for (let i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n                readSignedExpGolomb(bitstream); // offset_for_ref_frame[i]\n            }\n        }\n        readExpGolomb(bitstream); // max_num_ref_frames\n        bitstream.skipBits(1); // gaps_in_frame_num_value_allowed_flag\n        const picWidthInMbsMinus1 = readExpGolomb(bitstream);\n        const picHeightInMapUnitsMinus1 = readExpGolomb(bitstream);\n        const codedWidth = 16 * (picWidthInMbsMinus1 + 1);\n        const codedHeight = 16 * (picHeightInMapUnitsMinus1 + 1);\n        let displayWidth = codedWidth;\n        let displayHeight = codedHeight;\n        const frameMbsOnlyFlag = bitstream.readBits(1);\n        if (!frameMbsOnlyFlag) {\n            bitstream.skipBits(1); // mb_adaptive_frame_field_flag\n        }\n        bitstream.skipBits(1); // direct_8x8_inference_flag\n        const frameCroppingFlag = bitstream.readBits(1);\n        if (frameCroppingFlag) {\n            const frameCropLeftOffset = readExpGolomb(bitstream);\n            const frameCropRightOffset = readExpGolomb(bitstream);\n            const frameCropTopOffset = readExpGolomb(bitstream);\n            const frameCropBottomOffset = readExpGolomb(bitstream);\n            let cropUnitX;\n            let cropUnitY;\n            const chromaArrayType = separateColourPlaneFlag === 0 ? chromaFormatIdc : 0;\n            if (chromaArrayType === 0) {\n                // \"If ChromaArrayType is equal to 0, CropUnitX and CropUnitY are derived as:\"\n                cropUnitX = 1;\n                cropUnitY = 2 - frameMbsOnlyFlag;\n            }\n            else {\n                // \"Otherwise (ChromaArrayType is equal to 1, 2, or 3), CropUnitX and CropUnitY are derived as:\"\n                const subWidthC = chromaFormatIdc === 3 ? 1 : 2;\n                const subHeightC = chromaFormatIdc === 1 ? 2 : 1;\n                cropUnitX = subWidthC;\n                cropUnitY = subHeightC * (2 - frameMbsOnlyFlag);\n            }\n            displayWidth -= (cropUnitX * (frameCropLeftOffset + frameCropRightOffset));\n            displayHeight -= (cropUnitY * (frameCropTopOffset + frameCropBottomOffset));\n        }\n        // 2 = unspecified\n        let colourPrimaries = 2;\n        let transferCharacteristics = 2;\n        let matrixCoefficients = 2;\n        let fullRangeFlag = 0;\n        let numReorderFrames = null;\n        let maxDecFrameBuffering = null;\n        const vuiParametersPresentFlag = bitstream.readBits(1);\n        if (vuiParametersPresentFlag) {\n            const aspectRatioInfoPresentFlag = bitstream.readBits(1);\n            if (aspectRatioInfoPresentFlag) {\n                const aspectRatioIdc = bitstream.readBits(8);\n                if (aspectRatioIdc === 255) { // Extended_SAR\n                    bitstream.skipBits(16); // sar_width\n                    bitstream.skipBits(16); // sar_height\n                }\n            }\n            const overscanInfoPresentFlag = bitstream.readBits(1);\n            if (overscanInfoPresentFlag) {\n                bitstream.skipBits(1); // overscan_appropriate_flag\n            }\n            const videoSignalTypePresentFlag = bitstream.readBits(1);\n            if (videoSignalTypePresentFlag) {\n                bitstream.skipBits(3); // video_format\n                fullRangeFlag = bitstream.readBits(1);\n                const colourDescriptionPresentFlag = bitstream.readBits(1);\n                if (colourDescriptionPresentFlag) {\n                    colourPrimaries = bitstream.readBits(8);\n                    transferCharacteristics = bitstream.readBits(8);\n                    matrixCoefficients = bitstream.readBits(8);\n                }\n            }\n            const chromaLocInfoPresentFlag = bitstream.readBits(1);\n            if (chromaLocInfoPresentFlag) {\n                readExpGolomb(bitstream); // chroma_sample_loc_type_top_field\n                readExpGolomb(bitstream); // chroma_sample_loc_type_bottom_field\n            }\n            const timingInfoPresentFlag = bitstream.readBits(1);\n            if (timingInfoPresentFlag) {\n                bitstream.skipBits(32); // num_units_in_tick\n                bitstream.skipBits(32); // time_scale\n                bitstream.skipBits(1); // fixed_frame_rate_flag\n            }\n            const nalHrdParametersPresentFlag = bitstream.readBits(1);\n            if (nalHrdParametersPresentFlag) {\n                skipAvcHrdParameters(bitstream);\n            }\n            const vclHrdParametersPresentFlag = bitstream.readBits(1);\n            if (vclHrdParametersPresentFlag) {\n                skipAvcHrdParameters(bitstream);\n            }\n            if (nalHrdParametersPresentFlag || vclHrdParametersPresentFlag) {\n                bitstream.skipBits(1); // low_delay_hrd_flag\n            }\n            bitstream.skipBits(1); // pic_struct_present_flag\n            const bitstreamRestrictionFlag = bitstream.readBits(1);\n            if (bitstreamRestrictionFlag) {\n                bitstream.skipBits(1); // motion_vectors_over_pic_boundaries_flag\n                readExpGolomb(bitstream); // max_bytes_per_pic_denom\n                readExpGolomb(bitstream); // max_bits_per_mb_denom\n                readExpGolomb(bitstream); // log2_max_mv_length_horizontal\n                readExpGolomb(bitstream); // log2_max_mv_length_vertical\n                numReorderFrames = readExpGolomb(bitstream);\n                maxDecFrameBuffering = readExpGolomb(bitstream);\n            }\n        }\n        if (numReorderFrames === null) {\n            assert(maxDecFrameBuffering === null);\n            const constraintSet3Flag = constraintFlags & 0b00010000;\n            if ((profileIdc === 44 || profileIdc === 86 || profileIdc === 100\n                || profileIdc === 110 || profileIdc === 122 || profileIdc === 244) && constraintSet3Flag) {\n                // \"If profile_idc is equal to 44, 86, 100, 110, 122, or 244 and constraint_set3_flag is equal to 1, the\n                // value of num_reorder_frames shall be inferred to be equal to 0.\"\n                numReorderFrames = 0;\n                maxDecFrameBuffering = 0;\n            }\n            else {\n                const picWidthInMbs = picWidthInMbsMinus1 + 1;\n                const picHeightInMapUnits = picHeightInMapUnitsMinus1 + 1;\n                const frameHeightInMbs = (2 - frameMbsOnlyFlag) * picHeightInMapUnits;\n                const levelInfo = AVC_LEVEL_TABLE.find(x => x.level >= levelIdc) ?? last(AVC_LEVEL_TABLE);\n                // \"MaxDpbFrames is equal to\n                // Min( MaxDpbMbs / ( picWidthInMbs * frameHeightInMbs ), 16 ) and MaxDpbMbs is given in Table A-1.\"\n                const maxDpbFrames = Math.min(Math.floor(levelInfo.maxDpbMbs / (picWidthInMbs * frameHeightInMbs)), 16);\n                // \"Otherwise, [...] the value of num_reorder_frames shall be inferred to be equal to MaxDpbFrames.\"\n                numReorderFrames = maxDpbFrames;\n                maxDecFrameBuffering = maxDpbFrames;\n            }\n        }\n        assert(maxDecFrameBuffering !== null);\n        return {\n            profileIdc,\n            constraintFlags,\n            levelIdc,\n            frameMbsOnlyFlag,\n            chromaFormatIdc,\n            bitDepthLumaMinus8,\n            bitDepthChromaMinus8,\n            codedWidth,\n            codedHeight,\n            displayWidth,\n            displayHeight,\n            colourPrimaries,\n            matrixCoefficients,\n            transferCharacteristics,\n            fullRangeFlag,\n            numReorderFrames,\n            maxDecFrameBuffering,\n        };\n    }\n    catch (error) {\n        console.error('Error parsing AVC SPS:', error);\n        return null;\n    }\n};\nconst skipAvcHrdParameters = (bitstream) => {\n    const cpb_cnt_minus1 = readExpGolomb(bitstream);\n    bitstream.skipBits(4); // bit_rate_scale\n    bitstream.skipBits(4); // cpb_size_scale\n    for (let i = 0; i <= cpb_cnt_minus1; i++) {\n        readExpGolomb(bitstream); // bit_rate_value_minus1[i]\n        readExpGolomb(bitstream); // cpb_size_value_minus1[i]\n        bitstream.skipBits(1); // cbr_flag[i]\n    }\n    bitstream.skipBits(5); // initial_cpb_removal_delay_length_minus1\n    bitstream.skipBits(5); // cpb_removal_delay_length_minus1\n    bitstream.skipBits(5); // dpb_output_delay_length_minus1\n    bitstream.skipBits(5); // time_offset_length\n};\nexport const iterateHevcNalUnits = (packetData, decoderConfig) => {\n    if (decoderConfig.description) {\n        const bytes = toUint8Array(decoderConfig.description);\n        const lengthSizeMinusOne = bytes[21] & 0b11;\n        const lengthSize = (lengthSizeMinusOne + 1);\n        return iterateNalUnitsInLengthPrefixed(packetData, lengthSize);\n    }\n    else {\n        return iterateNalUnitsInAnnexB(packetData);\n    }\n};\nexport const extractNalUnitTypeForHevc = (byte) => {\n    return (byte >> 1) & 0x3F;\n};\n/** Parses an HEVC SPS (Sequence Parameter Set) to extract video information. */\nexport const parseHevcSps = (sps) => {\n    try {\n        const bitstream = new Bitstream(removeEmulationPreventionBytes(sps));\n        bitstream.skipBits(16); // NAL header\n        bitstream.readBits(4); // sps_video_parameter_set_id\n        const spsMaxSubLayersMinus1 = bitstream.readBits(3);\n        const spsTemporalIdNestingFlag = bitstream.readBits(1);\n        const { general_profile_space, general_tier_flag, general_profile_idc, general_profile_compatibility_flags, general_constraint_indicator_flags, general_level_idc, } = parseProfileTierLevel(bitstream, spsMaxSubLayersMinus1);\n        readExpGolomb(bitstream); // sps_seq_parameter_set_id\n        const chromaFormatIdc = readExpGolomb(bitstream);\n        let separateColourPlaneFlag = 0;\n        if (chromaFormatIdc === 3) {\n            separateColourPlaneFlag = bitstream.readBits(1);\n        }\n        const picWidthInLumaSamples = readExpGolomb(bitstream);\n        const picHeightInLumaSamples = readExpGolomb(bitstream);\n        let displayWidth = picWidthInLumaSamples;\n        let displayHeight = picHeightInLumaSamples;\n        if (bitstream.readBits(1)) { // conformance_window_flag\n            const confWinLeftOffset = readExpGolomb(bitstream);\n            const confWinRightOffset = readExpGolomb(bitstream);\n            const confWinTopOffset = readExpGolomb(bitstream);\n            const confWinBottomOffset = readExpGolomb(bitstream);\n            // SubWidthC and SubHeightC depend on chroma_format_idc and separate_colour_plane_flag\n            let subWidthC = 1;\n            let subHeightC = 1;\n            const chromaArrayType = separateColourPlaneFlag === 0 ? chromaFormatIdc : 0;\n            if (chromaArrayType === 1) {\n                subWidthC = 2;\n                subHeightC = 2;\n            }\n            else if (chromaArrayType === 2) {\n                subWidthC = 2;\n                subHeightC = 1;\n            }\n            displayWidth -= (confWinLeftOffset + confWinRightOffset) * subWidthC;\n            displayHeight -= (confWinTopOffset + confWinBottomOffset) * subHeightC;\n        }\n        const bitDepthLumaMinus8 = readExpGolomb(bitstream);\n        const bitDepthChromaMinus8 = readExpGolomb(bitstream);\n        readExpGolomb(bitstream); // log2_max_pic_order_cnt_lsb_minus4\n        const spsSubLayerOrderingInfoPresentFlag = bitstream.readBits(1);\n        const startI = spsSubLayerOrderingInfoPresentFlag ? 0 : spsMaxSubLayersMinus1;\n        let spsMaxNumReorderPics = 0;\n        for (let i = startI; i <= spsMaxSubLayersMinus1; i++) {\n            readExpGolomb(bitstream); // sps_max_dec_pic_buffering_minus1[i]\n            spsMaxNumReorderPics = readExpGolomb(bitstream); // sps_max_num_reorder_pics[i]\n            readExpGolomb(bitstream); // sps_max_latency_increase_plus1[i]\n        }\n        readExpGolomb(bitstream); // log2_min_luma_coding_block_size_minus3\n        readExpGolomb(bitstream); // log2_diff_max_min_luma_coding_block_size\n        readExpGolomb(bitstream); // log2_min_luma_transform_block_size_minus2\n        readExpGolomb(bitstream); // log2_diff_max_min_luma_transform_block_size\n        readExpGolomb(bitstream); // max_transform_hierarchy_depth_inter\n        readExpGolomb(bitstream); // max_transform_hierarchy_depth_intra\n        if (bitstream.readBits(1)) { // scaling_list_enabled_flag\n            if (bitstream.readBits(1)) {\n                skipScalingListData(bitstream);\n            }\n        }\n        bitstream.skipBits(1); // amp_enabled_flag\n        bitstream.skipBits(1); // sample_adaptive_offset_enabled_flag\n        if (bitstream.readBits(1)) { // pcm_enabled_flag\n            bitstream.skipBits(4); // pcm_sample_bit_depth_luma_minus1\n            bitstream.skipBits(4); // pcm_sample_bit_depth_chroma_minus1\n            readExpGolomb(bitstream); // log2_min_pcm_luma_coding_block_size_minus3\n            readExpGolomb(bitstream); // log2_diff_max_min_pcm_luma_coding_block_size\n            bitstream.skipBits(1); // pcm_loop_filter_disabled_flag\n        }\n        const numShortTermRefPicSets = readExpGolomb(bitstream);\n        skipAllStRefPicSets(bitstream, numShortTermRefPicSets);\n        if (bitstream.readBits(1)) { // long_term_ref_pics_present_flag\n            const numLongTermRefPicsSps = readExpGolomb(bitstream);\n            for (let i = 0; i < numLongTermRefPicsSps; i++) {\n                readExpGolomb(bitstream); // lt_ref_pic_poc_lsb_sps[i]\n                bitstream.skipBits(1); // used_by_curr_pic_lt_sps_flag[i]\n            }\n        }\n        bitstream.skipBits(1); // sps_temporal_mvp_enabled_flag\n        bitstream.skipBits(1); // strong_intra_smoothing_enabled_flag\n        let colourPrimaries = 2;\n        let transferCharacteristics = 2;\n        let matrixCoefficients = 2;\n        let fullRangeFlag = 0;\n        let minSpatialSegmentationIdc = 0;\n        if (bitstream.readBits(1)) { // vui_parameters_present_flag\n            const vui = parseHevcVui(bitstream, spsMaxSubLayersMinus1);\n            colourPrimaries = vui.colourPrimaries;\n            transferCharacteristics = vui.transferCharacteristics;\n            matrixCoefficients = vui.matrixCoefficients;\n            fullRangeFlag = vui.fullRangeFlag;\n            minSpatialSegmentationIdc = vui.minSpatialSegmentationIdc;\n        }\n        return {\n            displayWidth,\n            displayHeight,\n            colourPrimaries,\n            transferCharacteristics,\n            matrixCoefficients,\n            fullRangeFlag,\n            maxDecFrameBuffering: spsMaxNumReorderPics + 1,\n            spsMaxSubLayersMinus1,\n            spsTemporalIdNestingFlag,\n            generalProfileSpace: general_profile_space,\n            generalTierFlag: general_tier_flag,\n            generalProfileIdc: general_profile_idc,\n            generalProfileCompatibilityFlags: general_profile_compatibility_flags,\n            generalConstraintIndicatorFlags: general_constraint_indicator_flags,\n            generalLevelIdc: general_level_idc,\n            chromaFormatIdc,\n            bitDepthLumaMinus8,\n            bitDepthChromaMinus8,\n            minSpatialSegmentationIdc,\n        };\n    }\n    catch (error) {\n        console.error('Error parsing HEVC SPS:', error);\n        return null;\n    }\n};\n/** Builds a HevcDecoderConfigurationRecord from an HEVC packet in Annex B format. */\nexport const extractHevcDecoderConfigurationRecord = (packetData) => {\n    try {\n        const vpsUnits = [];\n        const spsUnits = [];\n        const ppsUnits = [];\n        const seiUnits = [];\n        for (const loc of iterateNalUnitsInAnnexB(packetData)) {\n            const nalUnit = packetData.subarray(loc.offset, loc.offset + loc.length);\n            const type = extractNalUnitTypeForHevc(nalUnit[0]);\n            if (type === HevcNalUnitType.VPS_NUT) {\n                vpsUnits.push(nalUnit);\n            }\n            else if (type === HevcNalUnitType.SPS_NUT) {\n                spsUnits.push(nalUnit);\n            }\n            else if (type === HevcNalUnitType.PPS_NUT) {\n                ppsUnits.push(nalUnit);\n            }\n            else if (type === HevcNalUnitType.PREFIX_SEI_NUT || type === HevcNalUnitType.SUFFIX_SEI_NUT) {\n                seiUnits.push(nalUnit);\n            }\n        }\n        if (spsUnits.length === 0 || ppsUnits.length === 0)\n            return null;\n        const spsInfo = parseHevcSps(spsUnits[0]);\n        if (!spsInfo)\n            return null;\n        // Parse PPS for parallelismType\n        let parallelismType = 0;\n        if (ppsUnits.length > 0) {\n            const pps = ppsUnits[0];\n            const ppsBitstream = new Bitstream(removeEmulationPreventionBytes(pps));\n            ppsBitstream.skipBits(16); // NAL header\n            readExpGolomb(ppsBitstream); // pps_pic_parameter_set_id\n            readExpGolomb(ppsBitstream); // pps_seq_parameter_set_id\n            ppsBitstream.skipBits(1); // dependent_slice_segments_enabled_flag\n            ppsBitstream.skipBits(1); // output_flag_present_flag\n            ppsBitstream.skipBits(3); // num_extra_slice_header_bits\n            ppsBitstream.skipBits(1); // sign_data_hiding_enabled_flag\n            ppsBitstream.skipBits(1); // cabac_init_present_flag\n            readExpGolomb(ppsBitstream); // num_ref_idx_l0_default_active_minus1\n            readExpGolomb(ppsBitstream); // num_ref_idx_l1_default_active_minus1\n            readSignedExpGolomb(ppsBitstream); // init_qp_minus26\n            ppsBitstream.skipBits(1); // constrained_intra_pred_flag\n            ppsBitstream.skipBits(1); // transform_skip_enabled_flag\n            if (ppsBitstream.readBits(1)) { // cu_qp_delta_enabled_flag\n                readExpGolomb(ppsBitstream); // diff_cu_qp_delta_depth\n            }\n            readSignedExpGolomb(ppsBitstream); // pps_cb_qp_offset\n            readSignedExpGolomb(ppsBitstream); // pps_cr_qp_offset\n            ppsBitstream.skipBits(1); // pps_slice_chroma_qp_offsets_present_flag\n            ppsBitstream.skipBits(1); // weighted_pred_flag\n            ppsBitstream.skipBits(1); // weighted_bipred_flag\n            ppsBitstream.skipBits(1); // transquant_bypass_enabled_flag\n            const tiles_enabled_flag = ppsBitstream.readBits(1);\n            const entropy_coding_sync_enabled_flag = ppsBitstream.readBits(1);\n            if (!tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 0;\n            else if (tiles_enabled_flag && !entropy_coding_sync_enabled_flag)\n                parallelismType = 2;\n            else if (!tiles_enabled_flag && entropy_coding_sync_enabled_flag)\n                parallelismType = 3;\n            else\n                parallelismType = 0;\n        }\n        const arrays = [\n            ...(vpsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.VPS_NUT,\n                        nalUnits: vpsUnits,\n                    },\n                ]\n                : []),\n            ...(spsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.SPS_NUT,\n                        nalUnits: spsUnits,\n                    },\n                ]\n                : []),\n            ...(ppsUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: HevcNalUnitType.PPS_NUT,\n                        nalUnits: ppsUnits,\n                    },\n                ]\n                : []),\n            ...(seiUnits.length\n                ? [\n                    {\n                        arrayCompleteness: 1,\n                        nalUnitType: extractNalUnitTypeForHevc(seiUnits[0][0]),\n                        nalUnits: seiUnits,\n                    },\n                ]\n                : []),\n        ];\n        const record = {\n            configurationVersion: 1,\n            generalProfileSpace: spsInfo.generalProfileSpace,\n            generalTierFlag: spsInfo.generalTierFlag,\n            generalProfileIdc: spsInfo.generalProfileIdc,\n            generalProfileCompatibilityFlags: spsInfo.generalProfileCompatibilityFlags,\n            generalConstraintIndicatorFlags: spsInfo.generalConstraintIndicatorFlags,\n            generalLevelIdc: spsInfo.generalLevelIdc,\n            minSpatialSegmentationIdc: spsInfo.minSpatialSegmentationIdc,\n            parallelismType,\n            chromaFormatIdc: spsInfo.chromaFormatIdc,\n            bitDepthLumaMinus8: spsInfo.bitDepthLumaMinus8,\n            bitDepthChromaMinus8: spsInfo.bitDepthChromaMinus8,\n            avgFrameRate: 0,\n            constantFrameRate: 0,\n            numTemporalLayers: spsInfo.spsMaxSubLayersMinus1 + 1,\n            temporalIdNested: spsInfo.spsTemporalIdNestingFlag,\n            lengthSizeMinusOne: 3,\n            arrays,\n        };\n        return record;\n    }\n    catch (error) {\n        console.error('Error building HEVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\nconst parseProfileTierLevel = (bitstream, maxNumSubLayersMinus1) => {\n    const general_profile_space = bitstream.readBits(2);\n    const general_tier_flag = bitstream.readBits(1);\n    const general_profile_idc = bitstream.readBits(5);\n    let general_profile_compatibility_flags = 0;\n    for (let i = 0; i < 32; i++) {\n        general_profile_compatibility_flags = (general_profile_compatibility_flags << 1) | bitstream.readBits(1);\n    }\n    const general_constraint_indicator_flags = new Uint8Array(6);\n    for (let i = 0; i < 6; i++) {\n        general_constraint_indicator_flags[i] = bitstream.readBits(8);\n    }\n    const general_level_idc = bitstream.readBits(8);\n    const sub_layer_profile_present_flag = [];\n    const sub_layer_level_present_flag = [];\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        sub_layer_profile_present_flag.push(bitstream.readBits(1));\n        sub_layer_level_present_flag.push(bitstream.readBits(1));\n    }\n    if (maxNumSubLayersMinus1 > 0) {\n        for (let i = maxNumSubLayersMinus1; i < 8; i++) {\n            bitstream.skipBits(2); // reserved_zero_2bits\n        }\n    }\n    for (let i = 0; i < maxNumSubLayersMinus1; i++) {\n        if (sub_layer_profile_present_flag[i])\n            bitstream.skipBits(88);\n        if (sub_layer_level_present_flag[i])\n            bitstream.skipBits(8);\n    }\n    return {\n        general_profile_space,\n        general_tier_flag,\n        general_profile_idc,\n        general_profile_compatibility_flags,\n        general_constraint_indicator_flags,\n        general_level_idc,\n    };\n};\nconst skipScalingListData = (bitstream) => {\n    for (let sizeId = 0; sizeId < 4; sizeId++) {\n        for (let matrixId = 0; matrixId < (sizeId === 3 ? 2 : 6); matrixId++) {\n            const scaling_list_pred_mode_flag = bitstream.readBits(1);\n            if (!scaling_list_pred_mode_flag) {\n                readExpGolomb(bitstream); // scaling_list_pred_matrix_id_delta\n            }\n            else {\n                const coefNum = Math.min(64, 1 << (4 + (sizeId << 1)));\n                if (sizeId > 1) {\n                    readSignedExpGolomb(bitstream); // scaling_list_dc_coef_minus8\n                }\n                for (let i = 0; i < coefNum; i++) {\n                    readSignedExpGolomb(bitstream); // scaling_list_delta_coef\n                }\n            }\n        }\n    }\n};\nconst skipAllStRefPicSets = (bitstream, num_short_term_ref_pic_sets) => {\n    const NumDeltaPocs = [];\n    for (let stRpsIdx = 0; stRpsIdx < num_short_term_ref_pic_sets; stRpsIdx++) {\n        NumDeltaPocs[stRpsIdx] = skipStRefPicSet(bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs);\n    }\n};\nconst skipStRefPicSet = (bitstream, stRpsIdx, num_short_term_ref_pic_sets, NumDeltaPocs) => {\n    let NumDeltaPocsThis = 0;\n    let inter_ref_pic_set_prediction_flag = 0;\n    let RefRpsIdx = 0;\n    if (stRpsIdx !== 0) {\n        inter_ref_pic_set_prediction_flag = bitstream.readBits(1);\n    }\n    if (inter_ref_pic_set_prediction_flag) {\n        if (stRpsIdx === num_short_term_ref_pic_sets) {\n            const delta_idx_minus1 = readExpGolomb(bitstream);\n            RefRpsIdx = stRpsIdx - (delta_idx_minus1 + 1);\n        }\n        else {\n            RefRpsIdx = stRpsIdx - 1;\n        }\n        bitstream.readBits(1); // delta_rps_sign\n        readExpGolomb(bitstream); // abs_delta_rps_minus1\n        // The number of iterations is NumDeltaPocs[RefRpsIdx] + 1\n        const numDelta = NumDeltaPocs[RefRpsIdx] ?? 0;\n        for (let j = 0; j <= numDelta; j++) {\n            const used_by_curr_pic_flag = bitstream.readBits(1);\n            if (!used_by_curr_pic_flag) {\n                bitstream.readBits(1); // use_delta_flag\n            }\n        }\n        NumDeltaPocsThis = NumDeltaPocs[RefRpsIdx];\n    }\n    else {\n        const num_negative_pics = readExpGolomb(bitstream);\n        const num_positive_pics = readExpGolomb(bitstream);\n        for (let i = 0; i < num_negative_pics; i++) {\n            readExpGolomb(bitstream); // delta_poc_s0_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s0_flag[i]\n        }\n        for (let i = 0; i < num_positive_pics; i++) {\n            readExpGolomb(bitstream); // delta_poc_s1_minus1[i]\n            bitstream.readBits(1); // used_by_curr_pic_s1_flag[i]\n        }\n        NumDeltaPocsThis = num_negative_pics + num_positive_pics;\n    }\n    return NumDeltaPocsThis;\n};\nconst parseHevcVui = (bitstream, sps_max_sub_layers_minus1) => {\n    // Defaults: 2 = unspecified\n    let colourPrimaries = 2;\n    let transferCharacteristics = 2;\n    let matrixCoefficients = 2;\n    let fullRangeFlag = 0;\n    let minSpatialSegmentationIdc = 0;\n    if (bitstream.readBits(1)) { // aspect_ratio_info_present_flag\n        const aspect_ratio_idc = bitstream.readBits(8);\n        if (aspect_ratio_idc === 255) {\n            bitstream.readBits(16); // sar_width\n            bitstream.readBits(16); // sar_height\n        }\n    }\n    if (bitstream.readBits(1)) { // overscan_info_present_flag\n        bitstream.readBits(1); // overscan_appropriate_flag\n    }\n    if (bitstream.readBits(1)) { // video_signal_type_present_flag\n        bitstream.readBits(3); // video_format\n        fullRangeFlag = bitstream.readBits(1);\n        if (bitstream.readBits(1)) { // colour_description_present_flag\n            colourPrimaries = bitstream.readBits(8);\n            transferCharacteristics = bitstream.readBits(8);\n            matrixCoefficients = bitstream.readBits(8);\n        }\n    }\n    if (bitstream.readBits(1)) { // chroma_loc_info_present_flag\n        readExpGolomb(bitstream); // chroma_sample_loc_type_top_field\n        readExpGolomb(bitstream); // chroma_sample_loc_type_bottom_field\n    }\n    bitstream.readBits(1); // neutral_chroma_indication_flag\n    bitstream.readBits(1); // field_seq_flag\n    bitstream.readBits(1); // frame_field_info_present_flag\n    if (bitstream.readBits(1)) { // default_display_window_flag\n        readExpGolomb(bitstream); // def_disp_win_left_offset\n        readExpGolomb(bitstream); // def_disp_win_right_offset\n        readExpGolomb(bitstream); // def_disp_win_top_offset\n        readExpGolomb(bitstream); // def_disp_win_bottom_offset\n    }\n    if (bitstream.readBits(1)) { // vui_timing_info_present_flag\n        bitstream.readBits(32); // vui_num_units_in_tick\n        bitstream.readBits(32); // vui_time_scale\n        if (bitstream.readBits(1)) { // vui_poc_proportional_to_timing_flag\n            readExpGolomb(bitstream); // vui_num_ticks_poc_diff_one_minus1\n        }\n        if (bitstream.readBits(1)) {\n            skipHevcHrdParameters(bitstream, true, sps_max_sub_layers_minus1);\n        }\n    }\n    if (bitstream.readBits(1)) { // bitstream_restriction_flag\n        bitstream.readBits(1); // tiles_fixed_structure_flag\n        bitstream.readBits(1); // motion_vectors_over_pic_boundaries_flag\n        bitstream.readBits(1); // restricted_ref_pic_lists_flag\n        minSpatialSegmentationIdc = readExpGolomb(bitstream);\n        readExpGolomb(bitstream); // max_bytes_per_pic_denom\n        readExpGolomb(bitstream); // max_bits_per_min_cu_denom\n        readExpGolomb(bitstream); // log2_max_mv_length_horizontal\n        readExpGolomb(bitstream); // log2_max_mv_length_vertical\n    }\n    return {\n        colourPrimaries,\n        transferCharacteristics,\n        matrixCoefficients,\n        fullRangeFlag,\n        minSpatialSegmentationIdc,\n    };\n};\nconst skipHevcHrdParameters = (bitstream, commonInfPresentFlag, maxNumSubLayersMinus1) => {\n    let nal_hrd_parameters_present_flag = false;\n    let vcl_hrd_parameters_present_flag = false;\n    let sub_pic_hrd_params_present_flag = false;\n    if (commonInfPresentFlag) {\n        nal_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        vcl_hrd_parameters_present_flag = bitstream.readBits(1) === 1;\n        if (nal_hrd_parameters_present_flag || vcl_hrd_parameters_present_flag) {\n            sub_pic_hrd_params_present_flag = bitstream.readBits(1) === 1;\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(8); // tick_divisor_minus2\n                bitstream.readBits(5); // du_cpb_removal_delay_increment_length_minus1\n                bitstream.readBits(1); // sub_pic_cpb_params_in_pic_timing_sei_flag\n                bitstream.readBits(5); // dpb_output_delay_du_length_minus1\n            }\n            bitstream.readBits(4); // bit_rate_scale\n            bitstream.readBits(4); // cpb_size_scale\n            if (sub_pic_hrd_params_present_flag) {\n                bitstream.readBits(4); // cpb_size_du_scale\n            }\n            bitstream.readBits(5); // initial_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // au_cpb_removal_delay_length_minus1\n            bitstream.readBits(5); // dpb_output_delay_length_minus1\n        }\n    }\n    for (let i = 0; i <= maxNumSubLayersMinus1; i++) {\n        const fixed_pic_rate_general_flag = bitstream.readBits(1) === 1;\n        let fixed_pic_rate_within_cvs_flag = true; // Default assumption if general is true\n        if (!fixed_pic_rate_general_flag) {\n            fixed_pic_rate_within_cvs_flag = bitstream.readBits(1) === 1;\n        }\n        let low_delay_hrd_flag = false; // Default assumption\n        if (fixed_pic_rate_within_cvs_flag) {\n            readExpGolomb(bitstream); // elemental_duration_in_tc_minus1[i]\n        }\n        else {\n            low_delay_hrd_flag = bitstream.readBits(1) === 1;\n        }\n        let CpbCnt = 1; // Default if low_delay is true\n        if (!low_delay_hrd_flag) {\n            const cpb_cnt_minus1 = readExpGolomb(bitstream); // cpb_cnt_minus1[i]\n            CpbCnt = cpb_cnt_minus1 + 1;\n        }\n        if (nal_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n        if (vcl_hrd_parameters_present_flag) {\n            skipSubLayerHrdParameters(bitstream, CpbCnt, sub_pic_hrd_params_present_flag);\n        }\n    }\n};\nconst skipSubLayerHrdParameters = (bitstream, CpbCnt, sub_pic_hrd_params_present_flag) => {\n    for (let i = 0; i < CpbCnt; i++) {\n        readExpGolomb(bitstream); // bit_rate_value_minus1[i]\n        readExpGolomb(bitstream); // cpb_size_value_minus1[i]\n        if (sub_pic_hrd_params_present_flag) {\n            readExpGolomb(bitstream); // cpb_size_du_value_minus1[i]\n            readExpGolomb(bitstream); // bit_rate_du_value_minus1[i]\n        }\n        bitstream.readBits(1); // cbr_flag[i]\n    }\n};\n/** Serializes an HevcDecoderConfigurationRecord into the format specified in Section 8.3.3.1 of ISO 14496-15. */\nexport const serializeHevcDecoderConfigurationRecord = (record) => {\n    const bytes = [];\n    bytes.push(record.configurationVersion);\n    bytes.push(((record.generalProfileSpace & 0x3) << 6)\n        | ((record.generalTierFlag & 0x1) << 5)\n        | (record.generalProfileIdc & 0x1F));\n    bytes.push((record.generalProfileCompatibilityFlags >>> 24) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 16) & 0xFF);\n    bytes.push((record.generalProfileCompatibilityFlags >>> 8) & 0xFF);\n    bytes.push(record.generalProfileCompatibilityFlags & 0xFF);\n    bytes.push(...record.generalConstraintIndicatorFlags);\n    bytes.push(record.generalLevelIdc & 0xFF);\n    bytes.push(0xF0 | ((record.minSpatialSegmentationIdc >> 8) & 0x0F)); // Reserved + high nibble\n    bytes.push(record.minSpatialSegmentationIdc & 0xFF); // Low byte\n    bytes.push(0xFC | (record.parallelismType & 0x03));\n    bytes.push(0xFC | (record.chromaFormatIdc & 0x03));\n    bytes.push(0xF8 | (record.bitDepthLumaMinus8 & 0x07));\n    bytes.push(0xF8 | (record.bitDepthChromaMinus8 & 0x07));\n    bytes.push((record.avgFrameRate >> 8) & 0xFF); // High byte\n    bytes.push(record.avgFrameRate & 0xFF); // Low byte\n    bytes.push(((record.constantFrameRate & 0x03) << 6)\n        | ((record.numTemporalLayers & 0x07) << 3)\n        | ((record.temporalIdNested & 0x01) << 2)\n        | (record.lengthSizeMinusOne & 0x03));\n    bytes.push(record.arrays.length & 0xFF);\n    for (const arr of record.arrays) {\n        bytes.push(((arr.arrayCompleteness & 0x01) << 7)\n            | (0 << 6)\n            | (arr.nalUnitType & 0x3F));\n        bytes.push((arr.nalUnits.length >> 8) & 0xFF); // High byte\n        bytes.push(arr.nalUnits.length & 0xFF); // Low byte\n        for (const nal of arr.nalUnits) {\n            bytes.push((nal.length >> 8) & 0xFF); // High byte\n            bytes.push(nal.length & 0xFF); // Low byte\n            for (let i = 0; i < nal.length; i++) {\n                bytes.push(nal[i]);\n            }\n        }\n    }\n    return new Uint8Array(bytes);\n};\n/** Deserializes an HevcDecoderConfigurationRecord from the format specified in Section 8.3.3.1 of ISO 14496-15. */\nexport const deserializeHevcDecoderConfigurationRecord = (data) => {\n    try {\n        const view = toDataView(data);\n        let offset = 0;\n        const configurationVersion = view.getUint8(offset++);\n        const byte1 = view.getUint8(offset++);\n        const generalProfileSpace = (byte1 >> 6) & 0x3;\n        const generalTierFlag = (byte1 >> 5) & 0x1;\n        const generalProfileIdc = byte1 & 0x1F;\n        const generalProfileCompatibilityFlags = view.getUint32(offset, false);\n        offset += 4;\n        const generalConstraintIndicatorFlags = data.subarray(offset, offset + 6);\n        offset += 6;\n        const generalLevelIdc = view.getUint8(offset++);\n        const minSpatialSegmentationIdc = ((view.getUint8(offset++) & 0x0F) << 8) | view.getUint8(offset++);\n        const parallelismType = view.getUint8(offset++) & 0x03;\n        const chromaFormatIdc = view.getUint8(offset++) & 0x03;\n        const bitDepthLumaMinus8 = view.getUint8(offset++) & 0x07;\n        const bitDepthChromaMinus8 = view.getUint8(offset++) & 0x07;\n        const avgFrameRate = view.getUint16(offset, false);\n        offset += 2;\n        const byte21 = view.getUint8(offset++);\n        const constantFrameRate = (byte21 >> 6) & 0x03;\n        const numTemporalLayers = (byte21 >> 3) & 0x07;\n        const temporalIdNested = (byte21 >> 2) & 0x01;\n        const lengthSizeMinusOne = byte21 & 0x03;\n        const numOfArrays = view.getUint8(offset++);\n        const arrays = [];\n        for (let i = 0; i < numOfArrays; i++) {\n            const arrByte = view.getUint8(offset++);\n            const arrayCompleteness = (arrByte >> 7) & 0x01;\n            const nalUnitType = arrByte & 0x3F;\n            const numNalus = view.getUint16(offset, false);\n            offset += 2;\n            const nalUnits = [];\n            for (let j = 0; j < numNalus; j++) {\n                const nalUnitLength = view.getUint16(offset, false);\n                offset += 2;\n                nalUnits.push(data.subarray(offset, offset + nalUnitLength));\n                offset += nalUnitLength;\n            }\n            arrays.push({\n                arrayCompleteness,\n                nalUnitType,\n                nalUnits,\n            });\n        }\n        return {\n            configurationVersion,\n            generalProfileSpace,\n            generalTierFlag,\n            generalProfileIdc,\n            generalProfileCompatibilityFlags,\n            generalConstraintIndicatorFlags,\n            generalLevelIdc,\n            minSpatialSegmentationIdc,\n            parallelismType,\n            chromaFormatIdc,\n            bitDepthLumaMinus8,\n            bitDepthChromaMinus8,\n            avgFrameRate,\n            constantFrameRate,\n            numTemporalLayers,\n            temporalIdNested,\n            lengthSizeMinusOne,\n            arrays,\n        };\n    }\n    catch (error) {\n        console.error('Error deserializing HEVC Decoder Configuration Record:', error);\n        return null;\n    }\n};\nexport const extractVp9CodecInfoFromPacket = (packet) => {\n    // eslint-disable-next-line @stylistic/max-len\n    // https://storage.googleapis.com/downloads.webmproject.org/docs/vp9/vp9-bitstream-specification-v0.7-20170222-draft.pdf\n    // http://downloads.webmproject.org/docs/vp9/vp9-bitstream_superframe-and-uncompressed-header_v1.0.pdf\n    const bitstream = new Bitstream(packet);\n    // Frame marker (0b10)\n    const frameMarker = bitstream.readBits(2);\n    if (frameMarker !== 2) {\n        return null;\n    }\n    // Profile\n    const profileLowBit = bitstream.readBits(1);\n    const profileHighBit = bitstream.readBits(1);\n    const profile = (profileHighBit << 1) + profileLowBit;\n    // Skip reserved bit for profile 3\n    if (profile === 3) {\n        bitstream.skipBits(1);\n    }\n    // show_existing_frame\n    const showExistingFrame = bitstream.readBits(1);\n    if (showExistingFrame === 1) {\n        return null;\n    }\n    // frame_type (0 = key frame)\n    const frameType = bitstream.readBits(1);\n    if (frameType !== 0) {\n        return null;\n    }\n    // Skip show_frame and error_resilient_mode\n    bitstream.skipBits(2);\n    // Sync code (0x498342)\n    const syncCode = bitstream.readBits(24);\n    if (syncCode !== 0x498342) {\n        return null;\n    }\n    // Color config\n    let bitDepth = 8;\n    if (profile >= 2) {\n        const tenOrTwelveBit = bitstream.readBits(1);\n        bitDepth = tenOrTwelveBit ? 12 : 10;\n    }\n    // Color space\n    const colorSpace = bitstream.readBits(3);\n    let chromaSubsampling = 0;\n    let videoFullRangeFlag = 0;\n    if (colorSpace !== 7) { // 7 is CS_RGB\n        const colorRange = bitstream.readBits(1);\n        videoFullRangeFlag = colorRange;\n        if (profile === 1 || profile === 3) {\n            const subsamplingX = bitstream.readBits(1);\n            const subsamplingY = bitstream.readBits(1);\n            // 0 = 4:2:0 vertical\n            // 1 = 4:2:0 colocated\n            // 2 = 4:2:2\n            // 3 = 4:4:4\n            chromaSubsampling = !subsamplingX && !subsamplingY\n                ? 3 // 0,0 = 4:4:4\n                : subsamplingX && !subsamplingY\n                    ? 2 // 1,0 = 4:2:2\n                    : 1; // 1,1 = 4:2:0 colocated (default)\n            // Skip reserved bit\n            bitstream.skipBits(1);\n        }\n        else {\n            // For profile 0 and 2, always 4:2:0\n            chromaSubsampling = 1; // Using colocated as default\n        }\n    }\n    else {\n        // RGB is always 4:4:4\n        chromaSubsampling = 3;\n        videoFullRangeFlag = 1;\n    }\n    // Parse frame size\n    const widthMinusOne = bitstream.readBits(16);\n    const heightMinusOne = bitstream.readBits(16);\n    const width = widthMinusOne + 1;\n    const height = heightMinusOne + 1;\n    // Calculate level based on dimensions\n    const pictureSize = width * height;\n    let level = last(VP9_LEVEL_TABLE).level; // Default to highest level\n    for (const entry of VP9_LEVEL_TABLE) {\n        if (pictureSize <= entry.maxPictureSize) {\n            level = entry.level;\n            break;\n        }\n    }\n    // Map color_space to standard values\n    const matrixCoefficients = colorSpace === 7\n        ? 0\n        : colorSpace === 2\n            ? 1\n            : colorSpace === 1\n                ? 6\n                : 2;\n    const colourPrimaries = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    const transferCharacteristics = colorSpace === 2\n        ? 1\n        : colorSpace === 1\n            ? 6\n            : 2;\n    return {\n        profile,\n        level,\n        bitDepth,\n        chromaSubsampling,\n        videoFullRangeFlag,\n        colourPrimaries,\n        transferCharacteristics,\n        matrixCoefficients,\n    };\n};\n/** Iterates over all OBUs in an AV1 packet bistream. */\nexport const iterateAv1PacketObus = function* (packet) {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    const bitstream = new Bitstream(packet);\n    const readLeb128 = () => {\n        let value = 0;\n        for (let i = 0; i < 8; i++) {\n            const byte = bitstream.readAlignedByte();\n            value |= ((byte & 0x7f) << (i * 7));\n            if (!(byte & 0x80)) {\n                break;\n            }\n            // Spec requirement\n            if (i === 7 && (byte & 0x80)) {\n                return null;\n            }\n        }\n        // Spec requirement\n        if (value >= 2 ** 32 - 1) {\n            return null;\n        }\n        return value;\n    };\n    while (bitstream.getBitsLeft() >= 8) {\n        // Parse OBU header\n        bitstream.skipBits(1);\n        const obuType = bitstream.readBits(4);\n        const obuExtension = bitstream.readBits(1);\n        const obuHasSizeField = bitstream.readBits(1);\n        bitstream.skipBits(1);\n        // Skip extension header if present\n        if (obuExtension) {\n            bitstream.skipBits(8);\n        }\n        // Read OBU size if present\n        let obuSize;\n        if (obuHasSizeField) {\n            const obuSizeValue = readLeb128();\n            if (obuSizeValue === null)\n                return; // It was invalid\n            obuSize = obuSizeValue;\n        }\n        else {\n            // Calculate remaining bits and convert to bytes, rounding down\n            obuSize = Math.floor(bitstream.getBitsLeft() / 8);\n        }\n        assert(bitstream.pos % 8 === 0);\n        yield {\n            type: obuType,\n            data: packet.subarray(bitstream.pos / 8, bitstream.pos / 8 + obuSize),\n        };\n        // Move to next OBU\n        bitstream.skipBits(obuSize * 8);\n    }\n};\n/**\n * When AV1 codec information is not provided by the container, we can still try to extract the information by digging\n * into the AV1 bitstream.\n */\nexport const extractAv1CodecInfoFromPacket = (packet) => {\n    // https://aomediacodec.github.io/av1-spec/av1-spec.pdf\n    for (const { type, data } of iterateAv1PacketObus(packet)) {\n        if (type !== 1) {\n            continue; // 1 == OBU_SEQUENCE_HEADER\n        }\n        const bitstream = new Bitstream(data);\n        // Read sequence header fields\n        const seqProfile = bitstream.readBits(3);\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const stillPicture = bitstream.readBits(1);\n        const reducedStillPictureHeader = bitstream.readBits(1);\n        let seqLevel = 0;\n        let seqTier = 0;\n        let bufferDelayLengthMinus1 = 0;\n        if (reducedStillPictureHeader) {\n            seqLevel = bitstream.readBits(5);\n        }\n        else {\n            // Parse timing_info_present_flag\n            const timingInfoPresentFlag = bitstream.readBits(1);\n            if (timingInfoPresentFlag) {\n                // Skip timing info (num_units_in_display_tick, time_scale, equal_picture_interval)\n                bitstream.skipBits(32); // num_units_in_display_tick\n                bitstream.skipBits(32); // time_scale\n                const equalPictureInterval = bitstream.readBits(1);\n                if (equalPictureInterval) {\n                    // Skip num_ticks_per_picture_minus_1 (uvlc)\n                    // Since this is variable length, we'd need to implement uvlc reading\n                    // For now, we'll return null as this is rare\n                    return null;\n                }\n            }\n            // Parse decoder_model_info_present_flag\n            const decoderModelInfoPresentFlag = bitstream.readBits(1);\n            if (decoderModelInfoPresentFlag) {\n                // Store buffer_delay_length_minus_1 instead of just skipping\n                bufferDelayLengthMinus1 = bitstream.readBits(5);\n                bitstream.skipBits(32); // num_units_in_decoding_tick\n                bitstream.skipBits(5); // buffer_removal_time_length_minus_1\n                bitstream.skipBits(5); // frame_presentation_time_length_minus_1\n            }\n            // Parse operating_points_cnt_minus_1\n            const operatingPointsCntMinus1 = bitstream.readBits(5);\n            // For each operating point\n            for (let i = 0; i <= operatingPointsCntMinus1; i++) {\n                // operating_point_idc[i]\n                bitstream.skipBits(12);\n                // seq_level_idx[i]\n                const seqLevelIdx = bitstream.readBits(5);\n                if (i === 0) {\n                    seqLevel = seqLevelIdx;\n                }\n                if (seqLevelIdx > 7) {\n                    // seq_tier[i]\n                    const seqTierTemp = bitstream.readBits(1);\n                    if (i === 0) {\n                        seqTier = seqTierTemp;\n                    }\n                }\n                if (decoderModelInfoPresentFlag) {\n                    // decoder_model_present_for_this_op[i]\n                    const decoderModelPresentForThisOp = bitstream.readBits(1);\n                    if (decoderModelPresentForThisOp) {\n                        const n = bufferDelayLengthMinus1 + 1;\n                        bitstream.skipBits(n); // decoder_buffer_delay[op]\n                        bitstream.skipBits(n); // encoder_buffer_delay[op]\n                        bitstream.skipBits(1); // low_delay_mode_flag[op]\n                    }\n                }\n                // initial_display_delay_present_flag\n                const initialDisplayDelayPresentFlag = bitstream.readBits(1);\n                if (initialDisplayDelayPresentFlag) {\n                    // initial_display_delay_minus_1[i]\n                    bitstream.skipBits(4);\n                }\n            }\n        }\n        // Frame size\n        const frameWidthBitsMinus1 = bitstream.readBits(4);\n        const frameHeightBitsMinus1 = bitstream.readBits(4);\n        const n1 = frameWidthBitsMinus1 + 1;\n        bitstream.skipBits(n1); // max_frame_width_minus_1\n        const n2 = frameHeightBitsMinus1 + 1;\n        bitstream.skipBits(n2); // max_frame_height_minus_1\n        // Frame IDs\n        let frameIdNumbersPresentFlag = 0;\n        if (reducedStillPictureHeader) {\n            frameIdNumbersPresentFlag = 0;\n        }\n        else {\n            frameIdNumbersPresentFlag = bitstream.readBits(1);\n        }\n        if (frameIdNumbersPresentFlag) {\n            bitstream.skipBits(4); // delta_frame_id_length_minus_2\n            bitstream.skipBits(3); // additional_frame_id_length_minus_1\n        }\n        bitstream.skipBits(1); // use_128x128_superblock\n        bitstream.skipBits(1); // enable_filter_intra\n        bitstream.skipBits(1); // enable_intra_edge_filter\n        if (!reducedStillPictureHeader) {\n            bitstream.skipBits(1); // enable_interintra_compound\n            bitstream.skipBits(1); // enable_masked_compound\n            bitstream.skipBits(1); // enable_warped_motion\n            bitstream.skipBits(1); // enable_dual_filter\n            const enableOrderHint = bitstream.readBits(1);\n            if (enableOrderHint) {\n                bitstream.skipBits(1); // enable_jnt_comp\n                bitstream.skipBits(1); // enable_ref_frame_mvs\n            }\n            const seqChooseScreenContentTools = bitstream.readBits(1);\n            let seqForceScreenContentTools = 0;\n            if (seqChooseScreenContentTools) {\n                seqForceScreenContentTools = 2; // SELECT_SCREEN_CONTENT_TOOLS\n            }\n            else {\n                seqForceScreenContentTools = bitstream.readBits(1);\n            }\n            if (seqForceScreenContentTools > 0) {\n                const seqChooseIntegerMv = bitstream.readBits(1);\n                if (!seqChooseIntegerMv) {\n                    bitstream.skipBits(1); // seq_force_integer_mv\n                }\n            }\n            if (enableOrderHint) {\n                bitstream.skipBits(3); // order_hint_bits_minus_1\n            }\n        }\n        bitstream.skipBits(1); // enable_superres\n        bitstream.skipBits(1); // enable_cdef\n        bitstream.skipBits(1); // enable_restoration\n        // color_config()\n        const highBitdepth = bitstream.readBits(1);\n        let bitDepth = 8;\n        if (seqProfile === 2 && highBitdepth) {\n            const twelveBit = bitstream.readBits(1);\n            bitDepth = twelveBit ? 12 : 10;\n        }\n        else if (seqProfile <= 2) {\n            bitDepth = highBitdepth ? 10 : 8;\n        }\n        let monochrome = 0;\n        if (seqProfile !== 1) {\n            monochrome = bitstream.readBits(1);\n        }\n        let chromaSubsamplingX = 1;\n        let chromaSubsamplingY = 1;\n        let chromaSamplePosition = 0;\n        if (!monochrome) {\n            if (seqProfile === 0) {\n                chromaSubsamplingX = 1;\n                chromaSubsamplingY = 1;\n            }\n            else if (seqProfile === 1) {\n                chromaSubsamplingX = 0;\n                chromaSubsamplingY = 0;\n            }\n            else {\n                if (bitDepth === 12) {\n                    chromaSubsamplingX = bitstream.readBits(1);\n                    if (chromaSubsamplingX) {\n                        chromaSubsamplingY = bitstream.readBits(1);\n                    }\n                }\n            }\n            if (chromaSubsamplingX && chromaSubsamplingY) {\n                chromaSamplePosition = bitstream.readBits(2);\n            }\n        }\n        return {\n            profile: seqProfile,\n            level: seqLevel,\n            tier: seqTier,\n            bitDepth,\n            monochrome,\n            chromaSubsamplingX,\n            chromaSubsamplingY,\n            chromaSamplePosition,\n        };\n    }\n    return null;\n};\nexport const parseOpusIdentificationHeader = (bytes) => {\n    const view = toDataView(bytes);\n    const outputChannelCount = view.getUint8(9);\n    const preSkip = view.getUint16(10, true);\n    const inputSampleRate = view.getUint32(12, true);\n    const outputGain = view.getInt16(16, true);\n    const channelMappingFamily = view.getUint8(18);\n    let channelMappingTable = null;\n    if (channelMappingFamily) {\n        channelMappingTable = bytes.subarray(19, 19 + 2 + outputChannelCount);\n    }\n    return {\n        outputChannelCount,\n        preSkip,\n        inputSampleRate,\n        outputGain,\n        channelMappingFamily,\n        channelMappingTable,\n    };\n};\n// From https://datatracker.ietf.org/doc/html/rfc6716, in 48 kHz samples\nconst OPUS_FRAME_DURATION_TABLE = [\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960, 1920, 2880,\n    480, 960,\n    480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n    120, 240, 480, 960,\n];\nexport const parseOpusTocByte = (packet) => {\n    const config = packet[0] >> 3;\n    return {\n        durationInSamples: OPUS_FRAME_DURATION_TABLE[config],\n    };\n};\n// Based on vorbis_parser.c from FFmpeg.\nexport const parseModesFromVorbisSetupPacket = (setupHeader) => {\n    // Verify that this is a Setup header.\n    if (setupHeader.length < 7) {\n        throw new Error('Setup header is too short.');\n    }\n    if (setupHeader[0] !== 5) {\n        throw new Error('Wrong packet type in Setup header.');\n    }\n    const signature = String.fromCharCode(...setupHeader.slice(1, 7));\n    if (signature !== 'vorbis') {\n        throw new Error('Invalid packet signature in Setup header.');\n    }\n    // Reverse the entire buffer.\n    const bufSize = setupHeader.length;\n    const revBuffer = new Uint8Array(bufSize);\n    for (let i = 0; i < bufSize; i++) {\n        revBuffer[i] = setupHeader[bufSize - 1 - i];\n    }\n    // Initialize a Bitstream on the reversed buffer.\n    const bitstream = new Bitstream(revBuffer);\n    // --- Find the framing bit.\n    // In FFmpeg code, we scan until get_bits1() returns 1.\n    let gotFramingBit = 0;\n    while (bitstream.getBitsLeft() > 97) {\n        if (bitstream.readBits(1) === 1) {\n            gotFramingBit = bitstream.pos;\n            break;\n        }\n    }\n    if (gotFramingBit === 0) {\n        throw new Error('Invalid Setup header: framing bit not found.');\n    }\n    // --- Search backwards for a valid mode header.\n    // We try to guess the number of modes by reading a fixed pattern.\n    let modeCount = 0;\n    let gotModeHeader = false;\n    let lastModeCount = 0;\n    while (bitstream.getBitsLeft() >= 97) {\n        const tempPos = bitstream.pos;\n        const a = bitstream.readBits(8);\n        const b = bitstream.readBits(16);\n        const c = bitstream.readBits(16);\n        // If a > 63 or b or c nonzero, assume weve gone too far.\n        if (a > 63 || b !== 0 || c !== 0) {\n            bitstream.pos = tempPos;\n            break;\n        }\n        bitstream.skipBits(1);\n        modeCount++;\n        if (modeCount > 64) {\n            break;\n        }\n        const bsClone = bitstream.clone();\n        const candidate = bsClone.readBits(6) + 1;\n        if (candidate === modeCount) {\n            gotModeHeader = true;\n            lastModeCount = modeCount;\n        }\n    }\n    if (!gotModeHeader) {\n        throw new Error('Invalid Setup header: mode header not found.');\n    }\n    if (lastModeCount > 63) {\n        throw new Error(`Unsupported mode count: ${lastModeCount}.`);\n    }\n    const finalModeCount = lastModeCount;\n    // --- Reinitialize the bitstream.\n    bitstream.pos = 0;\n    // Skip the bits up to the found framing bit.\n    bitstream.skipBits(gotFramingBit);\n    // --- Now read, for each mode (in reverse order), 40 bits then one bit.\n    // That one bit is the mode blockflag.\n    const modeBlockflags = Array(finalModeCount).fill(0);\n    for (let i = finalModeCount - 1; i >= 0; i--) {\n        bitstream.skipBits(40);\n        modeBlockflags[i] = bitstream.readBits(1);\n    }\n    return { modeBlockflags };\n};\n/** Determines a packet's type (key or delta) by digging into the packet bitstream. */\nexport const determineVideoPacketType = (codec, decoderConfig, packetData) => {\n    switch (codec) {\n        case 'avc':\n            {\n                for (const loc of iterateAvcNalUnits(packetData, decoderConfig)) {\n                    const nalTypeByte = packetData[loc.offset];\n                    const type = extractNalUnitTypeForAvc(nalTypeByte);\n                    if (type >= AvcNalUnitType.NON_IDR_SLICE && type <= AvcNalUnitType.SLICE_DPC) {\n                        return 'delta';\n                    }\n                    if (type === AvcNalUnitType.IDR) {\n                        return 'key';\n                    }\n                    // In addition to IDR, Recovery Point SEI also counts as a valid H.264 keyframe by current consensus.\n                    // See https://github.com/w3c/webcodecs/issues/650 for the relevant discussion. WebKit and Firefox have\n                    // always supported them, but Chromium hasn't, therefore the (admittedly dirty) version check.\n                    if (type === AvcNalUnitType.SEI && (!isChromium() || getChromiumVersion() >= 144)) {\n                        const nalUnit = packetData.subarray(loc.offset, loc.offset + loc.length);\n                        const bytes = removeEmulationPreventionBytes(nalUnit);\n                        let pos = 1; // Skip NALU header\n                        // sei_rbsp()\n                        do {\n                            // sei_message()\n                            let payloadType = 0;\n                            while (true) {\n                                const nextByte = bytes[pos++];\n                                if (nextByte === undefined)\n                                    break;\n                                payloadType += nextByte;\n                                if (nextByte < 255) {\n                                    break;\n                                }\n                            }\n                            let payloadSize = 0;\n                            while (true) {\n                                const nextByte = bytes[pos++];\n                                if (nextByte === undefined)\n                                    break;\n                                payloadSize += nextByte;\n                                if (nextByte < 255) {\n                                    break;\n                                }\n                            }\n                            // sei_payload()\n                            const PAYLOAD_TYPE_RECOVERY_POINT = 6;\n                            if (payloadType === PAYLOAD_TYPE_RECOVERY_POINT) {\n                                const bitstream = new Bitstream(bytes);\n                                bitstream.pos = 8 * pos;\n                                const recoveryFrameCount = readExpGolomb(bitstream);\n                                const exactMatchFlag = bitstream.readBits(1);\n                                if (recoveryFrameCount === 0 && exactMatchFlag === 1) {\n                                    // https://github.com/w3c/webcodecs/pull/910\n                                    // \"recovery_frame_cnt == 0 and exact_match_flag=1 in the SEI recovery payload\"\n                                    return 'key';\n                                }\n                            }\n                            pos += payloadSize;\n                        } while (pos < bytes.length - 1);\n                    }\n                }\n                return 'delta';\n            }\n            ;\n        case 'hevc':\n            {\n                for (const loc of iterateHevcNalUnits(packetData, decoderConfig)) {\n                    const type = extractNalUnitTypeForHevc(packetData[loc.offset]);\n                    if (type < HevcNalUnitType.BLA_W_LP) {\n                        return 'delta';\n                    }\n                    if (type <= HevcNalUnitType.RSV_IRAP_VCL23) {\n                        return 'key';\n                    }\n                }\n                return 'delta';\n            }\n            ;\n        case 'vp8':\n            {\n                // VP8, once again, by far the easiest to deal with.\n                const frameType = packetData[0] & 0b1;\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'vp9':\n            {\n                const bitstream = new Bitstream(packetData);\n                if (bitstream.readBits(2) !== 2) {\n                    return null;\n                }\n                ;\n                const profileLowBit = bitstream.readBits(1);\n                const profileHighBit = bitstream.readBits(1);\n                const profile = (profileHighBit << 1) + profileLowBit;\n                // Skip reserved bit for profile 3\n                if (profile === 3) {\n                    bitstream.skipBits(1);\n                }\n                const showExistingFrame = bitstream.readBits(1);\n                if (showExistingFrame) {\n                    return null;\n                }\n                const frameType = bitstream.readBits(1);\n                return frameType === 0 ? 'key' : 'delta';\n            }\n            ;\n        case 'av1':\n            {\n                let reducedStillPictureHeader = false;\n                for (const { type, data } of iterateAv1PacketObus(packetData)) {\n                    if (type === 1) { // OBU_SEQUENCE_HEADER\n                        const bitstream = new Bitstream(data);\n                        bitstream.skipBits(4);\n                        reducedStillPictureHeader = !!bitstream.readBits(1);\n                    }\n                    else if (type === 3 // OBU_FRAME_HEADER\n                        || type === 6 // OBU_FRAME\n                        || type === 7 // OBU_REDUNDANT_FRAME_HEADER\n                    ) {\n                        if (reducedStillPictureHeader) {\n                            return 'key';\n                        }\n                        const bitstream = new Bitstream(data);\n                        const showExistingFrame = bitstream.readBits(1);\n                        if (showExistingFrame) {\n                            return null;\n                        }\n                        const frameType = bitstream.readBits(2);\n                        return frameType === 0 ? 'key' : 'delta';\n                    }\n                }\n                return null;\n            }\n            ;\n        default:\n            {\n                assertNever(codec);\n                assert(false);\n            }\n            ;\n    }\n};\nexport var FlacBlockType;\n(function (FlacBlockType) {\n    FlacBlockType[FlacBlockType[\"STREAMINFO\"] = 0] = \"STREAMINFO\";\n    FlacBlockType[FlacBlockType[\"VORBIS_COMMENT\"] = 4] = \"VORBIS_COMMENT\";\n    FlacBlockType[FlacBlockType[\"PICTURE\"] = 6] = \"PICTURE\";\n})(FlacBlockType || (FlacBlockType = {}));\nexport const readVorbisComments = (bytes, metadataTags) => {\n    // https://datatracker.ietf.org/doc/html/rfc7845#section-5.2\n    const commentView = toDataView(bytes);\n    let commentPos = 0;\n    const vendorStringLength = commentView.getUint32(commentPos, true);\n    commentPos += 4;\n    const vendorString = textDecoder.decode(bytes.subarray(commentPos, commentPos + vendorStringLength));\n    commentPos += vendorStringLength;\n    if (vendorStringLength > 0) {\n        // Expose the vendor string in the raw metadata\n        metadataTags.raw ??= {};\n        metadataTags.raw['vendor'] ??= vendorString;\n    }\n    const listLength = commentView.getUint32(commentPos, true);\n    commentPos += 4;\n    // Loop over all metadata tags\n    for (let i = 0; i < listLength; i++) {\n        const stringLength = commentView.getUint32(commentPos, true);\n        commentPos += 4;\n        const string = textDecoder.decode(bytes.subarray(commentPos, commentPos + stringLength));\n        commentPos += stringLength;\n        const separatorIndex = string.indexOf('=');\n        if (separatorIndex === -1) {\n            continue;\n        }\n        const key = string.slice(0, separatorIndex).toUpperCase();\n        const value = string.slice(separatorIndex + 1);\n        metadataTags.raw ??= {};\n        metadataTags.raw[key] ??= value;\n        switch (key) {\n            case 'TITLE':\n                {\n                    metadataTags.title ??= value;\n                }\n                ;\n                break;\n            case 'DESCRIPTION':\n                {\n                    metadataTags.description ??= value;\n                }\n                ;\n                break;\n            case 'ARTIST':\n                {\n                    metadataTags.artist ??= value;\n                }\n                ;\n                break;\n            case 'ALBUM':\n                {\n                    metadataTags.album ??= value;\n                }\n                ;\n                break;\n            case 'ALBUMARTIST':\n                {\n                    metadataTags.albumArtist ??= value;\n                }\n                ;\n                break;\n            case 'COMMENT':\n                {\n                    metadataTags.comment ??= value;\n                }\n                ;\n                break;\n            case 'LYRICS':\n                {\n                    metadataTags.lyrics ??= value;\n                }\n                ;\n                break;\n            case 'TRACKNUMBER':\n                {\n                    const parts = value.split('/');\n                    const trackNum = Number.parseInt(parts[0], 10);\n                    const tracksTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(trackNum) && trackNum > 0) {\n                        metadataTags.trackNumber ??= trackNum;\n                    }\n                    if (tracksTotal && Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                        metadataTags.tracksTotal ??= tracksTotal;\n                    }\n                }\n                ;\n                break;\n            case 'TRACKTOTAL':\n                {\n                    const tracksTotal = Number.parseInt(value, 10);\n                    if (Number.isInteger(tracksTotal) && tracksTotal > 0) {\n                        metadataTags.tracksTotal ??= tracksTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DISCNUMBER':\n                {\n                    const parts = value.split('/');\n                    const discNum = Number.parseInt(parts[0], 10);\n                    const discsTotal = parts[1] && Number.parseInt(parts[1], 10);\n                    if (Number.isInteger(discNum) && discNum > 0) {\n                        metadataTags.discNumber ??= discNum;\n                    }\n                    if (discsTotal && Number.isInteger(discsTotal) && discsTotal > 0) {\n                        metadataTags.discsTotal ??= discsTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DISCTOTAL':\n                {\n                    const discsTotal = Number.parseInt(value, 10);\n                    if (Number.isInteger(discsTotal) && discsTotal > 0) {\n                        metadataTags.discsTotal ??= discsTotal;\n                    }\n                }\n                ;\n                break;\n            case 'DATE':\n                {\n                    const date = new Date(value);\n                    if (!Number.isNaN(date.getTime())) {\n                        metadataTags.date ??= date;\n                    }\n                }\n                ;\n                break;\n            case 'GENRE':\n                {\n                    metadataTags.genre ??= value;\n                }\n                ;\n                break;\n            case 'METADATA_BLOCK_PICTURE':\n                {\n                    // https://datatracker.ietf.org/doc/rfc9639/ Section 8.8\n                    const decoded = base64ToBytes(value);\n                    const view = toDataView(decoded);\n                    const pictureType = view.getUint32(0, false);\n                    const mediaTypeLength = view.getUint32(4, false);\n                    const mediaType = String.fromCharCode(...decoded.subarray(8, 8 + mediaTypeLength)); // ASCII\n                    const descriptionLength = view.getUint32(8 + mediaTypeLength, false);\n                    const description = textDecoder.decode(decoded.subarray(12 + mediaTypeLength, 12 + mediaTypeLength + descriptionLength));\n                    const dataLength = view.getUint32(mediaTypeLength + descriptionLength + 28);\n                    const data = decoded.subarray(mediaTypeLength + descriptionLength + 32, mediaTypeLength + descriptionLength + 32 + dataLength);\n                    metadataTags.images ??= [];\n                    metadataTags.images.push({\n                        data,\n                        mimeType: mediaType,\n                        kind: pictureType === 3 ? 'coverFront' : pictureType === 4 ? 'coverBack' : 'unknown',\n                        name: undefined,\n                        description: description || undefined,\n                    });\n                }\n                ;\n                break;\n        }\n    }\n};\nexport const createVorbisComments = (headerBytes, tags, writeImages) => {\n    // https://datatracker.ietf.org/doc/html/rfc7845#section-5.2\n    const commentHeaderParts = [\n        headerBytes,\n    ];\n    const vendorString = 'Mediabunny';\n    const encodedVendorString = textEncoder.encode(vendorString);\n    let currentBuffer = new Uint8Array(4 + encodedVendorString.length);\n    let currentView = new DataView(currentBuffer.buffer);\n    currentView.setUint32(0, encodedVendorString.length, true);\n    currentBuffer.set(encodedVendorString, 4);\n    commentHeaderParts.push(currentBuffer);\n    const writtenTags = new Set();\n    const addCommentTag = (key, value) => {\n        const joined = `${key}=${value}`;\n        const encoded = textEncoder.encode(joined);\n        currentBuffer = new Uint8Array(4 + encoded.length);\n        currentView = new DataView(currentBuffer.buffer);\n        currentView.setUint32(0, encoded.length, true);\n        currentBuffer.set(encoded, 4);\n        commentHeaderParts.push(currentBuffer);\n        writtenTags.add(key);\n    };\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    addCommentTag('TITLE', value);\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    addCommentTag('DESCRIPTION', value);\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    addCommentTag('ARTIST', value);\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    addCommentTag('ALBUM', value);\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    addCommentTag('ALBUMARTIST', value);\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    addCommentTag('GENRE', value);\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    const rawVersion = tags.raw?.['DATE'] ?? tags.raw?.['date'];\n                    if (rawVersion && typeof rawVersion === 'string') {\n                        addCommentTag('DATE', rawVersion);\n                    }\n                    else {\n                        addCommentTag('DATE', value.toISOString().slice(0, 10));\n                    }\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    addCommentTag('COMMENT', value);\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    addCommentTag('LYRICS', value);\n                }\n                ;\n                break;\n            case 'trackNumber':\n                {\n                    addCommentTag('TRACKNUMBER', value.toString());\n                }\n                ;\n                break;\n            case 'tracksTotal':\n                {\n                    addCommentTag('TRACKTOTAL', value.toString());\n                }\n                ;\n                break;\n            case 'discNumber':\n                {\n                    addCommentTag('DISCNUMBER', value.toString());\n                }\n                ;\n                break;\n            case 'discsTotal':\n                {\n                    addCommentTag('DISCTOTAL', value.toString());\n                }\n                ;\n                break;\n            case 'images':\n                {\n                    // For example, in .flac, we put the pictures in a different section,\n                    // not in the Vorbis comment header.\n                    if (!writeImages) {\n                        break;\n                    }\n                    for (const image of value) {\n                        // https://datatracker.ietf.org/doc/rfc9639/ Section 8.8\n                        const pictureType = image.kind === 'coverFront' ? 3 : image.kind === 'coverBack' ? 4 : 0;\n                        const encodedMediaType = new Uint8Array(image.mimeType.length);\n                        for (let i = 0; i < image.mimeType.length; i++) {\n                            encodedMediaType[i] = image.mimeType.charCodeAt(i);\n                        }\n                        const encodedDescription = textEncoder.encode(image.description ?? '');\n                        const buffer = new Uint8Array(4 // Picture type\n                            + 4 // MIME type length\n                            + encodedMediaType.length // MIME type\n                            + 4 // Description length\n                            + encodedDescription.length // Description\n                            + 16 // Width, height, color depth, number of colors\n                            + 4 // Picture data length\n                            + image.data.length);\n                        const view = toDataView(buffer);\n                        view.setUint32(0, pictureType, false);\n                        view.setUint32(4, encodedMediaType.length, false);\n                        buffer.set(encodedMediaType, 8);\n                        view.setUint32(8 + encodedMediaType.length, encodedDescription.length, false);\n                        buffer.set(encodedDescription, 12 + encodedMediaType.length);\n                        // Skip a bunch of fields (width, height, color depth, number of colors)\n                        view.setUint32(28 + encodedMediaType.length + encodedDescription.length, image.data.length, false);\n                        buffer.set(image.data, 32 + encodedMediaType.length + encodedDescription.length);\n                        const encoded = bytesToBase64(buffer);\n                        addCommentTag('METADATA_BLOCK_PICTURE', encoded);\n                    }\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key] ?? tags.raw[key.toLowerCase()];\n            if (key === 'vendor' || value == null || writtenTags.has(key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                addCommentTag(key, value);\n            }\n        }\n    }\n    const listLengthBuffer = new Uint8Array(4);\n    toDataView(listLengthBuffer).setUint32(0, writtenTags.size, true);\n    commentHeaderParts.splice(2, 0, listLengthBuffer); // Insert after the header and vendor section\n    // Merge all comment header parts into a single buffer\n    const commentHeaderLength = commentHeaderParts.reduce((a, b) => a + b.length, 0);\n    const commentHeader = new Uint8Array(commentHeaderLength);\n    let pos = 0;\n    for (const part of commentHeaderParts) {\n        commentHeader.set(part, pos);\n        pos += part.length;\n    }\n    return commentHeader;\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\n/**\n * Base class for custom video decoders. To add your own custom video decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using {@link registerDecoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomVideoDecoder {\n    /** Returns true if and only if the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio decoders. To add your own custom audio decoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the decoder using {@link registerDecoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomAudioDecoder {\n    /** Returns true if and only if the decoder can decode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom video encoders. To add your own custom video encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using {@link registerEncoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomVideoEncoder {\n    /** Returns true if and only if the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\n/**\n * Base class for custom audio encoders. To add your own custom audio encoder, extend this class, implement the\n * abstract methods and static `supports` method, and register the encoder using {@link registerEncoder}.\n * @group Custom coders\n * @public\n */\nexport class CustomAudioEncoder {\n    /** Returns true if and only if the encoder can encode the given codec configuration. */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    static supports(codec, config) {\n        return false;\n    }\n}\nexport const customVideoDecoders = [];\nexport const customAudioDecoders = [];\nexport const customVideoEncoders = [];\nexport const customAudioEncoders = [];\n/**\n * Registers a custom video or audio decoder. Registered decoders will automatically be used for decoding whenever\n * possible.\n * @group Custom coders\n * @public\n */\nexport const registerDecoder = (decoder) => {\n    if (decoder.prototype instanceof CustomVideoDecoder) {\n        const casted = decoder;\n        if (customVideoDecoders.includes(casted)) {\n            console.warn('Video decoder already registered.');\n            return;\n        }\n        customVideoDecoders.push(casted);\n    }\n    else if (decoder.prototype instanceof CustomAudioDecoder) {\n        const casted = decoder;\n        if (customAudioDecoders.includes(casted)) {\n            console.warn('Audio decoder already registered.');\n            return;\n        }\n        customAudioDecoders.push(casted);\n    }\n    else {\n        throw new TypeError('Decoder must be a CustomVideoDecoder or CustomAudioDecoder.');\n    }\n};\n/**\n * Registers a custom video or audio encoder. Registered encoders will automatically be used for encoding whenever\n * possible.\n * @group Custom coders\n * @public\n */\nexport const registerEncoder = (encoder) => {\n    if (encoder.prototype instanceof CustomVideoEncoder) {\n        const casted = encoder;\n        if (customVideoEncoders.includes(casted)) {\n            console.warn('Video encoder already registered.');\n            return;\n        }\n        customVideoEncoders.push(casted);\n    }\n    else if (encoder.prototype instanceof CustomAudioEncoder) {\n        const casted = encoder;\n        if (customAudioEncoders.includes(casted)) {\n            console.warn('Audio encoder already registered.');\n            return;\n        }\n        customAudioEncoders.push(casted);\n    }\n    else {\n        throw new TypeError('Encoder must be a CustomVideoEncoder or CustomAudioEncoder.');\n    }\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { SECOND_TO_MICROSECOND_FACTOR } from './misc.js';\nexport const PLACEHOLDER_DATA = /* #__PURE__ */ new Uint8Array(0);\n/**\n * Represents an encoded chunk of media. Mainly used as an expressive wrapper around WebCodecs API's\n * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) and\n * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk), but can also be used\n * standalone.\n * @group Packets\n * @public\n */\nexport class EncodedPacket {\n    /** Creates a new {@link EncodedPacket} from raw bytes and timing information. */\n    constructor(\n    /** The encoded data of this packet. */\n    data, \n    /** The type of this packet. */\n    type, \n    /**\n     * The presentation timestamp of this packet in seconds. May be negative. Samples with negative end timestamps\n     * should not be presented.\n     */\n    timestamp, \n    /** The duration of this packet in seconds. */\n    duration, \n    /**\n     * The sequence number indicates the decode order of the packets. Packet A  must be decoded before packet B if A\n     * has a lower sequence number than B. If two packets have the same sequence number, they are the same packet.\n     * Otherwise, sequence numbers are arbitrary and are not guaranteed to have any meaning besides their relative\n     * ordering. Negative sequence numbers mean the sequence number is undefined.\n     */\n    sequenceNumber = -1, byteLength, sideData) {\n        this.data = data;\n        this.type = type;\n        this.timestamp = timestamp;\n        this.duration = duration;\n        this.sequenceNumber = sequenceNumber;\n        if (data === PLACEHOLDER_DATA && byteLength === undefined) {\n            throw new Error('Internal error: byteLength must be explicitly provided when constructing metadata-only packets.');\n        }\n        if (byteLength === undefined) {\n            byteLength = data.byteLength;\n        }\n        if (!(data instanceof Uint8Array)) {\n            throw new TypeError('data must be a Uint8Array.');\n        }\n        if (type !== 'key' && type !== 'delta') {\n            throw new TypeError('type must be either \"key\" or \"delta\".');\n        }\n        if (!Number.isFinite(timestamp)) {\n            throw new TypeError('timestamp must be a number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        if (!Number.isFinite(sequenceNumber)) {\n            throw new TypeError('sequenceNumber must be a number.');\n        }\n        if (!Number.isInteger(byteLength) || byteLength < 0) {\n            throw new TypeError('byteLength must be a non-negative integer.');\n        }\n        if (sideData !== undefined && (typeof sideData !== 'object' || !sideData)) {\n            throw new TypeError('sideData, when provided, must be an object.');\n        }\n        if (sideData?.alpha !== undefined && !(sideData.alpha instanceof Uint8Array)) {\n            throw new TypeError('sideData.alpha, when provided, must be a Uint8Array.');\n        }\n        if (sideData?.alphaByteLength !== undefined\n            && (!Number.isInteger(sideData.alphaByteLength) || sideData.alphaByteLength < 0)) {\n            throw new TypeError('sideData.alphaByteLength, when provided, must be a non-negative integer.');\n        }\n        this.byteLength = byteLength;\n        this.sideData = sideData ?? {};\n        if (this.sideData.alpha && this.sideData.alphaByteLength === undefined) {\n            this.sideData.alphaByteLength = this.sideData.alpha.byteLength;\n        }\n    }\n    /**\n     * If this packet is a metadata-only packet. Metadata-only packets don't contain their packet data. They are the\n     * result of retrieving packets with {@link PacketRetrievalOptions.metadataOnly} set to `true`.\n     */\n    get isMetadataOnly() {\n        return this.data === PLACEHOLDER_DATA;\n    }\n    /** The timestamp of this packet in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of this packet in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /** Converts this packet to an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) for use with the\n     * WebCodecs API. */\n    toEncodedVideoChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to a video chunk.');\n        }\n        if (typeof EncodedVideoChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedVideoChunk.');\n        }\n        return new EncodedVideoChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /**\n     * Converts this packet to an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) for use with the\n     * WebCodecs API, using the alpha side data instead of the color data. Throws if no alpha side data is defined.\n     */\n    alphaToEncodedVideoChunk(type = this.type) {\n        if (!this.sideData.alpha) {\n            throw new TypeError('This packet does not contain alpha side data.');\n        }\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to a video chunk.');\n        }\n        if (typeof EncodedVideoChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedVideoChunk.');\n        }\n        return new EncodedVideoChunk({\n            data: this.sideData.alpha,\n            type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /** Converts this packet to an\n     * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk) for use with the\n     * WebCodecs API. */\n    toEncodedAudioChunk() {\n        if (this.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be converted to an audio chunk.');\n        }\n        if (typeof EncodedAudioChunk === 'undefined') {\n            throw new Error('Your browser does not support EncodedAudioChunk.');\n        }\n        return new EncodedAudioChunk({\n            data: this.data,\n            type: this.type,\n            timestamp: this.microsecondTimestamp,\n            duration: this.microsecondDuration,\n        });\n    }\n    /**\n     * Creates an {@link EncodedPacket} from an\n     * [`EncodedVideoChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedVideoChunk) or\n     * [`EncodedAudioChunk`](https://developer.mozilla.org/en-US/docs/Web/API/EncodedAudioChunk). This method is useful\n     * for converting chunks from the WebCodecs API to `EncodedPacket` instances.\n     */\n    static fromEncodedChunk(chunk, sideData) {\n        if (!(chunk instanceof EncodedVideoChunk || chunk instanceof EncodedAudioChunk)) {\n            throw new TypeError('chunk must be an EncodedVideoChunk or EncodedAudioChunk.');\n        }\n        const data = new Uint8Array(chunk.byteLength);\n        chunk.copyTo(data);\n        return new EncodedPacket(data, chunk.type, chunk.timestamp / 1e6, (chunk.duration ?? 0) / 1e6, undefined, undefined, sideData);\n    }\n    /** Clones this packet while optionally modifying the new packet's data. */\n    clone(options) {\n        if (options !== undefined && (typeof options !== 'object' || options === null)) {\n            throw new TypeError('options, when provided, must be an object.');\n        }\n        if (options?.data !== undefined && !(options.data instanceof Uint8Array)) {\n            throw new TypeError('options.data, when provided, must be a Uint8Array.');\n        }\n        if (options?.type !== undefined && options.type !== 'key' && options.type !== 'delta') {\n            throw new TypeError('options.type, when provided, must be either \"key\" or \"delta\".');\n        }\n        if (options?.timestamp !== undefined && !Number.isFinite(options.timestamp)) {\n            throw new TypeError('options.timestamp, when provided, must be a number.');\n        }\n        if (options?.duration !== undefined && !Number.isFinite(options.duration)) {\n            throw new TypeError('options.duration, when provided, must be a number.');\n        }\n        if (options?.sequenceNumber !== undefined && !Number.isFinite(options.sequenceNumber)) {\n            throw new TypeError('options.sequenceNumber, when provided, must be a number.');\n        }\n        if (options?.sideData !== undefined && (typeof options.sideData !== 'object' || options.sideData === null)) {\n            throw new TypeError('options.sideData, when provided, must be an object.');\n        }\n        return new EncodedPacket(options?.data ?? this.data, options?.type ?? this.type, options?.timestamp ?? this.timestamp, options?.duration ?? this.duration, options?.sequenceNumber ?? this.sequenceNumber, this.byteLength, options?.sideData ?? this.sideData);\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert, clamp, isAllowSharedBufferSource, SECOND_TO_MICROSECOND_FACTOR, toDataView, toUint8Array, isFirefox, polyfillSymbolDispose, assertNever, isWebKit, } from './misc.js';\npolyfillSymbolDispose();\n// Let's manually handle logging the garbage collection errors that are typically logged by the browser. This way, they\n// also kick for audio samples (which is normally not the case), making sure any incorrect code is quickly caught.\nlet lastVideoGcErrorLog = -Infinity;\nlet lastAudioGcErrorLog = -Infinity;\nlet finalizationRegistry = null;\nif (typeof FinalizationRegistry !== 'undefined') {\n    finalizationRegistry = new FinalizationRegistry((value) => {\n        const now = Date.now();\n        if (value.type === 'video') {\n            if (now - lastVideoGcErrorLog >= 1000) {\n                // This error is annoying but oh so important\n                console.error(`A VideoSample was garbage collected without first being closed. For proper resource management,`\n                    + ` make sure to call close() on all your VideoSamples as soon as you're done using them.`);\n                lastVideoGcErrorLog = now;\n            }\n            if (typeof VideoFrame !== 'undefined' && value.data instanceof VideoFrame) {\n                value.data.close(); // Prevent the browser error since we're logging our own\n            }\n        }\n        else {\n            if (now - lastAudioGcErrorLog >= 1000) {\n                console.error(`An AudioSample was garbage collected without first being closed. For proper resource management,`\n                    + ` make sure to call close() on all your AudioSamples as soon as you're done using them.`);\n                lastAudioGcErrorLog = now;\n            }\n            if (typeof AudioData !== 'undefined' && value.data instanceof AudioData) {\n                value.data.close();\n            }\n        }\n    });\n}\n/**\n * The list of {@link VideoSample} pixel formats.\n * @group Samples\n * @public\n */\nexport const VIDEO_SAMPLE_PIXEL_FORMATS = [\n    // 4:2:0 Y, U, V\n    'I420',\n    'I420P10',\n    'I420P12',\n    // 4:2:0 Y, U, V, A\n    'I420A',\n    'I420AP10',\n    'I420AP12',\n    // 4:2:2 Y, U, V\n    'I422',\n    'I422P10',\n    'I422P12',\n    // 4:2:2 Y, U, V, A\n    'I422A',\n    'I422AP10',\n    'I422AP12',\n    // 4:4:4 Y, U, V\n    'I444',\n    'I444P10',\n    'I444P12',\n    // 4:4:4 Y, U, V, A\n    'I444A',\n    'I444AP10',\n    'I444AP12',\n    // 4:2:0 Y, UV\n    'NV12',\n    // 4:4:4 RGBA\n    'RGBA',\n    // 4:4:4 RGBX (opaque)\n    'RGBX',\n    // 4:4:4 BGRA\n    'BGRA',\n    // 4:4:4 BGRX (opaque)\n    'BGRX',\n];\nconst VIDEO_SAMPLE_PIXEL_FORMATS_SET = new Set(VIDEO_SAMPLE_PIXEL_FORMATS);\n/**\n * Represents a raw, unencoded video sample (frame). Mainly used as an expressive wrapper around WebCodecs API's\n * [`VideoFrame`](https://developer.mozilla.org/en-US/docs/Web/API/VideoFrame), but can also be used standalone.\n * @group Samples\n * @public\n */\nexport class VideoSample {\n    /** The width of the frame in pixels after rotation. */\n    get displayWidth() {\n        return this.rotation % 180 === 0 ? this.codedWidth : this.codedHeight;\n    }\n    /** The height of the frame in pixels after rotation. */\n    get displayHeight() {\n        return this.rotation % 180 === 0 ? this.codedHeight : this.codedWidth;\n    }\n    /** The presentation timestamp of the frame in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the frame in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /**\n     * Whether this sample uses a pixel format that can hold transparency data. Note that this doesn't necessarily mean\n     * that the sample is transparent.\n     */\n    get hasAlpha() {\n        return this.format && this.format.includes('A');\n    }\n    constructor(data, init) {\n        /** @internal */\n        this._closed = false;\n        if (data instanceof ArrayBuffer\n            || (typeof SharedArrayBuffer !== 'undefined' && data instanceof SharedArrayBuffer)\n            || ArrayBuffer.isView(data)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (init.format === undefined || !VIDEO_SAMPLE_PIXEL_FORMATS_SET.has(init.format)) {\n                throw new TypeError('init.format must be one of: ' + VIDEO_SAMPLE_PIXEL_FORMATS.join(', '));\n            }\n            if (!Number.isInteger(init.codedWidth) || init.codedWidth <= 0) {\n                throw new TypeError('init.codedWidth must be a positive integer.');\n            }\n            if (!Number.isInteger(init.codedHeight) || init.codedHeight <= 0) {\n                throw new TypeError('init.codedHeight must be a positive integer.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = toUint8Array(data).slice(); // Copy it\n            this._layout = init.layout ?? createDefaultPlaneLayout(init.format, init.codedWidth, init.codedHeight);\n            this.format = init.format;\n            this.codedWidth = init.codedWidth;\n            this.codedHeight = init.codedHeight;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoSampleColorSpace(init.colorSpace);\n        }\n        else if (typeof VideoFrame !== 'undefined' && data instanceof VideoFrame) {\n            if (init?.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (init?.timestamp !== undefined && !Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp, when provided, must be a number.');\n            }\n            if (init?.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            this._data = data;\n            this._layout = null;\n            this.format = data.format;\n            // Copying the display dimensions here, assuming no innate VideoFrame rotation\n            this.codedWidth = data.displayWidth;\n            this.codedHeight = data.displayHeight;\n            // The VideoFrame's rotation is ignored here. It's still a new field, and I'm not sure of any application\n            // where the browser makes use of it. If a case gets found, I'll add it.\n            this.rotation = init?.rotation ?? 0;\n            this.timestamp = init?.timestamp ?? data.timestamp / 1e6;\n            this.duration = init?.duration ?? (data.duration ?? 0) / 1e6;\n            this.colorSpace = new VideoSampleColorSpace(data.colorSpace);\n        }\n        else if ((typeof HTMLImageElement !== 'undefined' && data instanceof HTMLImageElement)\n            || (typeof SVGImageElement !== 'undefined' && data instanceof SVGImageElement)\n            || (typeof ImageBitmap !== 'undefined' && data instanceof ImageBitmap)\n            || (typeof HTMLVideoElement !== 'undefined' && data instanceof HTMLVideoElement)\n            || (typeof HTMLCanvasElement !== 'undefined' && data instanceof HTMLCanvasElement)\n            || (typeof OffscreenCanvas !== 'undefined' && data instanceof OffscreenCanvas)) {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('init must be an object.');\n            }\n            if (init.rotation !== undefined && ![0, 90, 180, 270].includes(init.rotation)) {\n                throw new TypeError('init.rotation, when provided, must be 0, 90, 180, or 270.');\n            }\n            if (!Number.isFinite(init.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            if (init.duration !== undefined && (!Number.isFinite(init.duration) || init.duration < 0)) {\n                throw new TypeError('init.duration, when provided, must be a non-negative number.');\n            }\n            if (typeof VideoFrame !== 'undefined') {\n                return new VideoSample(new VideoFrame(data, {\n                    timestamp: Math.trunc(init.timestamp * SECOND_TO_MICROSECOND_FACTOR),\n                    // Drag 0 to undefined\n                    duration: Math.trunc((init.duration ?? 0) * SECOND_TO_MICROSECOND_FACTOR) || undefined,\n                }), init);\n            }\n            let width = 0;\n            let height = 0;\n            // Determine the dimensions of the thing\n            if ('naturalWidth' in data) {\n                width = data.naturalWidth;\n                height = data.naturalHeight;\n            }\n            else if ('videoWidth' in data) {\n                width = data.videoWidth;\n                height = data.videoHeight;\n            }\n            else if ('width' in data) {\n                width = Number(data.width);\n                height = Number(data.height);\n            }\n            if (!width || !height) {\n                throw new TypeError('Could not determine dimensions.');\n            }\n            const canvas = new OffscreenCanvas(width, height);\n            const context = canvas.getContext('2d', {\n                alpha: isFirefox(), // Firefox has VideoFrame glitches with opaque canvases\n                willReadFrequently: true,\n            });\n            assert(context);\n            // Draw it to a canvas\n            context.drawImage(data, 0, 0);\n            this._data = canvas;\n            this._layout = null;\n            this.format = 'RGBX';\n            this.codedWidth = width;\n            this.codedHeight = height;\n            this.rotation = init.rotation ?? 0;\n            this.timestamp = init.timestamp;\n            this.duration = init.duration ?? 0;\n            this.colorSpace = new VideoSampleColorSpace({\n                matrix: 'rgb',\n                primaries: 'bt709',\n                transfer: 'iec61966-2-1',\n                fullRange: true,\n            });\n        }\n        else {\n            throw new TypeError('Invalid data type: Must be a BufferSource or CanvasImageSource.');\n        }\n        finalizationRegistry?.register(this, { type: 'video', data: this._data }, this);\n    }\n    /** Clones this video sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoSample(this._data.clone(), {\n                timestamp: this.timestamp,\n                duration: this.duration,\n                rotation: this.rotation,\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            assert(this._layout);\n            return new VideoSample(this._data, {\n                format: this.format,\n                layout: this._layout,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n        else {\n            return new VideoSample(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.timestamp,\n                duration: this.duration,\n                colorSpace: this.colorSpace,\n                rotation: this.rotation,\n            });\n        }\n    }\n    /**\n     * Closes this video sample, releasing held resources. Video samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        finalizationRegistry?.unregister(this);\n        if (isVideoFrame(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = null; // GC that shit\n        }\n        this._closed = true;\n    }\n    /**\n     * Returns the number of bytes required to hold this video sample's pixel data. Throws if `format` is `null`.\n     */\n    allocationSize(options = {}) {\n        validateVideoFrameCopyToOptions(options);\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        if (this.format === null) {\n            // https://github.com/Vanilagy/mediabunny/issues/267\n            // https://github.com/w3c/webcodecs/issues/920\n            throw new Error('Cannot get allocation size when format is null. Sorry!');\n        }\n        assert(this._data !== null);\n        if (!isVideoFrame(this._data)) {\n            if (options.colorSpace\n                || (options.format && options.format !== this.format)\n                || options.layout\n                || options.rect) {\n                // Temporarily convert to VideoFrame to get it done\n                // TODO: Compute this directly without needing to go through VideoFrame\n                const videoFrame = this.toVideoFrame();\n                const size = videoFrame.allocationSize(options);\n                videoFrame.close();\n                return size;\n            }\n        }\n        if (isVideoFrame(this._data)) {\n            return this._data.allocationSize(options);\n        }\n        else if (this._data instanceof Uint8Array) {\n            return this._data.byteLength;\n        }\n        else {\n            return this.codedWidth * this.codedHeight * 4; // RGBX\n        }\n    }\n    /**\n     * Copies this video sample's pixel data to an ArrayBuffer or ArrayBufferView. Throws if `format` is `null`.\n     * @returns The byte layout of the planes of the copied data.\n     */\n    async copyTo(destination, options = {}) {\n        if (!isAllowSharedBufferSource(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        validateVideoFrameCopyToOptions(options);\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        if (this.format === null) {\n            throw new Error('Cannot copy video sample data when format is null. Sorry!');\n        }\n        assert(this._data !== null);\n        if (!isVideoFrame(this._data)) {\n            if (options.colorSpace\n                || (options.format && options.format !== this.format)\n                || options.layout\n                || options.rect) {\n                // Temporarily convert to VideoFrame to get it done\n                // TODO: Do this directly without needing to go through VideoFrame\n                const videoFrame = this.toVideoFrame();\n                const layout = await videoFrame.copyTo(destination, options);\n                videoFrame.close();\n                return layout;\n            }\n        }\n        if (isVideoFrame(this._data)) {\n            return this._data.copyTo(destination, options);\n        }\n        else if (this._data instanceof Uint8Array) {\n            assert(this._layout);\n            const dest = toUint8Array(destination);\n            dest.set(this._data);\n            return this._layout;\n        }\n        else {\n            const canvas = this._data;\n            const context = canvas.getContext('2d');\n            assert(context);\n            const imageData = context.getImageData(0, 0, this.codedWidth, this.codedHeight);\n            const dest = toUint8Array(destination);\n            dest.set(imageData.data);\n            return [{\n                    offset: 0,\n                    stride: 4 * this.codedWidth,\n                }];\n        }\n    }\n    /**\n     * Converts this video sample to a VideoFrame for use with the WebCodecs API. The VideoFrame returned by this\n     * method *must* be closed separately from this video sample.\n     */\n    toVideoFrame() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (isVideoFrame(this._data)) {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined, // Drag 0 duration to undefined, glitches some codecs\n            });\n        }\n        else if (this._data instanceof Uint8Array) {\n            return new VideoFrame(this._data, {\n                format: this.format,\n                codedWidth: this.codedWidth,\n                codedHeight: this.codedHeight,\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined,\n                colorSpace: this.colorSpace,\n            });\n        }\n        else {\n            return new VideoFrame(this._data, {\n                timestamp: this.microsecondTimestamp,\n                duration: this.microsecondDuration || undefined,\n            });\n        }\n    }\n    draw(context, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8) {\n        let sx = 0;\n        let sy = 0;\n        let sWidth = this.displayWidth;\n        let sHeight = this.displayHeight;\n        let dx = 0;\n        let dy = 0;\n        let dWidth = this.displayWidth;\n        let dHeight = this.displayHeight;\n        if (arg5 !== undefined) {\n            sx = arg1;\n            sy = arg2;\n            sWidth = arg3;\n            sHeight = arg4;\n            dx = arg5;\n            dy = arg6;\n            if (arg7 !== undefined) {\n                dWidth = arg7;\n                dHeight = arg8;\n            }\n            else {\n                dWidth = sWidth;\n                dHeight = sHeight;\n            }\n        }\n        else {\n            dx = arg1;\n            dy = arg2;\n            if (arg3 !== undefined) {\n                dWidth = arg3;\n                dHeight = arg4;\n            }\n        }\n        if (!((typeof CanvasRenderingContext2D !== 'undefined' && context instanceof CanvasRenderingContext2D)\n            || (typeof OffscreenCanvasRenderingContext2D !== 'undefined'\n                && context instanceof OffscreenCanvasRenderingContext2D))) {\n            throw new TypeError('context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.');\n        }\n        if (!Number.isFinite(sx)) {\n            throw new TypeError('sx must be a number.');\n        }\n        if (!Number.isFinite(sy)) {\n            throw new TypeError('sy must be a number.');\n        }\n        if (!Number.isFinite(sWidth) || sWidth < 0) {\n            throw new TypeError('sWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(sHeight) || sHeight < 0) {\n            throw new TypeError('sHeight must be a non-negative number.');\n        }\n        if (!Number.isFinite(dx)) {\n            throw new TypeError('dx must be a number.');\n        }\n        if (!Number.isFinite(dy)) {\n            throw new TypeError('dy must be a number.');\n        }\n        if (!Number.isFinite(dWidth) || dWidth < 0) {\n            throw new TypeError('dWidth must be a non-negative number.');\n        }\n        if (!Number.isFinite(dHeight) || dHeight < 0) {\n            throw new TypeError('dHeight must be a non-negative number.');\n        }\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        ({ sx, sy, sWidth, sHeight } = this._rotateSourceRegion(sx, sy, sWidth, sHeight, this.rotation));\n        const source = this.toCanvasImageSource();\n        context.save();\n        const centerX = dx + dWidth / 2;\n        const centerY = dy + dHeight / 2;\n        context.translate(centerX, centerY);\n        context.rotate(this.rotation * Math.PI / 180);\n        const aspectRatioChange = this.rotation % 180 === 0 ? 1 : dWidth / dHeight;\n        // Scale to compensate for aspect ratio changes when rotated\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.drawImage(source, sx, sy, sWidth, sHeight, -dWidth / 2, -dHeight / 2, dWidth, dHeight);\n        context.restore();\n    }\n    /**\n     * Draws the sample in the middle of the canvas corresponding to the context with the specified fit behavior.\n     */\n    drawWithFit(context, options) {\n        if (!((typeof CanvasRenderingContext2D !== 'undefined' && context instanceof CanvasRenderingContext2D)\n            || (typeof OffscreenCanvasRenderingContext2D !== 'undefined'\n                && context instanceof OffscreenCanvasRenderingContext2D))) {\n            throw new TypeError('context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!['fill', 'contain', 'cover'].includes(options.fit)) {\n            throw new TypeError('options.fit must be \\'fill\\', \\'contain\\', or \\'cover\\'.');\n        }\n        if (options.rotation !== undefined && ![0, 90, 180, 270].includes(options.rotation)) {\n            throw new TypeError('options.rotation, when provided, must be 0, 90, 180, or 270.');\n        }\n        if (options.crop !== undefined) {\n            validateCropRectangle(options.crop, 'options.');\n        }\n        const canvasWidth = context.canvas.width;\n        const canvasHeight = context.canvas.height;\n        const rotation = options.rotation ?? this.rotation;\n        const [rotatedWidth, rotatedHeight] = rotation % 180 === 0\n            ? [this.codedWidth, this.codedHeight]\n            : [this.codedHeight, this.codedWidth];\n        if (options.crop) {\n            clampCropRectangle(options.crop, rotatedWidth, rotatedHeight);\n        }\n        // These variables specify where the final sample will be drawn on the canvas\n        let dx;\n        let dy;\n        let newWidth;\n        let newHeight;\n        const { sx, sy, sWidth, sHeight } = this._rotateSourceRegion(options.crop?.left ?? 0, options.crop?.top ?? 0, options.crop?.width ?? rotatedWidth, options.crop?.height ?? rotatedHeight, rotation);\n        if (options.fit === 'fill') {\n            dx = 0;\n            dy = 0;\n            newWidth = canvasWidth;\n            newHeight = canvasHeight;\n        }\n        else {\n            const [sampleWidth, sampleHeight] = options.crop\n                ? [options.crop.width, options.crop.height]\n                : [rotatedWidth, rotatedHeight];\n            const scale = options.fit === 'contain'\n                ? Math.min(canvasWidth / sampleWidth, canvasHeight / sampleHeight)\n                : Math.max(canvasWidth / sampleWidth, canvasHeight / sampleHeight);\n            newWidth = sampleWidth * scale;\n            newHeight = sampleHeight * scale;\n            dx = (canvasWidth - newWidth) / 2;\n            dy = (canvasHeight - newHeight) / 2;\n        }\n        context.save();\n        const aspectRatioChange = rotation % 180 === 0 ? 1 : newWidth / newHeight;\n        context.translate(canvasWidth / 2, canvasHeight / 2);\n        context.rotate(rotation * Math.PI / 180);\n        // This aspect ratio compensation is done so that we can draw the sample with the intended dimensions and\n        // don't need to think about how those dimensions change after the rotation\n        context.scale(1 / aspectRatioChange, aspectRatioChange);\n        context.translate(-canvasWidth / 2, -canvasHeight / 2);\n        // Important that we don't use .draw() here since that would take rotation into account, but we wanna handle it\n        // ourselves here\n        context.drawImage(this.toCanvasImageSource(), sx, sy, sWidth, sHeight, dx, dy, newWidth, newHeight);\n        context.restore();\n    }\n    /** @internal */\n    _rotateSourceRegion(sx, sy, sWidth, sHeight, rotation) {\n        // The provided sx,sy,sWidth,sHeight refer to the final rotated image, but that's not actually how the image is\n        // stored. Therefore, we must map these back onto the original, pre-rotation image.\n        if (rotation === 90) {\n            [sx, sy, sWidth, sHeight] = [\n                sy,\n                this.codedHeight - sx - sWidth,\n                sHeight,\n                sWidth,\n            ];\n        }\n        else if (rotation === 180) {\n            [sx, sy] = [\n                this.codedWidth - sx - sWidth,\n                this.codedHeight - sy - sHeight,\n            ];\n        }\n        else if (rotation === 270) {\n            [sx, sy, sWidth, sHeight] = [\n                this.codedWidth - sy - sHeight,\n                sx,\n                sHeight,\n                sWidth,\n            ];\n        }\n        return { sx, sy, sWidth, sHeight };\n    }\n    /**\n     * Converts this video sample to a\n     * [`CanvasImageSource`](https://udn.realityripple.com/docs/Web/API/CanvasImageSource) for drawing to a canvas.\n     *\n     * You must use the value returned by this method immediately, as any VideoFrame created internally will\n     * automatically be closed in the next microtask.\n     */\n    toCanvasImageSource() {\n        if (this._closed) {\n            throw new Error('VideoSample is closed.');\n        }\n        assert(this._data !== null);\n        if (this._data instanceof Uint8Array) {\n            // Requires VideoFrame to be defined\n            const videoFrame = this.toVideoFrame();\n            queueMicrotask(() => videoFrame.close()); // Let's automatically close the frame in the next microtask\n            return videoFrame;\n        }\n        else {\n            return this._data;\n        }\n    }\n    /** Sets the rotation metadata of this video sample. */\n    setRotation(newRotation) {\n        if (![0, 90, 180, 270].includes(newRotation)) {\n            throw new TypeError('newRotation must be 0, 90, 180, or 270.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.rotation = newRotation;\n    }\n    /** Sets the presentation timestamp of this video sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** Sets the duration of this video sample, in seconds. */\n    setDuration(newDuration) {\n        if (!Number.isFinite(newDuration) || newDuration < 0) {\n            throw new TypeError('newDuration must be a non-negative number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.duration = newDuration;\n    }\n    /** Calls `.close()`. */\n    [Symbol.dispose]() {\n        this.close();\n    }\n}\n/**\n * Describes the color space of a {@link VideoSample}. Corresponds to the WebCodecs API's VideoColorSpace.\n * @group Samples\n * @public\n */\nexport class VideoSampleColorSpace {\n    /** Creates a new VideoSampleColorSpace. */\n    constructor(init) {\n        this.primaries = init?.primaries ?? null;\n        this.transfer = init?.transfer ?? null;\n        this.matrix = init?.matrix ?? null;\n        this.fullRange = init?.fullRange ?? null;\n    }\n    /** Serializes the color space to a JSON object. */\n    toJSON() {\n        return {\n            primaries: this.primaries,\n            transfer: this.transfer,\n            matrix: this.matrix,\n            fullRange: this.fullRange,\n        };\n    }\n}\nconst isVideoFrame = (x) => {\n    return typeof VideoFrame !== 'undefined' && x instanceof VideoFrame;\n};\nexport const clampCropRectangle = (crop, outerWidth, outerHeight) => {\n    crop.left = Math.min(crop.left, outerWidth);\n    crop.top = Math.min(crop.top, outerHeight);\n    crop.width = Math.min(crop.width, outerWidth - crop.left);\n    crop.height = Math.min(crop.height, outerHeight - crop.top);\n    assert(crop.width >= 0);\n    assert(crop.height >= 0);\n};\nexport const validateCropRectangle = (crop, prefix) => {\n    if (!crop || typeof crop !== 'object') {\n        throw new TypeError(prefix + 'crop, when provided, must be an object.');\n    }\n    if (!Number.isInteger(crop.left) || crop.left < 0) {\n        throw new TypeError(prefix + 'crop.left must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.top) || crop.top < 0) {\n        throw new TypeError(prefix + 'crop.top must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.width) || crop.width < 0) {\n        throw new TypeError(prefix + 'crop.width must be a non-negative integer.');\n    }\n    if (!Number.isInteger(crop.height) || crop.height < 0) {\n        throw new TypeError(prefix + 'crop.height must be a non-negative integer.');\n    }\n};\nconst validateVideoFrameCopyToOptions = (options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('options must be an object.');\n    }\n    if (options.colorSpace !== undefined && !['display-p3', 'srgb'].includes(options.colorSpace)) {\n        throw new TypeError('options.colorSpace, when provided, must be \\'display-p3\\' or \\'srgb\\'.');\n    }\n    if (options.format !== undefined && typeof options.format !== 'string') {\n        throw new TypeError('options.format, when provided, must be a string.');\n    }\n    if (options.layout !== undefined) {\n        if (!Array.isArray(options.layout)) {\n            throw new TypeError('options.layout, when provided, must be an array.');\n        }\n        for (const plane of options.layout) {\n            if (!plane || typeof plane !== 'object') {\n                throw new TypeError('Each entry in options.layout must be an object.');\n            }\n            if (!Number.isInteger(plane.offset) || plane.offset < 0) {\n                throw new TypeError('plane.offset must be a non-negative integer.');\n            }\n            if (!Number.isInteger(plane.stride) || plane.stride < 0) {\n                throw new TypeError('plane.stride must be a non-negative integer.');\n            }\n        }\n    }\n    if (options.rect !== undefined) {\n        if (!options.rect || typeof options.rect !== 'object') {\n            throw new TypeError('options.rect, when provided, must be an object.');\n        }\n        if (options.rect.x !== undefined && (!Number.isInteger(options.rect.x) || options.rect.x < 0)) {\n            throw new TypeError('options.rect.x, when provided, must be a non-negative integer.');\n        }\n        if (options.rect.y !== undefined && (!Number.isInteger(options.rect.y) || options.rect.y < 0)) {\n            throw new TypeError('options.rect.y, when provided, must be a non-negative integer.');\n        }\n        if (options.rect.width !== undefined && (!Number.isInteger(options.rect.width) || options.rect.width < 0)) {\n            throw new TypeError('options.rect.width, when provided, must be a non-negative integer.');\n        }\n        if (options.rect.height !== undefined && (!Number.isInteger(options.rect.height) || options.rect.height < 0)) {\n            throw new TypeError('options.rect.height, when provided, must be a non-negative integer.');\n        }\n    }\n};\n/** Implements logic from WebCodecs  9.4.6 \"Compute Layout and Allocation Size\" */\nconst createDefaultPlaneLayout = (format, codedWidth, codedHeight) => {\n    const planes = getPlaneConfigs(format);\n    const layouts = [];\n    let currentOffset = 0;\n    for (const plane of planes) {\n        // Per  9.8, dimensions are usually \"rounded up to the nearest integer\".\n        const planeWidth = Math.ceil(codedWidth / plane.widthDivisor);\n        const planeHeight = Math.ceil(codedHeight / plane.heightDivisor);\n        const stride = planeWidth * plane.sampleBytes;\n        // Tight packing\n        const planeSize = stride * planeHeight;\n        layouts.push({\n            offset: currentOffset,\n            stride: stride,\n        });\n        currentOffset += planeSize;\n    }\n    return layouts;\n};\n/** Helper to retrieve plane configurations based on WebCodecs  9.8 Pixel Format definitions. */\nconst getPlaneConfigs = (format) => {\n    // Helper for standard YUV planes\n    const yuv = (yBytes, uvBytes, subX, subY, hasAlpha) => {\n        const configs = [\n            { sampleBytes: yBytes, widthDivisor: 1, heightDivisor: 1 },\n            { sampleBytes: uvBytes, widthDivisor: subX, heightDivisor: subY },\n            { sampleBytes: uvBytes, widthDivisor: subX, heightDivisor: subY },\n        ];\n        if (hasAlpha) {\n            // Match luma dimensions\n            configs.push({ sampleBytes: yBytes, widthDivisor: 1, heightDivisor: 1 });\n        }\n        return configs;\n    };\n    switch (format) {\n        case 'I420':\n            return yuv(1, 1, 2, 2, false);\n        case 'I420P10':\n        case 'I420P12':\n            return yuv(2, 2, 2, 2, false);\n        case 'I420A':\n            return yuv(1, 1, 2, 2, true);\n        case 'I420AP10':\n        case 'I420AP12':\n            return yuv(2, 2, 2, 2, true);\n        case 'I422':\n            return yuv(1, 1, 2, 1, false);\n        case 'I422P10':\n        case 'I422P12':\n            return yuv(2, 2, 2, 1, false);\n        case 'I422A':\n            return yuv(1, 1, 2, 1, true);\n        case 'I422AP10':\n        case 'I422AP12':\n            return yuv(2, 2, 2, 1, true);\n        case 'I444':\n            return yuv(1, 1, 1, 1, false);\n        case 'I444P10':\n        case 'I444P12':\n            return yuv(2, 2, 1, 1, false);\n        case 'I444A':\n            return yuv(1, 1, 1, 1, true);\n        case 'I444AP10':\n        case 'I444AP12':\n            return yuv(2, 2, 1, 1, true);\n        case 'NV12':\n            return [\n                { sampleBytes: 1, widthDivisor: 1, heightDivisor: 1 },\n                { sampleBytes: 2, widthDivisor: 2, heightDivisor: 2 }, // Interleaved U and V\n            ];\n        case 'RGBA':\n        case 'RGBX':\n        case 'BGRA':\n        case 'BGRX':\n            return [\n                { sampleBytes: 4, widthDivisor: 1, heightDivisor: 1 },\n            ];\n        default:\n            assertNever(format);\n            assert(false);\n    }\n};\nconst AUDIO_SAMPLE_FORMATS = new Set(['f32', 'f32-planar', 's16', 's16-planar', 's32', 's32-planar', 'u8', 'u8-planar']);\n/**\n * Represents a raw, unencoded audio sample. Mainly used as an expressive wrapper around WebCodecs API's\n * [`AudioData`](https://developer.mozilla.org/en-US/docs/Web/API/AudioData), but can also be used standalone.\n * @group Samples\n * @public\n */\nexport class AudioSample {\n    /** The presentation timestamp of the sample in microseconds. */\n    get microsecondTimestamp() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.timestamp);\n    }\n    /** The duration of the sample in microseconds. */\n    get microsecondDuration() {\n        return Math.trunc(SECOND_TO_MICROSECOND_FACTOR * this.duration);\n    }\n    /**\n     * Creates a new {@link AudioSample}, either from an existing\n     * [`AudioData`](https://developer.mozilla.org/en-US/docs/Web/API/AudioData) or from raw bytes specified in\n     * {@link AudioSampleInit}.\n     */\n    constructor(init) {\n        /** @internal */\n        this._closed = false;\n        if (isAudioData(init)) {\n            if (init.format === null) {\n                throw new TypeError('AudioData with null format is not supported.');\n            }\n            this._data = init;\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = init.numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp / 1e6;\n            this.duration = init.numberOfFrames / init.sampleRate;\n        }\n        else {\n            if (!init || typeof init !== 'object') {\n                throw new TypeError('Invalid AudioDataInit: must be an object.');\n            }\n            if (!AUDIO_SAMPLE_FORMATS.has(init.format)) {\n                throw new TypeError('Invalid AudioDataInit: invalid format.');\n            }\n            if (!Number.isFinite(init.sampleRate) || init.sampleRate <= 0) {\n                throw new TypeError('Invalid AudioDataInit: sampleRate must be > 0.');\n            }\n            if (!Number.isInteger(init.numberOfChannels) || init.numberOfChannels === 0) {\n                throw new TypeError('Invalid AudioDataInit: numberOfChannels must be an integer > 0.');\n            }\n            if (!Number.isFinite(init?.timestamp)) {\n                throw new TypeError('init.timestamp must be a number.');\n            }\n            const numberOfFrames = init.data.byteLength / (getBytesPerSample(init.format) * init.numberOfChannels);\n            if (!Number.isInteger(numberOfFrames)) {\n                throw new TypeError('Invalid AudioDataInit: data size is not a multiple of frame size.');\n            }\n            this.format = init.format;\n            this.sampleRate = init.sampleRate;\n            this.numberOfFrames = numberOfFrames;\n            this.numberOfChannels = init.numberOfChannels;\n            this.timestamp = init.timestamp;\n            this.duration = numberOfFrames / init.sampleRate;\n            let dataBuffer;\n            if (init.data instanceof ArrayBuffer) {\n                dataBuffer = new Uint8Array(init.data);\n            }\n            else if (ArrayBuffer.isView(init.data)) {\n                dataBuffer = new Uint8Array(init.data.buffer, init.data.byteOffset, init.data.byteLength);\n            }\n            else {\n                throw new TypeError('Invalid AudioDataInit: data is not a BufferSource.');\n            }\n            const expectedSize = this.numberOfFrames * this.numberOfChannels * getBytesPerSample(this.format);\n            if (dataBuffer.byteLength < expectedSize) {\n                throw new TypeError('Invalid AudioDataInit: insufficient data size.');\n            }\n            this._data = dataBuffer;\n        }\n        finalizationRegistry?.register(this, { type: 'audio', data: this._data }, this);\n    }\n    /** Returns the number of bytes required to hold the audio sample's data as specified by the given options. */\n    allocationSize(options) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const destFormat = options.format ?? this.format;\n        const frameOffset = options.frameOffset ?? 0;\n        if (frameOffset >= this.numberOfFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = options.frameCount !== undefined ? options.frameCount : (this.numberOfFrames - frameOffset);\n        if (copyFrameCount > (this.numberOfFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const bytesPerSample = getBytesPerSample(destFormat);\n        const isPlanar = formatIsPlanar(destFormat);\n        if (isPlanar && options.planeIndex >= this.numberOfChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!isPlanar && options.planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const elementCount = isPlanar ? copyFrameCount : copyFrameCount * this.numberOfChannels;\n        return elementCount * bytesPerSample;\n    }\n    /** Copies the audio sample's data to an ArrayBuffer or ArrayBufferView as specified by the given options. */\n    copyTo(destination, options) {\n        if (!isAllowSharedBufferSource(destination)) {\n            throw new TypeError('destination must be an ArrayBuffer or an ArrayBuffer view.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!Number.isInteger(options.planeIndex) || options.planeIndex < 0) {\n            throw new TypeError('planeIndex must be a non-negative integer.');\n        }\n        if (options.format !== undefined && !AUDIO_SAMPLE_FORMATS.has(options.format)) {\n            throw new TypeError('Invalid format.');\n        }\n        if (options.frameOffset !== undefined && (!Number.isInteger(options.frameOffset) || options.frameOffset < 0)) {\n            throw new TypeError('frameOffset must be a non-negative integer.');\n        }\n        if (options.frameCount !== undefined && (!Number.isInteger(options.frameCount) || options.frameCount < 0)) {\n            throw new TypeError('frameCount must be a non-negative integer.');\n        }\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const { planeIndex, format, frameCount: optFrameCount, frameOffset: optFrameOffset } = options;\n        const srcFormat = this.format;\n        const destFormat = format ?? this.format;\n        if (!destFormat)\n            throw new Error('Destination format not determined');\n        const numFrames = this.numberOfFrames;\n        const numChannels = this.numberOfChannels;\n        const frameOffset = optFrameOffset ?? 0;\n        if (frameOffset >= numFrames) {\n            throw new RangeError('frameOffset out of range');\n        }\n        const copyFrameCount = optFrameCount !== undefined ? optFrameCount : (numFrames - frameOffset);\n        if (copyFrameCount > (numFrames - frameOffset)) {\n            throw new RangeError('frameCount out of range');\n        }\n        const destBytesPerSample = getBytesPerSample(destFormat);\n        const destIsPlanar = formatIsPlanar(destFormat);\n        if (destIsPlanar && planeIndex >= numChannels) {\n            throw new RangeError('planeIndex out of range');\n        }\n        if (!destIsPlanar && planeIndex !== 0) {\n            throw new RangeError('planeIndex out of range');\n        }\n        const destElementCount = destIsPlanar ? copyFrameCount : copyFrameCount * numChannels;\n        const requiredSize = destElementCount * destBytesPerSample;\n        if (destination.byteLength < requiredSize) {\n            throw new RangeError('Destination buffer is too small');\n        }\n        const destView = toDataView(destination);\n        const writeFn = getWriteFunction(destFormat);\n        if (isAudioData(this._data)) {\n            if (isWebKit() && numChannels > 2 && destFormat !== srcFormat) {\n                // WebKit bug workaround\n                doAudioDataCopyToWebKitWorkaround(this._data, destView, srcFormat, destFormat, numChannels, planeIndex, frameOffset, copyFrameCount);\n            }\n            else {\n                // Per spec, only f32-planar conversion must be supported, but in practice, all browsers support all\n                // destination formats, so let's just delegate here:\n                this._data.copyTo(destination, {\n                    planeIndex,\n                    frameOffset,\n                    frameCount: copyFrameCount,\n                    format: destFormat,\n                });\n            }\n        }\n        else {\n            const uint8Data = this._data;\n            const srcView = toDataView(uint8Data);\n            const readFn = getReadFunction(srcFormat);\n            const srcBytesPerSample = getBytesPerSample(srcFormat);\n            const srcIsPlanar = formatIsPlanar(srcFormat);\n            for (let i = 0; i < copyFrameCount; i++) {\n                if (destIsPlanar) {\n                    const destOffset = i * destBytesPerSample;\n                    let srcOffset;\n                    if (srcIsPlanar) {\n                        srcOffset = (planeIndex * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                    }\n                    else {\n                        srcOffset = (((i + frameOffset) * numChannels) + planeIndex) * srcBytesPerSample;\n                    }\n                    const normalized = readFn(srcView, srcOffset);\n                    writeFn(destView, destOffset, normalized);\n                }\n                else {\n                    for (let ch = 0; ch < numChannels; ch++) {\n                        const destIndex = i * numChannels + ch;\n                        const destOffset = destIndex * destBytesPerSample;\n                        let srcOffset;\n                        if (srcIsPlanar) {\n                            srcOffset = (ch * numFrames + (i + frameOffset)) * srcBytesPerSample;\n                        }\n                        else {\n                            srcOffset = (((i + frameOffset) * numChannels) + ch) * srcBytesPerSample;\n                        }\n                        const normalized = readFn(srcView, srcOffset);\n                        writeFn(destView, destOffset, normalized);\n                    }\n                }\n            }\n        }\n    }\n    /** Clones this audio sample. */\n    clone() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            const sample = new AudioSample(this._data.clone());\n            sample.setTimestamp(this.timestamp); // Make sure the timestamp is precise (beyond microsecond accuracy)\n            return sample;\n        }\n        else {\n            return new AudioSample({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.timestamp,\n                data: this._data,\n            });\n        }\n    }\n    /**\n     * Closes this audio sample, releasing held resources. Audio samples should be closed as soon as they are not\n     * needed anymore.\n     */\n    close() {\n        if (this._closed) {\n            return;\n        }\n        finalizationRegistry?.unregister(this);\n        if (isAudioData(this._data)) {\n            this._data.close();\n        }\n        else {\n            this._data = new Uint8Array(0);\n        }\n        this._closed = true;\n    }\n    /**\n     * Converts this audio sample to an AudioData for use with the WebCodecs API. The AudioData returned by this\n     * method *must* be closed separately from this audio sample.\n     */\n    toAudioData() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        if (isAudioData(this._data)) {\n            if (this._data.timestamp === this.microsecondTimestamp) {\n                // Timestamp matches, let's just return the data (but cloned)\n                return this._data.clone();\n            }\n            else {\n                // It's impossible to simply change an AudioData's timestamp, so we'll need to create a new one\n                if (formatIsPlanar(this.format)) {\n                    const size = this.allocationSize({ planeIndex: 0, format: this.format });\n                    const data = new ArrayBuffer(size * this.numberOfChannels);\n                    // We gotta read out each plane individually\n                    for (let i = 0; i < this.numberOfChannels; i++) {\n                        this.copyTo(new Uint8Array(data, i * size, size), { planeIndex: i, format: this.format });\n                    }\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n                else {\n                    const data = new ArrayBuffer(this.allocationSize({ planeIndex: 0, format: this.format }));\n                    this.copyTo(data, { planeIndex: 0, format: this.format });\n                    return new AudioData({\n                        format: this.format,\n                        sampleRate: this.sampleRate,\n                        numberOfFrames: this.numberOfFrames,\n                        numberOfChannels: this.numberOfChannels,\n                        timestamp: this.microsecondTimestamp,\n                        data,\n                    });\n                }\n            }\n        }\n        else {\n            return new AudioData({\n                format: this.format,\n                sampleRate: this.sampleRate,\n                numberOfFrames: this.numberOfFrames,\n                numberOfChannels: this.numberOfChannels,\n                timestamp: this.microsecondTimestamp,\n                data: this._data.buffer instanceof ArrayBuffer\n                    ? this._data.buffer\n                    : this._data.slice(), // In the case of SharedArrayBuffer, convert to ArrayBuffer\n            });\n        }\n    }\n    /** Convert this audio sample to an AudioBuffer for use with the Web Audio API. */\n    toAudioBuffer() {\n        if (this._closed) {\n            throw new Error('AudioSample is closed.');\n        }\n        const audioBuffer = new AudioBuffer({\n            numberOfChannels: this.numberOfChannels,\n            length: this.numberOfFrames,\n            sampleRate: this.sampleRate,\n        });\n        const dataBytes = new Float32Array(this.allocationSize({ planeIndex: 0, format: 'f32-planar' }) / 4);\n        for (let i = 0; i < this.numberOfChannels; i++) {\n            this.copyTo(dataBytes, { planeIndex: i, format: 'f32-planar' });\n            audioBuffer.copyToChannel(dataBytes, i);\n        }\n        return audioBuffer;\n    }\n    /** Sets the presentation timestamp of this audio sample, in seconds. */\n    setTimestamp(newTimestamp) {\n        if (!Number.isFinite(newTimestamp)) {\n            throw new TypeError('newTimestamp must be a number.');\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-type-assertion\n        this.timestamp = newTimestamp;\n    }\n    /** Calls `.close()`. */\n    [Symbol.dispose]() {\n        this.close();\n    }\n    /** @internal */\n    static *_fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            yield new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n    }\n    /**\n     * Creates AudioSamples from an AudioBuffer, starting at the given timestamp in seconds. Typically creates exactly\n     * one sample, but may create multiple if the AudioBuffer is exceedingly large.\n     */\n    static fromAudioBuffer(audioBuffer, timestamp) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const MAX_FLOAT_COUNT = 48000 * 5; // 5 seconds of mono 48 kHz audio per sample\n        const numberOfChannels = audioBuffer.numberOfChannels;\n        const sampleRate = audioBuffer.sampleRate;\n        const totalFrames = audioBuffer.length;\n        const maxFramesPerChunk = Math.floor(MAX_FLOAT_COUNT / numberOfChannels);\n        let currentRelativeFrame = 0;\n        let remainingFrames = totalFrames;\n        const result = [];\n        // Create AudioSamples in a chunked fashion so we don't create huge Float32Arrays\n        while (remainingFrames > 0) {\n            const framesToCopy = Math.min(maxFramesPerChunk, remainingFrames);\n            const chunkData = new Float32Array(numberOfChannels * framesToCopy);\n            for (let channel = 0; channel < numberOfChannels; channel++) {\n                audioBuffer.copyFromChannel(chunkData.subarray(channel * framesToCopy, (channel + 1) * framesToCopy), channel, currentRelativeFrame);\n            }\n            const audioSample = new AudioSample({\n                format: 'f32-planar',\n                sampleRate,\n                numberOfFrames: framesToCopy,\n                numberOfChannels,\n                timestamp: timestamp + currentRelativeFrame / sampleRate,\n                data: chunkData,\n            });\n            result.push(audioSample);\n            currentRelativeFrame += framesToCopy;\n            remainingFrames -= framesToCopy;\n        }\n        return result;\n    }\n}\nconst getBytesPerSample = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return 1;\n        case 's16':\n        case 's16-planar':\n            return 2;\n        case 's32':\n        case 's32-planar':\n            return 4;\n        case 'f32':\n        case 'f32-planar':\n            return 4;\n        default:\n            throw new Error('Unknown AudioSampleFormat');\n    }\n};\nconst formatIsPlanar = (format) => {\n    switch (format) {\n        case 'u8-planar':\n        case 's16-planar':\n        case 's32-planar':\n        case 'f32-planar':\n            return true;\n        default:\n            return false;\n    }\n};\nconst getReadFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset) => (view.getUint8(offset) - 128) / 128;\n        case 's16':\n        case 's16-planar':\n            return (view, offset) => view.getInt16(offset, true) / 32768;\n        case 's32':\n        case 's32-planar':\n            return (view, offset) => view.getInt32(offset, true) / 2147483648;\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset) => view.getFloat32(offset, true);\n    }\n};\nconst getWriteFunction = (format) => {\n    switch (format) {\n        case 'u8':\n        case 'u8-planar':\n            return (view, offset, value) => view.setUint8(offset, clamp((value + 1) * 127.5, 0, 255));\n        case 's16':\n        case 's16-planar':\n            return (view, offset, value) => view.setInt16(offset, clamp(Math.round(value * 32767), -32768, 32767), true);\n        case 's32':\n        case 's32-planar':\n            return (view, offset, value) => view.setInt32(offset, clamp(Math.round(value * 2147483647), -2147483648, 2147483647), true);\n        case 'f32':\n        case 'f32-planar':\n            return (view, offset, value) => view.setFloat32(offset, value, true);\n    }\n};\nconst isAudioData = (x) => {\n    return typeof AudioData !== 'undefined' && x instanceof AudioData;\n};\n/**\n * WebKit has a bug where calling AudioData.copyTo with a format different from the source format\n * crashes the tab when there are more than 2 channels. This function works around that by always\n * copying with the source format and then manually converting to the destination format.\n *\n * See https://bugs.webkit.org/show_bug.cgi?id=302521.\n */\nconst doAudioDataCopyToWebKitWorkaround = (audioData, destView, srcFormat, destFormat, numChannels, planeIndex, frameOffset, copyFrameCount) => {\n    const readFn = getReadFunction(srcFormat);\n    const writeFn = getWriteFunction(destFormat);\n    const srcBytesPerSample = getBytesPerSample(srcFormat);\n    const destBytesPerSample = getBytesPerSample(destFormat);\n    const srcIsPlanar = formatIsPlanar(srcFormat);\n    const destIsPlanar = formatIsPlanar(destFormat);\n    if (destIsPlanar) {\n        if (srcIsPlanar) {\n            // src planar -> dest planar: copy single plane and convert\n            const data = new ArrayBuffer(copyFrameCount * srcBytesPerSample);\n            const dataView = toDataView(data);\n            audioData.copyTo(data, {\n                planeIndex,\n                frameOffset,\n                frameCount: copyFrameCount,\n                format: srcFormat,\n            });\n            for (let i = 0; i < copyFrameCount; i++) {\n                const srcOffset = i * srcBytesPerSample;\n                const destOffset = i * destBytesPerSample;\n                const sample = readFn(dataView, srcOffset);\n                writeFn(destView, destOffset, sample);\n            }\n        }\n        else {\n            // src interleaved -> dest planar: copy all interleaved data, extract one channel\n            const data = new ArrayBuffer(copyFrameCount * numChannels * srcBytesPerSample);\n            const dataView = toDataView(data);\n            audioData.copyTo(data, {\n                planeIndex: 0,\n                frameOffset,\n                frameCount: copyFrameCount,\n                format: srcFormat,\n            });\n            for (let i = 0; i < copyFrameCount; i++) {\n                const srcOffset = (i * numChannels + planeIndex) * srcBytesPerSample;\n                const destOffset = i * destBytesPerSample;\n                const sample = readFn(dataView, srcOffset);\n                writeFn(destView, destOffset, sample);\n            }\n        }\n    }\n    else {\n        if (srcIsPlanar) {\n            // src planar -> dest interleaved: copy each plane and interleave\n            const planeSize = copyFrameCount * srcBytesPerSample;\n            const data = new ArrayBuffer(planeSize);\n            const dataView = toDataView(data);\n            for (let ch = 0; ch < numChannels; ch++) {\n                audioData.copyTo(data, {\n                    planeIndex: ch,\n                    frameOffset,\n                    frameCount: copyFrameCount,\n                    format: srcFormat,\n                });\n                for (let i = 0; i < copyFrameCount; i++) {\n                    const srcOffset = i * srcBytesPerSample;\n                    const destOffset = (i * numChannels + ch) * destBytesPerSample;\n                    const sample = readFn(dataView, srcOffset);\n                    writeFn(destView, destOffset, sample);\n                }\n            }\n        }\n        else {\n            // src interleaved -> dest interleaved: copy all and convert\n            const data = new ArrayBuffer(copyFrameCount * numChannels * srcBytesPerSample);\n            const dataView = toDataView(data);\n            audioData.copyTo(data, {\n                planeIndex: 0,\n                frameOffset,\n                frameCount: copyFrameCount,\n                format: srcFormat,\n            });\n            for (let i = 0; i < copyFrameCount; i++) {\n                for (let ch = 0; ch < numChannels; ch++) {\n                    const idx = i * numChannels + ch;\n                    const srcOffset = idx * srcBytesPerSample;\n                    const destOffset = idx * destBytesPerSample;\n                    const sample = readFn(dataView, srcOffset);\n                    writeFn(destView, destOffset, sample);\n                }\n            }\n        }\n    }\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nexport const buildIsobmffMimeType = (info) => {\n    const base = info.hasVideo\n        ? 'video/'\n        : info.hasAudio\n            ? 'audio/'\n            : 'application/';\n    let string = base + (info.isQuickTime ? 'quicktime' : 'mp4');\n    if (info.codecStrings.length > 0) {\n        const uniqueCodecMimeTypes = [...new Set(info.codecStrings)];\n        string += `; codecs=\"${uniqueCodecMimeTypes.join(', ')}\"`;\n    }\n    return string;\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { RichImageData } from '../metadata.js';\nimport { textDecoder } from '../misc.js';\nimport { readAscii, readBytes, readI32Be, readU16Be, readU32Be, readU64Be, readU8 } from '../reader.js';\nexport const MIN_BOX_HEADER_SIZE = 8;\nexport const MAX_BOX_HEADER_SIZE = 16;\nexport const readBoxHeader = (slice) => {\n    let totalSize = readU32Be(slice);\n    const name = readAscii(slice, 4);\n    let headerSize = 8;\n    const hasLargeSize = totalSize === 1;\n    if (hasLargeSize) {\n        totalSize = readU64Be(slice);\n        headerSize = 16;\n    }\n    const contentSize = totalSize - headerSize;\n    if (contentSize < 0) {\n        return null; // Hardly a box is it\n    }\n    return { name, totalSize, headerSize, contentSize };\n};\nexport const readFixed_16_16 = (slice) => {\n    return readI32Be(slice) / 0x10000;\n};\nexport const readFixed_2_30 = (slice) => {\n    return readI32Be(slice) / 0x40000000;\n};\nexport const readIsomVariableInteger = (slice) => {\n    let result = 0;\n    for (let i = 0; i < 4; i++) {\n        result <<= 7;\n        const nextByte = readU8(slice);\n        result |= nextByte & 0x7f;\n        if ((nextByte & 0x80) === 0) {\n            break;\n        }\n    }\n    return result;\n};\nexport const readMetadataStringShort = (slice) => {\n    let stringLength = readU16Be(slice);\n    slice.skip(2); // Language\n    stringLength = Math.min(stringLength, slice.remainingLength);\n    return textDecoder.decode(readBytes(slice, stringLength));\n};\nexport const readDataBox = (slice) => {\n    const header = readBoxHeader(slice);\n    if (!header || header.name !== 'data') {\n        return null;\n    }\n    if (slice.remainingLength < 8) {\n        // Box is too small\n        return null;\n    }\n    const typeIndicator = readU32Be(slice);\n    slice.skip(4); // Locale indicator\n    const data = readBytes(slice, header.contentSize - 8);\n    switch (typeIndicator) {\n        case 1: return textDecoder.decode(data); // UTF-8\n        case 2: return new TextDecoder('utf-16be').decode(data); // UTF-16-BE\n        case 13: return new RichImageData(data, 'image/jpeg');\n        case 14: return new RichImageData(data, 'image/png');\n        case 27: return new RichImageData(data, 'image/bmp');\n        default: return data;\n    }\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { Bitstream } from '../misc.js';\nimport { readBytes } from '../reader.js';\nexport const MIN_ADTS_FRAME_HEADER_SIZE = 7;\nexport const MAX_ADTS_FRAME_HEADER_SIZE = 9;\nexport const readAdtsFrameHeader = (slice) => {\n    // https://wiki.multimedia.cx/index.php/ADTS (last visited: 2025/08/17)\n    const startPos = slice.filePos;\n    const bytes = readBytes(slice, 9); // 9 with CRC, 7 without CRC\n    const bitstream = new Bitstream(bytes);\n    const syncword = bitstream.readBits(12);\n    if (syncword !== 0b1111_11111111) {\n        return null;\n    }\n    bitstream.skipBits(1); // MPEG version\n    const layer = bitstream.readBits(2);\n    if (layer !== 0) {\n        return null;\n    }\n    const protectionAbsence = bitstream.readBits(1);\n    const objectType = bitstream.readBits(2) + 1;\n    const samplingFrequencyIndex = bitstream.readBits(4);\n    if (samplingFrequencyIndex === 15) {\n        return null;\n    }\n    bitstream.skipBits(1); // Private bit\n    const channelConfiguration = bitstream.readBits(3);\n    if (channelConfiguration === 0) {\n        throw new Error('ADTS frames with channel configuration 0 are not supported.');\n    }\n    bitstream.skipBits(1); // Originality\n    bitstream.skipBits(1); // Home\n    bitstream.skipBits(1); // Copyright ID bit\n    bitstream.skipBits(1); // Copyright ID start\n    const frameLength = bitstream.readBits(13);\n    bitstream.skipBits(11); // Buffer fullness\n    const numberOfAacFrames = bitstream.readBits(2) + 1;\n    if (numberOfAacFrames !== 1) {\n        throw new Error('ADTS frames with more than one AAC frame are not supported.');\n    }\n    let crcCheck = null;\n    if (protectionAbsence === 1) { // No CRC\n        slice.filePos -= 2;\n    }\n    else { // CRC\n        crcCheck = bitstream.readBits(16);\n    }\n    return {\n        objectType,\n        samplingFrequencyIndex,\n        channelConfiguration,\n        frameLength,\n        numberOfAacFrames,\n        crcCheck,\n        startPos,\n    };\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { InputDisposedError } from './input.js';\nimport { assert, clamp, getUint24, toDataView } from './misc.js';\nexport class Reader {\n    constructor(source) {\n        this.source = source;\n    }\n    requestSlice(start, length) {\n        if (this.source._disposed) {\n            throw new InputDisposedError();\n        }\n        if (start < 0) {\n            return null;\n        }\n        if (this.fileSize !== null && start + length > this.fileSize) {\n            return null;\n        }\n        const end = start + length;\n        const result = this.source._read(start, end);\n        if (result instanceof Promise) {\n            return result.then((x) => {\n                if (!x) {\n                    return null;\n                }\n                return new FileSlice(x.bytes, x.view, x.offset, start, end);\n            });\n        }\n        else {\n            if (!result) {\n                return null;\n            }\n            return new FileSlice(result.bytes, result.view, result.offset, start, end);\n        }\n    }\n    requestSliceRange(start, minLength, maxLength) {\n        if (this.source._disposed) {\n            throw new InputDisposedError();\n        }\n        if (start < 0) {\n            return null;\n        }\n        if (this.fileSize !== null) {\n            return this.requestSlice(start, clamp(this.fileSize - start, minLength, maxLength));\n        }\n        else {\n            const promisedAttempt = this.requestSlice(start, maxLength);\n            const handleAttempt = (attempt) => {\n                if (attempt) {\n                    return attempt;\n                }\n                const handleFileSize = (fileSize) => {\n                    assert(fileSize !== null); // The slice couldn't fit, meaning we must know the file size now\n                    return this.requestSlice(start, clamp(fileSize - start, minLength, maxLength));\n                };\n                const promisedFileSize = this.source._retrieveSize();\n                if (promisedFileSize instanceof Promise) {\n                    return promisedFileSize.then(handleFileSize);\n                }\n                else {\n                    return handleFileSize(promisedFileSize);\n                }\n            };\n            if (promisedAttempt instanceof Promise) {\n                return promisedAttempt.then(handleAttempt);\n            }\n            else {\n                return handleAttempt(promisedAttempt);\n            }\n        }\n    }\n}\nexport class FileSlice {\n    constructor(\n    /** The underlying bytes backing this slice. Avoid using this directly and prefer reader functions instead. */\n    bytes, \n    /** A view into the bytes backing this slice. Avoid using this directly and prefer reader functions instead. */\n    view, \n    /** The offset in \"file bytes\" at which `bytes` begins in the file. */\n    offset, \n    /** The offset in \"file bytes\" where this slice begins. */\n    start, \n    /** The offset in \"file bytes\" where this slice ends (exclusive). */\n    end) {\n        this.bytes = bytes;\n        this.view = view;\n        this.offset = offset;\n        this.start = start;\n        this.end = end;\n        this.bufferPos = start - offset;\n    }\n    static tempFromBytes(bytes) {\n        return new FileSlice(bytes, toDataView(bytes), 0, 0, bytes.length);\n    }\n    get length() {\n        return this.end - this.start;\n    }\n    get filePos() {\n        return this.offset + this.bufferPos;\n    }\n    set filePos(value) {\n        this.bufferPos = value - this.offset;\n    }\n    /** The number of bytes left from the current pos to the end of the slice. */\n    get remainingLength() {\n        return Math.max(this.end - this.filePos, 0);\n    }\n    skip(byteCount) {\n        this.bufferPos += byteCount;\n    }\n    /** Creates a new subslice of this slice whose byte range must be contained within this slice. */\n    slice(filePos, length = this.end - filePos) {\n        if (filePos < this.start || filePos + length > this.end) {\n            throw new RangeError('Slicing outside of original slice.');\n        }\n        return new FileSlice(this.bytes, this.view, this.offset, filePos, filePos + length);\n    }\n}\nconst checkIsInRange = (slice, bytesToRead) => {\n    if (slice.filePos < slice.start || slice.filePos + bytesToRead > slice.end) {\n        throw new RangeError(`Tried reading [${slice.filePos}, ${slice.filePos + bytesToRead}), but slice is`\n            + ` [${slice.start}, ${slice.end}). This is likely an internal error, please report it alongside the file`\n            + ` that caused it.`);\n    }\n};\nexport const readBytes = (slice, length) => {\n    checkIsInRange(slice, length);\n    const bytes = slice.bytes.subarray(slice.bufferPos, slice.bufferPos + length);\n    slice.bufferPos += length;\n    return bytes;\n};\nexport const readU8 = (slice) => {\n    checkIsInRange(slice, 1);\n    return slice.view.getUint8(slice.bufferPos++);\n};\nexport const readU16 = (slice, littleEndian) => {\n    checkIsInRange(slice, 2);\n    const value = slice.view.getUint16(slice.bufferPos, littleEndian);\n    slice.bufferPos += 2;\n    return value;\n};\nexport const readU16Be = (slice) => {\n    checkIsInRange(slice, 2);\n    const value = slice.view.getUint16(slice.bufferPos, false);\n    slice.bufferPos += 2;\n    return value;\n};\nexport const readU24Be = (slice) => {\n    checkIsInRange(slice, 3);\n    const value = getUint24(slice.view, slice.bufferPos, false);\n    slice.bufferPos += 3;\n    return value;\n};\nexport const readI16Be = (slice) => {\n    checkIsInRange(slice, 2);\n    const value = slice.view.getInt16(slice.bufferPos, false);\n    slice.bufferPos += 2;\n    return value;\n};\nexport const readU32 = (slice, littleEndian) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getUint32(slice.bufferPos, littleEndian);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readU32Be = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getUint32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readU32Le = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getUint32(slice.bufferPos, true);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readI32Be = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getInt32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readI32Le = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getInt32(slice.bufferPos, true);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readU64 = (slice, littleEndian) => {\n    let low;\n    let high;\n    if (littleEndian) {\n        low = readU32(slice, true);\n        high = readU32(slice, true);\n    }\n    else {\n        high = readU32(slice, false);\n        low = readU32(slice, false);\n    }\n    return high * 0x100000000 + low;\n};\nexport const readU64Be = (slice) => {\n    const high = readU32Be(slice);\n    const low = readU32Be(slice);\n    return high * 0x100000000 + low;\n};\nexport const readI64Be = (slice) => {\n    const high = readI32Be(slice);\n    const low = readU32Be(slice);\n    return high * 0x100000000 + low;\n};\nexport const readI64Le = (slice) => {\n    const low = readU32Le(slice);\n    const high = readI32Le(slice);\n    return high * 0x100000000 + low;\n};\nexport const readF32Be = (slice) => {\n    checkIsInRange(slice, 4);\n    const value = slice.view.getFloat32(slice.bufferPos, false);\n    slice.bufferPos += 4;\n    return value;\n};\nexport const readF64Be = (slice) => {\n    checkIsInRange(slice, 8);\n    const value = slice.view.getFloat64(slice.bufferPos, false);\n    slice.bufferPos += 8;\n    return value;\n};\nexport const readAscii = (slice, length) => {\n    checkIsInRange(slice, length);\n    let str = '';\n    for (let i = 0; i < length; i++) {\n        str += String.fromCharCode(slice.bytes[slice.bufferPos++]);\n    }\n    return str;\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AsyncMutex } from './misc.js';\nexport class Muxer {\n    constructor(output) {\n        this.mutex = new AsyncMutex();\n        /**\n         * This field is used to synchronize multiple MediaStreamTracks. They use the same time coordinate system across\n         * tracks, and to ensure correct audio-video sync, we must use the same offset for all of them. The reason an offset\n         * is needed at all is because the timestamps typically don't start at zero.\n         */\n        this.firstMediaStreamTimestamp = null;\n        this.trackTimestampInfo = new WeakMap();\n        this.output = output;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onTrackClose(track) { }\n    validateAndNormalizeTimestamp(track, timestampInSeconds, isKeyPacket) {\n        timestampInSeconds += track.source._timestampOffset;\n        let timestampInfo = this.trackTimestampInfo.get(track);\n        if (!timestampInfo) {\n            if (!isKeyPacket) {\n                throw new Error('First packet must be a key packet.');\n            }\n            timestampInfo = {\n                maxTimestamp: timestampInSeconds,\n                maxTimestampBeforeLastKeyPacket: timestampInSeconds,\n            };\n            this.trackTimestampInfo.set(track, timestampInfo);\n        }\n        if (timestampInSeconds < 0) {\n            throw new Error(`Timestamps must be non-negative (got ${timestampInSeconds}s).`);\n        }\n        if (isKeyPacket) {\n            timestampInfo.maxTimestampBeforeLastKeyPacket = timestampInfo.maxTimestamp;\n        }\n        if (timestampInSeconds < timestampInfo.maxTimestampBeforeLastKeyPacket) {\n            throw new Error(`Timestamps cannot be smaller than the largest timestamp of the previous GOP (a GOP begins with a key`\n                + ` packet and ends right before the next key packet). Got ${timestampInSeconds}s, but largest`\n                + ` timestamp is ${timestampInfo.maxTimestampBeforeLastKeyPacket}s.`);\n        }\n        timestampInfo.maxTimestamp = Math.max(timestampInfo.maxTimestamp, timestampInSeconds);\n        return timestampInSeconds;\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nconst cueBlockHeaderRegex = /(?:(.+?)\\n)?((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})\\s+-->\\s+((?:\\d{2}:)?\\d{2}:\\d{2}.\\d{3})/g;\nconst preambleStartRegex = /^WEBVTT(.|\\n)*?\\n{2}/;\nexport const inlineTimestampRegex = /<(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})>/g;\nexport class SubtitleParser {\n    constructor(options) {\n        this.preambleText = null;\n        this.preambleEmitted = false;\n        this.options = options;\n    }\n    parse(text) {\n        text = text.replaceAll('\\r\\n', '\\n').replaceAll('\\r', '\\n');\n        cueBlockHeaderRegex.lastIndex = 0;\n        let match;\n        if (!this.preambleText) {\n            if (!preambleStartRegex.test(text)) {\n                throw new Error('WebVTT preamble incorrect.');\n            }\n            match = cueBlockHeaderRegex.exec(text);\n            const preamble = text.slice(0, match?.index ?? text.length).trimEnd();\n            if (!preamble) {\n                throw new Error('No WebVTT preamble provided.');\n            }\n            this.preambleText = preamble;\n            if (match) {\n                text = text.slice(match.index);\n                cueBlockHeaderRegex.lastIndex = 0;\n            }\n        }\n        while ((match = cueBlockHeaderRegex.exec(text))) {\n            const notes = text.slice(0, match.index);\n            const cueIdentifier = match[1];\n            const matchEnd = match.index + match[0].length;\n            const bodyStart = text.indexOf('\\n', matchEnd) + 1;\n            const cueSettings = text.slice(matchEnd, bodyStart).trim();\n            let bodyEnd = text.indexOf('\\n\\n', matchEnd);\n            if (bodyEnd === -1)\n                bodyEnd = text.length;\n            const startTime = parseSubtitleTimestamp(match[2]);\n            const endTime = parseSubtitleTimestamp(match[3]);\n            const duration = endTime - startTime;\n            const body = text.slice(bodyStart, bodyEnd).trim();\n            text = text.slice(bodyEnd).trimStart();\n            cueBlockHeaderRegex.lastIndex = 0;\n            const cue = {\n                timestamp: startTime / 1000,\n                duration: duration / 1000,\n                text: body,\n                identifier: cueIdentifier,\n                settings: cueSettings,\n                notes,\n            };\n            const meta = {};\n            if (!this.preambleEmitted) {\n                meta.config = {\n                    description: this.preambleText,\n                };\n                this.preambleEmitted = true;\n            }\n            this.options.output(cue, meta);\n        }\n    }\n}\nconst timestampRegex = /(?:(\\d{2}):)?(\\d{2}):(\\d{2}).(\\d{3})/;\nexport const parseSubtitleTimestamp = (string) => {\n    const match = timestampRegex.exec(string);\n    if (!match)\n        throw new Error('Expected match.');\n    return 60 * 60 * 1000 * Number(match[1] || '0')\n        + 60 * 1000 * Number(match[2])\n        + 1000 * Number(match[3])\n        + Number(match[4]);\n};\nexport const formatSubtitleTimestamp = (timestamp) => {\n    const hours = Math.floor(timestamp / (60 * 60 * 1000));\n    const minutes = Math.floor((timestamp % (60 * 60 * 1000)) / (60 * 1000));\n    const seconds = Math.floor((timestamp % (60 * 1000)) / 1000);\n    const milliseconds = timestamp % 1000;\n    return hours.toString().padStart(2, '0') + ':'\n        + minutes.toString().padStart(2, '0') + ':'\n        + seconds.toString().padStart(2, '0') + '.'\n        + milliseconds.toString().padStart(3, '0');\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { toUint8Array, assert, isU32, last, textEncoder, COLOR_PRIMARIES_MAP, TRANSFER_CHARACTERISTICS_MAP, MATRIX_COEFFICIENTS_MAP, colorSpaceIsComplete, UNDETERMINED_LANGUAGE, assertNever, keyValueIterator, } from '../misc.js';\nimport { generateAv1CodecConfigurationFromCodecString, parsePcmCodec, PCM_AUDIO_CODECS, } from '../codec.js';\nimport { formatSubtitleTimestamp } from '../subtitles.js';\nimport { getTrackMetadata, GLOBAL_TIMESCALE, intoTimescale, } from './isobmff-muxer.js';\nimport { parseOpusIdentificationHeader } from '../codec-data.js';\nimport { RichImageData } from '../metadata.js';\nexport class IsobmffBoxWriter {\n    constructor(writer) {\n        this.writer = writer;\n        this.helper = new Uint8Array(8);\n        this.helperView = new DataView(this.helper.buffer);\n        /**\n         * Stores the position from the start of the file to where boxes elements have been written. This is used to\n         * rewrite/edit elements that were already added before, and to measure sizes of things.\n         */\n        this.offsets = new WeakMap();\n    }\n    writeU32(value) {\n        this.helperView.setUint32(0, value, false);\n        this.writer.write(this.helper.subarray(0, 4));\n    }\n    writeU64(value) {\n        this.helperView.setUint32(0, Math.floor(value / 2 ** 32), false);\n        this.helperView.setUint32(4, value, false);\n        this.writer.write(this.helper.subarray(0, 8));\n    }\n    writeAscii(text) {\n        for (let i = 0; i < text.length; i++) {\n            this.helperView.setUint8(i % 8, text.charCodeAt(i));\n            if (i % 8 === 7)\n                this.writer.write(this.helper);\n        }\n        if (text.length % 8 !== 0) {\n            this.writer.write(this.helper.subarray(0, text.length % 8));\n        }\n    }\n    writeBox(box) {\n        this.offsets.set(box, this.writer.getPos());\n        if (box.contents && !box.children) {\n            this.writeBoxHeader(box, box.size ?? box.contents.byteLength + 8);\n            this.writer.write(box.contents);\n        }\n        else {\n            const startPos = this.writer.getPos();\n            this.writeBoxHeader(box, 0);\n            if (box.contents)\n                this.writer.write(box.contents);\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        this.writeBox(child);\n            const endPos = this.writer.getPos();\n            const size = box.size ?? endPos - startPos;\n            this.writer.seek(startPos);\n            this.writeBoxHeader(box, size);\n            this.writer.seek(endPos);\n        }\n    }\n    writeBoxHeader(box, size) {\n        this.writeU32(box.largeSize ? 1 : size);\n        this.writeAscii(box.type);\n        if (box.largeSize)\n            this.writeU64(size);\n    }\n    measureBoxHeader(box) {\n        return 8 + (box.largeSize ? 8 : 0);\n    }\n    patchBox(box) {\n        const boxOffset = this.offsets.get(box);\n        assert(boxOffset !== undefined);\n        const endPos = this.writer.getPos();\n        this.writer.seek(boxOffset);\n        this.writeBox(box);\n        this.writer.seek(endPos);\n    }\n    measureBox(box) {\n        if (box.contents && !box.children) {\n            const headerSize = this.measureBoxHeader(box);\n            return headerSize + box.contents.byteLength;\n        }\n        else {\n            let result = this.measureBoxHeader(box);\n            if (box.contents)\n                result += box.contents.byteLength;\n            if (box.children)\n                for (const child of box.children)\n                    if (child)\n                        result += this.measureBox(child);\n            return result;\n        }\n    }\n}\nconst bytes = /* #__PURE__ */ new Uint8Array(8);\nconst view = /* #__PURE__ */ new DataView(bytes.buffer);\nconst u8 = (value) => {\n    return [(value % 0x100 + 0x100) % 0x100];\n};\nconst u16 = (value) => {\n    view.setUint16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst i16 = (value) => {\n    view.setInt16(0, value, false);\n    return [bytes[0], bytes[1]];\n};\nconst u24 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[1], bytes[2], bytes[3]];\n};\nconst u32 = (value) => {\n    view.setUint32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst i32 = (value) => {\n    view.setInt32(0, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst u64 = (value) => {\n    view.setUint32(0, Math.floor(value / 2 ** 32), false);\n    view.setUint32(4, value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3], bytes[4], bytes[5], bytes[6], bytes[7]];\n};\nconst fixed_8_8 = (value) => {\n    view.setInt16(0, 2 ** 8 * value, false);\n    return [bytes[0], bytes[1]];\n};\nconst fixed_16_16 = (value) => {\n    view.setInt32(0, 2 ** 16 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst fixed_2_30 = (value) => {\n    view.setInt32(0, 2 ** 30 * value, false);\n    return [bytes[0], bytes[1], bytes[2], bytes[3]];\n};\nconst variableUnsignedInt = (value, byteLength) => {\n    const bytes = [];\n    let remaining = value;\n    do {\n        let byte = remaining & 0x7f;\n        remaining >>= 7;\n        // If this isn't the first byte we're adding (meaning there will be more bytes after it\n        // when we reverse the array), set the continuation bit\n        if (bytes.length > 0) {\n            byte |= 0x80;\n        }\n        bytes.push(byte);\n        if (byteLength !== undefined) {\n            byteLength--;\n        }\n    } while (remaining > 0 || byteLength);\n    // Reverse the array since we built it backwards\n    return bytes.reverse();\n};\nconst ascii = (text, nullTerminated = false) => {\n    const bytes = Array(text.length).fill(null).map((_, i) => text.charCodeAt(i));\n    if (nullTerminated)\n        bytes.push(0x00);\n    return bytes;\n};\nconst lastPresentedSample = (samples) => {\n    let result = null;\n    for (const sample of samples) {\n        if (!result || sample.timestamp > result.timestamp) {\n            result = sample;\n        }\n    }\n    return result;\n};\nconst rotationMatrix = (rotationInDegrees) => {\n    const theta = rotationInDegrees * (Math.PI / 180);\n    const cosTheta = Math.round(Math.cos(theta));\n    const sinTheta = Math.round(Math.sin(theta));\n    // Matrices are post-multiplied in ISOBMFF, meaning this is the transpose of your typical rotation matrix\n    return [\n        cosTheta, sinTheta, 0,\n        -sinTheta, cosTheta, 0,\n        0, 0, 1,\n    ];\n};\nconst IDENTITY_MATRIX = /* #__PURE__ */ rotationMatrix(0);\nconst matrixToBytes = (matrix) => {\n    return [\n        fixed_16_16(matrix[0]), fixed_16_16(matrix[1]), fixed_2_30(matrix[2]),\n        fixed_16_16(matrix[3]), fixed_16_16(matrix[4]), fixed_2_30(matrix[5]),\n        fixed_16_16(matrix[6]), fixed_16_16(matrix[7]), fixed_2_30(matrix[8]),\n    ];\n};\nexport const box = (type, contents, children) => ({\n    type,\n    contents: contents && new Uint8Array(contents.flat(10)),\n    children,\n});\n/** A FullBox always starts with a version byte, followed by three flag bytes. */\nexport const fullBox = (type, version, flags, contents, children) => box(type, [u8(version), u24(flags), contents ?? []], children);\n/**\n * File Type Compatibility Box: Allows the reader to determine whether this is a type of file that the\n * reader understands.\n */\nexport const ftyp = (details) => {\n    // You can find the full logic for this at\n    // https://github.com/FFmpeg/FFmpeg/blob/de2fb43e785773738c660cdafb9309b1ef1bc80d/libavformat/movenc.c#L5518\n    // Obviously, this lib only needs a small subset of that logic.\n    const minorVersion = 0x200;\n    if (details.isQuickTime) {\n        return box('ftyp', [\n            ascii('qt  '), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('qt  '),\n        ]);\n    }\n    if (details.fragmented) {\n        return box('ftyp', [\n            ascii('iso5'), // Major brand\n            u32(minorVersion), // Minor version\n            // Compatible brands\n            ascii('iso5'),\n            ascii('iso6'),\n            ascii('mp41'),\n        ]);\n    }\n    return box('ftyp', [\n        ascii('isom'), // Major brand\n        u32(minorVersion), // Minor version\n        // Compatible brands\n        ascii('isom'),\n        details.holdsAvc ? ascii('avc1') : [],\n        ascii('mp41'),\n    ]);\n};\n/** Movie Sample Data Box. Contains the actual frames/samples of the media. */\nexport const mdat = (reserveLargeSize) => ({ type: 'mdat', largeSize: reserveLargeSize });\n/** Free Space Box: A box that designates unused space in the movie data file. */\nexport const free = (size) => ({ type: 'free', size });\n/**\n * Movie Box: Used to specify the information that defines a movie - that is, the information that allows\n * an application to interpret the sample data that is stored elsewhere.\n */\nexport const moov = (muxer) => box('moov', undefined, [\n    mvhd(muxer.creationTime, muxer.trackDatas),\n    ...muxer.trackDatas.map(x => trak(x, muxer.creationTime)),\n    muxer.isFragmented ? mvex(muxer.trackDatas) : null,\n    udta(muxer),\n]);\n/** Movie Header Box: Used to specify the characteristics of the entire movie, such as timescale and duration. */\nexport const mvhd = (creationTime, trackDatas) => {\n    const duration = intoTimescale(Math.max(0, ...trackDatas\n        .filter(x => x.samples.length > 0)\n        .map((x) => {\n        const lastSample = lastPresentedSample(x.samples);\n        return lastSample.timestamp + lastSample.duration;\n    })), GLOBAL_TIMESCALE);\n    const nextTrackId = Math.max(0, ...trackDatas.map(x => x.track.id)) + 1;\n    // Conditionally use u64 if u32 isn't enough\n    const needsU64 = !isU32(creationTime) || !isU32(duration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    return fullBox('mvhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(GLOBAL_TIMESCALE), // Timescale\n        u32OrU64(duration), // Duration\n        fixed_16_16(1), // Preferred rate\n        fixed_8_8(1), // Preferred volume\n        Array(10).fill(0), // Reserved\n        matrixToBytes(IDENTITY_MATRIX), // Matrix\n        Array(24).fill(0), // Pre-defined\n        u32(nextTrackId), // Next track ID\n    ]);\n};\n/**\n * Track Box: Defines a single track of a movie. A movie may consist of one or more tracks. Each track is\n * independent of the other tracks in the movie and carries its own temporal and spatial information. Each Track Box\n * contains its associated Media Box.\n */\nexport const trak = (trackData, creationTime) => {\n    const trackMetadata = getTrackMetadata(trackData);\n    return box('trak', undefined, [\n        tkhd(trackData, creationTime),\n        mdia(trackData, creationTime),\n        trackMetadata.name !== undefined\n            ? box('udta', undefined, [\n                box('name', [\n                    ...textEncoder.encode(trackMetadata.name),\n                ]),\n            ])\n            : null,\n    ]);\n};\n/** Track Header Box: Specifies the characteristics of a single track within a movie. */\nexport const tkhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const durationInGlobalTimescale = intoTimescale(lastSample ? lastSample.timestamp + lastSample.duration : 0, GLOBAL_TIMESCALE);\n    const needsU64 = !isU32(creationTime) || !isU32(durationInGlobalTimescale);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    let matrix;\n    if (trackData.type === 'video') {\n        const rotation = trackData.track.metadata.rotation;\n        matrix = rotationMatrix(rotation ?? 0);\n    }\n    else {\n        matrix = IDENTITY_MATRIX;\n    }\n    let flags = 0x2; // Track in movie\n    if (trackData.track.metadata.disposition?.default !== false) {\n        flags |= 0x1; // Track enabled\n    }\n    return fullBox('tkhd', +needsU64, flags, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.track.id), // Track ID\n        u32(0), // Reserved\n        u32OrU64(durationInGlobalTimescale), // Duration\n        Array(8).fill(0), // Reserved\n        u16(0), // Layer\n        u16(trackData.track.id), // Alternate group\n        fixed_8_8(trackData.type === 'audio' ? 1 : 0), // Volume\n        u16(0), // Reserved\n        matrixToBytes(matrix), // Matrix\n        fixed_16_16(trackData.type === 'video' ? trackData.info.width : 0), // Track width\n        fixed_16_16(trackData.type === 'video' ? trackData.info.height : 0), // Track height\n    ]);\n};\n/** Media Box: Describes and define a track's media type and sample data. */\nexport const mdia = (trackData, creationTime) => box('mdia', undefined, [\n    mdhd(trackData, creationTime),\n    hdlr(true, TRACK_TYPE_TO_COMPONENT_SUBTYPE[trackData.type], TRACK_TYPE_TO_HANDLER_NAME[trackData.type]),\n    minf(trackData),\n]);\n/** Media Header Box: Specifies the characteristics of a media, including timescale and duration. */\nexport const mdhd = (trackData, creationTime) => {\n    const lastSample = lastPresentedSample(trackData.samples);\n    const localDuration = intoTimescale(lastSample ? lastSample.timestamp + lastSample.duration : 0, trackData.timescale);\n    const needsU64 = !isU32(creationTime) || !isU32(localDuration);\n    const u32OrU64 = needsU64 ? u64 : u32;\n    return fullBox('mdhd', +needsU64, 0, [\n        u32OrU64(creationTime), // Creation time\n        u32OrU64(creationTime), // Modification time\n        u32(trackData.timescale), // Timescale\n        u32OrU64(localDuration), // Duration\n        u16(getLanguageCodeInt(trackData.track.metadata.languageCode ?? UNDETERMINED_LANGUAGE)), // Language\n        u16(0), // Quality\n    ]);\n};\nconst TRACK_TYPE_TO_COMPONENT_SUBTYPE = {\n    video: 'vide',\n    audio: 'soun',\n    subtitle: 'text',\n};\nconst TRACK_TYPE_TO_HANDLER_NAME = {\n    video: 'MediabunnyVideoHandler',\n    audio: 'MediabunnySoundHandler',\n    subtitle: 'MediabunnyTextHandler',\n};\n/** Handler Reference Box. */\nexport const hdlr = (hasComponentType, handlerType, name, manufacturer = '\\0\\0\\0\\0') => fullBox('hdlr', 0, 0, [\n    hasComponentType ? ascii('mhlr') : u32(0), // Component type\n    ascii(handlerType), // Component subtype\n    ascii(manufacturer), // Component manufacturer\n    u32(0), // Component flags\n    u32(0), // Component flags mask\n    ascii(name, true), // Component name\n]);\n/**\n * Media Information Box: Stores handler-specific information for a track's media data. The media handler uses this\n * information to map from media time to media data and to process the media data.\n */\nexport const minf = (trackData) => box('minf', undefined, [\n    TRACK_TYPE_TO_HEADER_BOX[trackData.type](),\n    dinf(),\n    stbl(trackData),\n]);\n/** Video Media Information Header Box: Defines specific color and graphics mode information. */\nexport const vmhd = () => fullBox('vmhd', 0, 1, [\n    u16(0), // Graphics mode\n    u16(0), // Opcolor R\n    u16(0), // Opcolor G\n    u16(0), // Opcolor B\n]);\n/** Sound Media Information Header Box: Stores the sound media's control information, such as balance. */\nexport const smhd = () => fullBox('smhd', 0, 0, [\n    u16(0), // Balance\n    u16(0), // Reserved\n]);\n/** Null Media Header Box. */\nexport const nmhd = () => fullBox('nmhd', 0, 0);\nconst TRACK_TYPE_TO_HEADER_BOX = {\n    video: vmhd,\n    audio: smhd,\n    subtitle: nmhd,\n};\n/**\n * Data Information Box: Contains information specifying the data handler component that provides access to the\n * media data. The data handler component uses the Data Information Box to interpret the media's data.\n */\nexport const dinf = () => box('dinf', undefined, [\n    dref(),\n]);\n/**\n * Data Reference Box: Contains tabular data that instructs the data handler component how to access the media's data.\n */\nexport const dref = () => fullBox('dref', 0, 0, [\n    u32(1), // Entry count\n], [\n    url(),\n]);\nexport const url = () => fullBox('url ', 0, 1); // Self-reference flag enabled\n/**\n * Sample Table Box: Contains information for converting from media time to sample number to sample location. This box\n * also indicates how to interpret the sample (for example, whether to decompress the video data and, if so, how).\n */\nexport const stbl = (trackData) => {\n    const needsCtts = trackData.compositionTimeOffsetTable.length > 1\n        || trackData.compositionTimeOffsetTable.some(x => x.sampleCompositionTimeOffset !== 0);\n    return box('stbl', undefined, [\n        stsd(trackData),\n        stts(trackData),\n        needsCtts ? ctts(trackData) : null,\n        needsCtts ? cslg(trackData) : null,\n        stsc(trackData),\n        stsz(trackData),\n        stco(trackData),\n        stss(trackData),\n    ]);\n};\n/**\n * Sample Description Box: Stores information that allows you to decode samples in the media. The data stored in the\n * sample description varies, depending on the media type.\n */\nexport const stsd = (trackData) => {\n    let sampleDescription;\n    if (trackData.type === 'video') {\n        sampleDescription = videoSampleDescription(videoCodecToBoxName(trackData.track.source._codec, trackData.info.decoderConfig.codec), trackData);\n    }\n    else if (trackData.type === 'audio') {\n        const boxName = audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime);\n        assert(boxName);\n        sampleDescription = soundSampleDescription(boxName, trackData);\n    }\n    else if (trackData.type === 'subtitle') {\n        sampleDescription = subtitleSampleDescription(SUBTITLE_CODEC_TO_BOX_NAME[trackData.track.source._codec], trackData);\n    }\n    assert(sampleDescription);\n    return fullBox('stsd', 0, 0, [\n        u32(1), // Entry count\n    ], [\n        sampleDescription,\n    ]);\n};\n/** Video Sample Description Box: Contains information that defines how to interpret video media data. */\nexport const videoSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n    u16(0), // Pre-defined\n    u16(0), // Reserved\n    Array(12).fill(0), // Pre-defined\n    u16(trackData.info.width), // Width\n    u16(trackData.info.height), // Height\n    u32(0x00480000), // Horizontal resolution\n    u32(0x00480000), // Vertical resolution\n    u32(0), // Reserved\n    u16(1), // Frame count\n    Array(32).fill(0), // Compressor name\n    u16(0x0018), // Depth\n    i16(0xffff), // Pre-defined\n], [\n    VIDEO_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n    colorSpaceIsComplete(trackData.info.decoderConfig.colorSpace) ? colr(trackData) : null,\n]);\n/** Colour Information Box: Specifies the color space of the video. */\nexport const colr = (trackData) => box('colr', [\n    ascii('nclx'), // Colour type\n    u16(COLOR_PRIMARIES_MAP[trackData.info.decoderConfig.colorSpace.primaries]), // Colour primaries\n    u16(TRANSFER_CHARACTERISTICS_MAP[trackData.info.decoderConfig.colorSpace.transfer]), // Transfer characteristics\n    u16(MATRIX_COEFFICIENTS_MAP[trackData.info.decoderConfig.colorSpace.matrix]), // Matrix coefficients\n    u8((trackData.info.decoderConfig.colorSpace.fullRange ? 1 : 0) << 7), // Full range flag\n]);\n/** AVC Configuration Box: Provides additional information to the decoder. */\nexport const avcC = (trackData) => trackData.info.decoderConfig && box('avcC', [\n    // For AVC, description is an AVCDecoderConfigurationRecord, so nothing else to do here\n    ...toUint8Array(trackData.info.decoderConfig.description),\n]);\n/** HEVC Configuration Box: Provides additional information to the decoder. */\nexport const hvcC = (trackData) => trackData.info.decoderConfig && box('hvcC', [\n    // For HEVC, description is an HEVCDecoderConfigurationRecord, so nothing else to do here\n    ...toUint8Array(trackData.info.decoderConfig.description),\n]);\n/** VP Configuration Box: Provides additional information to the decoder. */\nexport const vpcC = (trackData) => {\n    // Reference: https://www.webmproject.org/vp9/mp4/\n    if (!trackData.info.decoderConfig) {\n        return null;\n    }\n    const decoderConfig = trackData.info.decoderConfig;\n    const parts = decoderConfig.codec.split('.'); // We can derive the required values from the codec string\n    const profile = Number(parts[1]);\n    const level = Number(parts[2]);\n    const bitDepth = Number(parts[3]);\n    const chromaSubsampling = parts[4] ? Number(parts[4]) : 1; // 4:2:0 colocated with luma (0,0)\n    const videoFullRangeFlag = parts[8] ? Number(parts[8]) : Number(decoderConfig.colorSpace?.fullRange ?? 0);\n    const thirdByte = (bitDepth << 4) + (chromaSubsampling << 1) + videoFullRangeFlag;\n    const colourPrimaries = parts[5]\n        ? Number(parts[5])\n        : decoderConfig.colorSpace?.primaries\n            ? COLOR_PRIMARIES_MAP[decoderConfig.colorSpace.primaries]\n            : 2; // Default to undetermined\n    const transferCharacteristics = parts[6]\n        ? Number(parts[6])\n        : decoderConfig.colorSpace?.transfer\n            ? TRANSFER_CHARACTERISTICS_MAP[decoderConfig.colorSpace.transfer]\n            : 2;\n    const matrixCoefficients = parts[7]\n        ? Number(parts[7])\n        : decoderConfig.colorSpace?.matrix\n            ? MATRIX_COEFFICIENTS_MAP[decoderConfig.colorSpace.matrix]\n            : 2;\n    return fullBox('vpcC', 1, 0, [\n        u8(profile), // Profile\n        u8(level), // Level\n        u8(thirdByte), // Bit depth, chroma subsampling, full range\n        u8(colourPrimaries), // Colour primaries\n        u8(transferCharacteristics), // Transfer characteristics\n        u8(matrixCoefficients), // Matrix coefficients\n        u16(0), // Codec initialization data size\n    ]);\n};\n/** AV1 Configuration Box: Provides additional information to the decoder. */\nexport const av1C = (trackData) => {\n    return box('av1C', generateAv1CodecConfigurationFromCodecString(trackData.info.decoderConfig.codec));\n};\n/** Sound Sample Description Box: Contains information that defines how to interpret sound media data. */\nexport const soundSampleDescription = (compressionType, trackData) => {\n    let version = 0;\n    let contents;\n    let sampleSizeInBits = 16;\n    if (PCM_AUDIO_CODECS.includes(trackData.track.source._codec)) {\n        const codec = trackData.track.source._codec;\n        const { sampleSize } = parsePcmCodec(codec);\n        sampleSizeInBits = 8 * sampleSize;\n        if (sampleSizeInBits > 16) {\n            version = 1;\n        }\n    }\n    if (version === 0) {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(sampleSizeInBits), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n        ];\n    }\n    else {\n        contents = [\n            Array(6).fill(0), // Reserved\n            u16(1), // Data reference index\n            u16(version), // Version\n            u16(0), // Revision level\n            u32(0), // Vendor\n            u16(trackData.info.numberOfChannels), // Number of channels\n            u16(Math.min(sampleSizeInBits, 16)), // Sample size (bits)\n            u16(0), // Compression ID\n            u16(0), // Packet size\n            u16(trackData.info.sampleRate < 2 ** 16 ? trackData.info.sampleRate : 0), // Sample rate (upper)\n            u16(0), // Sample rate (lower)\n            u32(1), // Samples per packet (must be 1 for uncompressed formats)\n            u32(sampleSizeInBits / 8), // Bytes per packet\n            u32(trackData.info.numberOfChannels * sampleSizeInBits / 8), // Bytes per frame\n            u32(2), // Bytes per sample (constant in FFmpeg)\n        ];\n    }\n    return box(compressionType, contents, [\n        audioCodecToConfigurationBox(trackData.track.source._codec, trackData.muxer.isQuickTime)?.(trackData) ?? null,\n    ]);\n};\n/** MPEG-4 Elementary Stream Descriptor Box. */\nexport const esds = (trackData) => {\n    // We build up the bytes in a layered way which reflects the nested structure\n    let objectTypeIndication;\n    switch (trackData.track.source._codec) {\n        case 'aac':\n            {\n                objectTypeIndication = 0x40;\n            }\n            ;\n            break;\n        case 'mp3':\n            {\n                objectTypeIndication = 0x6b;\n            }\n            ;\n            break;\n        case 'vorbis':\n            {\n                objectTypeIndication = 0xdd;\n            }\n            ;\n            break;\n        default: throw new Error(`Unhandled audio codec: ${trackData.track.source._codec}`);\n    }\n    let bytes = [\n        ...u8(objectTypeIndication), // Object type indication\n        ...u8(0x15), // stream type(6bits)=5 audio, flags(2bits)=1\n        ...u24(0), // 24bit buffer size\n        ...u32(0), // max bitrate\n        ...u32(0), // avg bitrate\n    ];\n    if (trackData.info.decoderConfig.description) {\n        const description = toUint8Array(trackData.info.decoderConfig.description);\n        // Add the decoder description to the end\n        bytes = [\n            ...bytes,\n            ...u8(0x05), // TAG(5) = DecoderSpecificInfo\n            ...variableUnsignedInt(description.byteLength),\n            ...description,\n        ];\n    }\n    bytes = [\n        ...u16(1), // ES_ID = 1\n        ...u8(0x00), // flags etc = 0\n        ...u8(0x04), // TAG(4) = ES Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n        ...u8(0x06), // TAG(6)\n        ...u8(0x01), // length\n        ...u8(0x02), // data\n    ];\n    bytes = [\n        ...u8(0x03), // TAG(3) = Object Descriptor\n        ...variableUnsignedInt(bytes.length),\n        ...bytes,\n    ];\n    return fullBox('esds', 0, 0, bytes);\n};\nexport const wave = (trackData) => {\n    return box('wave', undefined, [\n        frma(trackData),\n        enda(trackData),\n        box('\\x00\\x00\\x00\\x00'), // NULL tag at the end\n    ]);\n};\nexport const frma = (trackData) => {\n    return box('frma', [\n        ascii(audioCodecToBoxName(trackData.track.source._codec, trackData.muxer.isQuickTime)),\n    ]);\n};\n// This box specifies PCM endianness\nexport const enda = (trackData) => {\n    const { littleEndian } = parsePcmCodec(trackData.track.source._codec);\n    return box('enda', [\n        u16(+littleEndian),\n    ]);\n};\n/** Opus Specific Box. */\nexport const dOps = (trackData) => {\n    let outputChannelCount = trackData.info.numberOfChannels;\n    // Default PreSkip, should be at least 80 milliseconds worth of playback, measured in 48000 Hz samples\n    let preSkip = 3840;\n    let inputSampleRate = trackData.info.sampleRate;\n    let outputGain = 0;\n    let channelMappingFamily = 0;\n    let channelMappingTable = new Uint8Array(0);\n    // Read preskip and from codec private data from the encoder\n    // https://www.rfc-editor.org/rfc/rfc7845#section-5\n    const description = trackData.info.decoderConfig?.description;\n    if (description) {\n        assert(description.byteLength >= 18);\n        const bytes = toUint8Array(description);\n        const header = parseOpusIdentificationHeader(bytes);\n        outputChannelCount = header.outputChannelCount;\n        preSkip = header.preSkip;\n        inputSampleRate = header.inputSampleRate;\n        outputGain = header.outputGain;\n        channelMappingFamily = header.channelMappingFamily;\n        if (header.channelMappingTable) {\n            channelMappingTable = header.channelMappingTable;\n        }\n    }\n    // https://www.opus-codec.org/docs/opus_in_isobmff.html\n    return box('dOps', [\n        u8(0), // Version\n        u8(outputChannelCount), // OutputChannelCount\n        u16(preSkip), // PreSkip\n        u32(inputSampleRate), // InputSampleRate\n        i16(outputGain), // OutputGain\n        u8(channelMappingFamily), // ChannelMappingFamily\n        ...channelMappingTable,\n    ]);\n};\n/** FLAC specific box. */\nexport const dfLa = (trackData) => {\n    const description = trackData.info.decoderConfig?.description;\n    assert(description);\n    const bytes = toUint8Array(description);\n    return fullBox('dfLa', 0, 0, [\n        ...bytes.subarray(4),\n    ]);\n};\n/** PCM Configuration Box, ISO/IEC 23003-5. */\nconst pcmC = (trackData) => {\n    const { littleEndian, sampleSize } = parsePcmCodec(trackData.track.source._codec);\n    const formatFlags = +littleEndian;\n    return fullBox('pcmC', 0, 0, [\n        u8(formatFlags),\n        u8(8 * sampleSize),\n    ]);\n};\nexport const subtitleSampleDescription = (compressionType, trackData) => box(compressionType, [\n    Array(6).fill(0), // Reserved\n    u16(1), // Data reference index\n], [\n    SUBTITLE_CODEC_TO_CONFIGURATION_BOX[trackData.track.source._codec](trackData),\n]);\nexport const vttC = (trackData) => box('vttC', [\n    ...textEncoder.encode(trackData.info.config.description),\n]);\nexport const txtC = (textConfig) => fullBox('txtC', 0, 0, [\n    ...textConfig, 0, // Text config (null-terminated)\n]);\n/**\n * Time-To-Sample Box: Stores duration information for a media's samples, providing a mapping from a time in a media\n * to the corresponding data sample. The table is compact, meaning that consecutive samples with the same time delta\n * will be grouped.\n */\nexport const stts = (trackData) => {\n    return fullBox('stts', 0, 0, [\n        u32(trackData.timeToSampleTable.length), // Number of entries\n        trackData.timeToSampleTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            u32(x.sampleDelta), // Sample duration\n        ]),\n    ]);\n};\n/** Sync Sample Box: Identifies the key frames in the media, marking the random access points within a stream. */\nexport const stss = (trackData) => {\n    if (trackData.samples.every(x => x.type === 'key'))\n        return null; // No stss box -> every frame is a key frame\n    const keySamples = [...trackData.samples.entries()].filter(([, sample]) => sample.type === 'key');\n    return fullBox('stss', 0, 0, [\n        u32(keySamples.length), // Number of entries\n        keySamples.map(([index]) => u32(index + 1)), // Sync sample table\n    ]);\n};\n/**\n * Sample-To-Chunk Box: As samples are added to a media, they are collected into chunks that allow optimized data\n * access. A chunk contains one or more samples. Chunks in a media may have different sizes, and the samples within a\n * chunk may have different sizes. The Sample-To-Chunk Box stores chunk information for the samples in a media, stored\n * in a compactly-coded fashion.\n */\nexport const stsc = (trackData) => {\n    return fullBox('stsc', 0, 0, [\n        u32(trackData.compactlyCodedChunkTable.length), // Number of entries\n        trackData.compactlyCodedChunkTable.map(x => [\n            u32(x.firstChunk), // First chunk\n            u32(x.samplesPerChunk), // Samples per chunk\n            u32(1), // Sample description index\n        ]),\n    ]);\n};\n/** Sample Size Box: Specifies the byte size of each sample in the media. */\nexport const stsz = (trackData) => {\n    if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n        const { sampleSize } = parsePcmCodec(trackData.track.source._codec);\n        // With PCM, every sample has the same size\n        return fullBox('stsz', 0, 0, [\n            u32(sampleSize * trackData.info.numberOfChannels), // Sample size\n            u32(trackData.samples.reduce((acc, x) => acc + intoTimescale(x.duration, trackData.timescale), 0)),\n        ]);\n    }\n    return fullBox('stsz', 0, 0, [\n        u32(0), // Sample size (0 means non-constant size)\n        u32(trackData.samples.length), // Number of entries\n        trackData.samples.map(x => u32(x.size)), // Sample size table\n    ]);\n};\n/** Chunk Offset Box: Identifies the location of each chunk of data in the media's data stream, relative to the file. */\nexport const stco = (trackData) => {\n    if (trackData.finalizedChunks.length > 0 && last(trackData.finalizedChunks).offset >= 2 ** 32) {\n        // If the file is large, use the co64 box\n        return fullBox('co64', 0, 0, [\n            u32(trackData.finalizedChunks.length), // Number of entries\n            trackData.finalizedChunks.map(x => u64(x.offset)), // Chunk offset table\n        ]);\n    }\n    return fullBox('stco', 0, 0, [\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(x => u32(x.offset)), // Chunk offset table\n    ]);\n};\n/**\n * Composition Time to Sample Box: Stores composition time offset information (PTS-DTS) for a\n * media's samples. The table is compact, meaning that consecutive samples with the same time\n * composition time offset will be grouped.\n */\nexport const ctts = (trackData) => {\n    return fullBox('ctts', 1, 0, [\n        u32(trackData.compositionTimeOffsetTable.length), // Number of entries\n        trackData.compositionTimeOffsetTable.map(x => [\n            u32(x.sampleCount), // Sample count\n            i32(x.sampleCompositionTimeOffset), // Sample offset\n        ]),\n    ]);\n};\n/**\n * Composition to Decode Box: Stores information about the composition and display times of the media samples.\n */\nexport const cslg = (trackData) => {\n    let leastDecodeToDisplayDelta = Infinity;\n    let greatestDecodeToDisplayDelta = -Infinity;\n    let compositionStartTime = Infinity;\n    let compositionEndTime = -Infinity;\n    assert(trackData.compositionTimeOffsetTable.length > 0);\n    assert(trackData.samples.length > 0);\n    for (let i = 0; i < trackData.compositionTimeOffsetTable.length; i++) {\n        const entry = trackData.compositionTimeOffsetTable[i];\n        leastDecodeToDisplayDelta = Math.min(leastDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n        greatestDecodeToDisplayDelta = Math.max(greatestDecodeToDisplayDelta, entry.sampleCompositionTimeOffset);\n    }\n    for (let i = 0; i < trackData.samples.length; i++) {\n        const sample = trackData.samples[i];\n        compositionStartTime = Math.min(compositionStartTime, intoTimescale(sample.timestamp, trackData.timescale));\n        compositionEndTime = Math.max(compositionEndTime, intoTimescale(sample.timestamp + sample.duration, trackData.timescale));\n    }\n    const compositionToDtsShift = Math.max(-leastDecodeToDisplayDelta, 0);\n    if (compositionEndTime >= 2 ** 31) {\n        // For very large files, the composition end time can't be represented in i32, so let's just scrap the box in\n        // that case. QuickTime fails to read the file if there's a cslg box with version 1, so that's sadly not an\n        // option.\n        return null;\n    }\n    return fullBox('cslg', 0, 0, [\n        i32(compositionToDtsShift), // Composition to DTS shift\n        i32(leastDecodeToDisplayDelta), // Least decode to display delta\n        i32(greatestDecodeToDisplayDelta), // Greatest decode to display delta\n        i32(compositionStartTime), // Composition start time\n        i32(compositionEndTime), // Composition end time\n    ]);\n};\n/**\n * Movie Extends Box: This box signals to readers that the file is fragmented. Contains a single Track Extends Box\n * for each track in the movie.\n */\nexport const mvex = (trackDatas) => {\n    return box('mvex', undefined, trackDatas.map(trex));\n};\n/** Track Extends Box: Contains the default values used by the movie fragments. */\nexport const trex = (trackData) => {\n    return fullBox('trex', 0, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(1), // Default sample description index\n        u32(0), // Default sample duration\n        u32(0), // Default sample size\n        u32(0), // Default sample flags\n    ]);\n};\n/**\n * Movie Fragment Box: The movie fragments extend the presentation in time. They provide the information that would\n * previously have been\tin the Movie Box.\n */\nexport const moof = (sequenceNumber, trackDatas) => {\n    return box('moof', undefined, [\n        mfhd(sequenceNumber),\n        ...trackDatas.map(traf),\n    ]);\n};\n/** Movie Fragment Header Box: Contains a sequence number as a safety check. */\nexport const mfhd = (sequenceNumber) => {\n    return fullBox('mfhd', 0, 0, [\n        u32(sequenceNumber), // Sequence number\n    ]);\n};\nconst fragmentSampleFlags = (sample) => {\n    let byte1 = 0;\n    let byte2 = 0;\n    const byte3 = 0;\n    const byte4 = 0;\n    const sampleIsDifferenceSample = sample.type === 'delta';\n    byte2 |= +sampleIsDifferenceSample;\n    if (sampleIsDifferenceSample) {\n        byte1 |= 1; // There is redundant coding in this sample\n    }\n    else {\n        byte1 |= 2; // There is no redundant coding in this sample\n    }\n    // Note that there are a lot of other flags to potentially set here, but most are irrelevant / non-necessary\n    return byte1 << 24 | byte2 << 16 | byte3 << 8 | byte4;\n};\n/** Track Fragment Box */\nexport const traf = (trackData) => {\n    return box('traf', undefined, [\n        tfhd(trackData),\n        tfdt(trackData),\n        trun(trackData),\n    ]);\n};\n/** Track Fragment Header Box: Provides a reference to the extended track, and flags. */\nexport const tfhd = (trackData) => {\n    assert(trackData.currentChunk);\n    let tfFlags = 0;\n    tfFlags |= 0x00008; // Default sample duration present\n    tfFlags |= 0x00010; // Default sample size present\n    tfFlags |= 0x00020; // Default sample flags present\n    tfFlags |= 0x20000; // Default base is moof\n    // Prefer the second sample over the first one, as the first one is a sync sample and therefore the \"odd one out\"\n    const referenceSample = trackData.currentChunk.samples[1] ?? trackData.currentChunk.samples[0];\n    const referenceSampleInfo = {\n        duration: referenceSample.timescaleUnitsToNextSample,\n        size: referenceSample.size,\n        flags: fragmentSampleFlags(referenceSample),\n    };\n    return fullBox('tfhd', 0, tfFlags, [\n        u32(trackData.track.id), // Track ID\n        u32(referenceSampleInfo.duration), // Default sample duration\n        u32(referenceSampleInfo.size), // Default sample size\n        u32(referenceSampleInfo.flags), // Default sample flags\n    ]);\n};\n/**\n * Track Fragment Decode Time Box: Provides the absolute decode time of the first sample of the fragment. This is\n * useful for performing random access on the media file.\n */\nexport const tfdt = (trackData) => {\n    assert(trackData.currentChunk);\n    return fullBox('tfdt', 1, 0, [\n        u64(intoTimescale(trackData.currentChunk.startTimestamp, trackData.timescale)), // Base Media Decode Time\n    ]);\n};\n/** Track Run Box: Specifies a run of contiguous samples for a given track. */\nexport const trun = (trackData) => {\n    assert(trackData.currentChunk);\n    const allSampleDurations = trackData.currentChunk.samples.map(x => x.timescaleUnitsToNextSample);\n    const allSampleSizes = trackData.currentChunk.samples.map(x => x.size);\n    const allSampleFlags = trackData.currentChunk.samples.map(fragmentSampleFlags);\n    const allSampleCompositionTimeOffsets = trackData.currentChunk.samples\n        .map(x => intoTimescale(x.timestamp - x.decodeTimestamp, trackData.timescale));\n    const uniqueSampleDurations = new Set(allSampleDurations);\n    const uniqueSampleSizes = new Set(allSampleSizes);\n    const uniqueSampleFlags = new Set(allSampleFlags);\n    const uniqueSampleCompositionTimeOffsets = new Set(allSampleCompositionTimeOffsets);\n    const firstSampleFlagsPresent = uniqueSampleFlags.size === 2 && allSampleFlags[0] !== allSampleFlags[1];\n    const sampleDurationPresent = uniqueSampleDurations.size > 1;\n    const sampleSizePresent = uniqueSampleSizes.size > 1;\n    const sampleFlagsPresent = !firstSampleFlagsPresent && uniqueSampleFlags.size > 1;\n    const sampleCompositionTimeOffsetsPresent = uniqueSampleCompositionTimeOffsets.size > 1 || [...uniqueSampleCompositionTimeOffsets].some(x => x !== 0);\n    let flags = 0;\n    flags |= 0x0001; // Data offset present\n    flags |= 0x0004 * +firstSampleFlagsPresent; // First sample flags present\n    flags |= 0x0100 * +sampleDurationPresent; // Sample duration present\n    flags |= 0x0200 * +sampleSizePresent; // Sample size present\n    flags |= 0x0400 * +sampleFlagsPresent; // Sample flags present\n    flags |= 0x0800 * +sampleCompositionTimeOffsetsPresent; // Sample composition time offsets present\n    return fullBox('trun', 1, flags, [\n        u32(trackData.currentChunk.samples.length), // Sample count\n        u32(trackData.currentChunk.offset - trackData.currentChunk.moofOffset || 0), // Data offset\n        firstSampleFlagsPresent ? u32(allSampleFlags[0]) : [],\n        trackData.currentChunk.samples.map((_, i) => [\n            sampleDurationPresent ? u32(allSampleDurations[i]) : [], // Sample duration\n            sampleSizePresent ? u32(allSampleSizes[i]) : [], // Sample size\n            sampleFlagsPresent ? u32(allSampleFlags[i]) : [], // Sample flags\n            // Sample composition time offsets\n            sampleCompositionTimeOffsetsPresent ? i32(allSampleCompositionTimeOffsets[i]) : [],\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Box: For each track, provides pointers to sync samples within the file\n * for random access.\n */\nexport const mfra = (trackDatas) => {\n    return box('mfra', undefined, [\n        ...trackDatas.map(tfra),\n        mfro(),\n    ]);\n};\n/** Track Fragment Random Access Box: Provides pointers to sync samples within the file for random access. */\nexport const tfra = (trackData, trackIndex) => {\n    const version = 1; // Using this version allows us to use 64-bit time and offset values\n    return fullBox('tfra', version, 0, [\n        u32(trackData.track.id), // Track ID\n        u32(0b111111), // This specifies that traf number, trun number and sample number are 32-bit ints\n        u32(trackData.finalizedChunks.length), // Number of entries\n        trackData.finalizedChunks.map(chunk => [\n            u64(intoTimescale(chunk.samples[0].timestamp, trackData.timescale)), // Time (in presentation time)\n            u64(chunk.moofOffset), // moof offset\n            u32(trackIndex + 1), // traf number\n            u32(1), // trun number\n            u32(1), // Sample number\n        ]),\n    ]);\n};\n/**\n * Movie Fragment Random Access Offset Box: Provides the size of the enclosing mfra box. This box can be used by readers\n * to quickly locate the mfra box by searching from the end of the file.\n */\nexport const mfro = () => {\n    return fullBox('mfro', 0, 0, [\n        // This value needs to be overwritten manually from the outside, where the actual size of the enclosing mfra box\n        // is known\n        u32(0), // Size\n    ]);\n};\n/** VTT Empty Cue Box */\nexport const vtte = () => box('vtte');\n/** VTT Cue Box */\nexport const vttc = (payload, timestamp, identifier, settings, sourceId) => box('vttc', undefined, [\n    sourceId !== null ? box('vsid', [i32(sourceId)]) : null,\n    identifier !== null ? box('iden', [...textEncoder.encode(identifier)]) : null,\n    timestamp !== null ? box('ctim', [...textEncoder.encode(formatSubtitleTimestamp(timestamp))]) : null,\n    settings !== null ? box('sttg', [...textEncoder.encode(settings)]) : null,\n    box('payl', [...textEncoder.encode(payload)]),\n]);\n/** VTT Additional Text Box */\nexport const vtta = (notes) => box('vtta', [...textEncoder.encode(notes)]);\n/** User Data Box */\nconst udta = (muxer) => {\n    const boxes = [];\n    const metadataFormat = muxer.format._options.metadataFormat ?? 'auto';\n    const metadataTags = muxer.output._metadataTags;\n    // Depending on the format, metadata tags are written differently\n    if (metadataFormat === 'mdir' || (metadataFormat === 'auto' && !muxer.isQuickTime)) {\n        const metaBox = metaMdir(metadataTags);\n        if (metaBox)\n            boxes.push(metaBox);\n    }\n    else if (metadataFormat === 'mdta') {\n        const metaBox = metaMdta(metadataTags);\n        if (metaBox)\n            boxes.push(metaBox);\n    }\n    else if (metadataFormat === 'udta' || (metadataFormat === 'auto' && muxer.isQuickTime)) {\n        addQuickTimeMetadataTagBoxes(boxes, muxer.output._metadataTags);\n    }\n    if (boxes.length === 0) {\n        return null;\n    }\n    return box('udta', undefined, boxes);\n};\nconst addQuickTimeMetadataTagBoxes = (boxes, tags) => {\n    // https://exiftool.org/TagNames/QuickTime.html (QuickTime UserData Tags)\n    // For QuickTime files, metadata tags are dumped into the udta box\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    boxes.push(metadataTagStringBoxShort('nam', value));\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    boxes.push(metadataTagStringBoxShort('des', value));\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    boxes.push(metadataTagStringBoxShort('ART', value));\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    boxes.push(metadataTagStringBoxShort('alb', value));\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    boxes.push(metadataTagStringBoxShort('albr', value));\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    boxes.push(metadataTagStringBoxShort('gen', value));\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    boxes.push(metadataTagStringBoxShort('day', value.toISOString().slice(0, 10)));\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    boxes.push(metadataTagStringBoxShort('cmt', value));\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    boxes.push(metadataTagStringBoxShort('lyr', value));\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            case 'discNumber':\n            case 'discsTotal':\n            case 'trackNumber':\n            case 'tracksTotal':\n            case 'images':\n                {\n                    // Not written for QuickTime (common Apple L)\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key];\n            if (value == null || key.length !== 4 || boxes.some(x => x.type === key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                boxes.push(metadataTagStringBoxShort(key, value));\n            }\n            else if (value instanceof Uint8Array) {\n                boxes.push(box(key, Array.from(value)));\n            }\n        }\n    }\n};\nconst metadataTagStringBoxShort = (name, value) => {\n    const encoded = textEncoder.encode(value);\n    return box(name, [\n        u16(encoded.length),\n        u16(getLanguageCodeInt('und')),\n        Array.from(encoded),\n    ]);\n};\nconst DATA_BOX_MIME_TYPE_MAP = {\n    'image/jpeg': 13,\n    'image/png': 14,\n    'image/bmp': 27,\n};\n/**\n * Generates key-value metadata for inclusion in the \"meta\" box.\n */\nconst generateMetadataPairs = (tags, isMdta) => {\n    const pairs = [];\n    // https://exiftool.org/TagNames/QuickTime.html (QuickTime ItemList Tags)\n    // This is the metadata format used for MP4 files\n    for (const { key, value } of keyValueIterator(tags)) {\n        switch (key) {\n            case 'title':\n                {\n                    pairs.push({ key: isMdta ? 'title' : 'nam', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'description':\n                {\n                    pairs.push({ key: isMdta ? 'description' : 'des', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'artist':\n                {\n                    pairs.push({ key: isMdta ? 'artist' : 'ART', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'album':\n                {\n                    pairs.push({ key: isMdta ? 'album' : 'alb', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'albumArtist':\n                {\n                    pairs.push({ key: isMdta ? 'album_artist' : 'aART', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'comment':\n                {\n                    pairs.push({ key: isMdta ? 'comment' : 'cmt', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'genre':\n                {\n                    pairs.push({ key: isMdta ? 'genre' : 'gen', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'lyrics':\n                {\n                    pairs.push({ key: isMdta ? 'lyrics' : 'lyr', value: dataStringBoxLong(value) });\n                }\n                ;\n                break;\n            case 'date':\n                {\n                    pairs.push({\n                        key: isMdta ? 'date' : 'day',\n                        value: dataStringBoxLong(value.toISOString().slice(0, 10)),\n                    });\n                }\n                ;\n                break;\n            case 'images':\n                {\n                    for (const image of value) {\n                        if (image.kind !== 'coverFront') {\n                            continue;\n                        }\n                        pairs.push({ key: 'covr', value: box('data', [\n                                u32(DATA_BOX_MIME_TYPE_MAP[image.mimeType] ?? 0), // Type indicator\n                                u32(0), // Locale indicator\n                                Array.from(image.data), // Kinda slow, hopefully temp\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'trackNumber':\n                {\n                    if (isMdta) {\n                        const string = tags.tracksTotal !== undefined\n                            ? `${value}/${tags.tracksTotal}`\n                            : value.toString();\n                        pairs.push({ key: 'track', value: dataStringBoxLong(string) });\n                    }\n                    else {\n                        pairs.push({ key: 'trkn', value: box('data', [\n                                u32(0), // 8 bytes empty\n                                u32(0),\n                                u16(0), // Empty\n                                u16(value),\n                                u16(tags.tracksTotal ?? 0),\n                                u16(0), // Empty\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'discNumber':\n                {\n                    if (!isMdta) {\n                        // Only written for mdir\n                        pairs.push({ key: 'disc', value: box('data', [\n                                u32(0), // 8 bytes empty\n                                u32(0),\n                                u16(0), // Empty\n                                u16(value),\n                                u16(tags.discsTotal ?? 0),\n                                u16(0), // Empty\n                            ]) });\n                    }\n                }\n                ;\n                break;\n            case 'tracksTotal':\n            case 'discsTotal':\n                {\n                    // These are included with 'trackNumber' and 'discNumber' respectively\n                }\n                ;\n                break;\n            case 'raw':\n                {\n                    // Handled later\n                }\n                ;\n                break;\n            default: assertNever(key);\n        }\n    }\n    if (tags.raw) {\n        for (const key in tags.raw) {\n            const value = tags.raw[key];\n            if (value == null || (!isMdta && key.length !== 4) || pairs.some(x => x.key === key)) {\n                continue;\n            }\n            if (typeof value === 'string') {\n                pairs.push({ key, value: dataStringBoxLong(value) });\n            }\n            else if (value instanceof Uint8Array) {\n                pairs.push({ key, value: box('data', [\n                        u32(0), // Type indicator\n                        u32(0), // Locale indicator\n                        Array.from(value),\n                    ]) });\n            }\n            else if (value instanceof RichImageData) {\n                pairs.push({ key, value: box('data', [\n                        u32(DATA_BOX_MIME_TYPE_MAP[value.mimeType] ?? 0), // Type indicator\n                        u32(0), // Locale indicator\n                        Array.from(value.data), // Kinda slow, hopefully temp\n                    ]) });\n            }\n        }\n    }\n    return pairs;\n};\n/** Metadata Box (mdir format) */\nconst metaMdir = (tags) => {\n    const pairs = generateMetadataPairs(tags, false);\n    if (pairs.length === 0) {\n        return null;\n    }\n    // fullBox format\n    return fullBox('meta', 0, 0, undefined, [\n        hdlr(false, 'mdir', '', 'appl'), // mdir handler\n        box('ilst', undefined, pairs.map(pair => box(pair.key, undefined, [pair.value]))), // Item list without keys box\n    ]);\n};\n/** Metadata Box (mdta format with keys box) */\nconst metaMdta = (tags) => {\n    const pairs = generateMetadataPairs(tags, true);\n    if (pairs.length === 0) {\n        return null;\n    }\n    // box without version and flags\n    return box('meta', undefined, [\n        hdlr(false, 'mdta', ''), // mdta handler\n        fullBox('keys', 0, 0, [\n            u32(pairs.length),\n        ], pairs.map(pair => box('mdta', [\n            ...textEncoder.encode(pair.key),\n        ]))),\n        box('ilst', undefined, pairs.map((pair, i) => {\n            const boxName = String.fromCharCode(...u32(i + 1));\n            return box(boxName, undefined, [pair.value]);\n        })),\n    ]);\n};\nconst dataStringBoxLong = (value) => {\n    return box('data', [\n        u32(1), // Type indicator (UTF-8)\n        u32(0), // Locale indicator\n        ...textEncoder.encode(value),\n    ]);\n};\nconst videoCodecToBoxName = (codec, fullCodecString) => {\n    switch (codec) {\n        case 'avc': return fullCodecString.startsWith('avc3') ? 'avc3' : 'avc1';\n        case 'hevc': return 'hvc1';\n        case 'vp8': return 'vp08';\n        case 'vp9': return 'vp09';\n        case 'av1': return 'av01';\n    }\n};\nconst VIDEO_CODEC_TO_CONFIGURATION_BOX = {\n    avc: avcC,\n    hevc: hvcC,\n    vp8: vpcC,\n    vp9: vpcC,\n    av1: av1C,\n};\nconst audioCodecToBoxName = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return 'mp4a';\n        case 'mp3': return 'mp4a';\n        case 'opus': return 'Opus';\n        case 'vorbis': return 'mp4a';\n        case 'flac': return 'fLaC';\n        case 'ulaw': return 'ulaw';\n        case 'alaw': return 'alaw';\n        case 'pcm-u8': return 'raw ';\n        case 'pcm-s8': return 'sowt';\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s16': return 'sowt';\n            case 'pcm-s16be': return 'twos';\n            case 'pcm-s24': return 'in24';\n            case 'pcm-s24be': return 'in24';\n            case 'pcm-s32': return 'in32';\n            case 'pcm-s32be': return 'in32';\n            case 'pcm-f32': return 'fl32';\n            case 'pcm-f32be': return 'fl32';\n            case 'pcm-f64': return 'fl64';\n            case 'pcm-f64be': return 'fl64';\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return 'ipcm';\n            case 'pcm-s16be': return 'ipcm';\n            case 'pcm-s24': return 'ipcm';\n            case 'pcm-s24be': return 'ipcm';\n            case 'pcm-s32': return 'ipcm';\n            case 'pcm-s32be': return 'ipcm';\n            case 'pcm-f32': return 'fpcm';\n            case 'pcm-f32be': return 'fpcm';\n            case 'pcm-f64': return 'fpcm';\n            case 'pcm-f64be': return 'fpcm';\n        }\n    }\n};\nconst audioCodecToConfigurationBox = (codec, isQuickTime) => {\n    switch (codec) {\n        case 'aac': return esds;\n        case 'mp3': return esds;\n        case 'opus': return dOps;\n        case 'vorbis': return esds;\n        case 'flac': return dfLa;\n    }\n    // Logic diverges here\n    if (isQuickTime) {\n        switch (codec) {\n            case 'pcm-s24': return wave;\n            case 'pcm-s24be': return wave;\n            case 'pcm-s32': return wave;\n            case 'pcm-s32be': return wave;\n            case 'pcm-f32': return wave;\n            case 'pcm-f32be': return wave;\n            case 'pcm-f64': return wave;\n            case 'pcm-f64be': return wave;\n        }\n    }\n    else {\n        switch (codec) {\n            case 'pcm-s16': return pcmC;\n            case 'pcm-s16be': return pcmC;\n            case 'pcm-s24': return pcmC;\n            case 'pcm-s24be': return pcmC;\n            case 'pcm-s32': return pcmC;\n            case 'pcm-s32be': return pcmC;\n            case 'pcm-f32': return pcmC;\n            case 'pcm-f32be': return pcmC;\n            case 'pcm-f64': return pcmC;\n            case 'pcm-f64be': return pcmC;\n        }\n    }\n    return null;\n};\nconst SUBTITLE_CODEC_TO_BOX_NAME = {\n    webvtt: 'wvtt',\n};\nconst SUBTITLE_CODEC_TO_CONFIGURATION_BOX = {\n    webvtt: vttC,\n};\nconst getLanguageCodeInt = (code) => {\n    assert(code.length === 3);\n    ;\n    let language = 0;\n    for (let i = 0; i < 3; i++) {\n        language <<= 5;\n        language += code.charCodeAt(i) - 0x60;\n    }\n    return language;\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { assert } from './misc.js';\nexport class Writer {\n    constructor() {\n        /** Setting this to true will cause the writer to ensure data is written in a strictly monotonic, streamable way. */\n        this.ensureMonotonicity = false;\n        this.trackedWrites = null;\n        this.trackedStart = -1;\n        this.trackedEnd = -1;\n    }\n    start() { }\n    maybeTrackWrites(data) {\n        if (!this.trackedWrites) {\n            return;\n        }\n        // Handle negative relative write positions\n        let pos = this.getPos();\n        if (pos < this.trackedStart) {\n            if (pos + data.byteLength <= this.trackedStart) {\n                return;\n            }\n            data = data.subarray(this.trackedStart - pos);\n            pos = 0;\n        }\n        const neededSize = pos + data.byteLength - this.trackedStart;\n        let newLength = this.trackedWrites.byteLength;\n        while (newLength < neededSize) {\n            newLength *= 2;\n        }\n        // Check if we need to resize the buffer\n        if (newLength !== this.trackedWrites.byteLength) {\n            const copy = new Uint8Array(newLength);\n            copy.set(this.trackedWrites, 0);\n            this.trackedWrites = copy;\n        }\n        this.trackedWrites.set(data, pos - this.trackedStart);\n        this.trackedEnd = Math.max(this.trackedEnd, pos + data.byteLength);\n    }\n    startTrackingWrites() {\n        this.trackedWrites = new Uint8Array(2 ** 10);\n        this.trackedStart = this.getPos();\n        this.trackedEnd = this.trackedStart;\n    }\n    stopTrackingWrites() {\n        if (!this.trackedWrites) {\n            throw new Error('Internal error: Can\\'t get tracked writes since nothing was tracked.');\n        }\n        const slice = this.trackedWrites.subarray(0, this.trackedEnd - this.trackedStart);\n        const result = {\n            data: slice,\n            start: this.trackedStart,\n            end: this.trackedEnd,\n        };\n        this.trackedWrites = null;\n        return result;\n    }\n}\nconst ARRAY_BUFFER_INITIAL_SIZE = 2 ** 16;\nconst ARRAY_BUFFER_MAX_SIZE = 2 ** 32;\nexport class BufferTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.maxPos = 0;\n        this.target = target;\n        this.supportsResize = 'resize' in new ArrayBuffer(0);\n        if (this.supportsResize) {\n            try {\n                // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE, { maxByteLength: ARRAY_BUFFER_MAX_SIZE });\n            }\n            catch {\n                this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n                this.supportsResize = false;\n            }\n        }\n        else {\n            this.buffer = new ArrayBuffer(ARRAY_BUFFER_INITIAL_SIZE);\n        }\n        this.bytes = new Uint8Array(this.buffer);\n    }\n    ensureSize(size) {\n        let newLength = this.buffer.byteLength;\n        while (newLength < size)\n            newLength *= 2;\n        if (newLength === this.buffer.byteLength)\n            return;\n        if (newLength > ARRAY_BUFFER_MAX_SIZE) {\n            throw new Error(`ArrayBuffer exceeded maximum size of ${ARRAY_BUFFER_MAX_SIZE} bytes. Please consider using another`\n                + ` target.`);\n        }\n        if (this.supportsResize) {\n            // Use resize if it exists\n            // @ts-expect-error Don't want to bump \"lib\" in tsconfig\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            this.buffer.resize(newLength);\n            // The Uint8Array scales automatically\n        }\n        else {\n            const newBuffer = new ArrayBuffer(newLength);\n            const newBytes = new Uint8Array(newBuffer);\n            newBytes.set(this.bytes, 0);\n            this.buffer = newBuffer;\n            this.bytes = newBytes;\n        }\n    }\n    write(data) {\n        this.maybeTrackWrites(data);\n        this.ensureSize(this.pos + data.byteLength);\n        this.bytes.set(data, this.pos);\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n        this.maxPos = Math.max(this.maxPos, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() { }\n    async finalize() {\n        this.ensureSize(this.pos);\n        this.target.buffer = this.buffer.slice(0, Math.max(this.maxPos, this.pos));\n    }\n    async close() { }\n    getSlice(start, end) {\n        return this.bytes.slice(start, end);\n    }\n}\nconst DEFAULT_CHUNK_SIZE = 2 ** 24;\nconst MAX_CHUNKS_AT_ONCE = 2;\n/**\n * Writes to a StreamTarget every time it is flushed, sending out all of the new data written since the\n * last flush. This is useful for streaming applications, like piping the output to disk. When using the chunked mode,\n * data will first be accumulated in larger chunks, and then the entire chunk will be flushed out at once when ready.\n */\nexport class StreamTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.pos = 0;\n        this.sections = [];\n        this.lastWriteEnd = 0;\n        this.lastFlushEnd = 0;\n        this.writer = null;\n        /**\n         * The data is divided up into fixed-size chunks, whose contents are first filled in RAM and then flushed out.\n         * A chunk is flushed if all of its contents have been written.\n         */\n        this.chunks = [];\n        this.target = target;\n        this.chunked = target._options.chunked ?? false;\n        this.chunkSize = target._options.chunkSize ?? DEFAULT_CHUNK_SIZE;\n    }\n    start() {\n        this.writer = this.target._writable.getWriter();\n    }\n    write(data) {\n        if (this.pos > this.lastWriteEnd) {\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        this.maybeTrackWrites(data);\n        this.sections.push({\n            data: data.slice(),\n            start: this.pos,\n        });\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n        this.lastWriteEnd = Math.max(this.lastWriteEnd, this.pos);\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    getPos() {\n        return this.pos;\n    }\n    async flush() {\n        if (this.pos > this.lastWriteEnd) {\n            // There's a \"void\" between the last written byte and the next byte we're about to write. Let's pad that\n            // void with zeroes explicitly.\n            const paddingBytesNeeded = this.pos - this.lastWriteEnd;\n            this.pos = this.lastWriteEnd;\n            this.write(new Uint8Array(paddingBytesNeeded));\n        }\n        assert(this.writer);\n        if (this.sections.length === 0)\n            return;\n        const chunks = [];\n        const sorted = [...this.sections].sort((a, b) => a.start - b.start);\n        chunks.push({\n            start: sorted[0].start,\n            size: sorted[0].data.byteLength,\n        });\n        // Figure out how many contiguous chunks we have\n        for (let i = 1; i < sorted.length; i++) {\n            const lastChunk = chunks[chunks.length - 1];\n            const section = sorted[i];\n            if (section.start <= lastChunk.start + lastChunk.size) {\n                lastChunk.size = Math.max(lastChunk.size, section.start + section.data.byteLength - lastChunk.start);\n            }\n            else {\n                chunks.push({\n                    start: section.start,\n                    size: section.data.byteLength,\n                });\n            }\n        }\n        for (const chunk of chunks) {\n            chunk.data = new Uint8Array(chunk.size);\n            // Make sure to write the data in the correct order for correct overwriting\n            for (const section of this.sections) {\n                // Check if the section is in the chunk\n                if (chunk.start <= section.start && section.start < chunk.start + chunk.size) {\n                    chunk.data.set(section.data, section.start - chunk.start);\n                }\n            }\n            if (this.writer.desiredSize !== null && this.writer.desiredSize <= 0) {\n                await this.writer.ready; // Allow the writer to apply backpressure\n            }\n            if (this.chunked) {\n                // Let's first gather the data into bigger chunks before writing it\n                this.writeDataIntoChunks(chunk.data, chunk.start);\n                this.tryToFlushChunks();\n            }\n            else {\n                if (this.ensureMonotonicity && chunk.start !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                // Write out the data immediately\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data,\n                    position: chunk.start,\n                });\n                this.lastFlushEnd = chunk.start + chunk.data.byteLength;\n            }\n        }\n        this.sections.length = 0;\n    }\n    writeDataIntoChunks(data, position) {\n        // First, find the chunk to write the data into, or create one if none exists\n        let chunkIndex = this.chunks.findIndex(x => x.start <= position && position < x.start + this.chunkSize);\n        if (chunkIndex === -1)\n            chunkIndex = this.createChunk(position);\n        const chunk = this.chunks[chunkIndex];\n        // Figure out how much to write to the chunk, and then write to the chunk\n        const relativePosition = position - chunk.start;\n        const toWrite = data.subarray(0, Math.min(this.chunkSize - relativePosition, data.byteLength));\n        chunk.data.set(toWrite, relativePosition);\n        // Create a section describing the region of data that was just written to\n        const section = {\n            start: relativePosition,\n            end: relativePosition + toWrite.byteLength,\n        };\n        this.insertSectionIntoChunk(chunk, section);\n        // Queue chunk for flushing to target if it has been fully written to\n        if (chunk.written[0].start === 0 && chunk.written[0].end === this.chunkSize) {\n            chunk.shouldFlush = true;\n        }\n        // Make sure we don't hold too many chunks in memory at once to keep memory usage down\n        if (this.chunks.length > MAX_CHUNKS_AT_ONCE) {\n            // Flush all but the last chunk\n            for (let i = 0; i < this.chunks.length - 1; i++) {\n                this.chunks[i].shouldFlush = true;\n            }\n            this.tryToFlushChunks();\n        }\n        // If the data didn't fit in one chunk, recurse with the remaining data\n        if (toWrite.byteLength < data.byteLength) {\n            this.writeDataIntoChunks(data.subarray(toWrite.byteLength), position + toWrite.byteLength);\n        }\n    }\n    insertSectionIntoChunk(chunk, section) {\n        let low = 0;\n        let high = chunk.written.length - 1;\n        let index = -1;\n        // Do a binary search to find the last section with a start not larger than `section`'s start\n        while (low <= high) {\n            const mid = Math.floor(low + (high - low + 1) / 2);\n            if (chunk.written[mid].start <= section.start) {\n                low = mid + 1;\n                index = mid;\n            }\n            else {\n                high = mid - 1;\n            }\n        }\n        // Insert the new section\n        chunk.written.splice(index + 1, 0, section);\n        if (index === -1 || chunk.written[index].end < section.start)\n            index++;\n        // Merge overlapping sections\n        while (index < chunk.written.length - 1 && chunk.written[index].end >= chunk.written[index + 1].start) {\n            chunk.written[index].end = Math.max(chunk.written[index].end, chunk.written[index + 1].end);\n            chunk.written.splice(index + 1, 1);\n        }\n    }\n    createChunk(includesPosition) {\n        const start = Math.floor(includesPosition / this.chunkSize) * this.chunkSize;\n        const chunk = {\n            start,\n            data: new Uint8Array(this.chunkSize),\n            written: [],\n            shouldFlush: false,\n        };\n        this.chunks.push(chunk);\n        this.chunks.sort((a, b) => a.start - b.start);\n        return this.chunks.indexOf(chunk);\n    }\n    tryToFlushChunks(force = false) {\n        assert(this.writer);\n        for (let i = 0; i < this.chunks.length; i++) {\n            const chunk = this.chunks[i];\n            if (!chunk.shouldFlush && !force)\n                continue;\n            for (const section of chunk.written) {\n                const position = chunk.start + section.start;\n                if (this.ensureMonotonicity && position !== this.lastFlushEnd) {\n                    throw new Error('Internal error: Monotonicity violation.');\n                }\n                void this.writer.write({\n                    type: 'write',\n                    data: chunk.data.subarray(section.start, section.end),\n                    position,\n                });\n                this.lastFlushEnd = chunk.start + section.end;\n            }\n            this.chunks.splice(i--, 1);\n        }\n    }\n    finalize() {\n        if (this.chunked) {\n            this.tryToFlushChunks(true);\n        }\n        assert(this.writer);\n        return this.writer.close();\n    }\n    async close() {\n        return this.writer?.close();\n    }\n}\nexport class NullTargetWriter extends Writer {\n    constructor(target) {\n        super();\n        this.target = target;\n        this.pos = 0;\n    }\n    write(data) {\n        this.maybeTrackWrites(data);\n        this.target.onwrite?.(this.pos, this.pos + data.byteLength);\n        this.pos += data.byteLength;\n    }\n    getPos() {\n        return this.pos;\n    }\n    seek(newPos) {\n        this.pos = newPos;\n    }\n    async flush() { }\n    async finalize() { }\n    async close() { }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { BufferTargetWriter, NullTargetWriter, StreamTargetWriter } from './writer.js';\nimport * as nodeAlias from './node.js';\nimport { assert } from './misc.js';\nconst node = typeof nodeAlias !== 'undefined'\n    ? nodeAlias // Aliasing it prevents some bundler warnings\n    : undefined;\n/**\n * Base class for targets, specifying where output files are written.\n * @group Output targets\n * @public\n */\nexport class Target {\n    constructor() {\n        /** @internal */\n        this._output = null;\n        /**\n         * Called each time data is written to the target. Will be called with the byte range into which data was written.\n         *\n         * Use this callback to track the size of the output file as it grows. But be warned, this function is chatty and\n         * gets called *extremely* often.\n         */\n        this.onwrite = null;\n    }\n}\n/**\n * A target that writes data directly into an ArrayBuffer in memory. Great for performance, but not suitable for very\n * large files. The buffer will be available once the output has been finalized.\n * @group Output targets\n * @public\n */\nexport class BufferTarget extends Target {\n    constructor() {\n        super(...arguments);\n        /** Stores the final output buffer. Until the output is finalized, this will be `null`. */\n        this.buffer = null;\n    }\n    /** @internal */\n    _createWriter() {\n        return new BufferTargetWriter(this);\n    }\n}\n/**\n * This target writes data to a [`WritableStream`](https://developer.mozilla.org/en-US/docs/Web/API/WritableStream),\n * making it a general-purpose target for writing data anywhere. It is also compatible with\n * [`FileSystemWritableFileStream`](https://developer.mozilla.org/en-US/docs/Web/API/FileSystemWritableFileStream) for\n * use with the [File System Access API](https://developer.mozilla.org/en-US/docs/Web/API/File_System_API). The\n * `WritableStream` can also apply backpressure, which will propagate to the output and throttle the encoders.\n * @group Output targets\n * @public\n */\nexport class StreamTarget extends Target {\n    /** Creates a new {@link StreamTarget} which writes to the specified `writable`. */\n    constructor(writable, options = {}) {\n        super();\n        if (!(writable instanceof WritableStream)) {\n            throw new TypeError('StreamTarget requires a WritableStream instance.');\n        }\n        if (options != null && typeof options !== 'object') {\n            throw new TypeError('StreamTarget options, when provided, must be an object.');\n        }\n        if (options.chunked !== undefined && typeof options.chunked !== 'boolean') {\n            throw new TypeError('options.chunked, when provided, must be a boolean.');\n        }\n        if (options.chunkSize !== undefined && (!Number.isInteger(options.chunkSize) || options.chunkSize < 1024)) {\n            throw new TypeError('options.chunkSize, when provided, must be an integer and not smaller than 1024.');\n        }\n        this._writable = writable;\n        this._options = options;\n    }\n    /** @internal */\n    _createWriter() {\n        return new StreamTargetWriter(this);\n    }\n}\n/**\n * A target that writes to a file at the specified path. Intended for server-side usage in Node, Bun, or Deno.\n *\n * Writing is chunked by default. The internally held file handle will be closed when `.finalize()` or `.cancel()` are\n * called on the corresponding {@link Output}.\n * @group Output targets\n * @public\n */\nexport class FilePathTarget extends Target {\n    /** Creates a new {@link FilePathTarget} that writes to the file at the specified file path. */\n    constructor(filePath, options = {}) {\n        if (typeof filePath !== 'string') {\n            throw new TypeError('filePath must be a string.');\n        }\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        super();\n        /** @internal */\n        this._fileHandle = null;\n        // Let's back this target with a StreamTarget, makes the implementation very simple\n        const writable = new WritableStream({\n            start: async () => {\n                this._fileHandle = await node.fs.open(filePath, 'w');\n            },\n            write: async (chunk) => {\n                assert(this._fileHandle);\n                await this._fileHandle.write(chunk.data, 0, chunk.data.byteLength, chunk.position);\n            },\n            close: async () => {\n                if (this._fileHandle) {\n                    await this._fileHandle.close();\n                    this._fileHandle = null;\n                }\n            },\n        });\n        this._streamTarget = new StreamTarget(writable, {\n            chunked: true,\n            ...options,\n        });\n        this._streamTarget._output = this._output;\n    }\n    /** @internal */\n    _createWriter() {\n        return this._streamTarget._createWriter();\n    }\n}\n/**\n * This target just discards all incoming data. It is useful for when you need an {@link Output} but extract data from\n * it differently, for example through format-specific callbacks (`onMoof`, `onMdat`, ...) or encoder events.\n * @group Output targets\n * @public\n */\nexport class NullTarget extends Target {\n    /** @internal */\n    _createWriter() {\n        return new NullTargetWriter(this);\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { free, ftyp, IsobmffBoxWriter, mdat, mfra, moof, moov, vtta, vttc, vtte } from './isobmff-boxes.js';\nimport { Muxer } from '../muxer.js';\nimport { BufferTargetWriter } from '../writer.js';\nimport { assert, computeRationalApproximation, last, promiseWithResolvers } from '../misc.js';\nimport { MovOutputFormat } from '../output-format.js';\nimport { inlineTimestampRegex } from '../subtitles.js';\nimport { aacChannelMap, aacFrequencyTable, buildAacAudioSpecificConfig, parsePcmCodec, PCM_AUDIO_CODECS, validateAudioChunkMetadata, validateSubtitleMetadata, validateVideoChunkMetadata, } from '../codec.js';\nimport { MAX_ADTS_FRAME_HEADER_SIZE, MIN_ADTS_FRAME_HEADER_SIZE, readAdtsFrameHeader } from '../adts/adts-reader.js';\nimport { FileSlice } from '../reader.js';\nimport { BufferTarget } from '../target.js';\nimport { concatNalUnitsInLengthPrefixed, extractAvcDecoderConfigurationRecord, extractHevcDecoderConfigurationRecord, iterateNalUnitsInAnnexB, serializeAvcDecoderConfigurationRecord, serializeHevcDecoderConfigurationRecord, } from '../codec-data.js';\nimport { buildIsobmffMimeType } from './isobmff-misc.js';\nimport { MAX_BOX_HEADER_SIZE, MIN_BOX_HEADER_SIZE } from './isobmff-reader.js';\nexport const GLOBAL_TIMESCALE = 1000;\nconst TIMESTAMP_OFFSET = 2_082_844_800; // Seconds between Jan 1 1904 and Jan 1 1970\nexport const getTrackMetadata = (trackData) => {\n    const metadata = {};\n    const track = trackData.track;\n    if (track.metadata.name !== undefined) {\n        metadata.name = track.metadata.name;\n    }\n    return metadata;\n};\nexport const intoTimescale = (timeInSeconds, timescale, round = true) => {\n    const value = timeInSeconds * timescale;\n    return round ? Math.round(value) : value;\n};\nexport class IsobmffMuxer extends Muxer {\n    constructor(output, format) {\n        super(output);\n        this.auxTarget = new BufferTarget();\n        this.auxWriter = this.auxTarget._createWriter();\n        this.auxBoxWriter = new IsobmffBoxWriter(this.auxWriter);\n        this.mdat = null;\n        this.ftypSize = null;\n        this.trackDatas = [];\n        this.allTracksKnown = promiseWithResolvers();\n        this.creationTime = Math.floor(Date.now() / 1000) + TIMESTAMP_OFFSET;\n        this.finalizedChunks = [];\n        this.nextFragmentNumber = 1;\n        // Only relevant for fragmented files, to make sure new fragments start with the highest timestamp seen so far\n        this.maxWrittenTimestamp = -Infinity;\n        this.format = format;\n        this.writer = output._writer;\n        this.boxWriter = new IsobmffBoxWriter(this.writer);\n        this.isQuickTime = format instanceof MovOutputFormat;\n        // If the fastStart option isn't defined, enable in-memory fast start if the target is an ArrayBuffer, as the\n        // memory usage remains identical\n        const fastStartDefault = this.writer instanceof BufferTargetWriter ? 'in-memory' : false;\n        this.fastStart = format._options.fastStart ?? fastStartDefault;\n        this.isFragmented = this.fastStart === 'fragmented';\n        if (this.fastStart === 'in-memory' || this.isFragmented) {\n            this.writer.ensureMonotonicity = true;\n        }\n        this.minimumFragmentDuration = format._options.minimumFragmentDuration ?? 1;\n    }\n    async start() {\n        const release = await this.mutex.acquire();\n        const holdsAvc = this.output._tracks.some(x => x.type === 'video' && x.source._codec === 'avc');\n        // Write the header\n        {\n            if (this.format._options.onFtyp) {\n                this.writer.startTrackingWrites();\n            }\n            this.boxWriter.writeBox(ftyp({\n                isQuickTime: this.isQuickTime,\n                holdsAvc: holdsAvc,\n                fragmented: this.isFragmented,\n            }));\n            if (this.format._options.onFtyp) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onFtyp(data, start);\n            }\n        }\n        this.ftypSize = this.writer.getPos();\n        if (this.fastStart === 'in-memory') {\n            // We're write at finalization\n        }\n        else if (this.fastStart === 'reserve') {\n            // Validate that all tracks have set maximumPacketCount\n            for (const track of this.output._tracks) {\n                if (track.metadata.maximumPacketCount === undefined) {\n                    throw new Error('All tracks must specify maximumPacketCount in their metadata when using'\n                        + ' fastStart: \\'reserve\\'.');\n                }\n            }\n            // We'll start writing once we know all tracks\n        }\n        else if (this.isFragmented) {\n            // We write the moov box once we write out the first fragment to make sure we get the decoder configs\n        }\n        else {\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat = mdat(true); // Reserve large size by default, can refine this when finalizing.\n            this.boxWriter.writeBox(this.mdat);\n        }\n        await this.writer.flush();\n        release();\n    }\n    allTracksAreKnown() {\n        for (const track of this.output._tracks) {\n            if (!track.source._closed && !this.trackDatas.some(x => x.track === track)) {\n                return false; // We haven't seen a sample from this open track yet\n            }\n        }\n        return true;\n    }\n    async getMimeType() {\n        await this.allTracksKnown.promise;\n        const codecStrings = this.trackDatas.map((trackData) => {\n            if (trackData.type === 'video') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else if (trackData.type === 'audio') {\n                return trackData.info.decoderConfig.codec;\n            }\n            else {\n                const map = {\n                    webvtt: 'wvtt',\n                };\n                return map[trackData.track.source._codec];\n            }\n        });\n        return buildIsobmffMimeType({\n            isQuickTime: this.isQuickTime,\n            hasVideo: this.trackDatas.some(x => x.type === 'video'),\n            hasAudio: this.trackDatas.some(x => x.type === 'audio'),\n            codecStrings,\n        });\n    }\n    getVideoTrackData(track, packet, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateVideoChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const decoderConfig = { ...meta.decoderConfig };\n        assert(decoderConfig.codedWidth !== undefined);\n        assert(decoderConfig.codedHeight !== undefined);\n        let requiresAnnexBTransformation = false;\n        if (track.source._codec === 'avc' && !decoderConfig.description) {\n            // ISOBMFF can only hold AVC in the AVCC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = extractAvcDecoderConfigurationRecord(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are'\n                    + ' in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or'\n                    + ' provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in AVCC format.');\n            }\n            decoderConfig.description = serializeAvcDecoderConfigurationRecord(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        else if (track.source._codec === 'hevc' && !decoderConfig.description) {\n            // ISOBMFF can only hold HEVC in the HEVC format, not in Annex B, but the missing description indicates\n            // Annex B. This means we'll need to do some converterino.\n            const decoderConfigurationRecord = extractHevcDecoderConfigurationRecord(packet.data);\n            if (!decoderConfigurationRecord) {\n                throw new Error('Couldn\\'t extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets'\n                    + ' are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or'\n                    + ' provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15)'\n                    + ' and ensure the packets are in HEVC format.');\n            }\n            decoderConfig.description = serializeHevcDecoderConfigurationRecord(decoderConfigurationRecord);\n            requiresAnnexBTransformation = true;\n        }\n        // The frame rate set by the user may not be an integer. Since timescale is an integer, we'll approximate the\n        // frame time (inverse of frame rate) with a rational number, then use that approximation's denominator\n        // as the timescale.\n        const timescale = computeRationalApproximation(1 / (track.metadata.frameRate ?? 57600), 1e6).denominator;\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'video',\n            info: {\n                width: decoderConfig.codedWidth,\n                height: decoderConfig.codedHeight,\n                decoderConfig: decoderConfig,\n                requiresAnnexBTransformation,\n            },\n            timescale,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getAudioTrackData(track, packet, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateAudioChunkMetadata(meta);\n        assert(meta);\n        assert(meta.decoderConfig);\n        const decoderConfig = { ...meta.decoderConfig };\n        let requiresAdtsStripping = false;\n        if (track.source._codec === 'aac' && !decoderConfig.description) {\n            // ISOBMFF can only hold AAC in raw format, not ADTS, but the missing description indicates ADTS.\n            // Parse the first packet to extract the AudioSpecificConfig.\n            const adtsFrame = readAdtsFrameHeader(FileSlice.tempFromBytes(packet.data));\n            if (!adtsFrame) {\n                throw new Error('Couldn\\'t parse ADTS header from the AAC packet. Make sure the packets are in ADTS format'\n                    + ' (as specified in ISO 13818-7) when not providing a description, or provide a description'\n                    + ' (must be an AudioSpecificConfig as specified in ISO 14496-3) and ensure the packets'\n                    + ' are raw AAC data.');\n            }\n            const sampleRate = aacFrequencyTable[adtsFrame.samplingFrequencyIndex];\n            const numberOfChannels = aacChannelMap[adtsFrame.channelConfiguration];\n            if (sampleRate === undefined || numberOfChannels === undefined) {\n                throw new Error('Invalid ADTS frame header.');\n            }\n            decoderConfig.description = buildAacAudioSpecificConfig({\n                objectType: adtsFrame.objectType,\n                sampleRate,\n                numberOfChannels,\n            });\n            requiresAdtsStripping = true;\n        }\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'audio',\n            info: {\n                numberOfChannels: meta.decoderConfig.numberOfChannels,\n                sampleRate: meta.decoderConfig.sampleRate,\n                decoderConfig,\n                requiresPcmTransformation: !this.isFragmented\n                    && PCM_AUDIO_CODECS.includes(track.source._codec),\n                requiresAdtsStripping,\n            },\n            timescale: meta.decoderConfig.sampleRate,\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    getSubtitleTrackData(track, meta) {\n        const existingTrackData = this.trackDatas.find(x => x.track === track);\n        if (existingTrackData) {\n            return existingTrackData;\n        }\n        validateSubtitleMetadata(meta);\n        assert(meta);\n        assert(meta.config);\n        const newTrackData = {\n            muxer: this,\n            track,\n            type: 'subtitle',\n            info: {\n                config: meta.config,\n            },\n            timescale: 1000, // Reasonable\n            samples: [],\n            sampleQueue: [],\n            timestampProcessingQueue: [],\n            timeToSampleTable: [],\n            compositionTimeOffsetTable: [],\n            lastTimescaleUnits: null,\n            lastSample: null,\n            finalizedChunks: [],\n            currentChunk: null,\n            compactlyCodedChunkTable: [],\n            lastCueEndTimestamp: 0,\n            cueQueue: [],\n            nextSourceId: 0,\n            cueToSourceId: new WeakMap(),\n        };\n        this.trackDatas.push(newTrackData);\n        this.trackDatas.sort((a, b) => a.track.id - b.track.id);\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        return newTrackData;\n    }\n    async addEncodedVideoPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getVideoTrackData(track, packet, meta);\n            let packetData = packet.data;\n            if (trackData.info.requiresAnnexBTransformation) {\n                const nalUnits = [...iterateNalUnitsInAnnexB(packetData)]\n                    .map(loc => packetData.subarray(loc.offset, loc.offset + loc.length));\n                if (nalUnits.length === 0) {\n                    // It's not valid Annex B data\n                    throw new Error('Failed to transform packet data. Make sure all packets are provided in Annex B format, as'\n                        + ' specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.');\n                }\n                // We don't strip things like SPS or PPS NALUs here, mainly because they can also appear in the middle\n                // of a stream and potentially modify the parameters of it. So, let's just leave them in to be sure.\n                packetData = concatNalUnitsInLengthPrefixed(nalUnits, 4);\n            }\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packetData, timestamp, packet.duration, packet.type);\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async addEncodedAudioPacket(track, packet, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getAudioTrackData(track, packet, meta);\n            let packetData = packet.data;\n            if (trackData.info.requiresAdtsStripping) {\n                const adtsFrame = readAdtsFrameHeader(FileSlice.tempFromBytes(packetData));\n                if (!adtsFrame) {\n                    throw new Error('Expected ADTS frame, didn\\'t get one.');\n                }\n                const headerLength = adtsFrame.crcCheck === null\n                    ? MIN_ADTS_FRAME_HEADER_SIZE\n                    : MAX_ADTS_FRAME_HEADER_SIZE;\n                packetData = packetData.subarray(headerLength);\n            }\n            const timestamp = this.validateAndNormalizeTimestamp(trackData.track, packet.timestamp, packet.type === 'key');\n            const internalSample = this.createSampleForTrack(trackData, packetData, timestamp, packet.duration, packet.type);\n            if (trackData.info.requiresPcmTransformation) {\n                await this.maybePadWithSilence(trackData, timestamp);\n            }\n            await this.registerSample(trackData, internalSample);\n        }\n        finally {\n            release();\n        }\n    }\n    async maybePadWithSilence(trackData, untilTimestamp) {\n        // The PCM transformation assumes that all samples are contiguous. This is not something that is enforced, so\n        // we need to pad the \"holes\" in between samples (and before the first sample) with additional\n        // \"silence samples\".\n        const lastSample = last(trackData.samples);\n        const lastEndTimestamp = lastSample\n            ? lastSample.timestamp + lastSample.duration\n            : 0;\n        const delta = untilTimestamp - lastEndTimestamp;\n        const deltaInTimescale = intoTimescale(delta, trackData.timescale);\n        if (deltaInTimescale > 0) {\n            const { sampleSize, silentValue } = parsePcmCodec(trackData.info.decoderConfig.codec);\n            const samplesNeeded = deltaInTimescale * trackData.info.numberOfChannels;\n            const data = new Uint8Array(sampleSize * samplesNeeded).fill(silentValue);\n            const paddingSample = this.createSampleForTrack(trackData, new Uint8Array(data.buffer), lastEndTimestamp, delta, 'key');\n            await this.registerSample(trackData, paddingSample);\n        }\n    }\n    async addSubtitleCue(track, cue, meta) {\n        const release = await this.mutex.acquire();\n        try {\n            const trackData = this.getSubtitleTrackData(track, meta);\n            this.validateAndNormalizeTimestamp(trackData.track, cue.timestamp, true);\n            if (track.source._codec === 'webvtt') {\n                trackData.cueQueue.push(cue);\n                await this.processWebVTTCues(trackData, cue.timestamp);\n            }\n            else {\n                // TODO\n            }\n        }\n        finally {\n            release();\n        }\n    }\n    async processWebVTTCues(trackData, until) {\n        // WebVTT cues need to undergo special processing as empty sections need to be padded out with samples, and\n        // overlapping samples require special logic. The algorithm produces the format specified in ISO 14496-30.\n        while (trackData.cueQueue.length > 0) {\n            const timestamps = new Set([]);\n            for (const cue of trackData.cueQueue) {\n                assert(cue.timestamp <= until);\n                assert(trackData.lastCueEndTimestamp <= cue.timestamp + cue.duration);\n                timestamps.add(Math.max(cue.timestamp, trackData.lastCueEndTimestamp)); // Start timestamp\n                timestamps.add(cue.timestamp + cue.duration); // End timestamp\n            }\n            const sortedTimestamps = [...timestamps].sort((a, b) => a - b);\n            // These are the timestamps of the next sample we'll create:\n            const sampleStart = sortedTimestamps[0];\n            const sampleEnd = sortedTimestamps[1] ?? sampleStart;\n            if (until < sampleEnd) {\n                break;\n            }\n            // We may need to pad out empty space with an vtte box\n            if (trackData.lastCueEndTimestamp < sampleStart) {\n                this.auxWriter.seek(0);\n                const box = vtte();\n                this.auxBoxWriter.writeBox(box);\n                const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n                const sample = this.createSampleForTrack(trackData, body, trackData.lastCueEndTimestamp, sampleStart - trackData.lastCueEndTimestamp, 'key');\n                await this.registerSample(trackData, sample);\n                trackData.lastCueEndTimestamp = sampleStart;\n            }\n            this.auxWriter.seek(0);\n            for (let i = 0; i < trackData.cueQueue.length; i++) {\n                const cue = trackData.cueQueue[i];\n                if (cue.timestamp >= sampleEnd) {\n                    break;\n                }\n                inlineTimestampRegex.lastIndex = 0;\n                const containsTimestamp = inlineTimestampRegex.test(cue.text);\n                const endTimestamp = cue.timestamp + cue.duration;\n                let sourceId = trackData.cueToSourceId.get(cue);\n                if (sourceId === undefined && sampleEnd < endTimestamp) {\n                    // We know this cue will appear in more than one sample, therefore we need to mark it with a\n                    // unique ID\n                    sourceId = trackData.nextSourceId++;\n                    trackData.cueToSourceId.set(cue, sourceId);\n                }\n                if (cue.notes) {\n                    // Any notes/comments are included in a special vtta box\n                    const box = vtta(cue.notes);\n                    this.auxBoxWriter.writeBox(box);\n                }\n                const box = vttc(cue.text, containsTimestamp ? sampleStart : null, cue.identifier ?? null, cue.settings ?? null, sourceId ?? null);\n                this.auxBoxWriter.writeBox(box);\n                if (endTimestamp === sampleEnd) {\n                    // The cue won't appear in any future sample, so we're done with it\n                    trackData.cueQueue.splice(i--, 1);\n                }\n            }\n            const body = this.auxWriter.getSlice(0, this.auxWriter.getPos());\n            const sample = this.createSampleForTrack(trackData, body, sampleStart, sampleEnd - sampleStart, 'key');\n            await this.registerSample(trackData, sample);\n            trackData.lastCueEndTimestamp = sampleEnd;\n        }\n    }\n    createSampleForTrack(trackData, data, timestamp, duration, type) {\n        const sample = {\n            timestamp,\n            decodeTimestamp: timestamp, // This may be refined later\n            duration,\n            data,\n            size: data.byteLength,\n            type,\n            timescaleUnitsToNextSample: intoTimescale(duration, trackData.timescale), // Will be refined\n        };\n        return sample;\n    }\n    processTimestamps(trackData, nextSample) {\n        if (trackData.timestampProcessingQueue.length === 0) {\n            return;\n        }\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            let totalDuration = 0;\n            // Compute the total duration in the track timescale (which is equal to the amount of PCM audio samples)\n            // and simply say that's how many new samples there are.\n            for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n                const sample = trackData.timestampProcessingQueue[i];\n                const duration = intoTimescale(sample.duration, trackData.timescale);\n                totalDuration += duration;\n            }\n            if (trackData.timeToSampleTable.length === 0) {\n                trackData.timeToSampleTable.push({\n                    sampleCount: totalDuration,\n                    sampleDelta: 1,\n                });\n            }\n            else {\n                const lastEntry = last(trackData.timeToSampleTable);\n                lastEntry.sampleCount += totalDuration;\n            }\n            trackData.timestampProcessingQueue.length = 0;\n            return;\n        }\n        const sortedTimestamps = trackData.timestampProcessingQueue.map(x => x.timestamp).sort((a, b) => a - b);\n        for (let i = 0; i < trackData.timestampProcessingQueue.length; i++) {\n            const sample = trackData.timestampProcessingQueue[i];\n            // Since the user only supplies presentation time, but these may be out of order, we reverse-engineer from\n            // that a sensible decode timestamp. The notion of a decode timestamp doesn't really make sense\n            // (presentation timestamp & decode order are all you need), but it is a concept in ISOBMFF so we need to\n            // model it.\n            sample.decodeTimestamp = sortedTimestamps[i];\n            if (!this.isFragmented && trackData.lastTimescaleUnits === null) {\n                // In non-fragmented files, the first decode timestamp is always zero. If the first presentation\n                // timestamp isn't zero, we'll simply use the composition time offset to achieve it.\n                sample.decodeTimestamp = 0;\n            }\n            const sampleCompositionTimeOffset = intoTimescale(sample.timestamp - sample.decodeTimestamp, trackData.timescale);\n            const durationInTimescale = intoTimescale(sample.duration, trackData.timescale);\n            if (trackData.lastTimescaleUnits !== null) {\n                assert(trackData.lastSample);\n                const timescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n                assert(delta >= 0);\n                trackData.lastTimescaleUnits += delta;\n                trackData.lastSample.timescaleUnitsToNextSample = delta;\n                if (!this.isFragmented) {\n                    let lastTableEntry = last(trackData.timeToSampleTable);\n                    assert(lastTableEntry);\n                    if (lastTableEntry.sampleCount === 1) {\n                        lastTableEntry.sampleDelta = delta;\n                        const entryBefore = trackData.timeToSampleTable[trackData.timeToSampleTable.length - 2];\n                        if (entryBefore && entryBefore.sampleDelta === delta) {\n                            // If the delta is the same as the previous one, merge the two entries\n                            entryBefore.sampleCount++;\n                            trackData.timeToSampleTable.pop();\n                            lastTableEntry = entryBefore;\n                        }\n                    }\n                    else if (lastTableEntry.sampleDelta !== delta) {\n                        // The delta has changed, so we need a new entry to reach the current sample\n                        lastTableEntry.sampleCount--;\n                        trackData.timeToSampleTable.push(lastTableEntry = {\n                            sampleCount: 1,\n                            sampleDelta: delta,\n                        });\n                    }\n                    if (lastTableEntry.sampleDelta === durationInTimescale) {\n                        // The sample's duration matches the delta, so we can increment the count\n                        lastTableEntry.sampleCount++;\n                    }\n                    else {\n                        // Add a new entry in order to maintain the last sample's true duration\n                        trackData.timeToSampleTable.push({\n                            sampleCount: 1,\n                            sampleDelta: durationInTimescale,\n                        });\n                    }\n                    const lastCompositionTimeOffsetTableEntry = last(trackData.compositionTimeOffsetTable);\n                    assert(lastCompositionTimeOffsetTableEntry);\n                    if (lastCompositionTimeOffsetTableEntry.sampleCompositionTimeOffset === sampleCompositionTimeOffset) {\n                        // Simply increment the count\n                        lastCompositionTimeOffsetTableEntry.sampleCount++;\n                    }\n                    else {\n                        // The composition time offset has changed, so create a new entry with the new composition time\n                        // offset\n                        trackData.compositionTimeOffsetTable.push({\n                            sampleCount: 1,\n                            sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                        });\n                    }\n                }\n            }\n            else {\n                // Decode timestamp of the first sample\n                trackData.lastTimescaleUnits = intoTimescale(sample.decodeTimestamp, trackData.timescale, false);\n                if (!this.isFragmented) {\n                    trackData.timeToSampleTable.push({\n                        sampleCount: 1,\n                        sampleDelta: durationInTimescale,\n                    });\n                    trackData.compositionTimeOffsetTable.push({\n                        sampleCount: 1,\n                        sampleCompositionTimeOffset: sampleCompositionTimeOffset,\n                    });\n                }\n            }\n            trackData.lastSample = sample;\n        }\n        trackData.timestampProcessingQueue.length = 0;\n        assert(trackData.lastSample);\n        assert(trackData.lastTimescaleUnits !== null);\n        if (nextSample !== undefined && trackData.lastSample.timescaleUnitsToNextSample === 0) {\n            assert(nextSample.type === 'key');\n            // Given the next sample, we can make a guess about the duration of the last sample. This avoids having\n            // the last sample's duration in each fragment be \"0\" for fragmented files. The guess we make here is\n            // actually correct most of the time, since typically, no delta frame with a lower timestamp follows the key\n            // frame (although it can happen).\n            const timescaleUnits = intoTimescale(nextSample.timestamp, trackData.timescale, false);\n            const delta = Math.round(timescaleUnits - trackData.lastTimescaleUnits);\n            trackData.lastSample.timescaleUnitsToNextSample = delta;\n        }\n    }\n    async registerSample(trackData, sample) {\n        if (sample.type === 'key') {\n            this.processTimestamps(trackData, sample);\n        }\n        trackData.timestampProcessingQueue.push(sample);\n        if (this.isFragmented) {\n            trackData.sampleQueue.push(sample);\n            await this.interleaveSamples();\n        }\n        else if (this.fastStart === 'reserve') {\n            await this.registerSampleFastStartReserve(trackData, sample);\n        }\n        else {\n            await this.addSampleToTrack(trackData, sample);\n        }\n    }\n    async addSampleToTrack(trackData, sample) {\n        if (!this.isFragmented) {\n            trackData.samples.push(sample);\n            if (this.fastStart === 'reserve') {\n                const maximumPacketCount = trackData.track.metadata.maximumPacketCount;\n                assert(maximumPacketCount !== undefined);\n                if (trackData.samples.length > maximumPacketCount) {\n                    throw new Error(`Track #${trackData.track.id} has already reached the maximum packet count`\n                        + ` (${maximumPacketCount}). Either add less packets or increase the maximum packet count.`);\n                }\n            }\n        }\n        let beginNewChunk = false;\n        if (!trackData.currentChunk) {\n            beginNewChunk = true;\n        }\n        else {\n            // Timestamp don't need to be monotonic (think B-frames), so we may need to update the start timestamp of\n            // the chunk\n            trackData.currentChunk.startTimestamp = Math.min(trackData.currentChunk.startTimestamp, sample.timestamp);\n            const currentChunkDuration = sample.timestamp - trackData.currentChunk.startTimestamp;\n            if (this.isFragmented) {\n                // We can only finalize this fragment (and begin a new one) if we know that each track will be able to\n                // start the new one with a key frame.\n                const keyFrameQueuedEverywhere = this.trackDatas.every((otherTrackData) => {\n                    if (trackData === otherTrackData) {\n                        return sample.type === 'key';\n                    }\n                    const firstQueuedSample = otherTrackData.sampleQueue[0];\n                    if (firstQueuedSample) {\n                        return firstQueuedSample.type === 'key';\n                    }\n                    return otherTrackData.track.source._closed;\n                });\n                if (currentChunkDuration >= this.minimumFragmentDuration\n                    && keyFrameQueuedEverywhere\n                    && sample.timestamp > this.maxWrittenTimestamp) {\n                    beginNewChunk = true;\n                    await this.finalizeFragment();\n                }\n            }\n            else {\n                beginNewChunk = currentChunkDuration >= 0.5; // Chunk is long enough, we need a new one\n            }\n        }\n        if (beginNewChunk) {\n            if (trackData.currentChunk) {\n                await this.finalizeCurrentChunk(trackData);\n            }\n            trackData.currentChunk = {\n                startTimestamp: sample.timestamp,\n                samples: [],\n                offset: null,\n                moofOffset: null,\n            };\n        }\n        assert(trackData.currentChunk);\n        trackData.currentChunk.samples.push(sample);\n        if (this.isFragmented) {\n            this.maxWrittenTimestamp = Math.max(this.maxWrittenTimestamp, sample.timestamp);\n        }\n    }\n    async finalizeCurrentChunk(trackData) {\n        assert(!this.isFragmented);\n        if (!trackData.currentChunk)\n            return;\n        trackData.finalizedChunks.push(trackData.currentChunk);\n        this.finalizedChunks.push(trackData.currentChunk);\n        let sampleCount = trackData.currentChunk.samples.length;\n        if (trackData.type === 'audio' && trackData.info.requiresPcmTransformation) {\n            sampleCount = trackData.currentChunk.samples\n                .reduce((acc, sample) => acc + intoTimescale(sample.duration, trackData.timescale), 0);\n        }\n        if (trackData.compactlyCodedChunkTable.length === 0\n            || last(trackData.compactlyCodedChunkTable).samplesPerChunk !== sampleCount) {\n            trackData.compactlyCodedChunkTable.push({\n                firstChunk: trackData.finalizedChunks.length, // 1-indexed\n                samplesPerChunk: sampleCount,\n            });\n        }\n        if (this.fastStart === 'in-memory') {\n            trackData.currentChunk.offset = 0; // We'll compute the proper offset when finalizing\n            return;\n        }\n        // Write out the data\n        trackData.currentChunk.offset = this.writer.getPos();\n        for (const sample of trackData.currentChunk.samples) {\n            assert(sample.data);\n            this.writer.write(sample.data);\n            sample.data = null; // Can be GC'd\n        }\n        await this.writer.flush();\n    }\n    async interleaveSamples(isFinalCall = false) {\n        assert(this.isFragmented);\n        if (!isFinalCall && !this.allTracksAreKnown()) {\n            return; // We can't interleave yet as we don't yet know how many tracks we'll truly have\n        }\n        outer: while (true) {\n            let trackWithMinTimestamp = null;\n            let minTimestamp = Infinity;\n            for (const trackData of this.trackDatas) {\n                if (!isFinalCall && trackData.sampleQueue.length === 0 && !trackData.track.source._closed) {\n                    break outer;\n                }\n                if (trackData.sampleQueue.length > 0 && trackData.sampleQueue[0].timestamp < minTimestamp) {\n                    trackWithMinTimestamp = trackData;\n                    minTimestamp = trackData.sampleQueue[0].timestamp;\n                }\n            }\n            if (!trackWithMinTimestamp) {\n                break;\n            }\n            const sample = trackWithMinTimestamp.sampleQueue.shift();\n            await this.addSampleToTrack(trackWithMinTimestamp, sample);\n        }\n    }\n    async finalizeFragment(flushWriter = true) {\n        assert(this.isFragmented);\n        const fragmentNumber = this.nextFragmentNumber++;\n        if (fragmentNumber === 1) {\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            // Write the moov box now that we have all decoder configs\n            const movieBox = moov(this);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        // Not all tracks need to be present in every fragment\n        const tracksInFragment = this.trackDatas.filter(x => x.currentChunk);\n        // Create an initial moof box and measure it; we need this to know where the following mdat box will begin\n        const moofBox = moof(fragmentNumber, tracksInFragment);\n        const moofOffset = this.writer.getPos();\n        const mdatStartPos = moofOffset + this.boxWriter.measureBox(moofBox);\n        let currentPos = mdatStartPos + MIN_BOX_HEADER_SIZE;\n        let fragmentStartTimestamp = Infinity;\n        for (const trackData of tracksInFragment) {\n            trackData.currentChunk.offset = currentPos;\n            trackData.currentChunk.moofOffset = moofOffset;\n            for (const sample of trackData.currentChunk.samples) {\n                currentPos += sample.size;\n            }\n            fragmentStartTimestamp = Math.min(fragmentStartTimestamp, trackData.currentChunk.startTimestamp);\n        }\n        const mdatSize = currentPos - mdatStartPos;\n        const needsLargeMdatSize = mdatSize >= 2 ** 32;\n        if (needsLargeMdatSize) {\n            // Shift all offsets by 8. Previously, all chunks were shifted assuming the large box size, but due to what\n            // I suspect is a bug in WebKit, it failed in Safari (when livestreaming with MSE, not for static playback).\n            for (const trackData of tracksInFragment) {\n                trackData.currentChunk.offset += MAX_BOX_HEADER_SIZE - MIN_BOX_HEADER_SIZE;\n            }\n        }\n        if (this.format._options.onMoof) {\n            this.writer.startTrackingWrites();\n        }\n        const newMoofBox = moof(fragmentNumber, tracksInFragment);\n        this.boxWriter.writeBox(newMoofBox);\n        if (this.format._options.onMoof) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMoof(data, start, fragmentStartTimestamp);\n        }\n        assert(this.writer.getPos() === mdatStartPos);\n        if (this.format._options.onMdat) {\n            this.writer.startTrackingWrites();\n        }\n        const mdatBox = mdat(needsLargeMdatSize);\n        mdatBox.size = mdatSize;\n        this.boxWriter.writeBox(mdatBox);\n        this.writer.seek(mdatStartPos + (needsLargeMdatSize ? MAX_BOX_HEADER_SIZE : MIN_BOX_HEADER_SIZE));\n        // Write sample data\n        for (const trackData of tracksInFragment) {\n            for (const sample of trackData.currentChunk.samples) {\n                this.writer.write(sample.data);\n                sample.data = null; // Can be GC'd\n            }\n        }\n        if (this.format._options.onMdat) {\n            const { data, start } = this.writer.stopTrackingWrites();\n            this.format._options.onMdat(data, start);\n        }\n        for (const trackData of tracksInFragment) {\n            trackData.finalizedChunks.push(trackData.currentChunk);\n            this.finalizedChunks.push(trackData.currentChunk);\n            trackData.currentChunk = null;\n        }\n        if (flushWriter) {\n            await this.writer.flush();\n        }\n    }\n    async registerSampleFastStartReserve(trackData, sample) {\n        if (this.allTracksAreKnown()) {\n            if (!this.mdat) {\n                // We finally know all tracks, let's reserve space for the moov box\n                const moovBox = moov(this);\n                const moovSize = this.boxWriter.measureBox(moovBox);\n                const reservedSize = moovSize\n                    + this.computeSampleTableSizeUpperBound()\n                    + 4096; // Just a little extra headroom\n                assert(this.ftypSize !== null);\n                this.writer.seek(this.ftypSize + reservedSize);\n                if (this.format._options.onMdat) {\n                    this.writer.startTrackingWrites();\n                }\n                this.mdat = mdat(true);\n                this.boxWriter.writeBox(this.mdat);\n                // Now write everything that was queued\n                for (const trackData of this.trackDatas) {\n                    for (const sample of trackData.sampleQueue) {\n                        await this.addSampleToTrack(trackData, sample);\n                    }\n                    trackData.sampleQueue.length = 0;\n                }\n            }\n            await this.addSampleToTrack(trackData, sample);\n        }\n        else {\n            // Queue it for when we know all tracks\n            trackData.sampleQueue.push(sample);\n        }\n    }\n    computeSampleTableSizeUpperBound() {\n        assert(this.fastStart === 'reserve');\n        let upperBound = 0;\n        for (const trackData of this.trackDatas) {\n            const n = trackData.track.metadata.maximumPacketCount;\n            assert(n !== undefined); // We validated this earlier\n            // Given the max allowed packet count, compute the space they'll take up in the Sample Table Box, assuming\n            // the worst case for each individual box:\n            // stts box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4) * Math.ceil(2 / 3 * n);\n            // stss box - 1 entry per sample\n            upperBound += 4 * n;\n            // ctts box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4) * Math.ceil(2 / 3 * n);\n            // stsc box - since it is compactly coded, the maximum length of this table will be 2/3n\n            upperBound += (4 + 4 + 4) * Math.ceil(2 / 3 * n);\n            // stsz box - 1 entry per sample\n            upperBound += 4 * n;\n            // co64 box - we assume 1 sample per chunk and 64-bit chunk offsets (co64 instead of stco)\n            upperBound += 8 * n;\n        }\n        return upperBound;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    async onTrackClose(track) {\n        const release = await this.mutex.acquire();\n        if (track.type === 'subtitle' && track.source._codec === 'webvtt') {\n            const trackData = this.trackDatas.find(x => x.track === track);\n            if (trackData) {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.allTracksAreKnown()) {\n            this.allTracksKnown.resolve();\n        }\n        if (this.isFragmented) {\n            // Since a track is now closed, we may be able to write out chunks that were previously waiting\n            await this.interleaveSamples();\n        }\n        release();\n    }\n    /** Finalizes the file, making it ready for use. Must be called after all video and audio chunks have been added. */\n    async finalize() {\n        const release = await this.mutex.acquire();\n        this.allTracksKnown.resolve();\n        for (const trackData of this.trackDatas) {\n            if (trackData.type === 'subtitle' && trackData.track.source._codec === 'webvtt') {\n                await this.processWebVTTCues(trackData, Infinity);\n            }\n        }\n        if (this.isFragmented) {\n            await this.interleaveSamples(true);\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n            }\n            await this.finalizeFragment(false); // Don't flush the last fragment as we will flush it with the mfra box\n        }\n        else {\n            for (const trackData of this.trackDatas) {\n                this.processTimestamps(trackData);\n                await this.finalizeCurrentChunk(trackData);\n            }\n        }\n        if (this.fastStart === 'in-memory') {\n            this.mdat = mdat(false);\n            let mdatSize;\n            // We know how many chunks there are, but computing the chunk positions requires an iterative approach:\n            // In order to know where the first chunk should go, we first need to know the size of the moov box. But we\n            // cannot write a proper moov box without first knowing all chunk positions. So, we generate a tentative\n            // moov box with placeholder values (0) for the chunk offsets to be able to compute its size. If it then\n            // turns out that appending all chunks exceeds 4 GiB, we need to repeat this process, now with the co64 box\n            // being used in the moov box instead, which will make it larger. After that, we definitely know the final\n            // size of the moov box and can compute the proper chunk positions.\n            for (let i = 0; i < 2; i++) {\n                const movieBox = moov(this);\n                const movieBoxSize = this.boxWriter.measureBox(movieBox);\n                mdatSize = this.boxWriter.measureBox(this.mdat);\n                let currentChunkPos = this.writer.getPos() + movieBoxSize + mdatSize;\n                for (const chunk of this.finalizedChunks) {\n                    chunk.offset = currentChunkPos;\n                    for (const { data } of chunk.samples) {\n                        assert(data);\n                        currentChunkPos += data.byteLength;\n                        mdatSize += data.byteLength;\n                    }\n                }\n                if (currentChunkPos < 2 ** 32)\n                    break;\n                if (mdatSize >= 2 ** 32)\n                    this.mdat.largeSize = true;\n            }\n            if (this.format._options.onMoov) {\n                this.writer.startTrackingWrites();\n            }\n            const movieBox = moov(this);\n            this.boxWriter.writeBox(movieBox);\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n            if (this.format._options.onMdat) {\n                this.writer.startTrackingWrites();\n            }\n            this.mdat.size = mdatSize;\n            this.boxWriter.writeBox(this.mdat);\n            for (const chunk of this.finalizedChunks) {\n                for (const sample of chunk.samples) {\n                    assert(sample.data);\n                    this.writer.write(sample.data);\n                    sample.data = null;\n                }\n            }\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n        }\n        else if (this.isFragmented) {\n            // Append the mfra box to the end of the file for better random access\n            const startPos = this.writer.getPos();\n            const mfraBox = mfra(this.trackDatas);\n            this.boxWriter.writeBox(mfraBox);\n            // Patch the 'size' field of the mfro box at the end of the mfra box now that we know its actual size\n            const mfraBoxSize = this.writer.getPos() - startPos;\n            this.writer.seek(this.writer.getPos() - 4);\n            this.boxWriter.writeU32(mfraBoxSize);\n        }\n        else {\n            assert(this.mdat);\n            const mdatPos = this.boxWriter.offsets.get(this.mdat);\n            assert(mdatPos !== undefined);\n            const mdatSize = this.writer.getPos() - mdatPos;\n            this.mdat.size = mdatSize;\n            this.mdat.largeSize = mdatSize >= 2 ** 32; // Only use the large size if we need it\n            this.boxWriter.patchBox(this.mdat);\n            if (this.format._options.onMdat) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMdat(data, start);\n            }\n            const movieBox = moov(this);\n            if (this.fastStart === 'reserve') {\n                assert(this.ftypSize !== null);\n                this.writer.seek(this.ftypSize);\n                if (this.format._options.onMoov) {\n                    this.writer.startTrackingWrites();\n                }\n                this.boxWriter.writeBox(movieBox);\n                // Fill the remaining space with a free box. If there are less than 8 bytes left, sucks I guess\n                const remainingSpace = this.boxWriter.offsets.get(this.mdat) - this.writer.getPos();\n                this.boxWriter.writeBox(free(remainingSpace));\n            }\n            else {\n                if (this.format._options.onMoov) {\n                    this.writer.startTrackingWrites();\n                }\n                this.boxWriter.writeBox(movieBox);\n            }\n            if (this.format._options.onMoov) {\n                const { data, start } = this.writer.stopTrackingWrites();\n                this.format._options.onMoov(data, start);\n            }\n        }\n        release();\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AdtsMuxer } from './adts/adts-muxer.js';\nimport { AUDIO_CODECS, NON_PCM_AUDIO_CODECS, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { FlacMuxer } from './flac/flac-muxer.js';\nimport { IsobmffMuxer } from './isobmff/isobmff-muxer.js';\nimport { MatroskaMuxer } from './matroska/matroska-muxer.js';\nimport { Mp3Muxer } from './mp3/mp3-muxer.js';\nimport { OggMuxer } from './ogg/ogg-muxer.js';\nimport { MpegTsMuxer } from './mpeg-ts/mpeg-ts-muxer.js';\nimport { WaveMuxer } from './wave/wave-muxer.js';\n/**\n * Base class representing an output media file format.\n * @group Output formats\n * @public\n */\nexport class OutputFormat {\n    /** Returns a list of video codecs that this output format can contain. */\n    getSupportedVideoCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => VIDEO_CODECS.includes(codec));\n    }\n    /** Returns a list of audio codecs that this output format can contain. */\n    getSupportedAudioCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => AUDIO_CODECS.includes(codec));\n    }\n    /** Returns a list of subtitle codecs that this output format can contain. */\n    getSupportedSubtitleCodecs() {\n        return this.getSupportedCodecs()\n            .filter(codec => SUBTITLE_CODECS.includes(codec));\n    }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _codecUnsupportedHint(codec) {\n        return '';\n    }\n}\n/**\n * Format representing files compatible with the ISO base media file format (ISOBMFF), like MP4 or MOV files.\n * @group Output formats\n * @public\n */\nexport class IsobmffOutputFormat extends OutputFormat {\n    /** Internal constructor. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.fastStart !== undefined\n            && ![false, 'in-memory', 'reserve', 'fragmented'].includes(options.fastStart)) {\n            throw new TypeError('options.fastStart, when provided, must be false, \\'in-memory\\', \\'reserve\\', or \\'fragmented\\'.');\n        }\n        if (options.minimumFragmentDuration !== undefined\n            && (!Number.isFinite(options.minimumFragmentDuration) || options.minimumFragmentDuration < 0)) {\n            throw new TypeError('options.minimumFragmentDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onFtyp !== undefined && typeof options.onFtyp !== 'function') {\n            throw new TypeError('options.onFtyp, when provided, must be a function.');\n        }\n        if (options.onMoov !== undefined && typeof options.onMoov !== 'function') {\n            throw new TypeError('options.onMoov, when provided, must be a function.');\n        }\n        if (options.onMdat !== undefined && typeof options.onMdat !== 'function') {\n            throw new TypeError('options.onMdat, when provided, must be a function.');\n        }\n        if (options.onMoof !== undefined && typeof options.onMoof !== 'function') {\n            throw new TypeError('options.onMoof, when provided, must be a function.');\n        }\n        if (options.metadataFormat !== undefined\n            && !['mdir', 'mdta', 'udta', 'auto'].includes(options.metadataFormat)) {\n            throw new TypeError('options.metadataFormat, when provided, must be either \\'auto\\', \\'mdir\\', \\'mdta\\', or \\'udta\\'.');\n        }\n        super();\n        this._options = options;\n    }\n    getSupportedTrackCounts() {\n        const max = 2 ** 32 - 1; // Have fun reaching this one\n        return {\n            video: { min: 0, max },\n            audio: { min: 0, max },\n            subtitle: { min: 0, max },\n            total: { min: 1, max },\n        };\n    }\n    get supportsVideoRotationMetadata() {\n        return true;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new IsobmffMuxer(output, this);\n    }\n}\n/**\n * MPEG-4 Part 14 (MP4) file format. Supports most codecs.\n * @group Output formats\n * @public\n */\nexport class Mp4OutputFormat extends IsobmffOutputFormat {\n    /** Creates a new {@link Mp4OutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    /** @internal */\n    get _name() {\n        return 'MP4';\n    }\n    get fileExtension() {\n        return '.mp4';\n    }\n    get mimeType() {\n        return 'video/mp4';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...NON_PCM_AUDIO_CODECS,\n            // These are supported via ISO/IEC 23003-5\n            'pcm-s16',\n            'pcm-s16be',\n            'pcm-s24',\n            'pcm-s24be',\n            'pcm-s32',\n            'pcm-s32be',\n            'pcm-f32',\n            'pcm-f32be',\n            'pcm-f64',\n            'pcm-f64be',\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MovOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MOV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * QuickTime File Format (QTFF), often called MOV. Supports all video and audio codecs, but not subtitle codecs.\n * @group Output formats\n * @public\n */\nexport class MovOutputFormat extends IsobmffOutputFormat {\n    /** Creates a new {@link MovOutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    /** @internal */\n    get _name() {\n        return 'MOV';\n    }\n    get fileExtension() {\n        return '.mov';\n    }\n    get mimeType() {\n        return 'video/quicktime';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...AUDIO_CODECS,\n        ];\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new Mp4OutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MP4 will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * Matroska file format.\n *\n * Supports writing transparent video. For a video track to be marked as transparent, the first packet added must\n * contain alpha side data.\n *\n * @group Output formats\n * @public\n */\nexport class MkvOutputFormat extends OutputFormat {\n    /** Creates a new {@link MkvOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.appendOnly !== undefined && typeof options.appendOnly !== 'boolean') {\n            throw new TypeError('options.appendOnly, when provided, must be a boolean.');\n        }\n        if (options.minimumClusterDuration !== undefined\n            && (!Number.isFinite(options.minimumClusterDuration) || options.minimumClusterDuration < 0)) {\n            throw new TypeError('options.minimumClusterDuration, when provided, must be a non-negative number.');\n        }\n        if (options.onEbmlHeader !== undefined && typeof options.onEbmlHeader !== 'function') {\n            throw new TypeError('options.onEbmlHeader, when provided, must be a function.');\n        }\n        if (options.onSegmentHeader !== undefined && typeof options.onSegmentHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        if (options.onCluster !== undefined && typeof options.onCluster !== 'function') {\n            throw new TypeError('options.onCluster, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new MatroskaMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Matroska';\n    }\n    getSupportedTrackCounts() {\n        const max = 127;\n        return {\n            video: { min: 0, max },\n            audio: { min: 0, max },\n            subtitle: { min: 0, max },\n            total: { min: 1, max },\n        };\n    }\n    get fileExtension() {\n        return '.mkv';\n    }\n    get mimeType() {\n        return 'video/x-matroska';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS,\n            ...NON_PCM_AUDIO_CODECS,\n            ...PCM_AUDIO_CODECS.filter(codec => !['pcm-s8', 'pcm-f32be', 'pcm-f64be', 'ulaw', 'alaw'].includes(codec)),\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        // While it technically does support it with ProjectionPoseRoll, many players appear to ignore this value\n        return false;\n    }\n}\n/**\n * WebM file format, based on Matroska.\n *\n * Supports writing transparent video. For a video track to be marked as transparent, the first packet added must\n * contain alpha side data.\n *\n * @group Output formats\n * @public\n */\nexport class WebMOutputFormat extends MkvOutputFormat {\n    /** Creates a new {@link WebMOutputFormat} configured with the specified `options`. */\n    constructor(options) {\n        super(options);\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS.filter(codec => ['vp8', 'vp9', 'av1'].includes(codec)),\n            ...AUDIO_CODECS.filter(codec => ['opus', 'vorbis'].includes(codec)),\n            ...SUBTITLE_CODECS,\n        ];\n    }\n    /** @internal */\n    get _name() {\n        return 'WebM';\n    }\n    get fileExtension() {\n        return '.webm';\n    }\n    get mimeType() {\n        return 'video/webm';\n    }\n    /** @internal */\n    _codecUnsupportedHint(codec) {\n        if (new MkvOutputFormat().getSupportedCodecs().includes(codec)) {\n            return ' Switching to MKV will grant support for this codec.';\n        }\n        return '';\n    }\n}\n/**\n * MP3 file format.\n * @group Output formats\n * @public\n */\nexport class Mp3OutputFormat extends OutputFormat {\n    /** Creates a new {@link Mp3OutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.xingHeader !== undefined && typeof options.xingHeader !== 'boolean') {\n            throw new TypeError('options.xingHeader, when provided, must be a boolean.');\n        }\n        if (options.onXingFrame !== undefined && typeof options.onXingFrame !== 'function') {\n            throw new TypeError('options.onXingFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new Mp3Muxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'MP3';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.mp3';\n    }\n    get mimeType() {\n        return 'audio/mpeg';\n    }\n    getSupportedCodecs() {\n        return ['mp3'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * WAVE file format, based on RIFF.\n * @group Output formats\n * @public\n */\nexport class WavOutputFormat extends OutputFormat {\n    /** Creates a new {@link WavOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.large !== undefined && typeof options.large !== 'boolean') {\n            throw new TypeError('options.large, when provided, must be a boolean.');\n        }\n        if (options.metadataFormat !== undefined && !['info', 'id3'].includes(options.metadataFormat)) {\n            throw new TypeError('options.metadataFormat, when provided, must be either \\'info\\' or \\'id3\\'.');\n        }\n        if (options.onHeader !== undefined && typeof options.onHeader !== 'function') {\n            throw new TypeError('options.onHeader, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new WaveMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'WAVE';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.wav';\n    }\n    get mimeType() {\n        return 'audio/wav';\n    }\n    getSupportedCodecs() {\n        return [\n            ...PCM_AUDIO_CODECS.filter(codec => ['pcm-s16', 'pcm-s24', 'pcm-s32', 'pcm-f32', 'pcm-u8', 'ulaw', 'alaw'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * Ogg file format.\n * @group Output formats\n * @public\n */\nexport class OggOutputFormat extends OutputFormat {\n    /** Creates a new {@link OggOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.maximumPageDuration !== undefined\n            && (!Number.isFinite(options.maximumPageDuration) || options.maximumPageDuration <= 0)) {\n            throw new TypeError('options.maximumPageDuration, when provided, must be a positive number.');\n        }\n        if (options.onPage !== undefined && typeof options.onPage !== 'function') {\n            throw new TypeError('options.onPage, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new OggMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'Ogg';\n    }\n    getSupportedTrackCounts() {\n        const max = 2 ** 32; // Have fun reaching this one\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 0, max },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max },\n        };\n    }\n    get fileExtension() {\n        return '.ogg';\n    }\n    get mimeType() {\n        return 'application/ogg';\n    }\n    getSupportedCodecs() {\n        return [\n            ...AUDIO_CODECS.filter(codec => ['vorbis', 'opus'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * ADTS file format.\n * @group Output formats\n * @public\n */\nexport class AdtsOutputFormat extends OutputFormat {\n    /** Creates a new {@link AdtsOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onFrame !== undefined && typeof options.onFrame !== 'function') {\n            throw new TypeError('options.onFrame, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new AdtsMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'ADTS';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.aac';\n    }\n    get mimeType() {\n        return 'audio/aac';\n    }\n    getSupportedCodecs() {\n        return ['aac'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * FLAC file format.\n * @group Output formats\n * @public\n */\nexport class FlacOutputFormat extends OutputFormat {\n    /** Creates a new {@link FlacOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new FlacMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'FLAC';\n    }\n    getSupportedTrackCounts() {\n        return {\n            video: { min: 0, max: 0 },\n            audio: { min: 1, max: 1 },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: 1 },\n        };\n    }\n    get fileExtension() {\n        return '.flac';\n    }\n    get mimeType() {\n        return 'audio/flac';\n    }\n    getSupportedCodecs() {\n        return ['flac'];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n/**\n * MPEG Transport Stream file format.\n * @group Output formats\n * @public\n */\nexport class MpegTsOutputFormat extends OutputFormat {\n    /** Creates a new {@link MpegTsOutputFormat} configured with the specified `options`. */\n    constructor(options = {}) {\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (options.onPacket !== undefined && typeof options.onPacket !== 'function') {\n            throw new TypeError('options.onPacket, when provided, must be a function.');\n        }\n        super();\n        this._options = options;\n    }\n    /** @internal */\n    _createMuxer(output) {\n        return new MpegTsMuxer(output, this);\n    }\n    /** @internal */\n    get _name() {\n        return 'MPEG-TS';\n    }\n    getSupportedTrackCounts() {\n        const maxVideo = 16; // Stream IDs 0xE0-0xEF\n        const maxAudio = 32;\n        const maxTotal = maxVideo + maxAudio;\n        return {\n            video: { min: 0, max: maxVideo },\n            audio: { min: 0, max: maxAudio },\n            subtitle: { min: 0, max: 0 },\n            total: { min: 1, max: maxTotal },\n        };\n    }\n    get fileExtension() {\n        return '.ts';\n    }\n    get mimeType() {\n        return 'video/MP2T';\n    }\n    getSupportedCodecs() {\n        return [\n            ...VIDEO_CODECS.filter(codec => ['avc', 'hevc'].includes(codec)),\n            ...AUDIO_CODECS.filter(codec => ['aac', 'mp3'].includes(codec)),\n        ];\n    }\n    get supportsVideoRotationMetadata() {\n        return false;\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AUDIO_CODECS, buildAudioCodecString, buildVideoCodecString, getAudioEncoderConfigExtension, getVideoEncoderConfigExtension, inferCodecFromCodecString, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { customAudioEncoders, customVideoEncoders } from './custom-coder.js';\nimport { isFirefox } from './misc.js';\nexport const validateVideoEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!VIDEO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid video codec '${config.codec}'. Must be one of: ${VIDEO_CODECS.join(', ')}.`);\n    }\n    if (!(config.bitrate instanceof Quality) && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate must be a positive integer or a quality.');\n    }\n    if (config.keyFrameInterval !== undefined\n        && (!Number.isFinite(config.keyFrameInterval) || config.keyFrameInterval < 0)) {\n        throw new TypeError('config.keyFrameInterval, when provided, must be a non-negative number.');\n    }\n    if (config.sizeChangeBehavior !== undefined\n        && !['deny', 'passThrough', 'fill', 'contain', 'cover'].includes(config.sizeChangeBehavior)) {\n        throw new TypeError('config.sizeChangeBehavior, when provided, must be \\'deny\\', \\'passThrough\\', \\'fill\\', \\'contain\\''\n            + ' or \\'cover\\'.');\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n    validateVideoEncodingAdditionalOptions(config.codec, config);\n};\nexport const validateVideoEncodingAdditionalOptions = (codec, options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('Encoding options must be an object.');\n    }\n    if (options.alpha !== undefined && !['discard', 'keep'].includes(options.alpha)) {\n        throw new TypeError('options.alpha, when provided, must be \\'discard\\' or \\'keep\\'.');\n    }\n    if (options.bitrateMode !== undefined && !['constant', 'variable'].includes(options.bitrateMode)) {\n        throw new TypeError('bitrateMode, when provided, must be \\'constant\\' or \\'variable\\'.');\n    }\n    if (options.latencyMode !== undefined && !['quality', 'realtime'].includes(options.latencyMode)) {\n        throw new TypeError('latencyMode, when provided, must be \\'quality\\' or \\'realtime\\'.');\n    }\n    if (options.fullCodecString !== undefined && typeof options.fullCodecString !== 'string') {\n        throw new TypeError('fullCodecString, when provided, must be a string.');\n    }\n    if (options.fullCodecString !== undefined && inferCodecFromCodecString(options.fullCodecString) !== codec) {\n        throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${codec}).`);\n    }\n    if (options.hardwareAcceleration !== undefined\n        && !['no-preference', 'prefer-hardware', 'prefer-software'].includes(options.hardwareAcceleration)) {\n        throw new TypeError('hardwareAcceleration, when provided, must be \\'no-preference\\', \\'prefer-hardware\\' or'\n            + ' \\'prefer-software\\'.');\n    }\n    if (options.scalabilityMode !== undefined && typeof options.scalabilityMode !== 'string') {\n        throw new TypeError('scalabilityMode, when provided, must be a string.');\n    }\n    if (options.contentHint !== undefined && typeof options.contentHint !== 'string') {\n        throw new TypeError('contentHint, when provided, must be a string.');\n    }\n};\nexport const buildVideoEncoderConfig = (options) => {\n    const resolvedBitrate = options.bitrate instanceof Quality\n        ? options.bitrate._toVideoBitrate(options.codec, options.width, options.height)\n        : options.bitrate;\n    return {\n        codec: options.fullCodecString ?? buildVideoCodecString(options.codec, options.width, options.height, resolvedBitrate),\n        width: options.width,\n        height: options.height,\n        bitrate: resolvedBitrate,\n        bitrateMode: options.bitrateMode,\n        alpha: options.alpha ?? 'discard',\n        framerate: options.framerate,\n        latencyMode: options.latencyMode,\n        hardwareAcceleration: options.hardwareAcceleration,\n        scalabilityMode: options.scalabilityMode,\n        contentHint: options.contentHint,\n        ...getVideoEncoderConfigExtension(options.codec),\n    };\n};\nexport const validateAudioEncodingConfig = (config) => {\n    if (!config || typeof config !== 'object') {\n        throw new TypeError('Encoding config must be an object.');\n    }\n    if (!AUDIO_CODECS.includes(config.codec)) {\n        throw new TypeError(`Invalid audio codec '${config.codec}'. Must be one of: ${AUDIO_CODECS.join(', ')}.`);\n    }\n    if (config.bitrate === undefined\n        && (!PCM_AUDIO_CODECS.includes(config.codec) || config.codec === 'flac')) {\n        throw new TypeError('config.bitrate must be provided for compressed audio codecs.');\n    }\n    if (config.bitrate !== undefined\n        && !(config.bitrate instanceof Quality)\n        && (!Number.isInteger(config.bitrate) || config.bitrate <= 0)) {\n        throw new TypeError('config.bitrate, when provided, must be a positive integer or a quality.');\n    }\n    if (config.onEncodedPacket !== undefined && typeof config.onEncodedPacket !== 'function') {\n        throw new TypeError('config.onEncodedChunk, when provided, must be a function.');\n    }\n    if (config.onEncoderConfig !== undefined && typeof config.onEncoderConfig !== 'function') {\n        throw new TypeError('config.onEncoderConfig, when provided, must be a function.');\n    }\n    validateAudioEncodingAdditionalOptions(config.codec, config);\n};\nexport const validateAudioEncodingAdditionalOptions = (codec, options) => {\n    if (!options || typeof options !== 'object') {\n        throw new TypeError('Encoding options must be an object.');\n    }\n    if (options.bitrateMode !== undefined && !['constant', 'variable'].includes(options.bitrateMode)) {\n        throw new TypeError('bitrateMode, when provided, must be \\'constant\\' or \\'variable\\'.');\n    }\n    if (options.fullCodecString !== undefined && typeof options.fullCodecString !== 'string') {\n        throw new TypeError('fullCodecString, when provided, must be a string.');\n    }\n    if (options.fullCodecString !== undefined && inferCodecFromCodecString(options.fullCodecString) !== codec) {\n        throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${codec}).`);\n    }\n};\nexport const buildAudioEncoderConfig = (options) => {\n    const resolvedBitrate = options.bitrate instanceof Quality\n        ? options.bitrate._toAudioBitrate(options.codec)\n        : options.bitrate;\n    return {\n        codec: options.fullCodecString ?? buildAudioCodecString(options.codec, options.numberOfChannels, options.sampleRate),\n        numberOfChannels: options.numberOfChannels,\n        sampleRate: options.sampleRate,\n        bitrate: resolvedBitrate,\n        bitrateMode: options.bitrateMode,\n        ...getAudioEncoderConfigExtension(options.codec),\n    };\n};\n/**\n * Represents a subjective media quality level.\n * @group Encoding\n * @public\n */\nexport class Quality {\n    /** @internal */\n    constructor(factor) {\n        this._factor = factor;\n    }\n    /** @internal */\n    _toVideoBitrate(codec, width, height) {\n        const pixels = width * height;\n        const codecEfficiencyFactors = {\n            avc: 1.0, // H.264/AVC (baseline)\n            hevc: 0.6, // H.265/HEVC (~40% more efficient than AVC)\n            vp9: 0.6, // Similar to HEVC\n            av1: 0.4, // ~60% more efficient than AVC\n            vp8: 1.2, // Slightly less efficient than AVC\n        };\n        const referencePixels = 1920 * 1080;\n        const referenceBitrate = 3000000;\n        const scaleFactor = Math.pow(pixels / referencePixels, 0.95); // Slight non-linear scaling\n        const baseBitrate = referenceBitrate * scaleFactor;\n        const codecAdjustedBitrate = baseBitrate * codecEfficiencyFactors[codec];\n        const finalBitrate = codecAdjustedBitrate * this._factor;\n        return Math.ceil(finalBitrate / 1000) * 1000;\n    }\n    /** @internal */\n    _toAudioBitrate(codec) {\n        if (PCM_AUDIO_CODECS.includes(codec) || codec === 'flac') {\n            return undefined;\n        }\n        const baseRates = {\n            aac: 128000, // 128kbps base for AAC\n            opus: 64000, // 64kbps base for Opus\n            mp3: 160000, // 160kbps base for MP3\n            vorbis: 64000, // 64kbps base for Vorbis\n        };\n        const baseBitrate = baseRates[codec];\n        if (!baseBitrate) {\n            throw new Error(`Unhandled codec: ${codec}`);\n        }\n        let finalBitrate = baseBitrate * this._factor;\n        if (codec === 'aac') {\n            // AAC only works with specific bitrates, let's find the closest\n            const validRates = [96000, 128000, 160000, 192000];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        else if (codec === 'opus' || codec === 'vorbis') {\n            finalBitrate = Math.max(6000, finalBitrate);\n        }\n        else if (codec === 'mp3') {\n            const validRates = [\n                8000, 16000, 24000, 32000, 40000, 48000, 64000, 80000,\n                96000, 112000, 128000, 160000, 192000, 224000, 256000, 320000,\n            ];\n            finalBitrate = validRates.reduce((prev, curr) => Math.abs(curr - finalBitrate) < Math.abs(prev - finalBitrate) ? curr : prev);\n        }\n        return Math.round(finalBitrate / 1000) * 1000;\n    }\n}\n/**\n * Represents a very low media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_VERY_LOW = /* #__PURE__ */ new Quality(0.3);\n/**\n * Represents a low media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_LOW = /* #__PURE__ */ new Quality(0.6);\n/**\n * Represents a medium media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_MEDIUM = /* #__PURE__ */ new Quality(1);\n/**\n * Represents a high media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_HIGH = /* #__PURE__ */ new Quality(2);\n/**\n * Represents a very high media quality.\n * @group Encoding\n * @public\n */\nexport const QUALITY_VERY_HIGH = /* #__PURE__ */ new Quality(4);\n/**\n * Checks if the browser is able to encode the given codec.\n * @group Encoding\n * @public\n */\nexport const canEncode = (codec) => {\n    if (VIDEO_CODECS.includes(codec)) {\n        return canEncodeVideo(codec);\n    }\n    else if (AUDIO_CODECS.includes(codec)) {\n        return canEncodeAudio(codec);\n    }\n    else if (SUBTITLE_CODECS.includes(codec)) {\n        return canEncodeSubtitles(codec);\n    }\n    throw new TypeError(`Unknown codec '${codec}'.`);\n};\n/**\n * Checks if the browser is able to encode the given video codec with the given parameters.\n * @group Encoding\n * @public\n */\nexport const canEncodeVideo = async (codec, options = {}) => {\n    const { width = 1280, height = 720, bitrate = 1e6, ...restOptions } = options;\n    if (!VIDEO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(width) || width <= 0) {\n        throw new TypeError('width must be a positive integer.');\n    }\n    if (!Number.isInteger(height) || height <= 0) {\n        throw new TypeError('height must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer or a quality.');\n    }\n    validateVideoEncodingAdditionalOptions(codec, restOptions);\n    let encoderConfig = null;\n    if (customVideoEncoders.length > 0) {\n        encoderConfig ??= buildVideoEncoderConfig({\n            codec,\n            width,\n            height,\n            bitrate,\n            framerate: undefined,\n            ...restOptions,\n        });\n        if (customVideoEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (typeof VideoEncoder === 'undefined') {\n        return false;\n    }\n    const hasOddDimension = width % 2 === 1 || height % 2 === 1;\n    if (hasOddDimension\n        && (codec === 'avc' || codec === 'hevc')) {\n        // Disallow odd dimensions for certain codecs\n        return false;\n    }\n    encoderConfig ??= buildVideoEncoderConfig({\n        codec,\n        width,\n        height,\n        bitrate,\n        framerate: undefined,\n        ...restOptions,\n        alpha: 'discard', // Since we handle alpha ourselves\n    });\n    const support = await VideoEncoder.isConfigSupported(encoderConfig);\n    if (!support.supported) {\n        return false;\n    }\n    if (isFirefox()) {\n        // isConfigSupported on Firefox appears to unreliably indicate if encoding will actually succeed. Therefore, we\n        // just try encoding a frame to see if it actually works.\n        // https://github.com/Vanilagy/mediabunny/issues/222\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises, no-async-promise-executor\n        return new Promise(async (resolve) => {\n            try {\n                const encoder = new VideoEncoder({\n                    output: () => { },\n                    error: () => resolve(false),\n                });\n                encoder.configure(encoderConfig);\n                const frameData = new Uint8Array(width * height * 4);\n                const frame = new VideoFrame(frameData, {\n                    format: 'RGBA',\n                    codedWidth: width,\n                    codedHeight: height,\n                    timestamp: 0,\n                });\n                encoder.encode(frame);\n                frame.close();\n                await encoder.flush();\n                resolve(true);\n            }\n            catch {\n                resolve(false);\n            }\n        });\n    }\n    else {\n        return true;\n    }\n};\n/**\n * Checks if the browser is able to encode the given audio codec with the given parameters.\n * @group Encoding\n * @public\n */\nexport const canEncodeAudio = async (codec, options = {}) => {\n    const { numberOfChannels = 2, sampleRate = 48000, bitrate = 128e3, ...restOptions } = options;\n    if (!AUDIO_CODECS.includes(codec)) {\n        return false;\n    }\n    if (!Number.isInteger(numberOfChannels) || numberOfChannels <= 0) {\n        throw new TypeError('numberOfChannels must be a positive integer.');\n    }\n    if (!Number.isInteger(sampleRate) || sampleRate <= 0) {\n        throw new TypeError('sampleRate must be a positive integer.');\n    }\n    if (!(bitrate instanceof Quality) && (!Number.isInteger(bitrate) || bitrate <= 0)) {\n        throw new TypeError('bitrate must be a positive integer.');\n    }\n    validateAudioEncodingAdditionalOptions(codec, restOptions);\n    let encoderConfig = null;\n    if (customAudioEncoders.length > 0) {\n        encoderConfig ??= buildAudioEncoderConfig({\n            codec,\n            numberOfChannels,\n            sampleRate,\n            bitrate,\n            ...restOptions,\n        });\n        if (customAudioEncoders.some(x => x.supports(codec, encoderConfig))) {\n            // There's a custom encoder\n            return true;\n        }\n    }\n    if (PCM_AUDIO_CODECS.includes(codec)) {\n        return true; // Because we encode these ourselves\n    }\n    if (typeof AudioEncoder === 'undefined') {\n        return false;\n    }\n    encoderConfig ??= buildAudioEncoderConfig({\n        codec,\n        numberOfChannels,\n        sampleRate,\n        bitrate,\n        ...restOptions,\n    });\n    const support = await AudioEncoder.isConfigSupported(encoderConfig);\n    return support.supported === true;\n};\n/**\n * Checks if the browser is able to encode the given subtitle codec.\n * @group Encoding\n * @public\n */\nexport const canEncodeSubtitles = async (codec) => {\n    if (!SUBTITLE_CODECS.includes(codec)) {\n        return false;\n    }\n    return true;\n};\n/**\n * Returns the list of all media codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableCodecs = async () => {\n    const [videoCodecs, audioCodecs, subtitleCodecs] = await Promise.all([\n        getEncodableVideoCodecs(),\n        getEncodableAudioCodecs(),\n        getEncodableSubtitleCodecs(),\n    ]);\n    return [...videoCodecs, ...audioCodecs, ...subtitleCodecs];\n};\n/**\n * Returns the list of all video codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableVideoCodecs = async (checkedCodecs = VIDEO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeVideo(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all audio codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableAudioCodecs = async (checkedCodecs = AUDIO_CODECS, options) => {\n    const bools = await Promise.all(checkedCodecs.map(codec => canEncodeAudio(codec, options)));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the list of all subtitle codecs that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getEncodableSubtitleCodecs = async (checkedCodecs = SUBTITLE_CODECS) => {\n    const bools = await Promise.all(checkedCodecs.map(canEncodeSubtitles));\n    return checkedCodecs.filter((_, i) => bools[i]);\n};\n/**\n * Returns the first video codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableVideoCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeVideo(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first audio codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableAudioCodec = async (checkedCodecs, options) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeAudio(codec, options)) {\n            return codec;\n        }\n    }\n    return null;\n};\n/**\n * Returns the first subtitle codec from the given list that can be encoded by the browser.\n * @group Encoding\n * @public\n */\nexport const getFirstEncodableSubtitleCodec = async (checkedCodecs) => {\n    for (const codec of checkedCodecs) {\n        if (await canEncodeSubtitles(codec)) {\n            return codec;\n        }\n    }\n    return null;\n};\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AUDIO_CODECS, buildAacAudioSpecificConfig, parseAacAudioSpecificConfig, parsePcmCodec, PCM_AUDIO_CODECS, SUBTITLE_CODECS, VIDEO_CODECS, } from './codec.js';\nimport { assert, assertNever, CallSerializer, clamp, isFirefox, last, promiseWithResolvers, setInt24, setUint24, toUint8Array, } from './misc.js';\nimport { SubtitleParser } from './subtitles.js';\nimport { toAlaw, toUlaw } from './pcm.js';\nimport { customVideoEncoders, customAudioEncoders, } from './custom-coder.js';\nimport { EncodedPacket } from './packet.js';\nimport { AudioSample, VideoSample } from './sample.js';\nimport { buildAudioEncoderConfig, buildVideoEncoderConfig, validateAudioEncodingConfig, validateVideoEncodingConfig, } from './encode.js';\n/**\n * Base class for media sources. Media sources are used to add media samples to an output file.\n * @group Media sources\n * @public\n */\nexport class MediaSource {\n    constructor() {\n        /** @internal */\n        this._connectedTrack = null;\n        /** @internal */\n        this._closingPromise = null;\n        /** @internal */\n        this._closed = false;\n        /**\n         * @internal\n         * A time offset in seconds that is added to all timestamps generated by this source.\n         */\n        this._timestampOffset = 0;\n    }\n    /** @internal */\n    _ensureValidAdd() {\n        if (!this._connectedTrack) {\n            throw new Error('Source is not connected to an output track.');\n        }\n        if (this._connectedTrack.output.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._connectedTrack.output.state === 'finalizing' || this._connectedTrack.output.state === 'finalized') {\n            throw new Error('Output has been finalized.');\n        }\n        if (this._connectedTrack.output.state === 'pending') {\n            throw new Error('Output has not started.');\n        }\n        if (this._closed) {\n            throw new Error('Source is closed.');\n        }\n    }\n    /** @internal */\n    async _start() { }\n    /** @internal */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    async _flushAndClose(forceClose) { }\n    /**\n     * Closes this source. This prevents future samples from being added and signals to the output file that no further\n     * samples will come in for this track. Calling `.close()` is optional but recommended after adding the\n     * last sample - for improved performance and reduced memory usage.\n     */\n    close() {\n        if (this._closingPromise) {\n            return;\n        }\n        const connectedTrack = this._connectedTrack;\n        if (!connectedTrack) {\n            throw new Error('Cannot call close without connecting the source to an output track.');\n        }\n        if (connectedTrack.output.state === 'pending') {\n            throw new Error('Cannot call close before output has been started.');\n        }\n        this._closingPromise = (async () => {\n            await this._flushAndClose(false);\n            this._closed = true;\n            if (connectedTrack.output.state === 'finalizing' || connectedTrack.output.state === 'finalized') {\n                return;\n            }\n            connectedTrack.output._muxer.onTrackClose(connectedTrack);\n        })();\n    }\n    /** @internal */\n    async _flushOrWaitForOngoingClose(forceClose) {\n        return this._closingPromise ??= (async () => {\n            await this._flushAndClose(forceClose);\n            this._closed = true;\n        })();\n    }\n}\n/**\n * Base class for video sources - sources for video tracks.\n * @group Media sources\n * @public\n */\nexport class VideoSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!VIDEO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid video codec '${codec}'. Must be one of: ${VIDEO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic video source; can be used to directly pipe encoded packets into the output file.\n * @group Media sources\n * @public\n */\nexport class EncodedVideoPacketSource extends VideoSource {\n    /** Creates a new {@link EncodedVideoPacketSource} whose packets are encoded using `codec`. */\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output video track. Packets must be added in *decode order*, while a packet's\n     * timestamp must be its *presentation timestamp*. B-frames are handled automatically.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedVideoPacket(this._connectedTrack, packet, meta);\n    }\n}\nclass VideoEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastMultipleOfKeyFrameInterval = -1;\n        this.codedWidth = null;\n        this.codedHeight = null;\n        this.resizeCanvas = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new CallSerializer();\n        this.customEncoderQueueSize = 0;\n        // Alpha stuff\n        this.alphaEncoder = null;\n        this.splitter = null;\n        this.splitterCreationFailed = false;\n        this.alphaFrameQueue = [];\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.error = null;\n        this.errorNeedsNewStack = true;\n    }\n    async add(videoSample, shouldClose, encodeOptions) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure video sample size remains constant\n            if (this.codedWidth !== null && this.codedHeight !== null) {\n                if (videoSample.codedWidth !== this.codedWidth || videoSample.codedHeight !== this.codedHeight) {\n                    const sizeChangeBehavior = this.encodingConfig.sizeChangeBehavior ?? 'deny';\n                    if (sizeChangeBehavior === 'passThrough') {\n                        // Do nada\n                    }\n                    else if (sizeChangeBehavior === 'deny') {\n                        throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight},`\n                            + ` got ${videoSample.codedWidth}x${videoSample.codedHeight}. To allow the sample size to`\n                            + ` change over time, set \\`sizeChangeBehavior\\` to a value other than 'strict' in the`\n                            + ` encoding options.`);\n                    }\n                    else {\n                        let canvasIsNew = false;\n                        if (!this.resizeCanvas) {\n                            if (typeof document !== 'undefined') {\n                                // Prefer an HTMLCanvasElement\n                                this.resizeCanvas = document.createElement('canvas');\n                                this.resizeCanvas.width = this.codedWidth;\n                                this.resizeCanvas.height = this.codedHeight;\n                            }\n                            else {\n                                this.resizeCanvas = new OffscreenCanvas(this.codedWidth, this.codedHeight);\n                            }\n                            canvasIsNew = true;\n                        }\n                        const context = this.resizeCanvas.getContext('2d', {\n                            alpha: isFirefox(), // Firefox has VideoFrame glitches with opaque canvases\n                        });\n                        assert(context);\n                        if (!canvasIsNew) {\n                            if (isFirefox()) {\n                                context.fillStyle = 'black';\n                                context.fillRect(0, 0, this.codedWidth, this.codedHeight);\n                            }\n                            else {\n                                context.clearRect(0, 0, this.codedWidth, this.codedHeight);\n                            }\n                        }\n                        videoSample.drawWithFit(context, { fit: sizeChangeBehavior });\n                        if (shouldClose) {\n                            videoSample.close();\n                        }\n                        videoSample = new VideoSample(this.resizeCanvas, {\n                            timestamp: videoSample.timestamp,\n                            duration: videoSample.duration,\n                            rotation: videoSample.rotation,\n                        });\n                        shouldClose = true;\n                    }\n                }\n            }\n            else {\n                this.codedWidth = videoSample.codedWidth;\n                this.codedHeight = videoSample.codedHeight;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    this.ensureEncoder(videoSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            assert(this.encoderInitialized);\n            const keyFrameInterval = this.encodingConfig.keyFrameInterval ?? 5;\n            const multipleOfKeyFrameInterval = Math.floor(videoSample.timestamp / keyFrameInterval);\n            // Ensure a key frame every keyFrameInterval seconds. It is important that all video tracks follow the same\n            // \"key frame\" rhythm, because aligned key frames are required to start new fragments in ISOBMFF or clusters\n            // in Matroska (or at least desirable).\n            const finalEncodeOptions = {\n                ...encodeOptions,\n                keyFrame: encodeOptions?.keyFrame\n                    || keyFrameInterval === 0\n                    || multipleOfKeyFrameInterval !== this.lastMultipleOfKeyFrameInterval,\n            };\n            this.lastMultipleOfKeyFrameInterval = multipleOfKeyFrameInterval;\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = videoSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample, finalEncodeOptions))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.error ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `videoSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n            }\n            else {\n                assert(this.encoder);\n                const videoFrame = videoSample.toVideoFrame();\n                if (!this.alphaEncoder) {\n                    // No alpha encoder, simple case\n                    this.encoder.encode(videoFrame, finalEncodeOptions);\n                    videoFrame.close();\n                }\n                else {\n                    // We're expected to encode alpha as well\n                    const frameDefinitelyHasNoAlpha = !!videoFrame.format && !videoFrame.format.includes('A');\n                    if (frameDefinitelyHasNoAlpha || this.splitterCreationFailed) {\n                        this.alphaFrameQueue.push(null);\n                        this.encoder.encode(videoFrame, finalEncodeOptions);\n                        videoFrame.close();\n                    }\n                    else {\n                        const width = videoFrame.displayWidth;\n                        const height = videoFrame.displayHeight;\n                        if (!this.splitter) {\n                            try {\n                                this.splitter = new ColorAlphaSplitter(width, height);\n                            }\n                            catch (error) {\n                                console.error('Due to an error, only color data will be encoded.', error);\n                                this.splitterCreationFailed = true;\n                                this.alphaFrameQueue.push(null);\n                                this.encoder.encode(videoFrame, finalEncodeOptions);\n                                videoFrame.close();\n                            }\n                        }\n                        if (this.splitter) {\n                            const colorFrame = this.splitter.extractColor(videoFrame);\n                            const alphaFrame = this.splitter.extractAlpha(videoFrame);\n                            this.alphaFrameQueue.push(alphaFrame);\n                            this.encoder.encode(colorFrame, finalEncodeOptions);\n                            colorFrame.close();\n                            videoFrame.close();\n                        }\n                    }\n                }\n                if (shouldClose) {\n                    videoSample.close();\n                }\n                // We need to do this after sending the frame to the encoder as the frame otherwise might be closed\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n            }\n            await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                videoSample.close();\n            }\n        }\n    }\n    ensureEncoder(videoSample) {\n        const encoderError = new Error();\n        this.ensureEncoderPromise = (async () => {\n            const encoderConfig = buildVideoEncoderConfig({\n                width: videoSample.codedWidth,\n                height: videoSample.codedHeight,\n                ...this.encodingConfig,\n                framerate: this.source._connectedTrack?.metadata.frameRate,\n            });\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = customVideoEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class \"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                await this.customEncoder.init();\n            }\n            else {\n                if (typeof VideoEncoder === 'undefined') {\n                    throw new Error('VideoEncoder is not supported by this browser.');\n                }\n                encoderConfig.alpha = 'discard'; // Since we handle alpha ourselves\n                if (this.encodingConfig.alpha === 'keep') {\n                    // Encoding alpha requires using two parallel encoders, so we need to make sure they stay in sync\n                    // and that neither of them drops frames. Setting latencyMode to 'quality' achieves this, because\n                    // \"User Agents MUST not drop frames to achieve the target bitrate and/or framerate.\"\n                    encoderConfig.latencyMode = 'quality';\n                }\n                const hasOddDimension = encoderConfig.width % 2 === 1 || encoderConfig.height % 2 === 1;\n                if (hasOddDimension\n                    && (this.encodingConfig.codec === 'avc' || this.encodingConfig.codec === 'hevc')) {\n                    // Throw a special error for this case as it gets hit often\n                    throw new Error(`The dimensions ${encoderConfig.width}x${encoderConfig.height} are not supported for codec`\n                        + ` '${this.encodingConfig.codec}'; both width and height must be even numbers. Make sure to`\n                        + ` round your dimensions to the nearest even number.`);\n                }\n                const support = await VideoEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.width}x${encoderConfig.height}, hardware acceleration:`\n                        + ` ${encoderConfig.hardwareAcceleration ?? 'no-preference'}) is not supported by this browser.`\n                        + ` Consider using another codec or changing your video parameters.`);\n                }\n                /** Queue of color chunks waiting for their alpha counterpart. */\n                const colorChunkQueue = [];\n                /** Each value is the number of encoded alpha chunks at which a null alpha chunk should be added. */\n                const nullAlphaChunkQueue = [];\n                let encodedAlphaChunkCount = 0;\n                let alphaEncoderQueue = 0;\n                const addPacket = (colorChunk, alphaChunk, meta) => {\n                    const sideData = {};\n                    if (alphaChunk) {\n                        const alphaData = new Uint8Array(alphaChunk.byteLength);\n                        alphaChunk.copyTo(alphaData);\n                        sideData.alpha = alphaData;\n                    }\n                    const packet = EncodedPacket.fromEncodedChunk(colorChunk, sideData);\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedVideoPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                this.encoder = new VideoEncoder({\n                    output: (chunk, meta) => {\n                        if (!this.alphaEncoder) {\n                            // We're done\n                            addPacket(chunk, null, meta);\n                            return;\n                        }\n                        const alphaFrame = this.alphaFrameQueue.shift();\n                        assert(alphaFrame !== undefined);\n                        if (alphaFrame) {\n                            this.alphaEncoder.encode(alphaFrame, {\n                                // Crucial: The alpha frame is forced to be a key frame whenever the color frame\n                                // also is. Without this, playback can glitch and even crash in some browsers.\n                                // This is the reason why the two encoders are wired in series and not in parallel.\n                                keyFrame: chunk.type === 'key',\n                            });\n                            alphaEncoderQueue++;\n                            alphaFrame.close();\n                            colorChunkQueue.push({ chunk, meta });\n                        }\n                        else {\n                            // There was no alpha component for this frame\n                            if (alphaEncoderQueue === 0) {\n                                // No pending alpha encodes either, so we're done\n                                addPacket(chunk, null, meta);\n                            }\n                            else {\n                                // There are still alpha encodes pending, so we can't add the packet immediately since\n                                // we'd end up with out-of-order packets. Instead, let's queue a null alpha chunk to be\n                                // added in the future, after the current encoder workload has completed:\n                                nullAlphaChunkQueue.push(encodedAlphaChunkCount + alphaEncoderQueue);\n                                colorChunkQueue.push({ chunk, meta });\n                            }\n                        }\n                    },\n                    error: (error) => {\n                        error.stack = encoderError.stack; // Provide a more useful stack trace\n                        this.error ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n                if (this.encodingConfig.alpha === 'keep') {\n                    // We need to encode alpha as well, which we do with a separate encoder\n                    this.alphaEncoder = new VideoEncoder({\n                        // We ignore the alpha chunk's metadata\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        output: (chunk, meta) => {\n                            alphaEncoderQueue--;\n                            // There has to be a color chunk because the encoders are wired in series\n                            const colorChunk = colorChunkQueue.shift();\n                            assert(colorChunk !== undefined);\n                            addPacket(colorChunk.chunk, chunk, colorChunk.meta);\n                            // See if there are any null alpha chunks queued up\n                            encodedAlphaChunkCount++;\n                            while (nullAlphaChunkQueue.length > 0\n                                && nullAlphaChunkQueue[0] === encodedAlphaChunkCount) {\n                                nullAlphaChunkQueue.shift();\n                                const colorChunk = colorChunkQueue.shift();\n                                assert(colorChunk !== undefined);\n                                addPacket(colorChunk.chunk, null, colorChunk.meta);\n                            }\n                        },\n                        error: (error) => {\n                            error.stack = encoderError.stack; // Provide a more useful stack trace\n                            this.error ??= error;\n                        },\n                    });\n                    this.alphaEncoder.configure(encoderConfig);\n                }\n            }\n            assert(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    async flushAndClose(forceClose) {\n        if (!forceClose)\n            this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                // These are wired in series, therefore they must also be flushed in series\n                await this.encoder.flush();\n                await this.alphaEncoder?.flush();\n            }\n            if (this.encoder.state !== 'closed') {\n                this.encoder.close();\n            }\n            if (this.alphaEncoder && this.alphaEncoder.state !== 'closed') {\n                this.alphaEncoder.close();\n            }\n            this.alphaFrameQueue.forEach(x => x?.close());\n            this.splitter?.close();\n        }\n        if (!forceClose)\n            this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else {\n            // Because the color and alpha encoders are wired in series, there's no need to also include the alpha\n            // encoder's queue size here\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.error) {\n            if (this.errorNeedsNewStack) {\n                this.error.stack = new Error().stack; // Provide an even more useful stack trace\n            }\n            throw this.error;\n        }\n    }\n}\n/** Utility class for splitting a composite frame into separate color and alpha components. */\nclass ColorAlphaSplitter {\n    constructor(initialWidth, initialHeight) {\n        this.lastFrame = null;\n        if (typeof OffscreenCanvas !== 'undefined') {\n            this.canvas = new OffscreenCanvas(initialWidth, initialHeight);\n        }\n        else {\n            this.canvas = document.createElement('canvas');\n            this.canvas.width = initialWidth;\n            this.canvas.height = initialHeight;\n        }\n        const gl = this.canvas.getContext('webgl2', {\n            alpha: true, // Needed due to the YUV thing we do for alpha\n        }); // Casting because of some TypeScript weirdness\n        if (!gl) {\n            throw new Error('Couldn\\'t acquire WebGL 2 context.');\n        }\n        this.gl = gl;\n        this.colorProgram = this.createColorProgram();\n        this.alphaProgram = this.createAlphaProgram();\n        this.vao = this.createVAO();\n        this.sourceTexture = this.createTexture();\n        this.alphaResolutionLocation = this.gl.getUniformLocation(this.alphaProgram, 'u_resolution');\n        this.gl.useProgram(this.colorProgram);\n        this.gl.uniform1i(this.gl.getUniformLocation(this.colorProgram, 'u_sourceTexture'), 0);\n        this.gl.useProgram(this.alphaProgram);\n        this.gl.uniform1i(this.gl.getUniformLocation(this.alphaProgram, 'u_sourceTexture'), 0);\n    }\n    createVertexShader() {\n        return this.createShader(this.gl.VERTEX_SHADER, `#version 300 es\n\t\t\tin vec2 a_position;\n\t\t\tin vec2 a_texCoord;\n\t\t\tout vec2 v_texCoord;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tgl_Position = vec4(a_position, 0.0, 1.0);\n\t\t\t\tv_texCoord = a_texCoord;\n\t\t\t}\n\t\t`);\n    }\n    createColorProgram() {\n        const vertexShader = this.createVertexShader();\n        // This shader is simple, simply copy the color information while setting alpha to 1\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, `#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_sourceTexture;\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\tvec4 source = texture(u_sourceTexture, v_texCoord);\n\t\t\t\tfragColor = vec4(source.rgb, 1.0);\n\t\t\t}\n\t\t`);\n        const program = this.gl.createProgram();\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n        return program;\n    }\n    createAlphaProgram() {\n        const vertexShader = this.createVertexShader();\n        // This shader's more complex. The main reason is that this shader writes data in I420 (yuv420) pixel format\n        // instead of regular RGBA. In other words, we use the shader to write out I420 data into an RGBA canvas, which\n        // we then later read out with JavaScript. The reason being that browsers weirdly encode canvases and mess up\n        // the color spaces, and the only way to have full control over the color space is by outputting YUV data\n        // directly (avoiding the RGB conversion). Doing this conversion in JS is painfully slow, so let's utlize the\n        // GPU since we're already calling it anyway.\n        const fragmentShader = this.createShader(this.gl.FRAGMENT_SHADER, `#version 300 es\n\t\t\tprecision highp float;\n\t\t\t\n\t\t\tuniform sampler2D u_sourceTexture;\n\t\t\tuniform vec2 u_resolution; // The width and height of the canvas\n\t\t\tin vec2 v_texCoord;\n\t\t\tout vec4 fragColor;\n\n\t\t\t// This function determines the value for a single byte in the YUV stream\n\t\t\tfloat getByteValue(float byteOffset) {\n\t\t\t\tfloat width = u_resolution.x;\n\t\t\t\tfloat height = u_resolution.y;\n\n\t\t\t\tfloat yPlaneSize = width * height;\n\n\t\t\t\tif (byteOffset < yPlaneSize) {\n\t\t\t\t\t// This byte is in the luma plane. Find the corresponding pixel coordinates to sample from\n\t\t\t\t\tfloat y = floor(byteOffset / width);\n\t\t\t\t\tfloat x = mod(byteOffset, width);\n\t\t\t\t\t\n\t\t\t\t\t// Add 0.5 to sample the center of the texel\n\t\t\t\t\tvec2 sampleCoord = (vec2(x, y) + 0.5) / u_resolution;\n\t\t\t\t\t\n\t\t\t\t\t// The luma value is the alpha from the source texture\n\t\t\t\t\treturn texture(u_sourceTexture, sampleCoord).a;\n\t\t\t\t} else {\n\t\t\t\t\t// Write a fixed value for chroma and beyond\n\t\t\t\t\treturn 128.0 / 255.0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tvoid main() {\n\t\t\t\t// Each fragment writes 4 bytes (R, G, B, A)\n\t\t\t\tfloat pixelIndex = floor(gl_FragCoord.y) * u_resolution.x + floor(gl_FragCoord.x);\n\t\t\t\tfloat baseByteOffset = pixelIndex * 4.0;\n\n\t\t\t\tvec4 result;\n\t\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\t\tfloat currentByteOffset = baseByteOffset + float(i);\n\t\t\t\t\tresult[i] = getByteValue(currentByteOffset);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfragColor = result;\n\t\t\t}\n\t\t`);\n        const program = this.gl.createProgram();\n        this.gl.attachShader(program, vertexShader);\n        this.gl.attachShader(program, fragmentShader);\n        this.gl.linkProgram(program);\n        return program;\n    }\n    createShader(type, source) {\n        const shader = this.gl.createShader(type);\n        this.gl.shaderSource(shader, source);\n        this.gl.compileShader(shader);\n        if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n            console.error('Shader compile error:', this.gl.getShaderInfoLog(shader));\n        }\n        return shader;\n    }\n    createVAO() {\n        const vao = this.gl.createVertexArray();\n        this.gl.bindVertexArray(vao);\n        const vertices = new Float32Array([\n            -1, -1, 0, 1,\n            1, -1, 1, 1,\n            -1, 1, 0, 0,\n            1, 1, 1, 0,\n        ]);\n        const buffer = this.gl.createBuffer();\n        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);\n        this.gl.bufferData(this.gl.ARRAY_BUFFER, vertices, this.gl.STATIC_DRAW);\n        const positionLocation = this.gl.getAttribLocation(this.colorProgram, 'a_position');\n        const texCoordLocation = this.gl.getAttribLocation(this.colorProgram, 'a_texCoord');\n        this.gl.enableVertexAttribArray(positionLocation);\n        this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 16, 0);\n        this.gl.enableVertexAttribArray(texCoordLocation);\n        this.gl.vertexAttribPointer(texCoordLocation, 2, this.gl.FLOAT, false, 16, 8);\n        return vao;\n    }\n    createTexture() {\n        const texture = this.gl.createTexture();\n        this.gl.bindTexture(this.gl.TEXTURE_2D, texture);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.LINEAR);\n        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.LINEAR);\n        return texture;\n    }\n    updateTexture(sourceFrame) {\n        if (this.lastFrame === sourceFrame) {\n            return;\n        }\n        if (sourceFrame.displayWidth !== this.canvas.width || sourceFrame.displayHeight !== this.canvas.height) {\n            this.canvas.width = sourceFrame.displayWidth;\n            this.canvas.height = sourceFrame.displayHeight;\n        }\n        this.gl.activeTexture(this.gl.TEXTURE0);\n        this.gl.bindTexture(this.gl.TEXTURE_2D, this.sourceTexture);\n        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, sourceFrame);\n        this.lastFrame = sourceFrame;\n    }\n    extractColor(sourceFrame) {\n        this.updateTexture(sourceFrame);\n        this.gl.useProgram(this.colorProgram);\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.bindVertexArray(this.vao);\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n        return new VideoFrame(this.canvas, {\n            timestamp: sourceFrame.timestamp,\n            duration: sourceFrame.duration ?? undefined,\n            alpha: 'discard',\n        });\n    }\n    extractAlpha(sourceFrame) {\n        this.updateTexture(sourceFrame);\n        this.gl.useProgram(this.alphaProgram);\n        this.gl.uniform2f(this.alphaResolutionLocation, this.canvas.width, this.canvas.height);\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT);\n        this.gl.bindVertexArray(this.vao);\n        this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);\n        const { width, height } = this.canvas;\n        const chromaSamples = Math.ceil(width / 2) * Math.ceil(height / 2);\n        const yuvSize = width * height + chromaSamples * 2;\n        const requiredHeight = Math.ceil(yuvSize / (width * 4));\n        let yuv = new Uint8Array(4 * width * requiredHeight);\n        this.gl.readPixels(0, 0, width, requiredHeight, this.gl.RGBA, this.gl.UNSIGNED_BYTE, yuv);\n        yuv = yuv.subarray(0, yuvSize);\n        assert(yuv[width * height] === 128); // Where chroma data starts\n        assert(yuv[yuv.length - 1] === 128); // Assert the YUV data has been fully written\n        // Defining this separately because TypeScript doesn't know `transfer` and I can't be bothered to do declaration\n        // merging right now\n        const init = {\n            format: 'I420',\n            codedWidth: width,\n            codedHeight: height,\n            timestamp: sourceFrame.timestamp,\n            duration: sourceFrame.duration ?? undefined,\n            transfer: [yuv.buffer],\n        };\n        return new VideoFrame(yuv, init);\n    }\n    close() {\n        this.gl.getExtension('WEBGL_lose_context')?.loseContext();\n        this.gl = null;\n    }\n}\n/**\n * This source can be used to add raw, unencoded video samples (frames) to an output video track. These frames will\n * automatically be encoded and then piped into the output.\n * @group Media sources\n * @public\n */\nexport class VideoSampleSource extends VideoSource {\n    /**\n     * Creates a new {@link VideoSampleSource} whose samples are encoded according to the specified\n     * {@link VideoEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateVideoEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes a video sample (frame) and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(videoSample, encodeOptions) {\n        if (!(videoSample instanceof VideoSample)) {\n            throw new TypeError('videoSample must be a VideoSample.');\n        }\n        return this._encoder.add(videoSample, false, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add video frames to the output track from a fixed canvas element. Since canvases are often\n * used for rendering, this source provides a convenient wrapper around {@link VideoSampleSource}.\n * @group Media sources\n * @public\n */\nexport class CanvasSource extends VideoSource {\n    /**\n     * Creates a new {@link CanvasSource} from a canvas element or `OffscreenCanvas` whose samples are encoded\n     * according to the specified {@link VideoEncodingConfig}.\n     */\n    constructor(canvas, encodingConfig) {\n        if (!(typeof HTMLCanvasElement !== 'undefined' && canvas instanceof HTMLCanvasElement)\n            && !(typeof OffscreenCanvas !== 'undefined' && canvas instanceof OffscreenCanvas)) {\n            throw new TypeError('canvas must be an HTMLCanvasElement or OffscreenCanvas.');\n        }\n        validateVideoEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._canvas = canvas;\n    }\n    /**\n     * Captures the current canvas state as a video sample (frame), encodes it and adds it to the output.\n     *\n     * @param timestamp - The timestamp of the sample, in seconds.\n     * @param duration - The duration of the sample, in seconds.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(timestamp, duration = 0, encodeOptions) {\n        if (!Number.isFinite(timestamp) || timestamp < 0) {\n            throw new TypeError('timestamp must be a non-negative number.');\n        }\n        if (!Number.isFinite(duration) || duration < 0) {\n            throw new TypeError('duration must be a non-negative number.');\n        }\n        const sample = new VideoSample(this._canvas, { timestamp, duration });\n        return this._encoder.add(sample, true, encodeOptions);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Video source that encodes the frames of a\n * [`MediaStreamVideoTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) and pipes them into the\n * output. This is useful for capturing live or real-time data such as webcams or screen captures. Frames will\n * automatically start being captured once the connected {@link Output} is started, and will keep being captured until\n * the {@link Output} is finalized or this source is closed.\n * @group Media sources\n * @public\n */\nexport class MediaStreamVideoTrackSource extends VideoSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    /** Whether this source is currently paused as a result of calling `.pause()`. */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Creates a new {@link MediaStreamVideoTrackSource} from a\n     * [`MediaStreamVideoTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack), which will pull\n     * video samples from the stream in real time and encode them according to {@link VideoEncodingConfig}.\n     */\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'video') {\n            throw new TypeError('track must be a video MediaStreamTrack.');\n        }\n        validateVideoEncodingConfig(encodingConfig);\n        encodingConfig = {\n            ...encodingConfig,\n            latencyMode: 'realtime',\n        };\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._workerTrackId = null;\n        /** @internal */\n        this._workerListener = null;\n        /** @internal */\n        this._promiseWithResolvers = promiseWithResolvers();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        /** @internal */\n        this._paused = false;\n        /** @internal */\n        this._lastSampleTimestamp = null;\n        /** @internal */\n        this._pauseOffset = 0;\n        this._encoder = new VideoEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        let firstVideoFrameTimestamp = null;\n        let errored = false;\n        const onVideoFrame = (videoFrame) => {\n            if (errored) {\n                videoFrame.close();\n                return;\n            }\n            const currentTimestamp = videoFrame.timestamp / 1e6;\n            if (this._paused) {\n                const frameSeen = firstVideoFrameTimestamp !== null;\n                if (frameSeen) {\n                    if (this._lastSampleTimestamp !== null) {\n                        // In addition to dropping this frame, let's also keep track of the time we have lost due to the\n                        // pause. Doing it like this instead of simply keeping track of the paused time is better since\n                        // it retains the frame rate of the underlying source.\n                        const timeDelta = currentTimestamp - this._lastSampleTimestamp;\n                        // We modify this field instead of _timestampOffset since we still might have data in flight\n                        // in the encoder, with which we don't want to mess.\n                        this._pauseOffset -= timeDelta;\n                    }\n                    this._lastSampleTimestamp = currentTimestamp;\n                }\n                videoFrame.close();\n                return;\n            }\n            if (firstVideoFrameTimestamp === null) {\n                firstVideoFrameTimestamp = currentTimestamp;\n                const muxer = this._connectedTrack.output._muxer;\n                if (muxer.firstMediaStreamTimestamp === null) {\n                    muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                    this._timestampOffset = -firstVideoFrameTimestamp;\n                }\n                else {\n                    this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                        - firstVideoFrameTimestamp;\n                }\n            }\n            this._lastSampleTimestamp = currentTimestamp;\n            if (this._encoder.getQueueSize() >= 4) {\n                // Drop frames if the encoder is overloaded\n                videoFrame.close();\n                return;\n            }\n            const sample = new VideoSample(videoFrame, {\n                timestamp: currentTimestamp + this._pauseOffset,\n            });\n            void this._encoder.add(sample, true)\n                .catch((error) => {\n                errored = true;\n                this._abortController?.abort();\n                this._promiseWithResolvers.reject(error);\n                if (this._workerTrackId !== null) {\n                    // Tell the worker to stop the track\n                    sendMessageToMediaStreamTrackProcessorWorker({\n                        type: 'stopTrack',\n                        trackId: this._workerTrackId,\n                    });\n                }\n            });\n        };\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // We can do it here directly, perfect\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({ write: onVideoFrame });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // It might still be supported in a worker, so let's check that\n            const supportedInWorker = await mediaStreamTrackProcessorIsSupportedInWorker();\n            if (supportedInWorker) {\n                this._workerTrackId = nextMediaStreamTrackProcessorWorkerId++;\n                sendMessageToMediaStreamTrackProcessorWorker({\n                    type: 'videoTrack',\n                    trackId: this._workerTrackId,\n                    track: this._track,\n                });\n                this._workerListener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'videoFrame' && message.trackId === this._workerTrackId) {\n                        onVideoFrame(message.videoFrame);\n                    }\n                    else if (message.type === 'error' && message.trackId === this._workerTrackId) {\n                        this._promiseWithResolvers.reject(message.error);\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', this._workerListener);\n            }\n            else {\n                throw new Error('MediaStreamTrackProcessor is required but not supported by this browser.');\n            }\n        }\n    }\n    /**\n     * Pauses the capture of video frames - any video frames emitted by the underlying media stream will be ignored\n     * while paused. This does *not* close the underlying `MediaStreamVideoTrack`, it just ignores its output.\n     */\n    pause() {\n        this._paused = true;\n    }\n    /** Resumes the capture of video frames after being paused. */\n    resume() {\n        this._paused = false;\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._workerTrackId !== null) {\n            assert(this._workerListener);\n            sendMessageToMediaStreamTrackProcessorWorker({\n                type: 'stopTrack',\n                trackId: this._workerTrackId,\n            });\n            // Wait for the worker to stop the track\n            await new Promise((resolve) => {\n                const listener = (event) => {\n                    const message = event.data;\n                    if (message.type === 'trackStopped' && message.trackId === this._workerTrackId) {\n                        assert(this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', this._workerListener);\n                        mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                        resolve();\n                    }\n                };\n                mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n            });\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Base class for audio sources - sources for audio tracks.\n * @group Media sources\n * @public\n */\nexport class AudioSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!AUDIO_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid audio codec '${codec}'. Must be one of: ${AUDIO_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * The most basic audio source; can be used to directly pipe encoded packets into the output file.\n * @group Media sources\n * @public\n */\nexport class EncodedAudioPacketSource extends AudioSource {\n    /** Creates a new {@link EncodedAudioPacketSource} whose packets are encoded using `codec`. */\n    constructor(codec) {\n        super(codec);\n    }\n    /**\n     * Adds an encoded packet to the output audio track. Packets must be added in *decode order*.\n     *\n     * @param meta - Additional metadata from the encoder. You should pass this for the first call, including a valid\n     * decoder config.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(packet, meta) {\n        if (!(packet instanceof EncodedPacket)) {\n            throw new TypeError('packet must be an EncodedPacket.');\n        }\n        if (packet.isMetadataOnly) {\n            throw new TypeError('Metadata-only packets cannot be added.');\n        }\n        if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n            throw new TypeError('meta, when provided, must be an object.');\n        }\n        this._ensureValidAdd();\n        return this._connectedTrack.output._muxer.addEncodedAudioPacket(this._connectedTrack, packet, meta);\n    }\n}\nclass AudioEncoderWrapper {\n    constructor(source, encodingConfig) {\n        this.source = source;\n        this.encodingConfig = encodingConfig;\n        this.ensureEncoderPromise = null;\n        this.encoderInitialized = false;\n        this.encoder = null;\n        this.muxer = null;\n        this.lastNumberOfChannels = null;\n        this.lastSampleRate = null;\n        this.isPcmEncoder = false;\n        this.outputSampleSize = null;\n        this.writeOutputValue = null;\n        this.customEncoder = null;\n        this.customEncoderCallSerializer = new CallSerializer();\n        this.customEncoderQueueSize = 0;\n        this.lastEndSampleIndex = null;\n        /**\n         * Encoders typically throw their errors \"out of band\", meaning asynchronously in some other execution context.\n         * However, we want to surface these errors to the user within the normal control flow, so they don't go uncaught.\n         * So, we keep track of the encoder error and throw it as soon as we get the chance.\n         */\n        this.error = null;\n        this.errorNeedsNewStack = true;\n    }\n    async add(audioSample, shouldClose) {\n        try {\n            this.checkForEncoderError();\n            this.source._ensureValidAdd();\n            // Ensure audio parameters remain constant\n            if (this.lastNumberOfChannels !== null && this.lastSampleRate !== null) {\n                if (audioSample.numberOfChannels !== this.lastNumberOfChannels\n                    || audioSample.sampleRate !== this.lastSampleRate) {\n                    throw new Error(`Audio parameters must remain constant. Expected ${this.lastNumberOfChannels} channels at`\n                        + ` ${this.lastSampleRate} Hz, got ${audioSample.numberOfChannels} channels at`\n                        + ` ${audioSample.sampleRate} Hz.`);\n                }\n            }\n            else {\n                this.lastNumberOfChannels = audioSample.numberOfChannels;\n                this.lastSampleRate = audioSample.sampleRate;\n            }\n            if (!this.encoderInitialized) {\n                if (!this.ensureEncoderPromise) {\n                    this.ensureEncoder(audioSample);\n                }\n                // No, this \"if\" statement is not useless. Sometimes, the above call to `ensureEncoder` might have\n                // synchronously completed and the encoder is already initialized. In this case, we don't need to await\n                // the promise anymore. This also fixes nasty async race condition bugs when multiple code paths are\n                // calling this method: It's important that the call that initialized the encoder go through this\n                // code first.\n                if (!this.encoderInitialized) {\n                    await this.ensureEncoderPromise;\n                }\n            }\n            assert(this.encoderInitialized);\n            // Handle padding of gaps with silence to avoid audio drift over time, like in\n            // https://github.com/Vanilagy/mediabunny/issues/176\n            // TODO An open question is how encoders deal with the first AudioData having a non-zero timestamp, and with\n            // AudioDatas that have an overlapping timestamp range.\n            {\n                const startSampleIndex = Math.round(audioSample.timestamp * audioSample.sampleRate);\n                const endSampleIndex = Math.round((audioSample.timestamp + audioSample.duration) * audioSample.sampleRate);\n                if (this.lastEndSampleIndex === null) {\n                    this.lastEndSampleIndex = endSampleIndex;\n                }\n                else {\n                    const sampleDiff = startSampleIndex - this.lastEndSampleIndex;\n                    if (sampleDiff >= 64) {\n                        // The gap is big enough, let's add a correction sample\n                        const fillSample = new AudioSample({\n                            data: new Float32Array(sampleDiff * audioSample.numberOfChannels),\n                            format: 'f32-planar',\n                            sampleRate: audioSample.sampleRate,\n                            numberOfChannels: audioSample.numberOfChannels,\n                            numberOfFrames: sampleDiff,\n                            timestamp: this.lastEndSampleIndex / audioSample.sampleRate,\n                        });\n                        await this.add(fillSample, true); // Recursive call\n                    }\n                    this.lastEndSampleIndex += audioSample.numberOfFrames;\n                }\n            }\n            if (this.customEncoder) {\n                this.customEncoderQueueSize++;\n                // We clone the sample so it cannot be closed on us from the outside before it reaches the encoder\n                const clonedSample = audioSample.clone();\n                const promise = this.customEncoderCallSerializer\n                    .call(() => this.customEncoder.encode(clonedSample))\n                    .then(() => this.customEncoderQueueSize--)\n                    .catch((error) => this.error ??= error)\n                    .finally(() => {\n                    clonedSample.close();\n                    // `audioSample` gets closed in the finally block at the end of the method\n                });\n                if (this.customEncoderQueueSize >= 4) {\n                    await promise;\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n            else if (this.isPcmEncoder) {\n                await this.doPcmEncoding(audioSample, shouldClose);\n            }\n            else {\n                assert(this.encoder);\n                const audioData = audioSample.toAudioData();\n                this.encoder.encode(audioData);\n                audioData.close();\n                if (shouldClose) {\n                    audioSample.close();\n                }\n                if (this.encoder.encodeQueueSize >= 4) {\n                    await new Promise(resolve => this.encoder.addEventListener('dequeue', resolve, { once: true }));\n                }\n                await this.muxer.mutex.currentPromise; // Allow the writer to apply backpressure\n            }\n        }\n        finally {\n            if (shouldClose) {\n                // Make sure it's always closed, even if there was an error\n                audioSample.close();\n            }\n        }\n    }\n    async doPcmEncoding(audioSample, shouldClose) {\n        assert(this.outputSampleSize);\n        assert(this.writeOutputValue);\n        // Need to extract data from the audio data before we close it\n        const { numberOfChannels, numberOfFrames, sampleRate, timestamp } = audioSample;\n        const CHUNK_SIZE = 2048;\n        const outputs = [];\n        // Prepare all of the output buffers, each being bounded by CHUNK_SIZE so we don't generate huge packets\n        for (let frame = 0; frame < numberOfFrames; frame += CHUNK_SIZE) {\n            const frameCount = Math.min(CHUNK_SIZE, audioSample.numberOfFrames - frame);\n            const outputSize = frameCount * numberOfChannels * this.outputSampleSize;\n            const outputBuffer = new ArrayBuffer(outputSize);\n            const outputView = new DataView(outputBuffer);\n            outputs.push({ frameCount, view: outputView });\n        }\n        const allocationSize = audioSample.allocationSize(({ planeIndex: 0, format: 'f32-planar' }));\n        const floats = new Float32Array(allocationSize / Float32Array.BYTES_PER_ELEMENT);\n        for (let i = 0; i < numberOfChannels; i++) {\n            audioSample.copyTo(floats, { planeIndex: i, format: 'f32-planar' });\n            for (let j = 0; j < outputs.length; j++) {\n                const { frameCount, view } = outputs[j];\n                for (let k = 0; k < frameCount; k++) {\n                    this.writeOutputValue(view, (k * numberOfChannels + i) * this.outputSampleSize, floats[j * CHUNK_SIZE + k]);\n                }\n            }\n        }\n        if (shouldClose) {\n            audioSample.close();\n        }\n        const meta = {\n            decoderConfig: {\n                codec: this.encodingConfig.codec,\n                numberOfChannels,\n                sampleRate,\n            },\n        };\n        for (let i = 0; i < outputs.length; i++) {\n            const { frameCount, view } = outputs[i];\n            const outputBuffer = view.buffer;\n            const startFrame = i * CHUNK_SIZE;\n            const packet = new EncodedPacket(new Uint8Array(outputBuffer), 'key', timestamp + startFrame / sampleRate, frameCount / sampleRate);\n            this.encodingConfig.onEncodedPacket?.(packet, meta);\n            await this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta); // With backpressure\n        }\n    }\n    ensureEncoder(audioSample) {\n        const encoderError = new Error();\n        this.ensureEncoderPromise = (async () => {\n            const { numberOfChannels, sampleRate } = audioSample;\n            const encoderConfig = buildAudioEncoderConfig({\n                numberOfChannels,\n                sampleRate,\n                ...this.encodingConfig,\n            });\n            this.encodingConfig.onEncoderConfig?.(encoderConfig);\n            const MatchingCustomEncoder = customAudioEncoders.find(x => x.supports(this.encodingConfig.codec, encoderConfig));\n            if (MatchingCustomEncoder) {\n                // @ts-expect-error \"Can't create instance of abstract class \"\n                this.customEncoder = new MatchingCustomEncoder();\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.codec = this.encodingConfig.codec;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.config = encoderConfig;\n                // @ts-expect-error It's technically readonly\n                this.customEncoder.onPacket = (packet, meta) => {\n                    if (!(packet instanceof EncodedPacket)) {\n                        throw new TypeError('The first argument passed to onPacket must be an EncodedPacket.');\n                    }\n                    if (meta !== undefined && (!meta || typeof meta !== 'object')) {\n                        throw new TypeError('The second argument passed to onPacket must be an object or undefined.');\n                    }\n                    this.encodingConfig.onEncodedPacket?.(packet, meta);\n                    void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta)\n                        .catch((error) => {\n                        this.error ??= error;\n                        this.errorNeedsNewStack = false;\n                    });\n                };\n                await this.customEncoder.init();\n            }\n            else if (PCM_AUDIO_CODECS.includes(this.encodingConfig.codec)) {\n                this.initPcmEncoder();\n            }\n            else {\n                if (typeof AudioEncoder === 'undefined') {\n                    throw new Error('AudioEncoder is not supported by this browser.');\n                }\n                const support = await AudioEncoder.isConfigSupported(encoderConfig);\n                if (!support.supported) {\n                    throw new Error(`This specific encoder configuration (${encoderConfig.codec}, ${encoderConfig.bitrate} bps,`\n                        + ` ${encoderConfig.numberOfChannels} channels, ${encoderConfig.sampleRate} Hz) is not`\n                        + ` supported by this browser. Consider using another codec or changing your audio parameters.`);\n                }\n                this.encoder = new AudioEncoder({\n                    output: (chunk, meta) => {\n                        // WebKit emits an invalid description for AAC (https://bugs.webkit.org/show_bug.cgi?id=302253),\n                        // which we try to detect here. If detected, we'll provide our own description instead, derived\n                        // from the codec string and audio parameters.\n                        if (this.encodingConfig.codec === 'aac' && meta?.decoderConfig) {\n                            let needsDescriptionOverwrite = false;\n                            if (!meta.decoderConfig.description || meta.decoderConfig.description.byteLength < 2) {\n                                needsDescriptionOverwrite = true;\n                            }\n                            else {\n                                const audioSpecificConfig = parseAacAudioSpecificConfig(toUint8Array(meta.decoderConfig.description));\n                                needsDescriptionOverwrite = audioSpecificConfig.objectType === 0;\n                            }\n                            if (needsDescriptionOverwrite) {\n                                const objectType = Number(last(encoderConfig.codec.split('.')));\n                                meta.decoderConfig.description = buildAacAudioSpecificConfig({\n                                    objectType,\n                                    numberOfChannels: meta.decoderConfig.numberOfChannels,\n                                    sampleRate: meta.decoderConfig.sampleRate,\n                                });\n                            }\n                        }\n                        const packet = EncodedPacket.fromEncodedChunk(chunk);\n                        this.encodingConfig.onEncodedPacket?.(packet, meta);\n                        void this.muxer.addEncodedAudioPacket(this.source._connectedTrack, packet, meta)\n                            .catch((error) => {\n                            this.error ??= error;\n                            this.errorNeedsNewStack = false;\n                        });\n                    },\n                    error: (error) => {\n                        error.stack = encoderError.stack; // Provide a more useful stack trace\n                        this.error ??= error;\n                    },\n                });\n                this.encoder.configure(encoderConfig);\n            }\n            assert(this.source._connectedTrack);\n            this.muxer = this.source._connectedTrack.output._muxer;\n            this.encoderInitialized = true;\n        })();\n    }\n    initPcmEncoder() {\n        this.isPcmEncoder = true;\n        const codec = this.encodingConfig.codec;\n        const { dataType, sampleSize, littleEndian } = parsePcmCodec(codec);\n        this.outputSampleSize = sampleSize;\n        // All these functions receive a float sample as input and map it into the desired format\n        switch (sampleSize) {\n            case 1:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint8(byteOffset, clamp((value + 1) * 127.5, 0, 255));\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            view.setInt8(byteOffset, clamp(Math.round(value * 128), -128, 127));\n                        };\n                    }\n                    else if (dataType === 'ulaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = clamp(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, toUlaw(int16));\n                        };\n                    }\n                    else if (dataType === 'alaw') {\n                        this.writeOutputValue = (view, byteOffset, value) => {\n                            const int16 = clamp(Math.floor(value * 32767), -32768, 32767);\n                            view.setUint8(byteOffset, toAlaw(int16));\n                        };\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 2:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint16(byteOffset, clamp((value + 1) * 32767.5, 0, 65535), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt16(byteOffset, clamp(Math.round(value * 32767), -32768, 32767), littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 3:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => setUint24(view, byteOffset, clamp((value + 1) * 8388607.5, 0, 16777215), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => setInt24(view, byteOffset, clamp(Math.round(value * 8388607), -8388608, 8388607), littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 4:\n                {\n                    if (dataType === 'unsigned') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setUint32(byteOffset, clamp((value + 1) * 2147483647.5, 0, 4294967295), littleEndian);\n                    }\n                    else if (dataType === 'signed') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setInt32(byteOffset, clamp(Math.round(value * 2147483647), -2147483648, 2147483647), littleEndian);\n                    }\n                    else if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat32(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            case 8:\n                {\n                    if (dataType === 'float') {\n                        this.writeOutputValue = (view, byteOffset, value) => view.setFloat64(byteOffset, value, littleEndian);\n                    }\n                    else {\n                        assert(false);\n                    }\n                }\n                ;\n                break;\n            default:\n                {\n                    assertNever(sampleSize);\n                    assert(false);\n                }\n                ;\n        }\n    }\n    async flushAndClose(forceClose) {\n        if (!forceClose)\n            this.checkForEncoderError();\n        if (this.customEncoder) {\n            if (!forceClose) {\n                void this.customEncoderCallSerializer.call(() => this.customEncoder.flush());\n            }\n            await this.customEncoderCallSerializer.call(() => this.customEncoder.close());\n        }\n        else if (this.encoder) {\n            if (!forceClose) {\n                await this.encoder.flush();\n            }\n            if (this.encoder.state !== 'closed') {\n                this.encoder.close();\n            }\n        }\n        if (!forceClose)\n            this.checkForEncoderError();\n    }\n    getQueueSize() {\n        if (this.customEncoder) {\n            return this.customEncoderQueueSize;\n        }\n        else if (this.isPcmEncoder) {\n            return 0;\n        }\n        else {\n            return this.encoder?.encodeQueueSize ?? 0;\n        }\n    }\n    checkForEncoderError() {\n        if (this.error) {\n            if (this.errorNeedsNewStack) {\n                this.error.stack = new Error().stack; // Provide an even more useful stack trace\n            }\n            throw this.error;\n        }\n    }\n}\n/**\n * This source can be used to add raw, unencoded audio samples to an output audio track. These samples will\n * automatically be encoded and then piped into the output.\n * @group Media sources\n * @public\n */\nexport class AudioSampleSource extends AudioSource {\n    /**\n     * Creates a new {@link AudioSampleSource} whose samples are encoded according to the specified\n     * {@link AudioEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Encodes an audio sample and then adds it to the output.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(audioSample) {\n        if (!(audioSample instanceof AudioSample)) {\n            throw new TypeError('audioSample must be an AudioSample.');\n        }\n        return this._encoder.add(audioSample, false);\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * This source can be used to add audio data from an AudioBuffer to the output track. This is useful when working with\n * the Web Audio API.\n * @group Media sources\n * @public\n */\nexport class AudioBufferSource extends AudioSource {\n    /**\n     * Creates a new {@link AudioBufferSource} whose `AudioBuffer` instances are encoded according to the specified\n     * {@link AudioEncodingConfig}.\n     */\n    constructor(encodingConfig) {\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._accumulatedTime = 0;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n    }\n    /**\n     * Converts an AudioBuffer to audio samples, encodes them and adds them to the output. The first AudioBuffer will\n     * be played at timestamp 0, and any subsequent AudioBuffer will have a timestamp equal to the total duration of\n     * all previous AudioBuffers.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    async add(audioBuffer) {\n        if (!(audioBuffer instanceof AudioBuffer)) {\n            throw new TypeError('audioBuffer must be an AudioBuffer.');\n        }\n        const iterator = AudioSample._fromAudioBuffer(audioBuffer, this._accumulatedTime);\n        this._accumulatedTime += audioBuffer.duration;\n        for (const audioSample of iterator) {\n            await this._encoder.add(audioSample, true);\n        }\n    }\n    /** @internal */\n    _flushAndClose(forceClose) {\n        return this._encoder.flushAndClose(forceClose);\n    }\n}\n/**\n * Audio source that encodes the data of a\n * [`MediaStreamAudioTrack`](https://developer.mozilla.org/en-US/docs/Web/API/MediaStreamTrack) and pipes it into the\n * output. This is useful for capturing live or real-time audio such as microphones or audio from other media elements.\n * Audio will automatically start being captured once the connected {@link Output} is started, and will keep being\n * captured until the {@link Output} is finalized or this source is closed.\n * @group Media sources\n * @public\n */\nexport class MediaStreamAudioTrackSource extends AudioSource {\n    /** A promise that rejects upon any error within this source. This promise never resolves. */\n    get errorPromise() {\n        this._errorPromiseAccessed = true;\n        return this._promiseWithResolvers.promise;\n    }\n    /** Whether this source is currently paused as a result of calling `.pause()`. */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Creates a new {@link MediaStreamAudioTrackSource} from a `MediaStreamAudioTrack`, which will pull audio samples\n     * from the stream in real time and encode them according to {@link AudioEncodingConfig}.\n     */\n    constructor(track, encodingConfig) {\n        if (!(track instanceof MediaStreamTrack) || track.kind !== 'audio') {\n            throw new TypeError('track must be an audio MediaStreamTrack.');\n        }\n        validateAudioEncodingConfig(encodingConfig);\n        super(encodingConfig.codec);\n        /** @internal */\n        this._abortController = null;\n        /** @internal */\n        this._audioContext = null;\n        /** @internal */\n        this._scriptProcessorNode = null; // Deprecated but goated\n        /** @internal */\n        this._promiseWithResolvers = promiseWithResolvers();\n        /** @internal */\n        this._errorPromiseAccessed = false;\n        /** @internal */\n        this._paused = false;\n        /** @internal */\n        this._lastSampleTimestamp = null;\n        /** @internal */\n        this._pauseOffset = 0;\n        this._encoder = new AudioEncoderWrapper(this, encodingConfig);\n        this._track = track;\n    }\n    /** @internal */\n    async _start() {\n        if (!this._errorPromiseAccessed) {\n            console.warn('Make sure not to ignore the `errorPromise` field on MediaStreamVideoTrackSource, so that any internal'\n                + ' errors get bubbled up properly.');\n        }\n        this._abortController = new AbortController();\n        let firstAudioDataTimestamp = null;\n        let errored = false;\n        const onAudioSample = (audioSample) => {\n            if (errored) {\n                audioSample.close();\n                return;\n            }\n            const currentTimestamp = audioSample.timestamp;\n            if (this._paused) {\n                const dataSeen = firstAudioDataTimestamp !== null;\n                if (dataSeen) {\n                    if (this._lastSampleTimestamp !== null) {\n                        // In addition to dropping this sample, let's also keep track of the time we have lost due to\n                        // the pause. Doing it like this instead of simply keeping track of the paused time is better\n                        // since it retains the sample rate of the underlying source.\n                        const timeDelta = currentTimestamp - this._lastSampleTimestamp;\n                        // We modify this field instead of _timestampOffset since we still might have data in flight\n                        // in the encoder, with which we don't want to mess.\n                        this._pauseOffset -= timeDelta;\n                    }\n                    this._lastSampleTimestamp = currentTimestamp;\n                }\n                audioSample.close();\n                return;\n            }\n            if (firstAudioDataTimestamp === null) {\n                firstAudioDataTimestamp = audioSample.timestamp;\n                const muxer = this._connectedTrack.output._muxer;\n                if (muxer.firstMediaStreamTimestamp === null) {\n                    muxer.firstMediaStreamTimestamp = performance.now() / 1000;\n                    this._timestampOffset = -firstAudioDataTimestamp;\n                }\n                else {\n                    this._timestampOffset = (performance.now() / 1000 - muxer.firstMediaStreamTimestamp)\n                        - firstAudioDataTimestamp;\n                }\n            }\n            this._lastSampleTimestamp = currentTimestamp;\n            if (this._encoder.getQueueSize() >= 4) {\n                // Drop data if the encoder is overloaded\n                audioSample.close();\n                return;\n            }\n            audioSample.setTimestamp(currentTimestamp + this._pauseOffset);\n            void this._encoder.add(audioSample, true)\n                .catch((error) => {\n                errored = true;\n                this._abortController?.abort();\n                this._promiseWithResolvers.reject(error);\n                void this._audioContext?.suspend();\n            });\n        };\n        if (typeof MediaStreamTrackProcessor !== 'undefined') {\n            // Great, MediaStreamTrackProcessor is supported, this is the preferred way of doing things\n            const processor = new MediaStreamTrackProcessor({ track: this._track });\n            const consumer = new WritableStream({\n                write: audioData => onAudioSample(new AudioSample(audioData)),\n            });\n            processor.readable.pipeTo(consumer, {\n                signal: this._abortController.signal,\n            }).catch((error) => {\n                // Handle AbortError silently\n                if (error instanceof DOMException && error.name === 'AbortError')\n                    return;\n                this._promiseWithResolvers.reject(error);\n            });\n        }\n        else {\n            // Let's fall back to an AudioContext approach\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n            const AudioContext = window.AudioContext || window.webkitAudioContext;\n            this._audioContext = new AudioContext({ sampleRate: this._track.getSettings().sampleRate });\n            const sourceNode = this._audioContext.createMediaStreamSource(new MediaStream([this._track]));\n            this._scriptProcessorNode = this._audioContext.createScriptProcessor(4096);\n            if (this._audioContext.state === 'suspended') {\n                await this._audioContext.resume();\n            }\n            sourceNode.connect(this._scriptProcessorNode);\n            this._scriptProcessorNode.connect(this._audioContext.destination);\n            let totalDuration = 0;\n            this._scriptProcessorNode.onaudioprocess = (event) => {\n                const iterator = AudioSample._fromAudioBuffer(event.inputBuffer, totalDuration);\n                totalDuration += event.inputBuffer.duration;\n                for (const audioSample of iterator) {\n                    onAudioSample(audioSample);\n                }\n            };\n        }\n    }\n    /**\n     * Pauses the capture of audio data - any audio data emitted by the underlying media stream will be ignored\n     * while paused. This does *not* close the underlying `MediaStreamAudioTrack`, it just ignores its output.\n     */\n    pause() {\n        this._paused = true;\n    }\n    /** Resumes the capture of audio data after being paused. */\n    resume() {\n        this._paused = false;\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (this._abortController) {\n            this._abortController.abort();\n            this._abortController = null;\n        }\n        if (this._audioContext) {\n            assert(this._scriptProcessorNode);\n            this._scriptProcessorNode.disconnect();\n            await this._audioContext.suspend();\n        }\n        await this._encoder.flushAndClose(forceClose);\n    }\n}\nconst mediaStreamTrackProcessorWorkerCode = () => {\n    const sendMessage = (message, transfer) => {\n        if (transfer) {\n            self.postMessage(message, { transfer });\n        }\n        else {\n            self.postMessage(message);\n        }\n    };\n    // Immediately send a message to the main thread, letting them know of the support\n    sendMessage({\n        type: 'support',\n        supported: typeof MediaStreamTrackProcessor !== 'undefined',\n    });\n    const abortControllers = new Map();\n    const activeTracks = new Map();\n    self.addEventListener('message', (event) => {\n        const message = event.data;\n        switch (message.type) {\n            case 'videoTrack':\n                {\n                    activeTracks.set(message.trackId, message.track);\n                    const processor = new MediaStreamTrackProcessor({ track: message.track });\n                    const consumer = new WritableStream({\n                        write: (videoFrame) => {\n                            if (!activeTracks.has(message.trackId)) {\n                                videoFrame.close();\n                                return;\n                            }\n                            // Send it to the main thread\n                            sendMessage({\n                                type: 'videoFrame',\n                                trackId: message.trackId,\n                                videoFrame,\n                            }, [videoFrame]);\n                        },\n                    });\n                    const abortController = new AbortController();\n                    abortControllers.set(message.trackId, abortController);\n                    processor.readable.pipeTo(consumer, {\n                        signal: abortController.signal,\n                    }).catch((error) => {\n                        // Handle AbortError silently\n                        if (error instanceof DOMException && error.name === 'AbortError')\n                            return;\n                        sendMessage({\n                            type: 'error',\n                            trackId: message.trackId,\n                            error,\n                        });\n                    });\n                }\n                ;\n                break;\n            case 'stopTrack':\n                {\n                    const abortController = abortControllers.get(message.trackId);\n                    if (abortController) {\n                        abortController.abort();\n                        abortControllers.delete(message.trackId);\n                    }\n                    const track = activeTracks.get(message.trackId);\n                    track?.stop();\n                    activeTracks.delete(message.trackId);\n                    sendMessage({\n                        type: 'trackStopped',\n                        trackId: message.trackId,\n                    });\n                }\n                ;\n                break;\n            default: assertNever(message);\n        }\n    });\n};\nlet nextMediaStreamTrackProcessorWorkerId = 0;\nlet mediaStreamTrackProcessorWorker = null;\nconst initMediaStreamTrackProcessorWorker = () => {\n    const blob = new Blob([`(${mediaStreamTrackProcessorWorkerCode.toString()})()`], { type: 'application/javascript' });\n    const url = URL.createObjectURL(blob);\n    mediaStreamTrackProcessorWorker = new Worker(url);\n};\nlet mediaStreamTrackProcessorIsSupportedInWorkerCache = null;\nconst mediaStreamTrackProcessorIsSupportedInWorker = async () => {\n    if (mediaStreamTrackProcessorIsSupportedInWorkerCache !== null) {\n        return mediaStreamTrackProcessorIsSupportedInWorkerCache;\n    }\n    if (!mediaStreamTrackProcessorWorker) {\n        initMediaStreamTrackProcessorWorker();\n    }\n    return new Promise((resolve) => {\n        assert(mediaStreamTrackProcessorWorker);\n        const listener = (event) => {\n            const message = event.data;\n            if (message.type === 'support') {\n                mediaStreamTrackProcessorIsSupportedInWorkerCache = message.supported;\n                mediaStreamTrackProcessorWorker.removeEventListener('message', listener);\n                resolve(message.supported);\n            }\n        };\n        mediaStreamTrackProcessorWorker.addEventListener('message', listener);\n    });\n};\nconst sendMessageToMediaStreamTrackProcessorWorker = (message, transfer) => {\n    assert(mediaStreamTrackProcessorWorker);\n    if (transfer) {\n        mediaStreamTrackProcessorWorker.postMessage(message, transfer);\n    }\n    else {\n        mediaStreamTrackProcessorWorker.postMessage(message);\n    }\n};\n/**\n * Base class for subtitle sources - sources for subtitle tracks.\n * @group Media sources\n * @public\n */\nexport class SubtitleSource extends MediaSource {\n    /** Internal constructor. */\n    constructor(codec) {\n        super();\n        /** @internal */\n        this._connectedTrack = null;\n        if (!SUBTITLE_CODECS.includes(codec)) {\n            throw new TypeError(`Invalid subtitle codec '${codec}'. Must be one of: ${SUBTITLE_CODECS.join(', ')}.`);\n        }\n        this._codec = codec;\n    }\n}\n/**\n * This source can be used to add subtitles from a subtitle text file.\n * @group Media sources\n * @public\n */\nexport class TextSubtitleSource extends SubtitleSource {\n    /** Creates a new {@link TextSubtitleSource} where added text chunks are in the specified `codec`. */\n    constructor(codec) {\n        super(codec);\n        /** @internal */\n        this._error = null;\n        this._parser = new SubtitleParser({\n            codec,\n            output: (cue, metadata) => {\n                void this._connectedTrack?.output._muxer.addSubtitleCue(this._connectedTrack, cue, metadata)\n                    .catch((error) => {\n                    this._error ??= error;\n                });\n            },\n        });\n    }\n    /**\n     * Parses the subtitle text according to the specified codec and adds it to the output track. You don't have to\n     * add the entire subtitle file at once here; you can provide it in chunks.\n     *\n     * @returns A Promise that resolves once the output is ready to receive more samples. You should await this Promise\n     * to respect writer and encoder backpressure.\n     */\n    add(text) {\n        if (typeof text !== 'string') {\n            throw new TypeError('text must be a string.');\n        }\n        this._checkForError();\n        this._ensureValidAdd();\n        this._parser.parse(text);\n        return this._connectedTrack.output._muxer.mutex.currentPromise;\n    }\n    /** @internal */\n    _checkForError() {\n        if (this._error) {\n            throw this._error;\n        }\n    }\n    /** @internal */\n    async _flushAndClose(forceClose) {\n        if (!forceClose) {\n            this._checkForError();\n        }\n    }\n}\n","/*!\n * Copyright (c) 2026-present, Vanilagy and contributors\n *\n * This Source Code Form is subject to the terms of the Mozilla Public\n * License, v. 2.0. If a copy of the MPL was not distributed with this\n * file, You can obtain one at https://mozilla.org/MPL/2.0/.\n */\nimport { AsyncMutex, isIso639Dash2LanguageCode } from './misc.js';\nimport { validateMetadataTags, validateTrackDisposition } from './metadata.js';\nimport { OutputFormat } from './output-format.js';\nimport { AudioSource, SubtitleSource, VideoSource } from './media-source.js';\nimport { Target } from './target.js';\n/**\n * List of all track types.\n * @group Miscellaneous\n * @public\n */\nexport const ALL_TRACK_TYPES = ['video', 'audio', 'subtitle'];\nconst validateBaseTrackMetadata = (metadata) => {\n    if (!metadata || typeof metadata !== 'object') {\n        throw new TypeError('metadata must be an object.');\n    }\n    if (metadata.languageCode !== undefined && !isIso639Dash2LanguageCode(metadata.languageCode)) {\n        throw new TypeError('metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.');\n    }\n    if (metadata.name !== undefined && typeof metadata.name !== 'string') {\n        throw new TypeError('metadata.name, when provided, must be a string.');\n    }\n    if (metadata.disposition !== undefined) {\n        validateTrackDisposition(metadata.disposition);\n    }\n    if (metadata.maximumPacketCount !== undefined\n        && (!Number.isInteger(metadata.maximumPacketCount) || metadata.maximumPacketCount < 0)) {\n        throw new TypeError('metadata.maximumPacketCount, when provided, must be a non-negative integer.');\n    }\n};\n/**\n * Main class orchestrating the creation of a new media file.\n * @group Output files\n * @public\n */\nexport class Output {\n    /**\n     * Creates a new instance of {@link Output} which can then be used to create a new media file according to the\n     * specified {@link OutputOptions}.\n     */\n    constructor(options) {\n        /** The current state of the output. */\n        this.state = 'pending';\n        /** @internal */\n        this._tracks = [];\n        /** @internal */\n        this._startPromise = null;\n        /** @internal */\n        this._cancelPromise = null;\n        /** @internal */\n        this._finalizePromise = null;\n        /** @internal */\n        this._mutex = new AsyncMutex();\n        /** @internal */\n        this._metadataTags = {};\n        if (!options || typeof options !== 'object') {\n            throw new TypeError('options must be an object.');\n        }\n        if (!(options.format instanceof OutputFormat)) {\n            throw new TypeError('options.format must be an OutputFormat.');\n        }\n        if (!(options.target instanceof Target)) {\n            throw new TypeError('options.target must be a Target.');\n        }\n        if (options.target._output) {\n            throw new Error('Target is already used for another output.');\n        }\n        options.target._output = this;\n        this.format = options.format;\n        this.target = options.target;\n        this._writer = options.target._createWriter();\n        this._muxer = options.format._createMuxer(this);\n    }\n    /** Adds a video track to the output with the given source. Can only be called before the output is started. */\n    addVideoTrack(source, metadata = {}) {\n        if (!(source instanceof VideoSource)) {\n            throw new TypeError('source must be a VideoSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        if (metadata.rotation !== undefined && ![0, 90, 180, 270].includes(metadata.rotation)) {\n            throw new TypeError(`Invalid video rotation: ${metadata.rotation}. Has to be 0, 90, 180 or 270.`);\n        }\n        if (!this.format.supportsVideoRotationMetadata && metadata.rotation) {\n            throw new Error(`${this.format._name} does not support video rotation metadata.`);\n        }\n        if (metadata.frameRate !== undefined\n            && (!Number.isFinite(metadata.frameRate) || metadata.frameRate <= 0)) {\n            throw new TypeError(`Invalid video frame rate: ${metadata.frameRate}. Must be a positive number.`);\n        }\n        this._addTrack('video', source, metadata);\n    }\n    /** Adds an audio track to the output with the given source. Can only be called before the output is started. */\n    addAudioTrack(source, metadata = {}) {\n        if (!(source instanceof AudioSource)) {\n            throw new TypeError('source must be an AudioSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('audio', source, metadata);\n    }\n    /** Adds a subtitle track to the output with the given source. Can only be called before the output is started. */\n    addSubtitleTrack(source, metadata = {}) {\n        if (!(source instanceof SubtitleSource)) {\n            throw new TypeError('source must be a SubtitleSource.');\n        }\n        validateBaseTrackMetadata(metadata);\n        this._addTrack('subtitle', source, metadata);\n    }\n    /**\n     * Sets descriptive metadata tags about the media file, such as title, author, date, or cover art. When called\n     * multiple times, only the metadata from the last call will be used.\n     *\n     * Can only be called before the output is started.\n     */\n    setMetadataTags(tags) {\n        validateMetadataTags(tags);\n        if (this.state !== 'pending') {\n            throw new Error('Cannot set metadata tags after output has been started or canceled.');\n        }\n        this._metadataTags = tags;\n    }\n    /** @internal */\n    _addTrack(type, source, metadata) {\n        if (this.state !== 'pending') {\n            throw new Error('Cannot add track after output has been started or canceled.');\n        }\n        if (source._connectedTrack) {\n            throw new Error('Source is already used for a track.');\n        }\n        // Verify maximum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === type ? 1 : 0), 0);\n        const maxCount = supportedTrackCounts[type].max;\n        if (presentTracksOfThisType === maxCount) {\n            throw new Error(maxCount === 0\n                ? `${this.format._name} does not support ${type} tracks.`\n                : (`${this.format._name} does not support more than ${maxCount} ${type} track`\n                    + `${maxCount === 1 ? '' : 's'}.`));\n        }\n        const maxTotalCount = supportedTrackCounts.total.max;\n        if (this._tracks.length === maxTotalCount) {\n            throw new Error(`${this.format._name} does not support more than ${maxTotalCount} tracks`\n                + `${maxTotalCount === 1 ? '' : 's'} in total.`);\n        }\n        const track = {\n            id: this._tracks.length + 1,\n            output: this,\n            type,\n            source: source,\n            metadata,\n        };\n        if (track.type === 'video') {\n            const supportedVideoCodecs = this.format.getSupportedVideoCodecs();\n            if (supportedVideoCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support video tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedVideoCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` video codecs are: ${supportedVideoCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'audio') {\n            const supportedAudioCodecs = this.format.getSupportedAudioCodecs();\n            if (supportedAudioCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support audio tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedAudioCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` audio codecs are: ${supportedAudioCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        else if (track.type === 'subtitle') {\n            const supportedSubtitleCodecs = this.format.getSupportedSubtitleCodecs();\n            if (supportedSubtitleCodecs.length === 0) {\n                throw new Error(`${this.format._name} does not support subtitle tracks.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n            else if (!supportedSubtitleCodecs.includes(track.source._codec)) {\n                throw new Error(`Codec '${track.source._codec}' cannot be contained within ${this.format._name}. Supported`\n                    + ` subtitle codecs are: ${supportedSubtitleCodecs.map(codec => `'${codec}'`).join(', ')}.`\n                    + this.format._codecUnsupportedHint(track.source._codec));\n            }\n        }\n        this._tracks.push(track);\n        source._connectedTrack = track;\n    }\n    /**\n     * Starts the creation of the output file. This method should be called after all tracks have been added. Only after\n     * the output has started can media samples be added to the tracks.\n     *\n     * @returns A promise that resolves when the output has successfully started and is ready to receive media samples.\n     */\n    async start() {\n        // Verify minimum track count constraints\n        const supportedTrackCounts = this.format.getSupportedTrackCounts();\n        for (const trackType of ALL_TRACK_TYPES) {\n            const presentTracksOfThisType = this._tracks.reduce((count, track) => count + (track.type === trackType ? 1 : 0), 0);\n            const minCount = supportedTrackCounts[trackType].min;\n            if (presentTracksOfThisType < minCount) {\n                throw new Error(minCount === supportedTrackCounts[trackType].max\n                    ? (`${this.format._name} requires exactly ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`)\n                    : (`${this.format._name} requires at least ${minCount} ${trackType}`\n                        + ` track${minCount === 1 ? '' : 's'}.`));\n            }\n        }\n        const totalMinCount = supportedTrackCounts.total.min;\n        if (this._tracks.length < totalMinCount) {\n            throw new Error(totalMinCount === supportedTrackCounts.total.max\n                ? (`${this.format._name} requires exactly ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`)\n                : (`${this.format._name} requires at least ${totalMinCount} track`\n                    + `${totalMinCount === 1 ? '' : 's'}.`));\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Output has been canceled.');\n        }\n        if (this._startPromise) {\n            console.warn('Output has already been started.');\n            return this._startPromise;\n        }\n        return this._startPromise = (async () => {\n            this.state = 'started';\n            this._writer.start();\n            const release = await this._mutex.acquire();\n            await this._muxer.start();\n            const promises = this._tracks.map(track => track.source._start());\n            await Promise.all(promises);\n            release();\n        })();\n    }\n    /**\n     * Resolves with the full MIME type of the output file, including track codecs.\n     *\n     * The returned promise will resolve only once the precise codec strings of all tracks are known.\n     */\n    getMimeType() {\n        return this._muxer.getMimeType();\n    }\n    /**\n     * Cancels the creation of the output file, releasing internal resources like encoders and preventing further\n     * samples from being added.\n     *\n     * @returns A promise that resolves once all internal resources have been released.\n     */\n    async cancel() {\n        if (this._cancelPromise) {\n            console.warn('Output has already been canceled.');\n            return this._cancelPromise;\n        }\n        else if (this.state === 'finalizing' || this.state === 'finalized') {\n            console.warn('Output has already been finalized.');\n            return;\n        }\n        return this._cancelPromise = (async () => {\n            this.state = 'canceled';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(true)); // Force close\n            await Promise.all(promises);\n            await this._writer.close();\n            release();\n        })();\n    }\n    /**\n     * Finalizes the output file. This method must be called after all media samples across all tracks have been added.\n     * Once the Promise returned by this method completes, the output file is ready.\n     */\n    async finalize() {\n        if (this.state === 'pending') {\n            throw new Error('Cannot finalize before starting.');\n        }\n        if (this.state === 'canceled') {\n            throw new Error('Cannot finalize after canceling.');\n        }\n        if (this._finalizePromise) {\n            console.warn('Output has already been finalized.');\n            return this._finalizePromise;\n        }\n        return this._finalizePromise = (async () => {\n            this.state = 'finalizing';\n            const release = await this._mutex.acquire();\n            const promises = this._tracks.map(x => x.source._flushOrWaitForOngoingClose(false));\n            await Promise.all(promises);\n            await this._muxer.finalize();\n            await this._writer.flush();\n            await this._writer.finalize();\n            this.state = 'finalized';\n            release();\n        })();\n    }\n}\n","import { Pair } from 'bitecs';\nimport { Output, Mp4OutputFormat, BufferTarget, CanvasSource } from 'mediabunny';\nimport { Sequence, SequenceState, Tween, TweenState, ChildOf, type State } from '@multiplekex/shallot';\nimport { StepTransition } from '@blog-components/sequence';\nimport type { RecordingConfig } from './types';\n\nexport function setCanvasSize(canvas: HTMLCanvasElement, width: number, height: number): void {\n  const dpr = window.devicePixelRatio || 1;\n  canvas.style.width = `${width / dpr}px`;\n  canvas.style.height = `${height / dpr}px`;\n  canvas.width = width;\n  canvas.height = height;\n}\n\nexport function findSequenceForTransition(state: State, from: number, to: number): number | null {\n  for (const eid of state.query([Sequence, StepTransition])) {\n    if (StepTransition.from[eid] === from && StepTransition.to[eid] === to) {\n      return eid;\n    }\n  }\n  return null;\n}\n\nexport function getMaxStep(state: State): number {\n  let max = 0;\n  for (const eid of state.query([Sequence, StepTransition])) {\n    max = Math.max(max, StepTransition.from[eid], StepTransition.to[eid]);\n  }\n  return max;\n}\n\nexport async function encodeSequence(\n  canvas: HTMLCanvasElement,\n  state: State,\n  seqEid: number,\n  config: RecordingConfig,\n  onProgress?: (frame: number, total: number) => void\n): Promise<Blob> {\n  // Reset sequence to initial state\n  Sequence.state[seqEid] = SequenceState.IDLE;\n  Sequence.elapsed[seqEid] = 0;\n  for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\n    Tween.state[childEid] = TweenState.IDLE;\n    Tween.elapsed[childEid] = 0;\n  }\n\n  // Start playing and trigger computeTweenDelays()\n  Sequence.state[seqEid] = SequenceState.PLAYING;\n  state.step(0);\n\n  // Calculate duration from delay + duration of all tweens\n  let maxEndTime = 0;\n  for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\n    const endTime = (Tween.delay[childEid] ?? 0) + (Tween.duration[childEid] ?? 0);\n    maxEndTime = Math.max(maxEndTime, endTime);\n  }\n  const duration = maxEndTime + 0.5;\n  const totalFrames = Math.ceil(duration * config.fps);\n\n  // Setup video output\n  const output = new Output({\n    format: new Mp4OutputFormat({ fastStart: 'in-memory' }),\n    target: new BufferTarget(),\n  });\n\n  const videoSource = new CanvasSource(canvas, {\n    codec: 'avc',\n    bitrate: config.bitrate,\n  });\n\n  output.addVideoTrack(videoSource, { frameRate: config.fps });\n  await output.start();\n\n  const stepTime = 1 / config.fps;\n\n  // Encoding loop\n  for (let i = 0; i < totalFrames; i++) {\n    setCanvasSize(canvas, config.width, config.height);\n    state.step(stepTime);\n\n    const timestamp = i / config.fps;\n    await videoSource.add(timestamp, stepTime);\n\n    if (i % 30 === 0) {\n      onProgress?.(i, totalFrames);\n      await new Promise((r) => setTimeout(r, 0));\n    }\n  }\n\n  await output.finalize();\n\n  // Mark sequence as complete to prevent replay\n  Sequence.state[seqEid] = SequenceState.COMPLETE;\n  for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\n    Tween.state[childEid] = TweenState.COMPLETE;\n  }\n\n  return new Blob([output.target.buffer!], { type: 'video/mp4' });\n}\n\nexport function downloadBlob(blob: Blob, filename: string): void {\n  const url = URL.createObjectURL(blob);\n  const a = document.createElement('a');\n  a.href = url;\n  a.download = filename;\n  a.click();\n  URL.revokeObjectURL(url);\n}\n","import type { State } from '@multiplekex/shallot';\nimport type { RecordSequenceConfig } from '@blog-components/sequence';\nimport { findSequenceForTransition, setCanvasSize, encodeSequence } from './core';\n\nexport function setupCanvasRecording(canvas: HTMLCanvasElement, state: State): void {\n  canvas.__recordSequence__ = async (\n    config: RecordSequenceConfig,\n    onProgress?: (frame: number, total: number) => void\n  ): Promise<Blob | null> => {\n    const seqEid = findSequenceForTransition(state, config.fromStep, config.toStep);\n    if (seqEid === null) return null;\n\n    const origWidth = canvas.width;\n    const origHeight = canvas.height;\n    const origStyle = canvas.style.cssText;\n\n    // Pause visibility loop to prevent double-stepping\n    canvas.__paused__ = true;\n\n    setCanvasSize(canvas, config.width, config.height);\n    await new Promise((r) => requestAnimationFrame(r));\n\n    const blob = await encodeSequence(canvas, state, seqEid, config, onProgress);\n\n    // Restore canvas size\n    canvas.width = origWidth;\n    canvas.height = origHeight;\n    canvas.style.cssText = origStyle;\n\n    // Resume visibility loop\n    canvas.__paused__ = false;\n\n    return blob;\n  };\n}\n","import { Canvas, type State } from '@multiplekex/shallot';\nimport { setupCanvasRecording } from '@blog-components/recording';\nimport { connectStepControls, type StepContent } from './ui';\n\nexport function setupCanvas(canvas: HTMLCanvasElement): void {\n  const rect = canvas.getBoundingClientRect();\n  canvas.width = rect.width * window.devicePixelRatio;\n  canvas.height = rect.height * window.devicePixelRatio;\n}\n\nexport function setupVisibilityControl(state: State): void {\n  new IntersectionObserver(([entry]) => {\n    if (entry.isIntersecting) {\n      state.start();\n    } else {\n      state.stop();\n    }\n  }).observe(document.documentElement);\n}\n\nexport function createVisibilityLoop(\n  state: State,\n  canvas?: HTMLCanvasElement,\n  onTick?: (dt: number) => void\n): void {\n  const canvasEl = canvas ?? Canvas.from(state)?.element;\n  let visible = false;\n  let lastTime = performance.now();\n\n  function tick(now: number): void {\n    if (!visible) return;\n    const dt = (now - lastTime) / 1000;\n    lastTime = now;\n    // Skip stepping if canvas is paused (e.g., during recording)\n    if (!canvasEl?.__paused__) {\n      state.step(dt);\n      onTick?.(dt);\n    }\n    requestAnimationFrame(tick);\n  }\n\n  new IntersectionObserver(([entry]) => {\n    if (entry.isIntersecting) {\n      if (!visible) {\n        visible = true;\n        lastTime = performance.now();\n        requestAnimationFrame(tick);\n      }\n    } else {\n      visible = false;\n    }\n  }).observe(document.documentElement);\n}\n\nexport function setupScrollPassthrough(canvas: HTMLCanvasElement): void {\n  canvas.addEventListener(\n    'wheel',\n    (e) => {\n      window.parent.postMessage({ type: 'iframe-scroll', deltaY: e.deltaY }, '*');\n    },\n    { passive: true }\n  );\n}\n\nexport function setupIframeScrollListener(): void {\n  window.addEventListener('message', (e) => {\n    if (e.data?.type === 'iframe-scroll' && typeof e.data.deltaY === 'number') {\n      window.scrollBy(0, e.data.deltaY);\n    }\n  });\n}\n\nexport function setupDemo(\n  canvas: HTMLCanvasElement,\n  state: State,\n  steps?: StepContent[],\n  onStepChange?: (step: number) => void\n): () => void {\n  canvas.__state__ = state;\n  setupCanvasRecording(canvas, state);\n\n  const disposeControls = steps\n    ? connectStepControls(canvas, state, steps, onStepChange)\n    : () => {};\n\n  createVisibilityLoop(state, canvas);\n\n  const reportHeight = () => {\n    window.parent.postMessage({ type: 'iframe-resize', height: document.body.scrollHeight }, '*');\n  };\n  reportHeight();\n  window.addEventListener('resize', reportHeight);\n\n  return disposeControls;\n}\n"],"file":"canvas-setup-FxFxhnX5.js"}