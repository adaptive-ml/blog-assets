import{k as At,l as Ue,n as It,o as Me,C as O,p as Gi,q as Ze,r as le,g as ae,t as m,j as P,u as S,v as ue,M as T,w as be,x as Yi,y as De,z as Qi,R as Zi,B as ui,D as Ki,E as Ji,F as er,G as tr,H as Z}from"./canvas-setup-F5JALq5m.js";function Ks(t){const e=typeof t=="string"?document.querySelector(t):t;return e?{btnPrev:e.querySelector(".btn-prev"),btnNext:e.querySelector(".btn-next"),counter:e.querySelector(".step-counter"),title:e.querySelector(".step-title"),description:e.querySelector(".step-description")}:{btnPrev:null,btnNext:null,counter:null,title:null,description:null}}function Js(t,e){const{steps:i,onStepChange:r}=e,n=i.length-1;let s=0;const o=t.title?.parentElement;if(o){let g=0;for(const h of i)t.title&&(t.title.textContent=h.title),t.description&&(t.description.innerHTML=h.description),g=Math.max(g,o.offsetHeight);o.style.minHeight=`${g}px`}function a(){const{btnPrev:g,btnNext:h,counter:p,title:x,description:B}=t,_=i[s];g&&(g.disabled=s<=0),h&&(h.disabled=s>=n),p&&(p.textContent=`Step ${s+1} of ${i.length}`),x&&(x.textContent=_?.title??""),B&&(B.innerHTML=_?.description??"")}function l(g){const h=Math.max(0,Math.min(n,g));h!==s&&(s=h,a(),r(s))}const c=()=>l(s-1),d=()=>l(s+1),f=g=>{g.key==="ArrowLeft"&&l(s-1),g.key==="ArrowRight"&&l(s+1)};return t.btnPrev?.addEventListener("click",c),t.btnNext?.addEventListener("click",d),document.addEventListener("keydown",f),a(),{setStep(g){s=Math.max(0,Math.min(n,g)),a()},getStep:()=>s,getMaxStep:()=>n,dispose(){t.btnPrev?.removeEventListener("click",c),t.btnNext?.removeEventListener("click",d),document.removeEventListener("keydown",f)}}}function v(t){if(!t)throw new Error("Assertion failed.")}const te=t=>t&&t[t.length-1],Ae=t=>t>=0&&t<2**32;class Pe{constructor(e){this.bytes=e,this.pos=0}seekToByte(e){this.pos=8*e}readBit(){const e=Math.floor(this.pos/8),i=this.bytes[e]??0,r=7-(this.pos&7),n=(i&1<<r)>>r;return this.pos++,n}readBits(e){if(e===1)return this.readBit();let i=0;for(let r=0;r<e;r++)i<<=1,i|=this.readBit();return i}writeBits(e,i){const r=this.pos+e;for(let n=this.pos;n<r;n++){const s=Math.floor(n/8);let o=this.bytes[s];const a=7-(n&7);o&=~(1<<a),o|=(i&1<<r-n-1)>>r-n-1<<a,this.bytes[s]=o}this.pos=r}readAlignedByte(){if(this.pos%8!==0)throw new Error("Bitstream is not byte-aligned.");const e=this.pos/8,i=this.bytes[e]??0;return this.pos+=8,i}skipBits(e){this.pos+=e}getBitsLeft(){return this.bytes.length*8-this.pos}clone(){const e=new Pe(this.bytes);return e.pos=this.pos,e}}const y=t=>{let e=0;for(;t.readBits(1)===0&&e<32;)e++;if(e>=32)throw new Error("Invalid exponential-Golomb code.");return(1<<e)-1+t.readBits(e)},me=t=>{const e=y(t);return(e&1)===0?-(e>>1):e+1>>1},ye=t=>t.constructor===Uint8Array?t:ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t),hi=t=>t.constructor===DataView?t:ArrayBuffer.isView(t)?new DataView(t.buffer,t.byteOffset,t.byteLength):new DataView(t),ce=new TextEncoder,yt={bt709:1,bt470bg:5,smpte170m:6,bt2020:9,smpte432:12},bt={bt709:1,smpte170m:6,linear:8,"iec61966-2-1":13,pq:16,hlg:18},Tt={rgb:0,bt709:1,bt470bg:5,smpte170m:6,"bt2020-ncl":9},ir=t=>!!t&&!!t.primaries&&!!t.transfer&&!!t.matrix&&t.fullRange!==void 0,vt=t=>t instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&t instanceof SharedArrayBuffer||ArrayBuffer.isView(t);class fi{constructor(){this.currentPromise=Promise.resolve(),this.pending=0}async acquire(){let e;const i=new Promise(n=>{let s=!1;e=()=>{s||(n(),this.pending--,s=!0)}}),r=this.currentPromise;return this.currentPromise=i,this.pending++,await r,e}}const rr=()=>{let t,e;return{promise:new Promise((r,n)=>{t=r,e=n}),resolve:t,reject:e}},Ct=t=>{throw new Error(`Unexpected value: ${t}`)},nr=(t,e,i,r)=>{i=i>>>0,i=i&16777215,t.setUint8(e,i>>>16&255),t.setUint8(e+1,i>>>8&255),t.setUint8(e+2,i&255)},sr="und",or=/^[a-z]{3}$/,ar=t=>or.test(t),Be=1e6*(1+Number.EPSILON),cr=(t,e)=>{const i=t<0?-1:1;t=Math.abs(t);let r=0,n=1,s=1,o=0,a=t;for(;;){const l=Math.floor(a),c=l*s+r,d=l*o+n;if(d>e)return{numerator:i*s,denominator:o};if(r=s,n=o,s=c,o=d,a=1/(a-l),!isFinite(a))break}return{numerator:i*s,denominator:o}};class dr{constructor(){this.currentPromise=Promise.resolve()}call(e){return this.currentPromise=this.currentPromise.then(e)}}let Ke=null;const dt=()=>Ke!==null?Ke:Ke=typeof navigator<"u"&&navigator.userAgent?.includes("Firefox"),mi=function*(t){for(const e in t){const i=t[e];i!==void 0&&(yield{key:e,value:i})}},lr=()=>{Symbol.dispose??=Symbol("Symbol.dispose")};class pi{constructor(e,i){if(this.data=e,this.mimeType=i,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(typeof i!="string")throw new TypeError("mimeType must be a string.")}}class ur{constructor(e,i,r,n){if(this.data=e,this.mimeType=i,this.name=r,this.description=n,!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(i!==void 0&&typeof i!="string")throw new TypeError("mimeType, when provided, must be a string.");if(r!==void 0&&typeof r!="string")throw new TypeError("name, when provided, must be a string.");if(n!==void 0&&typeof n!="string")throw new TypeError("description, when provided, must be a string.")}}const hr=t=>{if(!t||typeof t!="object")throw new TypeError("tags must be an object.");if(t.title!==void 0&&typeof t.title!="string")throw new TypeError("tags.title, when provided, must be a string.");if(t.description!==void 0&&typeof t.description!="string")throw new TypeError("tags.description, when provided, must be a string.");if(t.artist!==void 0&&typeof t.artist!="string")throw new TypeError("tags.artist, when provided, must be a string.");if(t.album!==void 0&&typeof t.album!="string")throw new TypeError("tags.album, when provided, must be a string.");if(t.albumArtist!==void 0&&typeof t.albumArtist!="string")throw new TypeError("tags.albumArtist, when provided, must be a string.");if(t.trackNumber!==void 0&&(!Number.isInteger(t.trackNumber)||t.trackNumber<=0))throw new TypeError("tags.trackNumber, when provided, must be a positive integer.");if(t.tracksTotal!==void 0&&(!Number.isInteger(t.tracksTotal)||t.tracksTotal<=0))throw new TypeError("tags.tracksTotal, when provided, must be a positive integer.");if(t.discNumber!==void 0&&(!Number.isInteger(t.discNumber)||t.discNumber<=0))throw new TypeError("tags.discNumber, when provided, must be a positive integer.");if(t.discsTotal!==void 0&&(!Number.isInteger(t.discsTotal)||t.discsTotal<=0))throw new TypeError("tags.discsTotal, when provided, must be a positive integer.");if(t.genre!==void 0&&typeof t.genre!="string")throw new TypeError("tags.genre, when provided, must be a string.");if(t.date!==void 0&&(!(t.date instanceof Date)||Number.isNaN(t.date.getTime())))throw new TypeError("tags.date, when provided, must be a valid Date.");if(t.lyrics!==void 0&&typeof t.lyrics!="string")throw new TypeError("tags.lyrics, when provided, must be a string.");if(t.images!==void 0){if(!Array.isArray(t.images))throw new TypeError("tags.images, when provided, must be an array.");for(const e of t.images){if(!e||typeof e!="object")throw new TypeError("Each image in tags.images must be an object.");if(!(e.data instanceof Uint8Array))throw new TypeError("Each image.data must be a Uint8Array.");if(typeof e.mimeType!="string")throw new TypeError("Each image.mimeType must be a string.");if(!["coverFront","coverBack","unknown"].includes(e.kind))throw new TypeError("Each image.kind must be 'coverFront', 'coverBack', or 'unknown'.")}}if(t.comment!==void 0&&typeof t.comment!="string")throw new TypeError("tags.comment, when provided, must be a string.");if(t.raw!==void 0){if(!t.raw||typeof t.raw!="object")throw new TypeError("tags.raw, when provided, must be an object.");for(const e of Object.values(t.raw))if(e!==null&&typeof e!="string"&&!(e instanceof Uint8Array)&&!(e instanceof pi)&&!(e instanceof ur))throw new TypeError("Each value in tags.raw must be a string, Uint8Array, RichImageData, AttachedFile, or null.")}},fr=t=>{if(!t||typeof t!="object")throw new TypeError("disposition must be an object.");if(t.default!==void 0&&typeof t.default!="boolean")throw new TypeError("disposition.default must be a boolean.");if(t.forced!==void 0&&typeof t.forced!="boolean")throw new TypeError("disposition.forced must be a boolean.");if(t.original!==void 0&&typeof t.original!="boolean")throw new TypeError("disposition.original must be a boolean.");if(t.commentary!==void 0&&typeof t.commentary!="boolean")throw new TypeError("disposition.commentary must be a boolean.");if(t.hearingImpaired!==void 0&&typeof t.hearingImpaired!="boolean")throw new TypeError("disposition.hearingImpaired must be a boolean.");if(t.visuallyImpaired!==void 0&&typeof t.visuallyImpaired!="boolean")throw new TypeError("disposition.visuallyImpaired must be a boolean.")};const Ee=["avc","hevc","vp9","av1","vp8"],Se=["pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be","pcm-u8","pcm-s8","ulaw","alaw"],gi=["aac","opus","mp3","vorbis","flac"],$e=[...gi,...Se],qe=["webvtt"],Xe=[{maxMacroblocks:99,maxBitrate:64e3,maxDpbMbs:396,level:10},{maxMacroblocks:396,maxBitrate:192e3,maxDpbMbs:900,level:11},{maxMacroblocks:396,maxBitrate:384e3,maxDpbMbs:2376,level:12},{maxMacroblocks:396,maxBitrate:768e3,maxDpbMbs:2376,level:13},{maxMacroblocks:396,maxBitrate:2e6,maxDpbMbs:2376,level:20},{maxMacroblocks:792,maxBitrate:4e6,maxDpbMbs:4752,level:21},{maxMacroblocks:1620,maxBitrate:4e6,maxDpbMbs:8100,level:22},{maxMacroblocks:1620,maxBitrate:1e7,maxDpbMbs:8100,level:30},{maxMacroblocks:3600,maxBitrate:14e6,maxDpbMbs:18e3,level:31},{maxMacroblocks:5120,maxBitrate:2e7,maxDpbMbs:20480,level:32},{maxMacroblocks:8192,maxBitrate:2e7,maxDpbMbs:32768,level:40},{maxMacroblocks:8192,maxBitrate:5e7,maxDpbMbs:32768,level:41},{maxMacroblocks:8704,maxBitrate:5e7,maxDpbMbs:34816,level:42},{maxMacroblocks:22080,maxBitrate:135e6,maxDpbMbs:110400,level:50},{maxMacroblocks:36864,maxBitrate:24e7,maxDpbMbs:184320,level:51},{maxMacroblocks:36864,maxBitrate:24e7,maxDpbMbs:184320,level:52},{maxMacroblocks:139264,maxBitrate:24e7,maxDpbMbs:696320,level:60},{maxMacroblocks:139264,maxBitrate:48e7,maxDpbMbs:696320,level:61},{maxMacroblocks:139264,maxBitrate:8e8,maxDpbMbs:696320,level:62}],Mt=[{maxPictureSize:36864,maxBitrate:128e3,tier:"L",level:30},{maxPictureSize:122880,maxBitrate:15e5,tier:"L",level:60},{maxPictureSize:245760,maxBitrate:3e6,tier:"L",level:63},{maxPictureSize:552960,maxBitrate:6e6,tier:"L",level:90},{maxPictureSize:983040,maxBitrate:1e7,tier:"L",level:93},{maxPictureSize:2228224,maxBitrate:12e6,tier:"L",level:120},{maxPictureSize:2228224,maxBitrate:3e7,tier:"H",level:120},{maxPictureSize:2228224,maxBitrate:2e7,tier:"L",level:123},{maxPictureSize:2228224,maxBitrate:5e7,tier:"H",level:123},{maxPictureSize:8912896,maxBitrate:25e6,tier:"L",level:150},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:150},{maxPictureSize:8912896,maxBitrate:4e7,tier:"L",level:153},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:153},{maxPictureSize:8912896,maxBitrate:6e7,tier:"L",level:156},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:156},{maxPictureSize:35651584,maxBitrate:6e7,tier:"L",level:180},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:180},{maxPictureSize:35651584,maxBitrate:12e7,tier:"L",level:183},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:183},{maxPictureSize:35651584,maxBitrate:24e7,tier:"L",level:186},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:186}],Ft=[{maxPictureSize:36864,maxBitrate:2e5,level:10},{maxPictureSize:73728,maxBitrate:8e5,level:11},{maxPictureSize:122880,maxBitrate:18e5,level:20},{maxPictureSize:245760,maxBitrate:36e5,level:21},{maxPictureSize:552960,maxBitrate:72e5,level:30},{maxPictureSize:983040,maxBitrate:12e6,level:31},{maxPictureSize:2228224,maxBitrate:18e6,level:40},{maxPictureSize:2228224,maxBitrate:3e7,level:41},{maxPictureSize:8912896,maxBitrate:6e7,level:50},{maxPictureSize:8912896,maxBitrate:12e7,level:51},{maxPictureSize:8912896,maxBitrate:18e7,level:52},{maxPictureSize:35651584,maxBitrate:18e7,level:60},{maxPictureSize:35651584,maxBitrate:24e7,level:61},{maxPictureSize:35651584,maxBitrate:48e7,level:62}],zt=[{maxPictureSize:147456,maxBitrate:15e5,tier:"M",level:0},{maxPictureSize:278784,maxBitrate:3e6,tier:"M",level:1},{maxPictureSize:665856,maxBitrate:6e6,tier:"M",level:4},{maxPictureSize:1065024,maxBitrate:1e7,tier:"M",level:5},{maxPictureSize:2359296,maxBitrate:12e6,tier:"M",level:8},{maxPictureSize:2359296,maxBitrate:3e7,tier:"H",level:8},{maxPictureSize:2359296,maxBitrate:2e7,tier:"M",level:9},{maxPictureSize:2359296,maxBitrate:5e7,tier:"H",level:9},{maxPictureSize:8912896,maxBitrate:3e7,tier:"M",level:12},{maxPictureSize:8912896,maxBitrate:1e8,tier:"H",level:12},{maxPictureSize:8912896,maxBitrate:4e7,tier:"M",level:13},{maxPictureSize:8912896,maxBitrate:16e7,tier:"H",level:13},{maxPictureSize:8912896,maxBitrate:6e7,tier:"M",level:14},{maxPictureSize:8912896,maxBitrate:24e7,tier:"H",level:14},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:15},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:15},{maxPictureSize:35651584,maxBitrate:6e7,tier:"M",level:16},{maxPictureSize:35651584,maxBitrate:24e7,tier:"H",level:16},{maxPictureSize:35651584,maxBitrate:1e8,tier:"M",level:17},{maxPictureSize:35651584,maxBitrate:48e7,tier:"H",level:17},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:18},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:18},{maxPictureSize:35651584,maxBitrate:16e7,tier:"M",level:19},{maxPictureSize:35651584,maxBitrate:8e8,tier:"H",level:19}],mr=(t,e,i,r)=>{if(t==="avc"){const s=Math.ceil(e/16)*Math.ceil(i/16),o=Xe.find(f=>s<=f.maxMacroblocks&&r<=f.maxBitrate)??te(Xe),a=o?o.level:0,l="64".padStart(2,"0"),c="00",d=a.toString(16).padStart(2,"0");return`avc1.${l}${c}${d}`}else if(t==="hevc"){const a=e*i,l=Mt.find(d=>a<=d.maxPictureSize&&r<=d.maxBitrate)??te(Mt);return`hev1.1.6.${l.tier}${l.level}.B0`}else{if(t==="vp8")return"vp8";if(t==="vp9"){const s=e*i;return`vp09.00.${(Ft.find(l=>s<=l.maxPictureSize&&r<=l.maxBitrate)??te(Ft)).level.toString().padStart(2,"0")}.08`}else if(t==="av1"){const s=e*i,o=zt.find(c=>s<=c.maxPictureSize&&r<=c.maxBitrate)??te(zt);return`av01.0.${o.level.toString().padStart(2,"0")}${o.tier}.08`}}throw new TypeError(`Unhandled codec '${t}'.`)},pr=t=>{const e=t.split("."),n=(1<<7)+1,s=Number(e[1]),o=e[2],a=Number(o.slice(0,-1)),l=(s<<5)+a,c=o.slice(-1)==="H"?1:0,f=Number(e[3])===8?0:1,g=0,h=e[4]?Number(e[4]):0,p=e[5]?Number(e[5][0]):1,x=e[5]?Number(e[5][1]):1,B=e[5]?Number(e[5][2]):0,_=(c<<7)+(f<<6)+(g<<5)+(h<<4)+(p<<3)+(x<<2)+B;return[n,l,_,0]},wi=[96e3,88200,64e3,48e3,44100,32e3,24e3,22050,16e3,12e3,11025,8e3,7350],yi=[-1,1,2,3,4,5,6,8],gr=t=>{let e=wi.indexOf(t.sampleRate),i=null;e===-1&&(e=15,i=t.sampleRate);const r=yi.indexOf(t.numberOfChannels);if(r===-1)throw new TypeError(`Unsupported number of channels: ${t.numberOfChannels}`);let n=13;t.objectType>=32&&(n+=6),e===15&&(n+=24);const s=Math.ceil(n/8),o=new Uint8Array(s),a=new Pe(o);return t.objectType<32?a.writeBits(5,t.objectType):(a.writeBits(5,31),a.writeBits(6,t.objectType-32)),a.writeBits(4,e),e===15&&a.writeBits(24,i),a.writeBits(4,r),o},bi=/^pcm-([usf])(\d+)+(be)?$/,We=t=>{if(v(Se.includes(t)),t==="ulaw")return{dataType:"ulaw",sampleSize:1,littleEndian:!0,silentValue:255};if(t==="alaw")return{dataType:"alaw",sampleSize:1,littleEndian:!0,silentValue:213};const e=bi.exec(t);v(e);let i;e[1]==="u"?i="unsigned":e[1]==="s"?i="signed":i="float";const r=Number(e[2])/8,n=e[3]!=="be",s=t==="pcm-u8"?2**7:0;return{dataType:i,sampleSize:r,littleEndian:n,silentValue:s}},wr=t=>t.startsWith("avc1")||t.startsWith("avc3")?"avc":t.startsWith("hev1")||t.startsWith("hvc1")?"hevc":t==="vp8"?"vp8":t.startsWith("vp09")?"vp9":t.startsWith("av01")?"av1":t.startsWith("mp4a.40")||t==="mp4a.67"?"aac":t==="mp3"||t==="mp4a.69"||t==="mp4a.6B"||t==="mp4a.6b"?"mp3":t==="opus"?"opus":t==="vorbis"?"vorbis":t==="flac"?"flac":t==="ulaw"?"ulaw":t==="alaw"?"alaw":bi.test(t)?t:t==="webvtt"?"webvtt":null,yr=t=>t==="avc"?{avc:{format:"avc"}}:t==="hevc"?{hevc:{format:"hevc"}}:{},br=["avc1","avc3","hev1","hvc1","vp8","vp09","av01"],Tr=/^(avc1|avc3)\.[0-9a-fA-F]{6}$/,vr=/^(hev1|hvc1)\.(?:[ABC]?\d+)\.[0-9a-fA-F]{1,8}\.[LH]\d+(?:\.[0-9a-fA-F]{1,2}){0,6}$/,Cr=/^vp09(?:\.\d{2}){3}(?:(?:\.\d{2}){5})?$/,xr=/^av01\.\d\.\d{2}[MH]\.\d{2}(?:\.\d\.\d{3}\.\d{2}\.\d{2}\.\d{2}\.\d)?$/,Er=t=>{if(!t)throw new TypeError("Video chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Video chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Video chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Video chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Video chunk metadata decoder configuration must specify a codec string.");if(!br.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Video chunk metadata decoder configuration codec string must be a valid video codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(t.decoderConfig.codedWidth)||t.decoderConfig.codedWidth<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedWidth (positive integer).");if(!Number.isInteger(t.decoderConfig.codedHeight)||t.decoderConfig.codedHeight<=0)throw new TypeError("Video chunk metadata decoder configuration must specify a valid codedHeight (positive integer).");if(t.decoderConfig.description!==void 0&&!vt(t.decoderConfig.description))throw new TypeError("Video chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.colorSpace!==void 0){const{colorSpace:e}=t.decoderConfig;if(typeof e!="object")throw new TypeError("Video chunk metadata decoder configuration colorSpace, when provided, must be an object.");const i=Object.keys(yt);if(e.primaries!=null&&!i.includes(e.primaries))throw new TypeError(`Video chunk metadata decoder configuration colorSpace primaries, when defined, must be one of ${i.join(", ")}.`);const r=Object.keys(bt);if(e.transfer!=null&&!r.includes(e.transfer))throw new TypeError(`Video chunk metadata decoder configuration colorSpace transfer, when defined, must be one of ${r.join(", ")}.`);const n=Object.keys(Tt);if(e.matrix!=null&&!n.includes(e.matrix))throw new TypeError(`Video chunk metadata decoder configuration colorSpace matrix, when defined, must be one of ${n.join(", ")}.`);if(e.fullRange!=null&&typeof e.fullRange!="boolean")throw new TypeError("Video chunk metadata decoder configuration colorSpace fullRange, when defined, must be a boolean.")}if(t.decoderConfig.codec.startsWith("avc1")||t.decoderConfig.codec.startsWith("avc3")){if(!Tr.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for AVC must be a valid AVC codec string as specified in Section 3.4 of RFC 6381.")}else if(t.decoderConfig.codec.startsWith("hev1")||t.decoderConfig.codec.startsWith("hvc1")){if(!vr.test(t.decoderConfig.codec))throw new TypeError("Video chunk metadata decoder configuration codec string for HEVC must be a valid HEVC codec string as specified in Section E.3 of ISO 14496-15.")}else if(t.decoderConfig.codec.startsWith("vp8")){if(t.decoderConfig.codec!=="vp8")throw new TypeError('Video chunk metadata decoder configuration codec string for VP8 must be "vp8".')}else if(t.decoderConfig.codec.startsWith("vp09")){if(!Cr.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for VP9 must be a valid VP9 codec string as specified in Section "Codecs Parameter String" of https://www.webmproject.org/vp9/mp4/.')}else if(t.decoderConfig.codec.startsWith("av01")&&!xr.test(t.decoderConfig.codec))throw new TypeError('Video chunk metadata decoder configuration codec string for AV1 must be a valid AV1 codec string as specified in Section "Codecs Parameter String" of https://aomediacodec.github.io/av1-isobmff/.')},Sr=["mp4a","mp3","opus","vorbis","flac","ulaw","alaw","pcm"],_r=t=>{if(!t)throw new TypeError("Audio chunk metadata must be provided.");if(typeof t!="object")throw new TypeError("Audio chunk metadata must be an object.");if(!t.decoderConfig)throw new TypeError("Audio chunk metadata must include a decoder configuration.");if(typeof t.decoderConfig!="object")throw new TypeError("Audio chunk metadata decoder configuration must be an object.");if(typeof t.decoderConfig.codec!="string")throw new TypeError("Audio chunk metadata decoder configuration must specify a codec string.");if(!Sr.some(e=>t.decoderConfig.codec.startsWith(e)))throw new TypeError("Audio chunk metadata decoder configuration codec string must be a valid audio codec string as specified in the WebCodecs Codec Registry.");if(!Number.isInteger(t.decoderConfig.sampleRate)||t.decoderConfig.sampleRate<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid sampleRate (positive integer).");if(!Number.isInteger(t.decoderConfig.numberOfChannels)||t.decoderConfig.numberOfChannels<=0)throw new TypeError("Audio chunk metadata decoder configuration must specify a valid numberOfChannels (positive integer).");if(t.decoderConfig.description!==void 0&&!vt(t.decoderConfig.description))throw new TypeError("Audio chunk metadata decoder configuration description, when defined, must be an ArrayBuffer or an ArrayBuffer view.");if(t.decoderConfig.codec.startsWith("mp4a")&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b"){if(!["mp4a.40.2","mp4a.40.02","mp4a.40.5","mp4a.40.05","mp4a.40.29","mp4a.67"].includes(t.decoderConfig.codec))throw new TypeError("Audio chunk metadata decoder configuration codec string for AAC must be a valid AAC codec string as specified in https://www.w3.org/TR/webcodecs-aac-codec-registration/.")}else if(t.decoderConfig.codec.startsWith("mp3")||t.decoderConfig.codec.startsWith("mp4a")){if(t.decoderConfig.codec!=="mp3"&&t.decoderConfig.codec!=="mp4a.69"&&t.decoderConfig.codec!=="mp4a.6B"&&t.decoderConfig.codec!=="mp4a.6b")throw new TypeError('Audio chunk metadata decoder configuration codec string for MP3 must be "mp3", "mp4a.69" or "mp4a.6B".')}else if(t.decoderConfig.codec.startsWith("opus")){if(t.decoderConfig.codec!=="opus")throw new TypeError('Audio chunk metadata decoder configuration codec string for Opus must be "opus".');if(t.decoderConfig.description&&t.decoderConfig.description.byteLength<18)throw new TypeError("Audio chunk metadata decoder configuration description, when specified, is expected to be an Identification Header as specified in Section 5.1 of RFC 7845.")}else if(t.decoderConfig.codec.startsWith("vorbis")){if(t.decoderConfig.codec!=="vorbis")throw new TypeError('Audio chunk metadata decoder configuration codec string for Vorbis must be "vorbis".');if(!t.decoderConfig.description)throw new TypeError("Audio chunk metadata decoder configuration for Vorbis must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-vorbis-codec-registration/.")}else if(t.decoderConfig.codec.startsWith("flac")){if(t.decoderConfig.codec!=="flac")throw new TypeError('Audio chunk metadata decoder configuration codec string for FLAC must be "flac".');if(!t.decoderConfig.description||t.decoderConfig.description.byteLength<42)throw new TypeError("Audio chunk metadata decoder configuration for FLAC must include a description, which is expected to adhere to the format described in https://www.w3.org/TR/webcodecs-flac-codec-registration/.")}else if((t.decoderConfig.codec.startsWith("pcm")||t.decoderConfig.codec.startsWith("ulaw")||t.decoderConfig.codec.startsWith("alaw"))&&!Se.includes(t.decoderConfig.codec))throw new TypeError(`Audio chunk metadata decoder configuration codec string for PCM must be one of the supported PCM codecs (${Se.join(", ")}).`)},Pr=t=>{if(!t)throw new TypeError("Subtitle metadata must be provided.");if(typeof t!="object")throw new TypeError("Subtitle metadata must be an object.");if(!t.config)throw new TypeError("Subtitle metadata must include a config object.");if(typeof t.config!="object")throw new TypeError("Subtitle metadata config must be an object.");if(typeof t.config.description!="string")throw new TypeError("Subtitle metadata config description must be a string.")};class Br{constructor(e){this.mutex=new fi,this.firstMediaStreamTimestamp=null,this.trackTimestampInfo=new WeakMap,this.output=e}onTrackClose(e){}validateAndNormalizeTimestamp(e,i,r){i+=e.source._timestampOffset;let n=this.trackTimestampInfo.get(e);if(!n){if(!r)throw new Error("First packet must be a key packet.");n={maxTimestamp:i,maxTimestampBeforeLastKeyPacket:i},this.trackTimestampInfo.set(e,n)}if(i<0)throw new Error(`Timestamps must be non-negative (got ${i}s).`);if(r&&(n.maxTimestampBeforeLastKeyPacket=n.maxTimestamp),i<n.maxTimestampBeforeLastKeyPacket)throw new Error(`Timestamps cannot be smaller than the largest timestamp of the previous GOP (a GOP begins with a key packet and ends right before the next key packet). Got ${i}s, but largest timestamp is ${n.maxTimestampBeforeLastKeyPacket}s.`);return n.maxTimestamp=Math.max(n.maxTimestamp,i),i}}var ze;(function(t){t[t.NON_IDR_SLICE=1]="NON_IDR_SLICE",t[t.SLICE_DPA=2]="SLICE_DPA",t[t.SLICE_DPB=3]="SLICE_DPB",t[t.SLICE_DPC=4]="SLICE_DPC",t[t.IDR=5]="IDR",t[t.SEI=6]="SEI",t[t.SPS=7]="SPS",t[t.PPS=8]="PPS",t[t.AUD=9]="AUD",t[t.SPS_EXT=13]="SPS_EXT"})(ze||(ze={}));var oe;(function(t){t[t.RASL_N=8]="RASL_N",t[t.RASL_R=9]="RASL_R",t[t.BLA_W_LP=16]="BLA_W_LP",t[t.RSV_IRAP_VCL23=23]="RSV_IRAP_VCL23",t[t.VPS_NUT=32]="VPS_NUT",t[t.SPS_NUT=33]="SPS_NUT",t[t.PPS_NUT=34]="PPS_NUT",t[t.AUD_NUT=35]="AUD_NUT",t[t.PREFIX_SEI_NUT=39]="PREFIX_SEI_NUT",t[t.SUFFIX_SEI_NUT=40]="SUFFIX_SEI_NUT"})(oe||(oe={}));const xt=function*(t){let e=0,i=-1;for(;e<t.length-2;){const r=t.indexOf(0,e);if(r===-1||r>=t.length-2)break;e=r;let n=0;if(e+3<t.length&&t[e+1]===0&&t[e+2]===0&&t[e+3]===1?n=4:t[e+1]===0&&t[e+2]===1&&(n=3),n===0){e++;continue}i!==-1&&e>i&&(yield{offset:i,length:e-i}),i=e+n,e=i}i!==-1&&i<t.length&&(yield{offset:i,length:t.length-i})},kr=function*(t){yield*xt(t)},Ar=t=>t&31,Et=t=>{const e=[],i=t.length;for(let r=0;r<i;r++)r+2<i&&t[r]===0&&t[r+1]===0&&t[r+2]===3?(e.push(0,0),r+=2):e.push(t[r]);return new Uint8Array(e)},Ir=(t,e)=>{const i=t.reduce((s,o)=>s+e+o.byteLength,0),r=new Uint8Array(i);let n=0;for(const s of t){const o=new DataView(r.buffer,r.byteOffset,r.byteLength);switch(e){case 1:o.setUint8(n,s.byteLength);break;case 2:o.setUint16(n,s.byteLength,!1);break;case 3:nr(o,n,s.byteLength);break;case 4:o.setUint32(n,s.byteLength,!1);break}n+=e,r.set(s,n),n+=s.byteLength}return r},Mr=t=>{try{const e=[],i=[],r=[];for(const a of kr(t)){const l=t.subarray(a.offset,a.offset+a.length),c=Ar(l[0]);c===ze.SPS?e.push(l):c===ze.PPS?i.push(l):c===ze.SPS_EXT&&r.push(l)}if(e.length===0||i.length===0)return null;const n=e[0],s=zr(n);v(s!==null);const o=s.profileIdc===100||s.profileIdc===110||s.profileIdc===122||s.profileIdc===144;return{configurationVersion:1,avcProfileIndication:s.profileIdc,profileCompatibility:s.constraintFlags,avcLevelIndication:s.levelIdc,lengthSizeMinusOne:3,sequenceParameterSets:e,pictureParameterSets:i,chromaFormat:o?s.chromaFormatIdc:null,bitDepthLumaMinus8:o?s.bitDepthLumaMinus8:null,bitDepthChromaMinus8:o?s.bitDepthChromaMinus8:null,sequenceParameterSetExt:o?r:null}}catch(e){return console.error("Error building AVC Decoder Configuration Record:",e),null}},Fr=t=>{const e=[];e.push(t.configurationVersion),e.push(t.avcProfileIndication),e.push(t.profileCompatibility),e.push(t.avcLevelIndication),e.push(252|t.lengthSizeMinusOne&3),e.push(224|t.sequenceParameterSets.length&31);for(const i of t.sequenceParameterSets){const r=i.byteLength;e.push(r>>8),e.push(r&255);for(let n=0;n<r;n++)e.push(i[n])}e.push(t.pictureParameterSets.length);for(const i of t.pictureParameterSets){const r=i.byteLength;e.push(r>>8),e.push(r&255);for(let n=0;n<r;n++)e.push(i[n])}if(t.avcProfileIndication===100||t.avcProfileIndication===110||t.avcProfileIndication===122||t.avcProfileIndication===144){v(t.chromaFormat!==null),v(t.bitDepthLumaMinus8!==null),v(t.bitDepthChromaMinus8!==null),v(t.sequenceParameterSetExt!==null),e.push(252|t.chromaFormat&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.sequenceParameterSetExt.length);for(const i of t.sequenceParameterSetExt){const r=i.byteLength;e.push(r>>8),e.push(r&255);for(let n=0;n<r;n++)e.push(i[n])}}return new Uint8Array(e)},zr=t=>{try{const e=new Pe(Et(t));if(e.skipBits(1),e.skipBits(2),e.readBits(5)!==7)return null;const r=e.readAlignedByte(),n=e.readAlignedByte(),s=e.readAlignedByte();y(e);let o=1,a=0,l=0,c=0;if((r===100||r===110||r===122||r===244||r===44||r===83||r===86||r===118||r===128)&&(o=y(e),o===3&&(c=e.readBits(1)),a=y(e),l=y(e),e.skipBits(1),e.readBits(1))){for(let M=0;M<(o!==3?8:12);M++)if(e.readBits(1)){const G=M<6?16:64;let V=8,u=8;for(let b=0;b<G;b++){if(u!==0){const I=me(e);u=(V+I+256)%256}V=u===0?V:u}}}y(e);const d=y(e);if(d===0)y(e);else if(d===1){e.skipBits(1),me(e),me(e);const q=y(e);for(let M=0;M<q;M++)me(e)}y(e),e.skipBits(1);const f=y(e),g=y(e),h=16*(f+1),p=16*(g+1);let x=h,B=p;const _=e.readBits(1);if(_||e.skipBits(1),e.skipBits(1),e.readBits(1)){const q=y(e),M=y(e),U=y(e),G=y(e);let V,u;if((c===0?o:0)===0)V=1,u=2-_;else{const I=o===3?1:2,F=o===1?2:1;V=I,u=F*(2-_)}x-=V*(q+M),B-=u*(U+G)}let N=2,he=2,X=2,ie=0,j=null,$=null;if(e.readBits(1)){e.readBits(1)&&e.readBits(8)===255&&(e.skipBits(16),e.skipBits(16)),e.readBits(1)&&e.skipBits(1),e.readBits(1)&&(e.skipBits(3),ie=e.readBits(1),e.readBits(1)&&(N=e.readBits(8),he=e.readBits(8),X=e.readBits(8))),e.readBits(1)&&(y(e),y(e)),e.readBits(1)&&(e.skipBits(32),e.skipBits(32),e.skipBits(1));const u=e.readBits(1);u&&Rt(e);const b=e.readBits(1);b&&Rt(e),(u||b)&&e.skipBits(1),e.skipBits(1),e.readBits(1)&&(e.skipBits(1),y(e),y(e),y(e),y(e),j=y(e),$=y(e))}if(j===null){v($===null);const q=n&16;if((r===44||r===86||r===100||r===110||r===122||r===244)&&q)j=0,$=0;else{const M=f+1,U=g+1,G=(2-_)*U,V=Xe.find(b=>b.level>=s)??te(Xe),u=Math.min(Math.floor(V.maxDpbMbs/(M*G)),16);j=u,$=u}}return v($!==null),{profileIdc:r,constraintFlags:n,levelIdc:s,frameMbsOnlyFlag:_,chromaFormatIdc:o,bitDepthLumaMinus8:a,bitDepthChromaMinus8:l,codedWidth:h,codedHeight:p,displayWidth:x,displayHeight:B,colourPrimaries:N,matrixCoefficients:X,transferCharacteristics:he,fullRangeFlag:ie,numReorderFrames:j,maxDecFrameBuffering:$}}catch(e){return console.error("Error parsing AVC SPS:",e),null}},Rt=t=>{const e=y(t);t.skipBits(4),t.skipBits(4);for(let i=0;i<=e;i++)y(t),y(t),t.skipBits(1);t.skipBits(5),t.skipBits(5),t.skipBits(5),t.skipBits(5)},Rr=function*(t){yield*xt(t)},Ot=t=>t>>1&63,Or=t=>{try{const e=new Pe(Et(t));e.skipBits(16),e.readBits(4);const i=e.readBits(3),r=e.readBits(1),{general_profile_space:n,general_tier_flag:s,general_profile_idc:o,general_profile_compatibility_flags:a,general_constraint_indicator_flags:l,general_level_idc:c}=Vr(e,i);y(e);const d=y(e);let f=0;d===3&&(f=e.readBits(1));const g=y(e),h=y(e);let p=g,x=h;if(e.readBits(1)){const M=y(e),U=y(e),G=y(e),V=y(e);let u=1,b=1;const I=f===0?d:0;I===1?(u=2,b=2):I===2&&(u=2,b=1),p-=(M+U)*u,x-=(G+V)*b}const B=y(e),_=y(e);y(e);const N=e.readBits(1)?0:i;let he=0;for(let M=N;M<=i;M++)y(e),he=y(e),y(e);y(e),y(e),y(e),y(e),y(e),y(e),e.readBits(1)&&e.readBits(1)&&Wr(e),e.skipBits(1),e.skipBits(1),e.readBits(1)&&(e.skipBits(4),e.skipBits(4),y(e),y(e),e.skipBits(1));const X=y(e);if(Nr(e,X),e.readBits(1)){const M=y(e);for(let U=0;U<M;U++)y(e),e.skipBits(1)}e.skipBits(1),e.skipBits(1);let ie=2,j=2,$=2,pe=0,q=0;if(e.readBits(1)){const M=Hr(e,i);ie=M.colourPrimaries,j=M.transferCharacteristics,$=M.matrixCoefficients,pe=M.fullRangeFlag,q=M.minSpatialSegmentationIdc}return{displayWidth:p,displayHeight:x,colourPrimaries:ie,transferCharacteristics:j,matrixCoefficients:$,fullRangeFlag:pe,maxDecFrameBuffering:he+1,spsMaxSubLayersMinus1:i,spsTemporalIdNestingFlag:r,generalProfileSpace:n,generalTierFlag:s,generalProfileIdc:o,generalProfileCompatibilityFlags:a,generalConstraintIndicatorFlags:l,generalLevelIdc:c,chromaFormatIdc:d,bitDepthLumaMinus8:B,bitDepthChromaMinus8:_,minSpatialSegmentationIdc:q}}catch(e){return console.error("Error parsing HEVC SPS:",e),null}},Lr=t=>{try{const e=[],i=[],r=[],n=[];for(const c of Rr(t)){const d=t.subarray(c.offset,c.offset+c.length),f=Ot(d[0]);f===oe.VPS_NUT?e.push(d):f===oe.SPS_NUT?i.push(d):f===oe.PPS_NUT?r.push(d):(f===oe.PREFIX_SEI_NUT||f===oe.SUFFIX_SEI_NUT)&&n.push(d)}if(i.length===0||r.length===0)return null;const s=Or(i[0]);if(!s)return null;let o=0;if(r.length>0){const c=r[0],d=new Pe(Et(c));d.skipBits(16),y(d),y(d),d.skipBits(1),d.skipBits(1),d.skipBits(3),d.skipBits(1),d.skipBits(1),y(d),y(d),me(d),d.skipBits(1),d.skipBits(1),d.readBits(1)&&y(d),me(d),me(d),d.skipBits(1),d.skipBits(1),d.skipBits(1),d.skipBits(1);const f=d.readBits(1),g=d.readBits(1);!f&&!g?o=0:f&&!g?o=2:!f&&g?o=3:o=0}const a=[...e.length?[{arrayCompleteness:1,nalUnitType:oe.VPS_NUT,nalUnits:e}]:[],...i.length?[{arrayCompleteness:1,nalUnitType:oe.SPS_NUT,nalUnits:i}]:[],...r.length?[{arrayCompleteness:1,nalUnitType:oe.PPS_NUT,nalUnits:r}]:[],...n.length?[{arrayCompleteness:1,nalUnitType:Ot(n[0][0]),nalUnits:n}]:[]];return{configurationVersion:1,generalProfileSpace:s.generalProfileSpace,generalTierFlag:s.generalTierFlag,generalProfileIdc:s.generalProfileIdc,generalProfileCompatibilityFlags:s.generalProfileCompatibilityFlags,generalConstraintIndicatorFlags:s.generalConstraintIndicatorFlags,generalLevelIdc:s.generalLevelIdc,minSpatialSegmentationIdc:s.minSpatialSegmentationIdc,parallelismType:o,chromaFormatIdc:s.chromaFormatIdc,bitDepthLumaMinus8:s.bitDepthLumaMinus8,bitDepthChromaMinus8:s.bitDepthChromaMinus8,avgFrameRate:0,constantFrameRate:0,numTemporalLayers:s.spsMaxSubLayersMinus1+1,temporalIdNested:s.spsTemporalIdNestingFlag,lengthSizeMinusOne:3,arrays:a}}catch(e){return console.error("Error building HEVC Decoder Configuration Record:",e),null}},Vr=(t,e)=>{const i=t.readBits(2),r=t.readBits(1),n=t.readBits(5);let s=0;for(let d=0;d<32;d++)s=s<<1|t.readBits(1);const o=new Uint8Array(6);for(let d=0;d<6;d++)o[d]=t.readBits(8);const a=t.readBits(8),l=[],c=[];for(let d=0;d<e;d++)l.push(t.readBits(1)),c.push(t.readBits(1));if(e>0)for(let d=e;d<8;d++)t.skipBits(2);for(let d=0;d<e;d++)l[d]&&t.skipBits(88),c[d]&&t.skipBits(8);return{general_profile_space:i,general_tier_flag:r,general_profile_idc:n,general_profile_compatibility_flags:s,general_constraint_indicator_flags:o,general_level_idc:a}},Wr=t=>{for(let e=0;e<4;e++)for(let i=0;i<(e===3?2:6);i++)if(!t.readBits(1))y(t);else{const n=Math.min(64,1<<4+(e<<1));e>1&&me(t);for(let s=0;s<n;s++)me(t)}},Nr=(t,e)=>{const i=[];for(let r=0;r<e;r++)i[r]=Ur(t,r,e,i)},Ur=(t,e,i,r)=>{let n=0,s=0,o=0;if(e!==0&&(s=t.readBits(1)),s){if(e===i){const l=y(t);o=e-(l+1)}else o=e-1;t.readBits(1),y(t);const a=r[o]??0;for(let l=0;l<=a;l++)t.readBits(1)||t.readBits(1);n=r[o]}else{const a=y(t),l=y(t);for(let c=0;c<a;c++)y(t),t.readBits(1);for(let c=0;c<l;c++)y(t),t.readBits(1);n=a+l}return n},Hr=(t,e)=>{let i=2,r=2,n=2,s=0,o=0;return t.readBits(1)&&t.readBits(8)===255&&(t.readBits(16),t.readBits(16)),t.readBits(1)&&t.readBits(1),t.readBits(1)&&(t.readBits(3),s=t.readBits(1),t.readBits(1)&&(i=t.readBits(8),r=t.readBits(8),n=t.readBits(8))),t.readBits(1)&&(y(t),y(t)),t.readBits(1),t.readBits(1),t.readBits(1),t.readBits(1)&&(y(t),y(t),y(t),y(t)),t.readBits(1)&&(t.readBits(32),t.readBits(32),t.readBits(1)&&y(t),t.readBits(1)&&Dr(t,!0,e)),t.readBits(1)&&(t.readBits(1),t.readBits(1),t.readBits(1),o=y(t),y(t),y(t),y(t),y(t)),{colourPrimaries:i,transferCharacteristics:r,matrixCoefficients:n,fullRangeFlag:s,minSpatialSegmentationIdc:o}},Dr=(t,e,i)=>{let r=!1,n=!1,s=!1;r=t.readBits(1)===1,n=t.readBits(1)===1,(r||n)&&(s=t.readBits(1)===1,s&&(t.readBits(8),t.readBits(5),t.readBits(1),t.readBits(5)),t.readBits(4),t.readBits(4),s&&t.readBits(4),t.readBits(5),t.readBits(5),t.readBits(5));for(let o=0;o<=i;o++){const a=t.readBits(1)===1;let l=!0;a||(l=t.readBits(1)===1);let c=!1;l?y(t):c=t.readBits(1)===1;let d=1;c||(d=y(t)+1),r&&Lt(t,d,s),n&&Lt(t,d,s)}},Lt=(t,e,i)=>{for(let r=0;r<e;r++)y(t),y(t),i&&(y(t),y(t)),t.readBits(1)},$r=t=>{const e=[];e.push(t.configurationVersion),e.push((t.generalProfileSpace&3)<<6|(t.generalTierFlag&1)<<5|t.generalProfileIdc&31),e.push(t.generalProfileCompatibilityFlags>>>24&255),e.push(t.generalProfileCompatibilityFlags>>>16&255),e.push(t.generalProfileCompatibilityFlags>>>8&255),e.push(t.generalProfileCompatibilityFlags&255),e.push(...t.generalConstraintIndicatorFlags),e.push(t.generalLevelIdc&255),e.push(240|t.minSpatialSegmentationIdc>>8&15),e.push(t.minSpatialSegmentationIdc&255),e.push(252|t.parallelismType&3),e.push(252|t.chromaFormatIdc&3),e.push(248|t.bitDepthLumaMinus8&7),e.push(248|t.bitDepthChromaMinus8&7),e.push(t.avgFrameRate>>8&255),e.push(t.avgFrameRate&255),e.push((t.constantFrameRate&3)<<6|(t.numTemporalLayers&7)<<3|(t.temporalIdNested&1)<<2|t.lengthSizeMinusOne&3),e.push(t.arrays.length&255);for(const i of t.arrays){e.push((i.arrayCompleteness&1)<<7|0|i.nalUnitType&63),e.push(i.nalUnits.length>>8&255),e.push(i.nalUnits.length&255);for(const r of i.nalUnits){e.push(r.length>>8&255),e.push(r.length&255);for(let n=0;n<r.length;n++)e.push(r[n])}}return new Uint8Array(e)},qr=t=>{const e=hi(t),i=e.getUint8(9),r=e.getUint16(10,!0),n=e.getUint32(12,!0),s=e.getInt16(16,!0),o=e.getUint8(18);let a=null;return o&&(a=t.subarray(19,21+i)),{outputChannelCount:i,preSkip:r,inputSampleRate:n,outputGain:s,channelMappingFamily:o,channelMappingTable:a}};var Vt;(function(t){t[t.STREAMINFO=0]="STREAMINFO",t[t.VORBIS_COMMENT=4]="VORBIS_COMMENT",t[t.PICTURE=6]="PICTURE"})(Vt||(Vt={}));const Xr=[];const Wt=new Uint8Array(0);class Oe{constructor(e,i,r,n,s=-1,o,a){if(this.data=e,this.type=i,this.timestamp=r,this.duration=n,this.sequenceNumber=s,e===Wt&&o===void 0)throw new Error("Internal error: byteLength must be explicitly provided when constructing metadata-only packets.");if(o===void 0&&(o=e.byteLength),!(e instanceof Uint8Array))throw new TypeError("data must be a Uint8Array.");if(i!=="key"&&i!=="delta")throw new TypeError('type must be either "key" or "delta".');if(!Number.isFinite(r))throw new TypeError("timestamp must be a number.");if(!Number.isFinite(n)||n<0)throw new TypeError("duration must be a non-negative number.");if(!Number.isFinite(s))throw new TypeError("sequenceNumber must be a number.");if(!Number.isInteger(o)||o<0)throw new TypeError("byteLength must be a non-negative integer.");if(a!==void 0&&(typeof a!="object"||!a))throw new TypeError("sideData, when provided, must be an object.");if(a?.alpha!==void 0&&!(a.alpha instanceof Uint8Array))throw new TypeError("sideData.alpha, when provided, must be a Uint8Array.");if(a?.alphaByteLength!==void 0&&(!Number.isInteger(a.alphaByteLength)||a.alphaByteLength<0))throw new TypeError("sideData.alphaByteLength, when provided, must be a non-negative integer.");this.byteLength=o,this.sideData=a??{},this.sideData.alpha&&this.sideData.alphaByteLength===void 0&&(this.sideData.alphaByteLength=this.sideData.alpha.byteLength)}get isMetadataOnly(){return this.data===Wt}get microsecondTimestamp(){return Math.trunc(Be*this.timestamp)}get microsecondDuration(){return Math.trunc(Be*this.duration)}toEncodedVideoChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}alphaToEncodedVideoChunk(e=this.type){if(!this.sideData.alpha)throw new TypeError("This packet does not contain alpha side data.");if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to a video chunk.");if(typeof EncodedVideoChunk>"u")throw new Error("Your browser does not support EncodedVideoChunk.");return new EncodedVideoChunk({data:this.sideData.alpha,type:e,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}toEncodedAudioChunk(){if(this.isMetadataOnly)throw new TypeError("Metadata-only packets cannot be converted to an audio chunk.");if(typeof EncodedAudioChunk>"u")throw new Error("Your browser does not support EncodedAudioChunk.");return new EncodedAudioChunk({data:this.data,type:this.type,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration})}static fromEncodedChunk(e,i){if(!(e instanceof EncodedVideoChunk||e instanceof EncodedAudioChunk))throw new TypeError("chunk must be an EncodedVideoChunk or EncodedAudioChunk.");const r=new Uint8Array(e.byteLength);return e.copyTo(r),new Oe(r,e.type,e.timestamp/1e6,(e.duration??0)/1e6,void 0,void 0,i)}clone(e){if(e!==void 0&&(typeof e!="object"||e===null))throw new TypeError("options, when provided, must be an object.");if(e?.data!==void 0&&!(e.data instanceof Uint8Array))throw new TypeError("options.data, when provided, must be a Uint8Array.");if(e?.type!==void 0&&e.type!=="key"&&e.type!=="delta")throw new TypeError('options.type, when provided, must be either "key" or "delta".');if(e?.timestamp!==void 0&&!Number.isFinite(e.timestamp))throw new TypeError("options.timestamp, when provided, must be a number.");if(e?.duration!==void 0&&!Number.isFinite(e.duration))throw new TypeError("options.duration, when provided, must be a number.");if(e?.sequenceNumber!==void 0&&!Number.isFinite(e.sequenceNumber))throw new TypeError("options.sequenceNumber, when provided, must be a number.");if(e?.sideData!==void 0&&(typeof e.sideData!="object"||e.sideData===null))throw new TypeError("options.sideData, when provided, must be an object.");return new Oe(e?.data??this.data,e?.type??this.type,e?.timestamp??this.timestamp,e?.duration??this.duration,e?.sequenceNumber??this.sequenceNumber,this.byteLength,e?.sideData??this.sideData)}}lr();let Nt=-1/0,Ut=-1/0,lt=null;typeof FinalizationRegistry<"u"&&(lt=new FinalizationRegistry(t=>{const e=Date.now();t.type==="video"?(e-Nt>=1e3&&(console.error("A VideoSample was garbage collected without first being closed. For proper resource management, make sure to call close() on all your VideoSamples as soon as you're done using them."),Nt=e),typeof VideoFrame<"u"&&t.data instanceof VideoFrame&&t.data.close()):(e-Ut>=1e3&&(console.error("An AudioSample was garbage collected without first being closed. For proper resource management, make sure to call close() on all your AudioSamples as soon as you're done using them."),Ut=e),typeof AudioData<"u"&&t.data instanceof AudioData&&t.data.close())}));const Ti=["I420","I420P10","I420P12","I420A","I420AP10","I420AP12","I422","I422P10","I422P12","I422A","I422AP10","I422AP12","I444","I444P10","I444P12","I444A","I444AP10","I444AP12","NV12","RGBA","RGBX","BGRA","BGRX"],jr=new Set(Ti);class Ce{get displayWidth(){return this.rotation%180===0?this.codedWidth:this.codedHeight}get displayHeight(){return this.rotation%180===0?this.codedHeight:this.codedWidth}get microsecondTimestamp(){return Math.trunc(Be*this.timestamp)}get microsecondDuration(){return Math.trunc(Be*this.duration)}get hasAlpha(){return this.format&&this.format.includes("A")}constructor(e,i){if(this._closed=!1,e instanceof ArrayBuffer||typeof SharedArrayBuffer<"u"&&e instanceof SharedArrayBuffer||ArrayBuffer.isView(e)){if(!i||typeof i!="object")throw new TypeError("init must be an object.");if(i.format===void 0||!jr.has(i.format))throw new TypeError("init.format must be one of: "+Ti.join(", "));if(!Number.isInteger(i.codedWidth)||i.codedWidth<=0)throw new TypeError("init.codedWidth must be a positive integer.");if(!Number.isInteger(i.codedHeight)||i.codedHeight<=0)throw new TypeError("init.codedHeight must be a positive integer.");if(i.rotation!==void 0&&![0,90,180,270].includes(i.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(i.timestamp))throw new TypeError("init.timestamp must be a number.");if(i.duration!==void 0&&(!Number.isFinite(i.duration)||i.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=ye(e).slice(),this._layout=i.layout??Qr(i.format,i.codedWidth,i.codedHeight),this.format=i.format,this.codedWidth=i.codedWidth,this.codedHeight=i.codedHeight,this.rotation=i.rotation??0,this.timestamp=i.timestamp,this.duration=i.duration??0,this.colorSpace=new Je(i.colorSpace)}else if(typeof VideoFrame<"u"&&e instanceof VideoFrame){if(i?.rotation!==void 0&&![0,90,180,270].includes(i.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(i?.timestamp!==void 0&&!Number.isFinite(i?.timestamp))throw new TypeError("init.timestamp, when provided, must be a number.");if(i?.duration!==void 0&&(!Number.isFinite(i.duration)||i.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");this._data=e,this._layout=null,this.format=e.format,this.codedWidth=e.displayWidth,this.codedHeight=e.displayHeight,this.rotation=i?.rotation??0,this.timestamp=i?.timestamp??e.timestamp/1e6,this.duration=i?.duration??(e.duration??0)/1e6,this.colorSpace=new Je(e.colorSpace)}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof SVGImageElement<"u"&&e instanceof SVGImageElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof HTMLVideoElement<"u"&&e instanceof HTMLVideoElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas){if(!i||typeof i!="object")throw new TypeError("init must be an object.");if(i.rotation!==void 0&&![0,90,180,270].includes(i.rotation))throw new TypeError("init.rotation, when provided, must be 0, 90, 180, or 270.");if(!Number.isFinite(i.timestamp))throw new TypeError("init.timestamp must be a number.");if(i.duration!==void 0&&(!Number.isFinite(i.duration)||i.duration<0))throw new TypeError("init.duration, when provided, must be a non-negative number.");if(typeof VideoFrame<"u")return new Ce(new VideoFrame(e,{timestamp:Math.trunc(i.timestamp*Be),duration:Math.trunc((i.duration??0)*Be)||void 0}),i);let r=0,n=0;if("naturalWidth"in e?(r=e.naturalWidth,n=e.naturalHeight):"videoWidth"in e?(r=e.videoWidth,n=e.videoHeight):"width"in e&&(r=Number(e.width),n=Number(e.height)),!r||!n)throw new TypeError("Could not determine dimensions.");const s=new OffscreenCanvas(r,n),o=s.getContext("2d",{alpha:dt(),willReadFrequently:!0});v(o),o.drawImage(e,0,0),this._data=s,this._layout=null,this.format="RGBX",this.codedWidth=r,this.codedHeight=n,this.rotation=i.rotation??0,this.timestamp=i.timestamp,this.duration=i.duration??0,this.colorSpace=new Je({matrix:"rgb",primaries:"bt709",transfer:"iec61966-2-1",fullRange:!0})}else throw new TypeError("Invalid data type: Must be a BufferSource or CanvasImageSource.");lt?.register(this,{type:"video",data:this._data},this)}clone(){if(this._closed)throw new Error("VideoSample is closed.");return v(this._data!==null),Te(this._data)?new Ce(this._data.clone(),{timestamp:this.timestamp,duration:this.duration,rotation:this.rotation}):this._data instanceof Uint8Array?(v(this._layout),new Ce(this._data,{format:this.format,layout:this._layout,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation})):new Ce(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.timestamp,duration:this.duration,colorSpace:this.colorSpace,rotation:this.rotation})}close(){this._closed||(lt?.unregister(this),Te(this._data)?this._data.close():this._data=null,this._closed=!0)}allocationSize(e={}){if(Ht(e),this._closed)throw new Error("VideoSample is closed.");if(this.format===null)throw new Error("Cannot get allocation size when format is null. Sorry!");if(v(this._data!==null),!Te(this._data)&&(e.colorSpace||e.format&&e.format!==this.format||e.layout||e.rect)){const i=this.toVideoFrame(),r=i.allocationSize(e);return i.close(),r}return Te(this._data)?this._data.allocationSize(e):this._data instanceof Uint8Array?this._data.byteLength:this.codedWidth*this.codedHeight*4}async copyTo(e,i={}){if(!vt(e))throw new TypeError("destination must be an ArrayBuffer or an ArrayBuffer view.");if(Ht(i),this._closed)throw new Error("VideoSample is closed.");if(this.format===null)throw new Error("Cannot copy video sample data when format is null. Sorry!");if(v(this._data!==null),!Te(this._data)&&(i.colorSpace||i.format&&i.format!==this.format||i.layout||i.rect)){const r=this.toVideoFrame(),n=await r.copyTo(e,i);return r.close(),n}if(Te(this._data))return this._data.copyTo(e,i);if(this._data instanceof Uint8Array)return v(this._layout),ye(e).set(this._data),this._layout;{const n=this._data.getContext("2d");v(n);const s=n.getImageData(0,0,this.codedWidth,this.codedHeight);return ye(e).set(s.data),[{offset:0,stride:4*this.codedWidth}]}}toVideoFrame(){if(this._closed)throw new Error("VideoSample is closed.");return v(this._data!==null),Te(this._data)?new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0}):this._data instanceof Uint8Array?new VideoFrame(this._data,{format:this.format,codedWidth:this.codedWidth,codedHeight:this.codedHeight,timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0,colorSpace:this.colorSpace}):new VideoFrame(this._data,{timestamp:this.microsecondTimestamp,duration:this.microsecondDuration||void 0})}draw(e,i,r,n,s,o,a,l,c){let d=0,f=0,g=this.displayWidth,h=this.displayHeight,p=0,x=0,B=this.displayWidth,_=this.displayHeight;if(o!==void 0?(d=i,f=r,g=n,h=s,p=o,x=a,l!==void 0?(B=l,_=c):(B=g,_=h)):(p=i,x=r,n!==void 0&&(B=n,_=s)),!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!Number.isFinite(d))throw new TypeError("sx must be a number.");if(!Number.isFinite(f))throw new TypeError("sy must be a number.");if(!Number.isFinite(g)||g<0)throw new TypeError("sWidth must be a non-negative number.");if(!Number.isFinite(h)||h<0)throw new TypeError("sHeight must be a non-negative number.");if(!Number.isFinite(p))throw new TypeError("dx must be a number.");if(!Number.isFinite(x))throw new TypeError("dy must be a number.");if(!Number.isFinite(B)||B<0)throw new TypeError("dWidth must be a non-negative number.");if(!Number.isFinite(_)||_<0)throw new TypeError("dHeight must be a non-negative number.");if(this._closed)throw new Error("VideoSample is closed.");({sx:d,sy:f,sWidth:g,sHeight:h}=this._rotateSourceRegion(d,f,g,h,this.rotation));const D=this.toCanvasImageSource();e.save();const N=p+B/2,he=x+_/2;e.translate(N,he),e.rotate(this.rotation*Math.PI/180);const X=this.rotation%180===0?1:B/_;e.scale(1/X,X),e.drawImage(D,d,f,g,h,-B/2,-_/2,B,_),e.restore()}drawWithFit(e,i){if(!(typeof CanvasRenderingContext2D<"u"&&e instanceof CanvasRenderingContext2D||typeof OffscreenCanvasRenderingContext2D<"u"&&e instanceof OffscreenCanvasRenderingContext2D))throw new TypeError("context must be a CanvasRenderingContext2D or OffscreenCanvasRenderingContext2D.");if(!i||typeof i!="object")throw new TypeError("options must be an object.");if(!["fill","contain","cover"].includes(i.fit))throw new TypeError("options.fit must be 'fill', 'contain', or 'cover'.");if(i.rotation!==void 0&&![0,90,180,270].includes(i.rotation))throw new TypeError("options.rotation, when provided, must be 0, 90, 180, or 270.");i.crop!==void 0&&Yr(i.crop,"options.");const r=e.canvas.width,n=e.canvas.height,s=i.rotation??this.rotation,[o,a]=s%180===0?[this.codedWidth,this.codedHeight]:[this.codedHeight,this.codedWidth];i.crop&&Gr(i.crop,o,a);let l,c,d,f;const{sx:g,sy:h,sWidth:p,sHeight:x}=this._rotateSourceRegion(i.crop?.left??0,i.crop?.top??0,i.crop?.width??o,i.crop?.height??a,s);if(i.fit==="fill")l=0,c=0,d=r,f=n;else{const[_,D]=i.crop?[i.crop.width,i.crop.height]:[o,a],N=i.fit==="contain"?Math.min(r/_,n/D):Math.max(r/_,n/D);d=_*N,f=D*N,l=(r-d)/2,c=(n-f)/2}e.save();const B=s%180===0?1:d/f;e.translate(r/2,n/2),e.rotate(s*Math.PI/180),e.scale(1/B,B),e.translate(-r/2,-n/2),e.drawImage(this.toCanvasImageSource(),g,h,p,x,l,c,d,f),e.restore()}_rotateSourceRegion(e,i,r,n,s){return s===90?[e,i,r,n]=[i,this.codedHeight-e-r,n,r]:s===180?[e,i]=[this.codedWidth-e-r,this.codedHeight-i-n]:s===270&&([e,i,r,n]=[this.codedWidth-i-n,e,n,r]),{sx:e,sy:i,sWidth:r,sHeight:n}}toCanvasImageSource(){if(this._closed)throw new Error("VideoSample is closed.");if(v(this._data!==null),this._data instanceof Uint8Array){const e=this.toVideoFrame();return queueMicrotask(()=>e.close()),e}else return this._data}setRotation(e){if(![0,90,180,270].includes(e))throw new TypeError("newRotation must be 0, 90, 180, or 270.");this.rotation=e}setTimestamp(e){if(!Number.isFinite(e))throw new TypeError("newTimestamp must be a number.");this.timestamp=e}setDuration(e){if(!Number.isFinite(e)||e<0)throw new TypeError("newDuration must be a non-negative number.");this.duration=e}[Symbol.dispose](){this.close()}}class Je{constructor(e){this.primaries=e?.primaries??null,this.transfer=e?.transfer??null,this.matrix=e?.matrix??null,this.fullRange=e?.fullRange??null}toJSON(){return{primaries:this.primaries,transfer:this.transfer,matrix:this.matrix,fullRange:this.fullRange}}}const Te=t=>typeof VideoFrame<"u"&&t instanceof VideoFrame,Gr=(t,e,i)=>{t.left=Math.min(t.left,e),t.top=Math.min(t.top,i),t.width=Math.min(t.width,e-t.left),t.height=Math.min(t.height,i-t.top),v(t.width>=0),v(t.height>=0)},Yr=(t,e)=>{if(!t||typeof t!="object")throw new TypeError(e+"crop, when provided, must be an object.");if(!Number.isInteger(t.left)||t.left<0)throw new TypeError(e+"crop.left must be a non-negative integer.");if(!Number.isInteger(t.top)||t.top<0)throw new TypeError(e+"crop.top must be a non-negative integer.");if(!Number.isInteger(t.width)||t.width<0)throw new TypeError(e+"crop.width must be a non-negative integer.");if(!Number.isInteger(t.height)||t.height<0)throw new TypeError(e+"crop.height must be a non-negative integer.")},Ht=t=>{if(!t||typeof t!="object")throw new TypeError("options must be an object.");if(t.colorSpace!==void 0&&!["display-p3","srgb"].includes(t.colorSpace))throw new TypeError("options.colorSpace, when provided, must be 'display-p3' or 'srgb'.");if(t.format!==void 0&&typeof t.format!="string")throw new TypeError("options.format, when provided, must be a string.");if(t.layout!==void 0){if(!Array.isArray(t.layout))throw new TypeError("options.layout, when provided, must be an array.");for(const e of t.layout){if(!e||typeof e!="object")throw new TypeError("Each entry in options.layout must be an object.");if(!Number.isInteger(e.offset)||e.offset<0)throw new TypeError("plane.offset must be a non-negative integer.");if(!Number.isInteger(e.stride)||e.stride<0)throw new TypeError("plane.stride must be a non-negative integer.")}}if(t.rect!==void 0){if(!t.rect||typeof t.rect!="object")throw new TypeError("options.rect, when provided, must be an object.");if(t.rect.x!==void 0&&(!Number.isInteger(t.rect.x)||t.rect.x<0))throw new TypeError("options.rect.x, when provided, must be a non-negative integer.");if(t.rect.y!==void 0&&(!Number.isInteger(t.rect.y)||t.rect.y<0))throw new TypeError("options.rect.y, when provided, must be a non-negative integer.");if(t.rect.width!==void 0&&(!Number.isInteger(t.rect.width)||t.rect.width<0))throw new TypeError("options.rect.width, when provided, must be a non-negative integer.");if(t.rect.height!==void 0&&(!Number.isInteger(t.rect.height)||t.rect.height<0))throw new TypeError("options.rect.height, when provided, must be a non-negative integer.")}},Qr=(t,e,i)=>{const r=Zr(t),n=[];let s=0;for(const o of r){const a=Math.ceil(e/o.widthDivisor),l=Math.ceil(i/o.heightDivisor),c=a*o.sampleBytes,d=c*l;n.push({offset:s,stride:c}),s+=d}return n},Zr=t=>{const e=(i,r,n,s,o)=>{const a=[{sampleBytes:i,widthDivisor:1,heightDivisor:1},{sampleBytes:r,widthDivisor:n,heightDivisor:s},{sampleBytes:r,widthDivisor:n,heightDivisor:s}];return o&&a.push({sampleBytes:i,widthDivisor:1,heightDivisor:1}),a};switch(t){case"I420":return e(1,1,2,2,!1);case"I420P10":case"I420P12":return e(2,2,2,2,!1);case"I420A":return e(1,1,2,2,!0);case"I420AP10":case"I420AP12":return e(2,2,2,2,!0);case"I422":return e(1,1,2,1,!1);case"I422P10":case"I422P12":return e(2,2,2,1,!1);case"I422A":return e(1,1,2,1,!0);case"I422AP10":case"I422AP12":return e(2,2,2,1,!0);case"I444":return e(1,1,1,1,!1);case"I444P10":case"I444P12":return e(2,2,1,1,!1);case"I444A":return e(1,1,1,1,!0);case"I444AP10":case"I444AP12":return e(2,2,1,1,!0);case"NV12":return[{sampleBytes:1,widthDivisor:1,heightDivisor:1},{sampleBytes:2,widthDivisor:2,heightDivisor:2}];case"RGBA":case"RGBX":case"BGRA":case"BGRX":return[{sampleBytes:4,widthDivisor:1,heightDivisor:1}];default:Ct(t),v(!1)}};const Kr=t=>{let i=(t.hasVideo?"video/":t.hasAudio?"audio/":"application/")+(t.isQuickTime?"quicktime":"mp4");if(t.codecStrings.length>0){const r=[...new Set(t.codecStrings)];i+=`; codecs="${r.join(", ")}"`}return i};const et=8,Dt=16;const Jr=7,en=9,$t=t=>{const e=t.filePos,i=rn(t,9),r=new Pe(i);if(r.readBits(12)!==4095||(r.skipBits(1),r.readBits(2)!==0))return null;const o=r.readBits(1),a=r.readBits(2)+1,l=r.readBits(4);if(l===15)return null;r.skipBits(1);const c=r.readBits(3);if(c===0)throw new Error("ADTS frames with channel configuration 0 are not supported.");r.skipBits(1),r.skipBits(1),r.skipBits(1),r.skipBits(1);const d=r.readBits(13);r.skipBits(11);const f=r.readBits(2)+1;if(f!==1)throw new Error("ADTS frames with more than one AAC frame are not supported.");let g=null;return o===1?t.filePos-=2:g=r.readBits(16),{objectType:a,samplingFrequencyIndex:l,channelConfiguration:c,frameLength:d,numberOfAacFrames:f,crcCheck:g,startPos:e}};class Le{constructor(e,i,r,n,s){this.bytes=e,this.view=i,this.offset=r,this.start=n,this.end=s,this.bufferPos=n-r}static tempFromBytes(e){return new Le(e,hi(e),0,0,e.length)}get length(){return this.end-this.start}get filePos(){return this.offset+this.bufferPos}set filePos(e){this.bufferPos=e-this.offset}get remainingLength(){return Math.max(this.end-this.filePos,0)}skip(e){this.bufferPos+=e}slice(e,i=this.end-e){if(e<this.start||e+i>this.end)throw new RangeError("Slicing outside of original slice.");return new Le(this.bytes,this.view,this.offset,e,e+i)}}const tn=(t,e)=>{if(t.filePos<t.start||t.filePos+e>t.end)throw new RangeError(`Tried reading [${t.filePos}, ${t.filePos+e}), but slice is [${t.start}, ${t.end}). This is likely an internal error, please report it alongside the file that caused it.`)},rn=(t,e)=>{tn(t,e);const i=t.bytes.subarray(t.bufferPos,t.bufferPos+e);return t.bufferPos+=e,i};const qt=/<(?:(\d{2}):)?(\d{2}):(\d{2}).(\d{3})>/g,nn=t=>{const e=Math.floor(t/36e5),i=Math.floor(t%(3600*1e3)/(60*1e3)),r=Math.floor(t%(60*1e3)/1e3),n=t%1e3;return e.toString().padStart(2,"0")+":"+i.toString().padStart(2,"0")+":"+r.toString().padStart(2,"0")+"."+n.toString().padStart(3,"0")};class Xt{constructor(e){this.writer=e,this.helper=new Uint8Array(8),this.helperView=new DataView(this.helper.buffer),this.offsets=new WeakMap}writeU32(e){this.helperView.setUint32(0,e,!1),this.writer.write(this.helper.subarray(0,4))}writeU64(e){this.helperView.setUint32(0,Math.floor(e/2**32),!1),this.helperView.setUint32(4,e,!1),this.writer.write(this.helper.subarray(0,8))}writeAscii(e){for(let i=0;i<e.length;i++)this.helperView.setUint8(i%8,e.charCodeAt(i)),i%8===7&&this.writer.write(this.helper);e.length%8!==0&&this.writer.write(this.helper.subarray(0,e.length%8))}writeBox(e){if(this.offsets.set(e,this.writer.getPos()),e.contents&&!e.children)this.writeBoxHeader(e,e.size??e.contents.byteLength+8),this.writer.write(e.contents);else{const i=this.writer.getPos();if(this.writeBoxHeader(e,0),e.contents&&this.writer.write(e.contents),e.children)for(const s of e.children)s&&this.writeBox(s);const r=this.writer.getPos(),n=e.size??r-i;this.writer.seek(i),this.writeBoxHeader(e,n),this.writer.seek(r)}}writeBoxHeader(e,i){this.writeU32(e.largeSize?1:i),this.writeAscii(e.type),e.largeSize&&this.writeU64(i)}measureBoxHeader(e){return 8+(e.largeSize?8:0)}patchBox(e){const i=this.offsets.get(e);v(i!==void 0);const r=this.writer.getPos();this.writer.seek(i),this.writeBox(e),this.writer.seek(r)}measureBox(e){if(e.contents&&!e.children)return this.measureBoxHeader(e)+e.contents.byteLength;{let i=this.measureBoxHeader(e);if(e.contents&&(i+=e.contents.byteLength),e.children)for(const r of e.children)r&&(i+=this.measureBox(r));return i}}}const k=new Uint8Array(8),de=new DataView(k.buffer),z=t=>[(t%256+256)%256],C=t=>(de.setUint16(0,t,!1),[k[0],k[1]]),vi=t=>(de.setInt16(0,t,!1),[k[0],k[1]]),Ci=t=>(de.setUint32(0,t,!1),[k[1],k[2],k[3]]),w=t=>(de.setUint32(0,t,!1),[k[0],k[1],k[2],k[3]]),we=t=>(de.setInt32(0,t,!1),[k[0],k[1],k[2],k[3]]),_e=t=>(de.setUint32(0,Math.floor(t/2**32),!1),de.setUint32(4,t,!1),[k[0],k[1],k[2],k[3],k[4],k[5],k[6],k[7]]),xi=t=>(de.setInt16(0,2**8*t,!1),[k[0],k[1]]),fe=t=>(de.setInt32(0,2**16*t,!1),[k[0],k[1],k[2],k[3]]),tt=t=>(de.setInt32(0,2**30*t,!1),[k[0],k[1],k[2],k[3]]),it=(t,e)=>{const i=[];let r=t;do{let n=r&127;r>>=7,i.length>0&&(n|=128),i.push(n)}while(r>0||e);return i.reverse()},W=(t,e=!1)=>{const i=Array(t.length).fill(null).map((r,n)=>t.charCodeAt(n));return e&&i.push(0),i},St=t=>{let e=null;for(const i of t)(!e||i.timestamp>e.timestamp)&&(e=i);return e},Ei=t=>{const e=t*(Math.PI/180),i=Math.round(Math.cos(e)),r=Math.round(Math.sin(e));return[i,r,0,-r,i,0,0,0,1]},Si=Ei(0),_i=t=>[fe(t[0]),fe(t[1]),tt(t[2]),fe(t[3]),fe(t[4]),tt(t[5]),fe(t[6]),fe(t[7]),tt(t[8])],E=(t,e,i)=>({type:t,contents:e&&new Uint8Array(e.flat(10)),children:i}),A=(t,e,i,r,n)=>E(t,[z(e),Ci(i),r??[]],n),sn=t=>t.isQuickTime?E("ftyp",[W("qt  "),w(512),W("qt  ")]):t.fragmented?E("ftyp",[W("iso5"),w(512),W("iso5"),W("iso6"),W("mp41")]):E("ftyp",[W("isom"),w(512),W("isom"),t.holdsAvc?W("avc1"):[],W("mp41")]),Ne=t=>({type:"mdat",largeSize:t}),on=t=>({type:"free",size:t}),Fe=t=>E("moov",void 0,[an(t.creationTime,t.trackDatas),...t.trackDatas.map(e=>cn(e,t.creationTime)),t.isFragmented?Dn(t.trackDatas):null,is(t)]),an=(t,e)=>{const i=L(Math.max(0,...e.filter(o=>o.samples.length>0).map(o=>{const a=St(o.samples);return a.timestamp+a.duration})),ut),r=Math.max(0,...e.map(o=>o.track.id))+1,n=!Ae(t)||!Ae(i),s=n?_e:w;return A("mvhd",+n,0,[s(t),s(t),w(ut),s(i),fe(1),xi(1),Array(10).fill(0),_i(Si),Array(24).fill(0),w(r)])},cn=(t,e)=>{const i=fs(t);return E("trak",void 0,[dn(t,e),ln(t,e),i.name!==void 0?E("udta",void 0,[E("name",[...ce.encode(i.name)])]):null])},dn=(t,e)=>{const i=St(t.samples),r=L(i?i.timestamp+i.duration:0,ut),n=!Ae(e)||!Ae(r),s=n?_e:w;let o;if(t.type==="video"){const l=t.track.metadata.rotation;o=Ei(l??0)}else o=Si;let a=2;return t.track.metadata.disposition?.default!==!1&&(a|=1),A("tkhd",+n,a,[s(e),s(e),w(t.track.id),w(0),s(r),Array(8).fill(0),C(0),C(t.track.id),xi(t.type==="audio"?1:0),C(0),_i(o),fe(t.type==="video"?t.info.width:0),fe(t.type==="video"?t.info.height:0)])},ln=(t,e)=>E("mdia",void 0,[un(t,e),_t(!0,hn[t.type],fn[t.type]),mn(t)]),un=(t,e)=>{const i=St(t.samples),r=L(i?i.timestamp+i.duration:0,t.timescale),n=!Ae(e)||!Ae(r),s=n?_e:w;return A("mdhd",+n,0,[s(e),s(e),w(t.timescale),s(r),C(Ai(t.track.metadata.languageCode??sr)),C(0)])},hn={video:"vide",audio:"soun",subtitle:"text"},fn={video:"MediabunnyVideoHandler",audio:"MediabunnySoundHandler",subtitle:"MediabunnyTextHandler"},_t=(t,e,i,r="\0\0\0\0")=>A("hdlr",0,0,[t?W("mhlr"):w(0),W(e),W(r),w(0),w(0),W(i,!0)]),mn=t=>E("minf",void 0,[yn[t.type](),bn(),Cn(t)]),pn=()=>A("vmhd",0,1,[C(0),C(0),C(0),C(0)]),gn=()=>A("smhd",0,0,[C(0),C(0)]),wn=()=>A("nmhd",0,0),yn={video:pn,audio:gn,subtitle:wn},bn=()=>E("dinf",void 0,[Tn()]),Tn=()=>A("dref",0,0,[w(1)],[vn()]),vn=()=>A("url ",0,1),Cn=t=>{const e=t.compositionTimeOffsetTable.length>1||t.compositionTimeOffsetTable.some(i=>i.sampleCompositionTimeOffset!==0);return E("stbl",void 0,[xn(t),On(t),e?Un(t):null,e?Hn(t):null,Vn(t),Wn(t),Nn(t),Ln(t)])},xn=t=>{let e;if(t.type==="video")e=En(os(t.track.source._codec,t.info.decoderConfig.codec),t);else if(t.type==="audio"){const i=ki(t.track.source._codec,t.muxer.isQuickTime);v(i),e=kn(i,t)}else t.type==="subtitle"&&(e=zn(ds[t.track.source._codec],t));return v(e),A("stsd",0,0,[w(1)],[e])},En=(t,e)=>E(t,[Array(6).fill(0),C(1),C(0),C(0),Array(12).fill(0),C(e.info.width),C(e.info.height),w(4718592),w(4718592),w(0),C(1),Array(32).fill(0),C(24),vi(65535)],[as[e.track.source._codec](e),ir(e.info.decoderConfig.colorSpace)?Sn(e):null]),Sn=t=>E("colr",[W("nclx"),C(yt[t.info.decoderConfig.colorSpace.primaries]),C(bt[t.info.decoderConfig.colorSpace.transfer]),C(Tt[t.info.decoderConfig.colorSpace.matrix]),z((t.info.decoderConfig.colorSpace.fullRange?1:0)<<7)]),_n=t=>t.info.decoderConfig&&E("avcC",[...ye(t.info.decoderConfig.description)]),Pn=t=>t.info.decoderConfig&&E("hvcC",[...ye(t.info.decoderConfig.description)]),jt=t=>{if(!t.info.decoderConfig)return null;const e=t.info.decoderConfig,i=e.codec.split("."),r=Number(i[1]),n=Number(i[2]),s=Number(i[3]),o=i[4]?Number(i[4]):1,a=i[8]?Number(i[8]):Number(e.colorSpace?.fullRange??0),l=(s<<4)+(o<<1)+a,c=i[5]?Number(i[5]):e.colorSpace?.primaries?yt[e.colorSpace.primaries]:2,d=i[6]?Number(i[6]):e.colorSpace?.transfer?bt[e.colorSpace.transfer]:2,f=i[7]?Number(i[7]):e.colorSpace?.matrix?Tt[e.colorSpace.matrix]:2;return A("vpcC",1,0,[z(r),z(n),z(l),z(c),z(d),z(f),C(0)])},Bn=t=>E("av1C",pr(t.info.decoderConfig.codec)),kn=(t,e)=>{let i=0,r,n=16;if(Se.includes(e.track.source._codec)){const s=e.track.source._codec,{sampleSize:o}=We(s);n=8*o,n>16&&(i=1)}return i===0?r=[Array(6).fill(0),C(1),C(i),C(0),w(0),C(e.info.numberOfChannels),C(n),C(0),C(0),C(e.info.sampleRate<2**16?e.info.sampleRate:0),C(0)]:r=[Array(6).fill(0),C(1),C(i),C(0),w(0),C(e.info.numberOfChannels),C(Math.min(n,16)),C(0),C(0),C(e.info.sampleRate<2**16?e.info.sampleRate:0),C(0),w(1),w(n/8),w(e.info.numberOfChannels*n/8),w(2)],E(t,r,[cs(e.track.source._codec,e.muxer.isQuickTime)?.(e)??null])},rt=t=>{let e;switch(t.track.source._codec){case"aac":e=64;break;case"mp3":e=107;break;case"vorbis":e=221;break;default:throw new Error(`Unhandled audio codec: ${t.track.source._codec}`)}let i=[...z(e),...z(21),...Ci(0),...w(0),...w(0)];if(t.info.decoderConfig.description){const r=ye(t.info.decoderConfig.description);i=[...i,...z(5),...it(r.byteLength),...r]}return i=[...C(1),...z(0),...z(4),...it(i.length),...i,...z(6),...z(1),...z(2)],i=[...z(3),...it(i.length),...i],A("esds",0,0,i)},ge=t=>E("wave",void 0,[An(t),In(t),E("\0\0\0\0")]),An=t=>E("frma",[W(ki(t.track.source._codec,t.muxer.isQuickTime))]),In=t=>{const{littleEndian:e}=We(t.track.source._codec);return E("enda",[C(+e)])},Mn=t=>{let e=t.info.numberOfChannels,i=3840,r=t.info.sampleRate,n=0,s=0,o=new Uint8Array(0);const a=t.info.decoderConfig?.description;if(a){v(a.byteLength>=18);const l=ye(a),c=qr(l);e=c.outputChannelCount,i=c.preSkip,r=c.inputSampleRate,n=c.outputGain,s=c.channelMappingFamily,c.channelMappingTable&&(o=c.channelMappingTable)}return E("dOps",[z(0),z(e),C(i),w(r),vi(n),z(s),...o])},Fn=t=>{const e=t.info.decoderConfig?.description;v(e);const i=ye(e);return A("dfLa",0,0,[...i.subarray(4)])},re=t=>{const{littleEndian:e,sampleSize:i}=We(t.track.source._codec),r=+e;return A("pcmC",0,0,[z(r),z(8*i)])},zn=(t,e)=>E(t,[Array(6).fill(0),C(1)],[ls[e.track.source._codec](e)]),Rn=t=>E("vttC",[...ce.encode(t.info.config.description)]),On=t=>A("stts",0,0,[w(t.timeToSampleTable.length),t.timeToSampleTable.map(e=>[w(e.sampleCount),w(e.sampleDelta)])]),Ln=t=>{if(t.samples.every(i=>i.type==="key"))return null;const e=[...t.samples.entries()].filter(([,i])=>i.type==="key");return A("stss",0,0,[w(e.length),e.map(([i])=>w(i+1))])},Vn=t=>A("stsc",0,0,[w(t.compactlyCodedChunkTable.length),t.compactlyCodedChunkTable.map(e=>[w(e.firstChunk),w(e.samplesPerChunk),w(1)])]),Wn=t=>{if(t.type==="audio"&&t.info.requiresPcmTransformation){const{sampleSize:e}=We(t.track.source._codec);return A("stsz",0,0,[w(e*t.info.numberOfChannels),w(t.samples.reduce((i,r)=>i+L(r.duration,t.timescale),0))])}return A("stsz",0,0,[w(0),w(t.samples.length),t.samples.map(e=>w(e.size))])},Nn=t=>t.finalizedChunks.length>0&&te(t.finalizedChunks).offset>=2**32?A("co64",0,0,[w(t.finalizedChunks.length),t.finalizedChunks.map(e=>_e(e.offset))]):A("stco",0,0,[w(t.finalizedChunks.length),t.finalizedChunks.map(e=>w(e.offset))]),Un=t=>A("ctts",1,0,[w(t.compositionTimeOffsetTable.length),t.compositionTimeOffsetTable.map(e=>[w(e.sampleCount),we(e.sampleCompositionTimeOffset)])]),Hn=t=>{let e=1/0,i=-1/0,r=1/0,n=-1/0;v(t.compositionTimeOffsetTable.length>0),v(t.samples.length>0);for(let o=0;o<t.compositionTimeOffsetTable.length;o++){const a=t.compositionTimeOffsetTable[o];e=Math.min(e,a.sampleCompositionTimeOffset),i=Math.max(i,a.sampleCompositionTimeOffset)}for(let o=0;o<t.samples.length;o++){const a=t.samples[o];r=Math.min(r,L(a.timestamp,t.timescale)),n=Math.max(n,L(a.timestamp+a.duration,t.timescale))}const s=Math.max(-e,0);return n>=2**31?null:A("cslg",0,0,[we(s),we(e),we(i),we(r),we(n)])},Dn=t=>E("mvex",void 0,t.map($n)),$n=t=>A("trex",0,0,[w(t.track.id),w(1),w(0),w(0),w(0)]),Gt=(t,e)=>E("moof",void 0,[qn(t),...e.map(Xn)]),qn=t=>A("mfhd",0,0,[w(t)]),Pi=t=>{let e=0,i=0;const r=0,n=0,s=t.type==="delta";return i|=+s,s?e|=1:e|=2,e<<24|i<<16|r<<8|n},Xn=t=>E("traf",void 0,[jn(t),Gn(t),Yn(t)]),jn=t=>{v(t.currentChunk);let e=0;e|=8,e|=16,e|=32,e|=131072;const i=t.currentChunk.samples[1]??t.currentChunk.samples[0],r={duration:i.timescaleUnitsToNextSample,size:i.size,flags:Pi(i)};return A("tfhd",0,e,[w(t.track.id),w(r.duration),w(r.size),w(r.flags)])},Gn=t=>(v(t.currentChunk),A("tfdt",1,0,[_e(L(t.currentChunk.startTimestamp,t.timescale))])),Yn=t=>{v(t.currentChunk);const e=t.currentChunk.samples.map(x=>x.timescaleUnitsToNextSample),i=t.currentChunk.samples.map(x=>x.size),r=t.currentChunk.samples.map(Pi),n=t.currentChunk.samples.map(x=>L(x.timestamp-x.decodeTimestamp,t.timescale)),s=new Set(e),o=new Set(i),a=new Set(r),l=new Set(n),c=a.size===2&&r[0]!==r[1],d=s.size>1,f=o.size>1,g=!c&&a.size>1,h=l.size>1||[...l].some(x=>x!==0);let p=0;return p|=1,p|=4*+c,p|=256*+d,p|=512*+f,p|=1024*+g,p|=2048*+h,A("trun",1,p,[w(t.currentChunk.samples.length),w(t.currentChunk.offset-t.currentChunk.moofOffset||0),c?w(r[0]):[],t.currentChunk.samples.map((x,B)=>[d?w(e[B]):[],f?w(i[B]):[],g?w(r[B]):[],h?we(n[B]):[]])])},Qn=t=>E("mfra",void 0,[...t.map(Zn),Kn()]),Zn=(t,e)=>A("tfra",1,0,[w(t.track.id),w(63),w(t.finalizedChunks.length),t.finalizedChunks.map(r=>[_e(L(r.samples[0].timestamp,t.timescale)),_e(r.moofOffset),w(e+1),w(1),w(1)])]),Kn=()=>A("mfro",0,0,[w(0)]),Jn=()=>E("vtte"),es=(t,e,i,r,n)=>E("vttc",void 0,[n!==null?E("vsid",[we(n)]):null,i!==null?E("iden",[...ce.encode(i)]):null,e!==null?E("ctim",[...ce.encode(nn(e))]):null,r!==null?E("sttg",[...ce.encode(r)]):null,E("payl",[...ce.encode(t)])]),ts=t=>E("vtta",[...ce.encode(t)]),is=t=>{const e=[],i=t.format._options.metadataFormat??"auto",r=t.output._metadataTags;if(i==="mdir"||i==="auto"&&!t.isQuickTime){const n=ns(r);n&&e.push(n)}else if(i==="mdta"){const n=ss(r);n&&e.push(n)}else(i==="udta"||i==="auto"&&t.isQuickTime)&&rs(e,t.output._metadataTags);return e.length===0?null:E("udta",void 0,e)},rs=(t,e)=>{for(const{key:i,value:r}of mi(e))switch(i){case"title":t.push(ne("nam",r));break;case"description":t.push(ne("des",r));break;case"artist":t.push(ne("ART",r));break;case"album":t.push(ne("alb",r));break;case"albumArtist":t.push(ne("albr",r));break;case"genre":t.push(ne("gen",r));break;case"date":t.push(ne("day",r.toISOString().slice(0,10)));break;case"comment":t.push(ne("cmt",r));break;case"lyrics":t.push(ne("lyr",r));break;case"raw":break;case"discNumber":case"discsTotal":case"trackNumber":case"tracksTotal":case"images":break;default:Ct(i)}if(e.raw)for(const i in e.raw){const r=e.raw[i];r==null||i.length!==4||t.some(n=>n.type===i)||(typeof r=="string"?t.push(ne(i,r)):r instanceof Uint8Array&&t.push(E(i,Array.from(r))))}},ne=(t,e)=>{const i=ce.encode(e);return E(t,[C(i.length),C(Ai("und")),Array.from(i)])},Yt={"image/jpeg":13,"image/png":14,"image/bmp":27},Bi=(t,e)=>{const i=[];for(const{key:r,value:n}of mi(t))switch(r){case"title":i.push({key:e?"title":"nam",value:ee(n)});break;case"description":i.push({key:e?"description":"des",value:ee(n)});break;case"artist":i.push({key:e?"artist":"ART",value:ee(n)});break;case"album":i.push({key:e?"album":"alb",value:ee(n)});break;case"albumArtist":i.push({key:e?"album_artist":"aART",value:ee(n)});break;case"comment":i.push({key:e?"comment":"cmt",value:ee(n)});break;case"genre":i.push({key:e?"genre":"gen",value:ee(n)});break;case"lyrics":i.push({key:e?"lyrics":"lyr",value:ee(n)});break;case"date":i.push({key:e?"date":"day",value:ee(n.toISOString().slice(0,10))});break;case"images":for(const s of n)s.kind==="coverFront"&&i.push({key:"covr",value:E("data",[w(Yt[s.mimeType]??0),w(0),Array.from(s.data)])});break;case"trackNumber":if(e){const s=t.tracksTotal!==void 0?`${n}/${t.tracksTotal}`:n.toString();i.push({key:"track",value:ee(s)})}else i.push({key:"trkn",value:E("data",[w(0),w(0),C(0),C(n),C(t.tracksTotal??0),C(0)])});break;case"discNumber":e||i.push({key:"disc",value:E("data",[w(0),w(0),C(0),C(n),C(t.discsTotal??0),C(0)])});break;case"tracksTotal":case"discsTotal":break;case"raw":break;default:Ct(r)}if(t.raw)for(const r in t.raw){const n=t.raw[r];n==null||!e&&r.length!==4||i.some(s=>s.key===r)||(typeof n=="string"?i.push({key:r,value:ee(n)}):n instanceof Uint8Array?i.push({key:r,value:E("data",[w(0),w(0),Array.from(n)])}):n instanceof pi&&i.push({key:r,value:E("data",[w(Yt[n.mimeType]??0),w(0),Array.from(n.data)])}))}return i},ns=t=>{const e=Bi(t,!1);return e.length===0?null:A("meta",0,0,void 0,[_t(!1,"mdir","","appl"),E("ilst",void 0,e.map(i=>E(i.key,void 0,[i.value])))])},ss=t=>{const e=Bi(t,!0);return e.length===0?null:E("meta",void 0,[_t(!1,"mdta",""),A("keys",0,0,[w(e.length)],e.map(i=>E("mdta",[...ce.encode(i.key)]))),E("ilst",void 0,e.map((i,r)=>{const n=String.fromCharCode(...w(r+1));return E(n,void 0,[i.value])}))])},ee=t=>E("data",[w(1),w(0),...ce.encode(t)]),os=(t,e)=>{switch(t){case"avc":return e.startsWith("avc3")?"avc3":"avc1";case"hevc":return"hvc1";case"vp8":return"vp08";case"vp9":return"vp09";case"av1":return"av01"}},as={avc:_n,hevc:Pn,vp8:jt,vp9:jt,av1:Bn},ki=(t,e)=>{switch(t){case"aac":return"mp4a";case"mp3":return"mp4a";case"opus":return"Opus";case"vorbis":return"mp4a";case"flac":return"fLaC";case"ulaw":return"ulaw";case"alaw":return"alaw";case"pcm-u8":return"raw ";case"pcm-s8":return"sowt"}if(e)switch(t){case"pcm-s16":return"sowt";case"pcm-s16be":return"twos";case"pcm-s24":return"in24";case"pcm-s24be":return"in24";case"pcm-s32":return"in32";case"pcm-s32be":return"in32";case"pcm-f32":return"fl32";case"pcm-f32be":return"fl32";case"pcm-f64":return"fl64";case"pcm-f64be":return"fl64"}else switch(t){case"pcm-s16":return"ipcm";case"pcm-s16be":return"ipcm";case"pcm-s24":return"ipcm";case"pcm-s24be":return"ipcm";case"pcm-s32":return"ipcm";case"pcm-s32be":return"ipcm";case"pcm-f32":return"fpcm";case"pcm-f32be":return"fpcm";case"pcm-f64":return"fpcm";case"pcm-f64be":return"fpcm"}},cs=(t,e)=>{switch(t){case"aac":return rt;case"mp3":return rt;case"opus":return Mn;case"vorbis":return rt;case"flac":return Fn}if(e)switch(t){case"pcm-s24":return ge;case"pcm-s24be":return ge;case"pcm-s32":return ge;case"pcm-s32be":return ge;case"pcm-f32":return ge;case"pcm-f32be":return ge;case"pcm-f64":return ge;case"pcm-f64be":return ge}else switch(t){case"pcm-s16":return re;case"pcm-s16be":return re;case"pcm-s24":return re;case"pcm-s24be":return re;case"pcm-s32":return re;case"pcm-s32be":return re;case"pcm-f32":return re;case"pcm-f32be":return re;case"pcm-f64":return re;case"pcm-f64be":return re}return null},ds={webvtt:"wvtt"},ls={webvtt:Rn},Ai=t=>{v(t.length===3);let e=0;for(let i=0;i<3;i++)e<<=5,e+=t.charCodeAt(i)-96;return e};class us{constructor(){this.ensureMonotonicity=!1,this.trackedWrites=null,this.trackedStart=-1,this.trackedEnd=-1}start(){}maybeTrackWrites(e){if(!this.trackedWrites)return;let i=this.getPos();if(i<this.trackedStart){if(i+e.byteLength<=this.trackedStart)return;e=e.subarray(this.trackedStart-i),i=0}const r=i+e.byteLength-this.trackedStart;let n=this.trackedWrites.byteLength;for(;n<r;)n*=2;if(n!==this.trackedWrites.byteLength){const s=new Uint8Array(n);s.set(this.trackedWrites,0),this.trackedWrites=s}this.trackedWrites.set(e,i-this.trackedStart),this.trackedEnd=Math.max(this.trackedEnd,i+e.byteLength)}startTrackingWrites(){this.trackedWrites=new Uint8Array(2**10),this.trackedStart=this.getPos(),this.trackedEnd=this.trackedStart}stopTrackingWrites(){if(!this.trackedWrites)throw new Error("Internal error: Can't get tracked writes since nothing was tracked.");const i={data:this.trackedWrites.subarray(0,this.trackedEnd-this.trackedStart),start:this.trackedStart,end:this.trackedEnd};return this.trackedWrites=null,i}}const nt=2**16,st=2**32;class Ii extends us{constructor(e){if(super(),this.pos=0,this.maxPos=0,this.target=e,this.supportsResize="resize"in new ArrayBuffer(0),this.supportsResize)try{this.buffer=new ArrayBuffer(nt,{maxByteLength:st})}catch{this.buffer=new ArrayBuffer(nt),this.supportsResize=!1}else this.buffer=new ArrayBuffer(nt);this.bytes=new Uint8Array(this.buffer)}ensureSize(e){let i=this.buffer.byteLength;for(;i<e;)i*=2;if(i!==this.buffer.byteLength){if(i>st)throw new Error(`ArrayBuffer exceeded maximum size of ${st} bytes. Please consider using another target.`);if(this.supportsResize)this.buffer.resize(i);else{const r=new ArrayBuffer(i),n=new Uint8Array(r);n.set(this.bytes,0),this.buffer=r,this.bytes=n}}}write(e){this.maybeTrackWrites(e),this.ensureSize(this.pos+e.byteLength),this.bytes.set(e,this.pos),this.target.onwrite?.(this.pos,this.pos+e.byteLength),this.pos+=e.byteLength,this.maxPos=Math.max(this.maxPos,this.pos)}seek(e){this.pos=e}getPos(){return this.pos}async flush(){}async finalize(){this.ensureSize(this.pos),this.target.buffer=this.buffer.slice(0,Math.max(this.maxPos,this.pos))}async close(){}getSlice(e,i){return this.bytes.slice(e,i)}}class Mi{constructor(){this._output=null,this.onwrite=null}}class Fi extends Mi{constructor(){super(...arguments),this.buffer=null}_createWriter(){return new Ii(this)}}const ut=1e3,hs=2082844800,fs=t=>{const e={},i=t.track;return i.metadata.name!==void 0&&(e.name=i.metadata.name),e},L=(t,e,i=!0)=>{const r=t*e;return i?Math.round(r):r};class ms extends Br{constructor(e,i){super(e),this.auxTarget=new Fi,this.auxWriter=this.auxTarget._createWriter(),this.auxBoxWriter=new Xt(this.auxWriter),this.mdat=null,this.ftypSize=null,this.trackDatas=[],this.allTracksKnown=rr(),this.creationTime=Math.floor(Date.now()/1e3)+hs,this.finalizedChunks=[],this.nextFragmentNumber=1,this.maxWrittenTimestamp=-1/0,this.format=i,this.writer=e._writer,this.boxWriter=new Xt(this.writer),this.isQuickTime=i instanceof Li;const r=this.writer instanceof Ii?"in-memory":!1;this.fastStart=i._options.fastStart??r,this.isFragmented=this.fastStart==="fragmented",(this.fastStart==="in-memory"||this.isFragmented)&&(this.writer.ensureMonotonicity=!0),this.minimumFragmentDuration=i._options.minimumFragmentDuration??1}async start(){const e=await this.mutex.acquire(),i=this.output._tracks.some(r=>r.type==="video"&&r.source._codec==="avc");if(this.format._options.onFtyp&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(sn({isQuickTime:this.isQuickTime,holdsAvc:i,fragmented:this.isFragmented})),this.format._options.onFtyp){const{data:r,start:n}=this.writer.stopTrackingWrites();this.format._options.onFtyp(r,n)}if(this.ftypSize=this.writer.getPos(),this.fastStart!=="in-memory")if(this.fastStart==="reserve"){for(const r of this.output._tracks)if(r.metadata.maximumPacketCount===void 0)throw new Error("All tracks must specify maximumPacketCount in their metadata when using fastStart: 'reserve'.")}else this.isFragmented||(this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=Ne(!0),this.boxWriter.writeBox(this.mdat));await this.writer.flush(),e()}allTracksAreKnown(){for(const e of this.output._tracks)if(!e.source._closed&&!this.trackDatas.some(i=>i.track===e))return!1;return!0}async getMimeType(){await this.allTracksKnown.promise;const e=this.trackDatas.map(i=>i.type==="video"||i.type==="audio"?i.info.decoderConfig.codec:{webvtt:"wvtt"}[i.track.source._codec]);return Kr({isQuickTime:this.isQuickTime,hasVideo:this.trackDatas.some(i=>i.type==="video"),hasAudio:this.trackDatas.some(i=>i.type==="audio"),codecStrings:e})}getVideoTrackData(e,i,r){const n=this.trackDatas.find(c=>c.track===e);if(n)return n;Er(r),v(r),v(r.decoderConfig);const s={...r.decoderConfig};v(s.codedWidth!==void 0),v(s.codedHeight!==void 0);let o=!1;if(e.source._codec==="avc"&&!s.description){const c=Mr(i.data);if(!c)throw new Error("Couldn't extract an AVCDecoderConfigurationRecord from the AVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.264) when not providing a description, or provide a description (must be an AVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in AVCC format.");s.description=Fr(c),o=!0}else if(e.source._codec==="hevc"&&!s.description){const c=Lr(i.data);if(!c)throw new Error("Couldn't extract an HEVCDecoderConfigurationRecord from the HEVC packet. Make sure the packets are in Annex B format (as specified in ITU-T-REC-H.265) when not providing a description, or provide a description (must be an HEVCDecoderConfigurationRecord as specified in ISO 14496-15) and ensure the packets are in HEVC format.");s.description=$r(c),o=!0}const a=cr(1/(e.metadata.frameRate??57600),1e6).denominator,l={muxer:this,track:e,type:"video",info:{width:s.codedWidth,height:s.codedHeight,decoderConfig:s,requiresAnnexBTransformation:o},timescale:a,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(l),this.trackDatas.sort((c,d)=>c.track.id-d.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),l}getAudioTrackData(e,i,r){const n=this.trackDatas.find(l=>l.track===e);if(n)return n;_r(r),v(r),v(r.decoderConfig);const s={...r.decoderConfig};let o=!1;if(e.source._codec==="aac"&&!s.description){const l=$t(Le.tempFromBytes(i.data));if(!l)throw new Error("Couldn't parse ADTS header from the AAC packet. Make sure the packets are in ADTS format (as specified in ISO 13818-7) when not providing a description, or provide a description (must be an AudioSpecificConfig as specified in ISO 14496-3) and ensure the packets are raw AAC data.");const c=wi[l.samplingFrequencyIndex],d=yi[l.channelConfiguration];if(c===void 0||d===void 0)throw new Error("Invalid ADTS frame header.");s.description=gr({objectType:l.objectType,sampleRate:c,numberOfChannels:d}),o=!0}const a={muxer:this,track:e,type:"audio",info:{numberOfChannels:r.decoderConfig.numberOfChannels,sampleRate:r.decoderConfig.sampleRate,decoderConfig:s,requiresPcmTransformation:!this.isFragmented&&Se.includes(e.source._codec),requiresAdtsStripping:o},timescale:r.decoderConfig.sampleRate,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[]};return this.trackDatas.push(a),this.trackDatas.sort((l,c)=>l.track.id-c.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),a}getSubtitleTrackData(e,i){const r=this.trackDatas.find(s=>s.track===e);if(r)return r;Pr(i),v(i),v(i.config);const n={muxer:this,track:e,type:"subtitle",info:{config:i.config},timescale:1e3,samples:[],sampleQueue:[],timestampProcessingQueue:[],timeToSampleTable:[],compositionTimeOffsetTable:[],lastTimescaleUnits:null,lastSample:null,finalizedChunks:[],currentChunk:null,compactlyCodedChunkTable:[],lastCueEndTimestamp:0,cueQueue:[],nextSourceId:0,cueToSourceId:new WeakMap};return this.trackDatas.push(n),this.trackDatas.sort((s,o)=>s.track.id-o.track.id),this.allTracksAreKnown()&&this.allTracksKnown.resolve(),n}async addEncodedVideoPacket(e,i,r){const n=await this.mutex.acquire();try{const s=this.getVideoTrackData(e,i,r);let o=i.data;if(s.info.requiresAnnexBTransformation){const c=[...xt(o)].map(d=>o.subarray(d.offset,d.offset+d.length));if(c.length===0)throw new Error("Failed to transform packet data. Make sure all packets are provided in Annex B format, as specified in ITU-T-REC-H.264 and ITU-T-REC-H.265.");o=Ir(c,4)}const a=this.validateAndNormalizeTimestamp(s.track,i.timestamp,i.type==="key"),l=this.createSampleForTrack(s,o,a,i.duration,i.type);await this.registerSample(s,l)}finally{n()}}async addEncodedAudioPacket(e,i,r){const n=await this.mutex.acquire();try{const s=this.getAudioTrackData(e,i,r);let o=i.data;if(s.info.requiresAdtsStripping){const c=$t(Le.tempFromBytes(o));if(!c)throw new Error("Expected ADTS frame, didn't get one.");const d=c.crcCheck===null?Jr:en;o=o.subarray(d)}const a=this.validateAndNormalizeTimestamp(s.track,i.timestamp,i.type==="key"),l=this.createSampleForTrack(s,o,a,i.duration,i.type);s.info.requiresPcmTransformation&&await this.maybePadWithSilence(s,a),await this.registerSample(s,l)}finally{n()}}async maybePadWithSilence(e,i){const r=te(e.samples),n=r?r.timestamp+r.duration:0,s=i-n,o=L(s,e.timescale);if(o>0){const{sampleSize:a,silentValue:l}=We(e.info.decoderConfig.codec),c=o*e.info.numberOfChannels,d=new Uint8Array(a*c).fill(l),f=this.createSampleForTrack(e,new Uint8Array(d.buffer),n,s,"key");await this.registerSample(e,f)}}async addSubtitleCue(e,i,r){const n=await this.mutex.acquire();try{const s=this.getSubtitleTrackData(e,r);this.validateAndNormalizeTimestamp(s.track,i.timestamp,!0),e.source._codec==="webvtt"&&(s.cueQueue.push(i),await this.processWebVTTCues(s,i.timestamp))}finally{n()}}async processWebVTTCues(e,i){for(;e.cueQueue.length>0;){const r=new Set([]);for(const c of e.cueQueue)v(c.timestamp<=i),v(e.lastCueEndTimestamp<=c.timestamp+c.duration),r.add(Math.max(c.timestamp,e.lastCueEndTimestamp)),r.add(c.timestamp+c.duration);const n=[...r].sort((c,d)=>c-d),s=n[0],o=n[1]??s;if(i<o)break;if(e.lastCueEndTimestamp<s){this.auxWriter.seek(0);const c=Jn();this.auxBoxWriter.writeBox(c);const d=this.auxWriter.getSlice(0,this.auxWriter.getPos()),f=this.createSampleForTrack(e,d,e.lastCueEndTimestamp,s-e.lastCueEndTimestamp,"key");await this.registerSample(e,f),e.lastCueEndTimestamp=s}this.auxWriter.seek(0);for(let c=0;c<e.cueQueue.length;c++){const d=e.cueQueue[c];if(d.timestamp>=o)break;qt.lastIndex=0;const f=qt.test(d.text),g=d.timestamp+d.duration;let h=e.cueToSourceId.get(d);if(h===void 0&&o<g&&(h=e.nextSourceId++,e.cueToSourceId.set(d,h)),d.notes){const x=ts(d.notes);this.auxBoxWriter.writeBox(x)}const p=es(d.text,f?s:null,d.identifier??null,d.settings??null,h??null);this.auxBoxWriter.writeBox(p),g===o&&e.cueQueue.splice(c--,1)}const a=this.auxWriter.getSlice(0,this.auxWriter.getPos()),l=this.createSampleForTrack(e,a,s,o-s,"key");await this.registerSample(e,l),e.lastCueEndTimestamp=o}}createSampleForTrack(e,i,r,n,s){return{timestamp:r,decodeTimestamp:r,duration:n,data:i,size:i.byteLength,type:s,timescaleUnitsToNextSample:L(n,e.timescale)}}processTimestamps(e,i){if(e.timestampProcessingQueue.length===0)return;if(e.type==="audio"&&e.info.requiresPcmTransformation){let n=0;for(let s=0;s<e.timestampProcessingQueue.length;s++){const o=e.timestampProcessingQueue[s],a=L(o.duration,e.timescale);n+=a}if(e.timeToSampleTable.length===0)e.timeToSampleTable.push({sampleCount:n,sampleDelta:1});else{const s=te(e.timeToSampleTable);s.sampleCount+=n}e.timestampProcessingQueue.length=0;return}const r=e.timestampProcessingQueue.map(n=>n.timestamp).sort((n,s)=>n-s);for(let n=0;n<e.timestampProcessingQueue.length;n++){const s=e.timestampProcessingQueue[n];s.decodeTimestamp=r[n],!this.isFragmented&&e.lastTimescaleUnits===null&&(s.decodeTimestamp=0);const o=L(s.timestamp-s.decodeTimestamp,e.timescale),a=L(s.duration,e.timescale);if(e.lastTimescaleUnits!==null){v(e.lastSample);const l=L(s.decodeTimestamp,e.timescale,!1),c=Math.round(l-e.lastTimescaleUnits);if(v(c>=0),e.lastTimescaleUnits+=c,e.lastSample.timescaleUnitsToNextSample=c,!this.isFragmented){let d=te(e.timeToSampleTable);if(v(d),d.sampleCount===1){d.sampleDelta=c;const g=e.timeToSampleTable[e.timeToSampleTable.length-2];g&&g.sampleDelta===c&&(g.sampleCount++,e.timeToSampleTable.pop(),d=g)}else d.sampleDelta!==c&&(d.sampleCount--,e.timeToSampleTable.push(d={sampleCount:1,sampleDelta:c}));d.sampleDelta===a?d.sampleCount++:e.timeToSampleTable.push({sampleCount:1,sampleDelta:a});const f=te(e.compositionTimeOffsetTable);v(f),f.sampleCompositionTimeOffset===o?f.sampleCount++:e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:o})}}else e.lastTimescaleUnits=L(s.decodeTimestamp,e.timescale,!1),this.isFragmented||(e.timeToSampleTable.push({sampleCount:1,sampleDelta:a}),e.compositionTimeOffsetTable.push({sampleCount:1,sampleCompositionTimeOffset:o}));e.lastSample=s}if(e.timestampProcessingQueue.length=0,v(e.lastSample),v(e.lastTimescaleUnits!==null),i!==void 0&&e.lastSample.timescaleUnitsToNextSample===0){v(i.type==="key");const n=L(i.timestamp,e.timescale,!1),s=Math.round(n-e.lastTimescaleUnits);e.lastSample.timescaleUnitsToNextSample=s}}async registerSample(e,i){i.type==="key"&&this.processTimestamps(e,i),e.timestampProcessingQueue.push(i),this.isFragmented?(e.sampleQueue.push(i),await this.interleaveSamples()):this.fastStart==="reserve"?await this.registerSampleFastStartReserve(e,i):await this.addSampleToTrack(e,i)}async addSampleToTrack(e,i){if(!this.isFragmented&&(e.samples.push(i),this.fastStart==="reserve")){const n=e.track.metadata.maximumPacketCount;if(v(n!==void 0),e.samples.length>n)throw new Error(`Track #${e.track.id} has already reached the maximum packet count (${n}). Either add less packets or increase the maximum packet count.`)}let r=!1;if(!e.currentChunk)r=!0;else{e.currentChunk.startTimestamp=Math.min(e.currentChunk.startTimestamp,i.timestamp);const n=i.timestamp-e.currentChunk.startTimestamp;if(this.isFragmented){const s=this.trackDatas.every(o=>{if(e===o)return i.type==="key";const a=o.sampleQueue[0];return a?a.type==="key":o.track.source._closed});n>=this.minimumFragmentDuration&&s&&i.timestamp>this.maxWrittenTimestamp&&(r=!0,await this.finalizeFragment())}else r=n>=.5}r&&(e.currentChunk&&await this.finalizeCurrentChunk(e),e.currentChunk={startTimestamp:i.timestamp,samples:[],offset:null,moofOffset:null}),v(e.currentChunk),e.currentChunk.samples.push(i),this.isFragmented&&(this.maxWrittenTimestamp=Math.max(this.maxWrittenTimestamp,i.timestamp))}async finalizeCurrentChunk(e){if(v(!this.isFragmented),!e.currentChunk)return;e.finalizedChunks.push(e.currentChunk),this.finalizedChunks.push(e.currentChunk);let i=e.currentChunk.samples.length;if(e.type==="audio"&&e.info.requiresPcmTransformation&&(i=e.currentChunk.samples.reduce((r,n)=>r+L(n.duration,e.timescale),0)),(e.compactlyCodedChunkTable.length===0||te(e.compactlyCodedChunkTable).samplesPerChunk!==i)&&e.compactlyCodedChunkTable.push({firstChunk:e.finalizedChunks.length,samplesPerChunk:i}),this.fastStart==="in-memory"){e.currentChunk.offset=0;return}e.currentChunk.offset=this.writer.getPos();for(const r of e.currentChunk.samples)v(r.data),this.writer.write(r.data),r.data=null;await this.writer.flush()}async interleaveSamples(e=!1){if(v(this.isFragmented),!(!e&&!this.allTracksAreKnown()))e:for(;;){let i=null,r=1/0;for(const s of this.trackDatas){if(!e&&s.sampleQueue.length===0&&!s.track.source._closed)break e;s.sampleQueue.length>0&&s.sampleQueue[0].timestamp<r&&(i=s,r=s.sampleQueue[0].timestamp)}if(!i)break;const n=i.sampleQueue.shift();await this.addSampleToTrack(i,n)}}async finalizeFragment(e=!0){v(this.isFragmented);const i=this.nextFragmentNumber++;if(i===1){this.format._options.onMoov&&this.writer.startTrackingWrites();const h=Fe(this);if(this.boxWriter.writeBox(h),this.format._options.onMoov){const{data:p,start:x}=this.writer.stopTrackingWrites();this.format._options.onMoov(p,x)}}const r=this.trackDatas.filter(h=>h.currentChunk),n=Gt(i,r),s=this.writer.getPos(),o=s+this.boxWriter.measureBox(n);let a=o+et,l=1/0;for(const h of r){h.currentChunk.offset=a,h.currentChunk.moofOffset=s;for(const p of h.currentChunk.samples)a+=p.size;l=Math.min(l,h.currentChunk.startTimestamp)}const c=a-o,d=c>=2**32;if(d)for(const h of r)h.currentChunk.offset+=Dt-et;this.format._options.onMoof&&this.writer.startTrackingWrites();const f=Gt(i,r);if(this.boxWriter.writeBox(f),this.format._options.onMoof){const{data:h,start:p}=this.writer.stopTrackingWrites();this.format._options.onMoof(h,p,l)}v(this.writer.getPos()===o),this.format._options.onMdat&&this.writer.startTrackingWrites();const g=Ne(d);g.size=c,this.boxWriter.writeBox(g),this.writer.seek(o+(d?Dt:et));for(const h of r)for(const p of h.currentChunk.samples)this.writer.write(p.data),p.data=null;if(this.format._options.onMdat){const{data:h,start:p}=this.writer.stopTrackingWrites();this.format._options.onMdat(h,p)}for(const h of r)h.finalizedChunks.push(h.currentChunk),this.finalizedChunks.push(h.currentChunk),h.currentChunk=null;e&&await this.writer.flush()}async registerSampleFastStartReserve(e,i){if(this.allTracksAreKnown()){if(!this.mdat){const r=Fe(this),s=this.boxWriter.measureBox(r)+this.computeSampleTableSizeUpperBound()+4096;v(this.ftypSize!==null),this.writer.seek(this.ftypSize+s),this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat=Ne(!0),this.boxWriter.writeBox(this.mdat);for(const o of this.trackDatas){for(const a of o.sampleQueue)await this.addSampleToTrack(o,a);o.sampleQueue.length=0}}await this.addSampleToTrack(e,i)}else e.sampleQueue.push(i)}computeSampleTableSizeUpperBound(){v(this.fastStart==="reserve");let e=0;for(const i of this.trackDatas){const r=i.track.metadata.maximumPacketCount;v(r!==void 0),e+=8*Math.ceil(2/3*r),e+=4*r,e+=8*Math.ceil(2/3*r),e+=12*Math.ceil(2/3*r),e+=4*r,e+=8*r}return e}async onTrackClose(e){const i=await this.mutex.acquire();if(e.type==="subtitle"&&e.source._codec==="webvtt"){const r=this.trackDatas.find(n=>n.track===e);r&&await this.processWebVTTCues(r,1/0)}this.allTracksAreKnown()&&this.allTracksKnown.resolve(),this.isFragmented&&await this.interleaveSamples(),i()}async finalize(){const e=await this.mutex.acquire();this.allTracksKnown.resolve();for(const i of this.trackDatas)i.type==="subtitle"&&i.track.source._codec==="webvtt"&&await this.processWebVTTCues(i,1/0);if(this.isFragmented){await this.interleaveSamples(!0);for(const i of this.trackDatas)this.processTimestamps(i);await this.finalizeFragment(!1)}else for(const i of this.trackDatas)this.processTimestamps(i),await this.finalizeCurrentChunk(i);if(this.fastStart==="in-memory"){this.mdat=Ne(!1);let i;for(let n=0;n<2;n++){const s=Fe(this),o=this.boxWriter.measureBox(s);i=this.boxWriter.measureBox(this.mdat);let a=this.writer.getPos()+o+i;for(const l of this.finalizedChunks){l.offset=a;for(const{data:c}of l.samples)v(c),a+=c.byteLength,i+=c.byteLength}if(a<2**32)break;i>=2**32&&(this.mdat.largeSize=!0)}this.format._options.onMoov&&this.writer.startTrackingWrites();const r=Fe(this);if(this.boxWriter.writeBox(r),this.format._options.onMoov){const{data:n,start:s}=this.writer.stopTrackingWrites();this.format._options.onMoov(n,s)}this.format._options.onMdat&&this.writer.startTrackingWrites(),this.mdat.size=i,this.boxWriter.writeBox(this.mdat);for(const n of this.finalizedChunks)for(const s of n.samples)v(s.data),this.writer.write(s.data),s.data=null;if(this.format._options.onMdat){const{data:n,start:s}=this.writer.stopTrackingWrites();this.format._options.onMdat(n,s)}}else if(this.isFragmented){const i=this.writer.getPos(),r=Qn(this.trackDatas);this.boxWriter.writeBox(r);const n=this.writer.getPos()-i;this.writer.seek(this.writer.getPos()-4),this.boxWriter.writeU32(n)}else{v(this.mdat);const i=this.boxWriter.offsets.get(this.mdat);v(i!==void 0);const r=this.writer.getPos()-i;if(this.mdat.size=r,this.mdat.largeSize=r>=2**32,this.boxWriter.patchBox(this.mdat),this.format._options.onMdat){const{data:s,start:o}=this.writer.stopTrackingWrites();this.format._options.onMdat(s,o)}const n=Fe(this);if(this.fastStart==="reserve"){v(this.ftypSize!==null),this.writer.seek(this.ftypSize),this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(n);const s=this.boxWriter.offsets.get(this.mdat)-this.writer.getPos();this.boxWriter.writeBox(on(s))}else this.format._options.onMoov&&this.writer.startTrackingWrites(),this.boxWriter.writeBox(n);if(this.format._options.onMoov){const{data:s,start:o}=this.writer.stopTrackingWrites();this.format._options.onMoov(s,o)}}e()}}class zi{getSupportedVideoCodecs(){return this.getSupportedCodecs().filter(e=>Ee.includes(e))}getSupportedAudioCodecs(){return this.getSupportedCodecs().filter(e=>$e.includes(e))}getSupportedSubtitleCodecs(){return this.getSupportedCodecs().filter(e=>qe.includes(e))}_codecUnsupportedHint(e){return""}}class Ri extends zi{constructor(e={}){if(!e||typeof e!="object")throw new TypeError("options must be an object.");if(e.fastStart!==void 0&&![!1,"in-memory","reserve","fragmented"].includes(e.fastStart))throw new TypeError("options.fastStart, when provided, must be false, 'in-memory', 'reserve', or 'fragmented'.");if(e.minimumFragmentDuration!==void 0&&(!Number.isFinite(e.minimumFragmentDuration)||e.minimumFragmentDuration<0))throw new TypeError("options.minimumFragmentDuration, when provided, must be a non-negative number.");if(e.onFtyp!==void 0&&typeof e.onFtyp!="function")throw new TypeError("options.onFtyp, when provided, must be a function.");if(e.onMoov!==void 0&&typeof e.onMoov!="function")throw new TypeError("options.onMoov, when provided, must be a function.");if(e.onMdat!==void 0&&typeof e.onMdat!="function")throw new TypeError("options.onMdat, when provided, must be a function.");if(e.onMoof!==void 0&&typeof e.onMoof!="function")throw new TypeError("options.onMoof, when provided, must be a function.");if(e.metadataFormat!==void 0&&!["mdir","mdta","udta","auto"].includes(e.metadataFormat))throw new TypeError("options.metadataFormat, when provided, must be either 'auto', 'mdir', 'mdta', or 'udta'.");super(),this._options=e}getSupportedTrackCounts(){return{video:{min:0,max:4294967295},audio:{min:0,max:4294967295},subtitle:{min:0,max:4294967295},total:{min:1,max:4294967295}}}get supportsVideoRotationMetadata(){return!0}_createMuxer(e){return new ms(e,this)}}class Oi extends Ri{constructor(e){super(e)}get _name(){return"MP4"}get fileExtension(){return".mp4"}get mimeType(){return"video/mp4"}getSupportedCodecs(){return[...Ee,...gi,"pcm-s16","pcm-s16be","pcm-s24","pcm-s24be","pcm-s32","pcm-s32be","pcm-f32","pcm-f32be","pcm-f64","pcm-f64be",...qe]}_codecUnsupportedHint(e){return new Li().getSupportedCodecs().includes(e)?" Switching to MOV will grant support for this codec.":""}}class Li extends Ri{constructor(e){super(e)}get _name(){return"MOV"}get fileExtension(){return".mov"}get mimeType(){return"video/quicktime"}getSupportedCodecs(){return[...Ee,...$e]}_codecUnsupportedHint(e){return new Oi().getSupportedCodecs().includes(e)?" Switching to MP4 will grant support for this codec.":""}}const ps=t=>{if(!t||typeof t!="object")throw new TypeError("Encoding config must be an object.");if(!Ee.includes(t.codec))throw new TypeError(`Invalid video codec '${t.codec}'. Must be one of: ${Ee.join(", ")}.`);if(!(t.bitrate instanceof Vi)&&(!Number.isInteger(t.bitrate)||t.bitrate<=0))throw new TypeError("config.bitrate must be a positive integer or a quality.");if(t.keyFrameInterval!==void 0&&(!Number.isFinite(t.keyFrameInterval)||t.keyFrameInterval<0))throw new TypeError("config.keyFrameInterval, when provided, must be a non-negative number.");if(t.sizeChangeBehavior!==void 0&&!["deny","passThrough","fill","contain","cover"].includes(t.sizeChangeBehavior))throw new TypeError("config.sizeChangeBehavior, when provided, must be 'deny', 'passThrough', 'fill', 'contain' or 'cover'.");if(t.onEncodedPacket!==void 0&&typeof t.onEncodedPacket!="function")throw new TypeError("config.onEncodedChunk, when provided, must be a function.");if(t.onEncoderConfig!==void 0&&typeof t.onEncoderConfig!="function")throw new TypeError("config.onEncoderConfig, when provided, must be a function.");gs(t.codec,t)},gs=(t,e)=>{if(!e||typeof e!="object")throw new TypeError("Encoding options must be an object.");if(e.alpha!==void 0&&!["discard","keep"].includes(e.alpha))throw new TypeError("options.alpha, when provided, must be 'discard' or 'keep'.");if(e.bitrateMode!==void 0&&!["constant","variable"].includes(e.bitrateMode))throw new TypeError("bitrateMode, when provided, must be 'constant' or 'variable'.");if(e.latencyMode!==void 0&&!["quality","realtime"].includes(e.latencyMode))throw new TypeError("latencyMode, when provided, must be 'quality' or 'realtime'.");if(e.fullCodecString!==void 0&&typeof e.fullCodecString!="string")throw new TypeError("fullCodecString, when provided, must be a string.");if(e.fullCodecString!==void 0&&wr(e.fullCodecString)!==t)throw new TypeError(`fullCodecString, when provided, must be a string that matches the specified codec (${t}).`);if(e.hardwareAcceleration!==void 0&&!["no-preference","prefer-hardware","prefer-software"].includes(e.hardwareAcceleration))throw new TypeError("hardwareAcceleration, when provided, must be 'no-preference', 'prefer-hardware' or 'prefer-software'.");if(e.scalabilityMode!==void 0&&typeof e.scalabilityMode!="string")throw new TypeError("scalabilityMode, when provided, must be a string.");if(e.contentHint!==void 0&&typeof e.contentHint!="string")throw new TypeError("contentHint, when provided, must be a string.")},ws=t=>{const e=t.bitrate instanceof Vi?t.bitrate._toVideoBitrate(t.codec,t.width,t.height):t.bitrate;return{codec:t.fullCodecString??mr(t.codec,t.width,t.height,e),width:t.width,height:t.height,bitrate:e,bitrateMode:t.bitrateMode,alpha:t.alpha??"discard",framerate:t.framerate,latencyMode:t.latencyMode,hardwareAcceleration:t.hardwareAcceleration,scalabilityMode:t.scalabilityMode,contentHint:t.contentHint,...yr(t.codec)}};class Vi{constructor(e){this._factor=e}_toVideoBitrate(e,i,r){const n=i*r,s={avc:1,hevc:.6,vp9:.6,av1:.4,vp8:1.2},o=1920*1080,a=3e6,l=Math.pow(n/o,.95),f=a*l*s[e]*this._factor;return Math.ceil(f/1e3)*1e3}_toAudioBitrate(e){if(Se.includes(e)||e==="flac")return;const r={aac:128e3,opus:64e3,mp3:16e4,vorbis:64e3}[e];if(!r)throw new Error(`Unhandled codec: ${e}`);let n=r*this._factor;return e==="aac"?n=[96e3,128e3,16e4,192e3].reduce((o,a)=>Math.abs(a-n)<Math.abs(o-n)?a:o):e==="opus"||e==="vorbis"?n=Math.max(6e3,n):e==="mp3"&&(n=[8e3,16e3,24e3,32e3,4e4,48e3,64e3,8e4,96e3,112e3,128e3,16e4,192e3,224e3,256e3,32e4].reduce((o,a)=>Math.abs(a-n)<Math.abs(o-n)?a:o)),Math.round(n/1e3)*1e3}}class Pt{constructor(){this._connectedTrack=null,this._closingPromise=null,this._closed=!1,this._timestampOffset=0}_ensureValidAdd(){if(!this._connectedTrack)throw new Error("Source is not connected to an output track.");if(this._connectedTrack.output.state==="canceled")throw new Error("Output has been canceled.");if(this._connectedTrack.output.state==="finalizing"||this._connectedTrack.output.state==="finalized")throw new Error("Output has been finalized.");if(this._connectedTrack.output.state==="pending")throw new Error("Output has not started.");if(this._closed)throw new Error("Source is closed.")}async _start(){}async _flushAndClose(e){}close(){if(this._closingPromise)return;const e=this._connectedTrack;if(!e)throw new Error("Cannot call close without connecting the source to an output track.");if(e.output.state==="pending")throw new Error("Cannot call close before output has been started.");this._closingPromise=(async()=>{await this._flushAndClose(!1),this._closed=!0,!(e.output.state==="finalizing"||e.output.state==="finalized")&&e.output._muxer.onTrackClose(e)})()}async _flushOrWaitForOngoingClose(e){return this._closingPromise??=(async()=>{await this._flushAndClose(e),this._closed=!0})()}}class Wi extends Pt{constructor(e){if(super(),this._connectedTrack=null,!Ee.includes(e))throw new TypeError(`Invalid video codec '${e}'. Must be one of: ${Ee.join(", ")}.`);this._codec=e}}class ys{constructor(e,i){this.source=e,this.encodingConfig=i,this.ensureEncoderPromise=null,this.encoderInitialized=!1,this.encoder=null,this.muxer=null,this.lastMultipleOfKeyFrameInterval=-1,this.codedWidth=null,this.codedHeight=null,this.resizeCanvas=null,this.customEncoder=null,this.customEncoderCallSerializer=new dr,this.customEncoderQueueSize=0,this.alphaEncoder=null,this.splitter=null,this.splitterCreationFailed=!1,this.alphaFrameQueue=[],this.error=null,this.errorNeedsNewStack=!0}async add(e,i,r){try{if(this.checkForEncoderError(),this.source._ensureValidAdd(),this.codedWidth!==null&&this.codedHeight!==null){if(e.codedWidth!==this.codedWidth||e.codedHeight!==this.codedHeight){const a=this.encodingConfig.sizeChangeBehavior??"deny";if(a!=="passThrough"){if(a==="deny")throw new Error(`Video sample size must remain constant. Expected ${this.codedWidth}x${this.codedHeight}, got ${e.codedWidth}x${e.codedHeight}. To allow the sample size to change over time, set \`sizeChangeBehavior\` to a value other than 'strict' in the encoding options.`);{let l=!1;this.resizeCanvas||(typeof document<"u"?(this.resizeCanvas=document.createElement("canvas"),this.resizeCanvas.width=this.codedWidth,this.resizeCanvas.height=this.codedHeight):this.resizeCanvas=new OffscreenCanvas(this.codedWidth,this.codedHeight),l=!0);const c=this.resizeCanvas.getContext("2d",{alpha:dt()});v(c),l||(dt()?(c.fillStyle="black",c.fillRect(0,0,this.codedWidth,this.codedHeight)):c.clearRect(0,0,this.codedWidth,this.codedHeight)),e.drawWithFit(c,{fit:a}),i&&e.close(),e=new Ce(this.resizeCanvas,{timestamp:e.timestamp,duration:e.duration,rotation:e.rotation}),i=!0}}}}else this.codedWidth=e.codedWidth,this.codedHeight=e.codedHeight;this.encoderInitialized||(this.ensureEncoderPromise||this.ensureEncoder(e),this.encoderInitialized||await this.ensureEncoderPromise),v(this.encoderInitialized);const n=this.encodingConfig.keyFrameInterval??5,s=Math.floor(e.timestamp/n),o={...r,keyFrame:r?.keyFrame||n===0||s!==this.lastMultipleOfKeyFrameInterval};if(this.lastMultipleOfKeyFrameInterval=s,this.customEncoder){this.customEncoderQueueSize++;const a=e.clone(),l=this.customEncoderCallSerializer.call(()=>this.customEncoder.encode(a,o)).then(()=>this.customEncoderQueueSize--).catch(c=>this.error??=c).finally(()=>{a.close()});this.customEncoderQueueSize>=4&&await l}else{v(this.encoder);const a=e.toVideoFrame();if(!this.alphaEncoder)this.encoder.encode(a,o),a.close();else if(!!a.format&&!a.format.includes("A")||this.splitterCreationFailed)this.alphaFrameQueue.push(null),this.encoder.encode(a,o),a.close();else{const c=a.displayWidth,d=a.displayHeight;if(!this.splitter)try{this.splitter=new bs(c,d)}catch(f){console.error("Due to an error, only color data will be encoded.",f),this.splitterCreationFailed=!0,this.alphaFrameQueue.push(null),this.encoder.encode(a,o),a.close()}if(this.splitter){const f=this.splitter.extractColor(a),g=this.splitter.extractAlpha(a);this.alphaFrameQueue.push(g),this.encoder.encode(f,o),f.close(),a.close()}}i&&e.close(),this.encoder.encodeQueueSize>=4&&await new Promise(l=>this.encoder.addEventListener("dequeue",l,{once:!0}))}await this.muxer.mutex.currentPromise}finally{i&&e.close()}}ensureEncoder(e){const i=new Error;this.ensureEncoderPromise=(async()=>{const r=ws({width:e.codedWidth,height:e.codedHeight,...this.encodingConfig,framerate:this.source._connectedTrack?.metadata.frameRate});this.encodingConfig.onEncoderConfig?.(r);const n=Xr.find(s=>s.supports(this.encodingConfig.codec,r));if(n)this.customEncoder=new n,this.customEncoder.codec=this.encodingConfig.codec,this.customEncoder.config=r,this.customEncoder.onPacket=(s,o)=>{if(!(s instanceof Oe))throw new TypeError("The first argument passed to onPacket must be an EncodedPacket.");if(o!==void 0&&(!o||typeof o!="object"))throw new TypeError("The second argument passed to onPacket must be an object or undefined.");this.encodingConfig.onEncodedPacket?.(s,o),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,s,o).catch(a=>{this.error??=a,this.errorNeedsNewStack=!1})},await this.customEncoder.init();else{if(typeof VideoEncoder>"u")throw new Error("VideoEncoder is not supported by this browser.");if(r.alpha="discard",this.encodingConfig.alpha==="keep"&&(r.latencyMode="quality"),(r.width%2===1||r.height%2===1)&&(this.encodingConfig.codec==="avc"||this.encodingConfig.codec==="hevc"))throw new Error(`The dimensions ${r.width}x${r.height} are not supported for codec '${this.encodingConfig.codec}'; both width and height must be even numbers. Make sure to round your dimensions to the nearest even number.`);if(!(await VideoEncoder.isConfigSupported(r)).supported)throw new Error(`This specific encoder configuration (${r.codec}, ${r.bitrate} bps, ${r.width}x${r.height}, hardware acceleration: ${r.hardwareAcceleration??"no-preference"}) is not supported by this browser. Consider using another codec or changing your video parameters.`);const a=[],l=[];let c=0,d=0;const f=(g,h,p)=>{const x={};if(h){const _=new Uint8Array(h.byteLength);h.copyTo(_),x.alpha=_}const B=Oe.fromEncodedChunk(g,x);this.encodingConfig.onEncodedPacket?.(B,p),this.muxer.addEncodedVideoPacket(this.source._connectedTrack,B,p).catch(_=>{this.error??=_,this.errorNeedsNewStack=!1})};this.encoder=new VideoEncoder({output:(g,h)=>{if(!this.alphaEncoder){f(g,null,h);return}const p=this.alphaFrameQueue.shift();v(p!==void 0),p?(this.alphaEncoder.encode(p,{keyFrame:g.type==="key"}),d++,p.close(),a.push({chunk:g,meta:h})):d===0?f(g,null,h):(l.push(c+d),a.push({chunk:g,meta:h}))},error:g=>{g.stack=i.stack,this.error??=g}}),this.encoder.configure(r),this.encodingConfig.alpha==="keep"&&(this.alphaEncoder=new VideoEncoder({output:(g,h)=>{d--;const p=a.shift();for(v(p!==void 0),f(p.chunk,g,p.meta),c++;l.length>0&&l[0]===c;){l.shift();const x=a.shift();v(x!==void 0),f(x.chunk,null,x.meta)}},error:g=>{g.stack=i.stack,this.error??=g}}),this.alphaEncoder.configure(r))}v(this.source._connectedTrack),this.muxer=this.source._connectedTrack.output._muxer,this.encoderInitialized=!0})()}async flushAndClose(e){e||this.checkForEncoderError(),this.customEncoder?(e||this.customEncoderCallSerializer.call(()=>this.customEncoder.flush()),await this.customEncoderCallSerializer.call(()=>this.customEncoder.close())):this.encoder&&(e||(await this.encoder.flush(),await this.alphaEncoder?.flush()),this.encoder.state!=="closed"&&this.encoder.close(),this.alphaEncoder&&this.alphaEncoder.state!=="closed"&&this.alphaEncoder.close(),this.alphaFrameQueue.forEach(i=>i?.close()),this.splitter?.close()),e||this.checkForEncoderError()}getQueueSize(){return this.customEncoder?this.customEncoderQueueSize:this.encoder?.encodeQueueSize??0}checkForEncoderError(){if(this.error)throw this.errorNeedsNewStack&&(this.error.stack=new Error().stack),this.error}}class bs{constructor(e,i){this.lastFrame=null,typeof OffscreenCanvas<"u"?this.canvas=new OffscreenCanvas(e,i):(this.canvas=document.createElement("canvas"),this.canvas.width=e,this.canvas.height=i);const r=this.canvas.getContext("webgl2",{alpha:!0});if(!r)throw new Error("Couldn't acquire WebGL 2 context.");this.gl=r,this.colorProgram=this.createColorProgram(),this.alphaProgram=this.createAlphaProgram(),this.vao=this.createVAO(),this.sourceTexture=this.createTexture(),this.alphaResolutionLocation=this.gl.getUniformLocation(this.alphaProgram,"u_resolution"),this.gl.useProgram(this.colorProgram),this.gl.uniform1i(this.gl.getUniformLocation(this.colorProgram,"u_sourceTexture"),0),this.gl.useProgram(this.alphaProgram),this.gl.uniform1i(this.gl.getUniformLocation(this.alphaProgram,"u_sourceTexture"),0)}createVertexShader(){return this.createShader(this.gl.VERTEX_SHADER,`#version 300 es
			in vec2 a_position;
			in vec2 a_texCoord;
			out vec2 v_texCoord;
			
			void main() {
				gl_Position = vec4(a_position, 0.0, 1.0);
				v_texCoord = a_texCoord;
			}
		`)}createColorProgram(){const e=this.createVertexShader(),i=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_sourceTexture;
			in vec2 v_texCoord;
			out vec4 fragColor;
			
			void main() {
				vec4 source = texture(u_sourceTexture, v_texCoord);
				fragColor = vec4(source.rgb, 1.0);
			}
		`),r=this.gl.createProgram();return this.gl.attachShader(r,e),this.gl.attachShader(r,i),this.gl.linkProgram(r),r}createAlphaProgram(){const e=this.createVertexShader(),i=this.createShader(this.gl.FRAGMENT_SHADER,`#version 300 es
			precision highp float;
			
			uniform sampler2D u_sourceTexture;
			uniform vec2 u_resolution; // The width and height of the canvas
			in vec2 v_texCoord;
			out vec4 fragColor;

			// This function determines the value for a single byte in the YUV stream
			float getByteValue(float byteOffset) {
				float width = u_resolution.x;
				float height = u_resolution.y;

				float yPlaneSize = width * height;

				if (byteOffset < yPlaneSize) {
					// This byte is in the luma plane. Find the corresponding pixel coordinates to sample from
					float y = floor(byteOffset / width);
					float x = mod(byteOffset, width);
					
					// Add 0.5 to sample the center of the texel
					vec2 sampleCoord = (vec2(x, y) + 0.5) / u_resolution;
					
					// The luma value is the alpha from the source texture
					return texture(u_sourceTexture, sampleCoord).a;
				} else {
					// Write a fixed value for chroma and beyond
					return 128.0 / 255.0;
				}
			}
			
			void main() {
				// Each fragment writes 4 bytes (R, G, B, A)
				float pixelIndex = floor(gl_FragCoord.y) * u_resolution.x + floor(gl_FragCoord.x);
				float baseByteOffset = pixelIndex * 4.0;

				vec4 result;
				for (int i = 0; i < 4; i++) {
					float currentByteOffset = baseByteOffset + float(i);
					result[i] = getByteValue(currentByteOffset);
				}
				
				fragColor = result;
			}
		`),r=this.gl.createProgram();return this.gl.attachShader(r,e),this.gl.attachShader(r,i),this.gl.linkProgram(r),r}createShader(e,i){const r=this.gl.createShader(e);return this.gl.shaderSource(r,i),this.gl.compileShader(r),this.gl.getShaderParameter(r,this.gl.COMPILE_STATUS)||console.error("Shader compile error:",this.gl.getShaderInfoLog(r)),r}createVAO(){const e=this.gl.createVertexArray();this.gl.bindVertexArray(e);const i=new Float32Array([-1,-1,0,1,1,-1,1,1,-1,1,0,0,1,1,1,0]),r=this.gl.createBuffer();this.gl.bindBuffer(this.gl.ARRAY_BUFFER,r),this.gl.bufferData(this.gl.ARRAY_BUFFER,i,this.gl.STATIC_DRAW);const n=this.gl.getAttribLocation(this.colorProgram,"a_position"),s=this.gl.getAttribLocation(this.colorProgram,"a_texCoord");return this.gl.enableVertexAttribArray(n),this.gl.vertexAttribPointer(n,2,this.gl.FLOAT,!1,16,0),this.gl.enableVertexAttribArray(s),this.gl.vertexAttribPointer(s,2,this.gl.FLOAT,!1,16,8),e}createTexture(){const e=this.gl.createTexture();return this.gl.bindTexture(this.gl.TEXTURE_2D,e),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_S,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_WRAP_T,this.gl.CLAMP_TO_EDGE),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MIN_FILTER,this.gl.LINEAR),this.gl.texParameteri(this.gl.TEXTURE_2D,this.gl.TEXTURE_MAG_FILTER,this.gl.LINEAR),e}updateTexture(e){this.lastFrame!==e&&((e.displayWidth!==this.canvas.width||e.displayHeight!==this.canvas.height)&&(this.canvas.width=e.displayWidth,this.canvas.height=e.displayHeight),this.gl.activeTexture(this.gl.TEXTURE0),this.gl.bindTexture(this.gl.TEXTURE_2D,this.sourceTexture),this.gl.texImage2D(this.gl.TEXTURE_2D,0,this.gl.RGBA,this.gl.RGBA,this.gl.UNSIGNED_BYTE,e),this.lastFrame=e)}extractColor(e){return this.updateTexture(e),this.gl.useProgram(this.colorProgram),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4),new VideoFrame(this.canvas,{timestamp:e.timestamp,duration:e.duration??void 0,alpha:"discard"})}extractAlpha(e){this.updateTexture(e),this.gl.useProgram(this.alphaProgram),this.gl.uniform2f(this.alphaResolutionLocation,this.canvas.width,this.canvas.height),this.gl.viewport(0,0,this.canvas.width,this.canvas.height),this.gl.clear(this.gl.COLOR_BUFFER_BIT),this.gl.bindVertexArray(this.vao),this.gl.drawArrays(this.gl.TRIANGLE_STRIP,0,4);const{width:i,height:r}=this.canvas,n=Math.ceil(i/2)*Math.ceil(r/2),s=i*r+n*2,o=Math.ceil(s/(i*4));let a=new Uint8Array(4*i*o);this.gl.readPixels(0,0,i,o,this.gl.RGBA,this.gl.UNSIGNED_BYTE,a),a=a.subarray(0,s),v(a[i*r]===128),v(a[a.length-1]===128);const l={format:"I420",codedWidth:i,codedHeight:r,timestamp:e.timestamp,duration:e.duration??void 0,transfer:[a.buffer]};return new VideoFrame(a,l)}close(){this.gl.getExtension("WEBGL_lose_context")?.loseContext(),this.gl=null}}class Ts extends Wi{constructor(e,i){if(!(typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement)&&!(typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas))throw new TypeError("canvas must be an HTMLCanvasElement or OffscreenCanvas.");ps(i),super(i.codec),this._encoder=new ys(this,i),this._canvas=e}add(e,i=0,r){if(!Number.isFinite(e)||e<0)throw new TypeError("timestamp must be a non-negative number.");if(!Number.isFinite(i)||i<0)throw new TypeError("duration must be a non-negative number.");const n=new Ce(this._canvas,{timestamp:e,duration:i});return this._encoder.add(n,!0,r)}_flushAndClose(e){return this._encoder.flushAndClose(e)}}class vs extends Pt{constructor(e){if(super(),this._connectedTrack=null,!$e.includes(e))throw new TypeError(`Invalid audio codec '${e}'. Must be one of: ${$e.join(", ")}.`);this._codec=e}}class Cs extends Pt{constructor(e){if(super(),this._connectedTrack=null,!qe.includes(e))throw new TypeError(`Invalid subtitle codec '${e}'. Must be one of: ${qe.join(", ")}.`);this._codec=e}}const xs=["video","audio","subtitle"],ot=t=>{if(!t||typeof t!="object")throw new TypeError("metadata must be an object.");if(t.languageCode!==void 0&&!ar(t.languageCode))throw new TypeError("metadata.languageCode, when provided, must be a three-letter, ISO 639-2/T language code.");if(t.name!==void 0&&typeof t.name!="string")throw new TypeError("metadata.name, when provided, must be a string.");if(t.disposition!==void 0&&fr(t.disposition),t.maximumPacketCount!==void 0&&(!Number.isInteger(t.maximumPacketCount)||t.maximumPacketCount<0))throw new TypeError("metadata.maximumPacketCount, when provided, must be a non-negative integer.")};let Es=class{constructor(e){if(this.state="pending",this._tracks=[],this._startPromise=null,this._cancelPromise=null,this._finalizePromise=null,this._mutex=new fi,this._metadataTags={},!e||typeof e!="object")throw new TypeError("options must be an object.");if(!(e.format instanceof zi))throw new TypeError("options.format must be an OutputFormat.");if(!(e.target instanceof Mi))throw new TypeError("options.target must be a Target.");if(e.target._output)throw new Error("Target is already used for another output.");e.target._output=this,this.format=e.format,this.target=e.target,this._writer=e.target._createWriter(),this._muxer=e.format._createMuxer(this)}addVideoTrack(e,i={}){if(!(e instanceof Wi))throw new TypeError("source must be a VideoSource.");if(ot(i),i.rotation!==void 0&&![0,90,180,270].includes(i.rotation))throw new TypeError(`Invalid video rotation: ${i.rotation}. Has to be 0, 90, 180 or 270.`);if(!this.format.supportsVideoRotationMetadata&&i.rotation)throw new Error(`${this.format._name} does not support video rotation metadata.`);if(i.frameRate!==void 0&&(!Number.isFinite(i.frameRate)||i.frameRate<=0))throw new TypeError(`Invalid video frame rate: ${i.frameRate}. Must be a positive number.`);this._addTrack("video",e,i)}addAudioTrack(e,i={}){if(!(e instanceof vs))throw new TypeError("source must be an AudioSource.");ot(i),this._addTrack("audio",e,i)}addSubtitleTrack(e,i={}){if(!(e instanceof Cs))throw new TypeError("source must be a SubtitleSource.");ot(i),this._addTrack("subtitle",e,i)}setMetadataTags(e){if(hr(e),this.state!=="pending")throw new Error("Cannot set metadata tags after output has been started or canceled.");this._metadataTags=e}_addTrack(e,i,r){if(this.state!=="pending")throw new Error("Cannot add track after output has been started or canceled.");if(i._connectedTrack)throw new Error("Source is already used for a track.");const n=this.format.getSupportedTrackCounts(),s=this._tracks.reduce((c,d)=>c+(d.type===e?1:0),0),o=n[e].max;if(s===o)throw new Error(o===0?`${this.format._name} does not support ${e} tracks.`:`${this.format._name} does not support more than ${o} ${e} track${o===1?"":"s"}.`);const a=n.total.max;if(this._tracks.length===a)throw new Error(`${this.format._name} does not support more than ${a} tracks${a===1?"":"s"} in total.`);const l={id:this._tracks.length+1,output:this,type:e,source:i,metadata:r};if(l.type==="video"){const c=this.format.getSupportedVideoCodecs();if(c.length===0)throw new Error(`${this.format._name} does not support video tracks.`+this.format._codecUnsupportedHint(l.source._codec));if(!c.includes(l.source._codec))throw new Error(`Codec '${l.source._codec}' cannot be contained within ${this.format._name}. Supported video codecs are: ${c.map(d=>`'${d}'`).join(", ")}.`+this.format._codecUnsupportedHint(l.source._codec))}else if(l.type==="audio"){const c=this.format.getSupportedAudioCodecs();if(c.length===0)throw new Error(`${this.format._name} does not support audio tracks.`+this.format._codecUnsupportedHint(l.source._codec));if(!c.includes(l.source._codec))throw new Error(`Codec '${l.source._codec}' cannot be contained within ${this.format._name}. Supported audio codecs are: ${c.map(d=>`'${d}'`).join(", ")}.`+this.format._codecUnsupportedHint(l.source._codec))}else if(l.type==="subtitle"){const c=this.format.getSupportedSubtitleCodecs();if(c.length===0)throw new Error(`${this.format._name} does not support subtitle tracks.`+this.format._codecUnsupportedHint(l.source._codec));if(!c.includes(l.source._codec))throw new Error(`Codec '${l.source._codec}' cannot be contained within ${this.format._name}. Supported subtitle codecs are: ${c.map(d=>`'${d}'`).join(", ")}.`+this.format._codecUnsupportedHint(l.source._codec))}this._tracks.push(l),i._connectedTrack=l}async start(){const e=this.format.getSupportedTrackCounts();for(const r of xs){const n=this._tracks.reduce((o,a)=>o+(a.type===r?1:0),0),s=e[r].min;if(n<s)throw new Error(s===e[r].max?`${this.format._name} requires exactly ${s} ${r} track${s===1?"":"s"}.`:`${this.format._name} requires at least ${s} ${r} track${s===1?"":"s"}.`)}const i=e.total.min;if(this._tracks.length<i)throw new Error(i===e.total.max?`${this.format._name} requires exactly ${i} track${i===1?"":"s"}.`:`${this.format._name} requires at least ${i} track${i===1?"":"s"}.`);if(this.state==="canceled")throw new Error("Output has been canceled.");return this._startPromise?(console.warn("Output has already been started."),this._startPromise):this._startPromise=(async()=>{this.state="started",this._writer.start();const r=await this._mutex.acquire();await this._muxer.start();const n=this._tracks.map(s=>s.source._start());await Promise.all(n),r()})()}getMimeType(){return this._muxer.getMimeType()}async cancel(){if(this._cancelPromise)return console.warn("Output has already been canceled."),this._cancelPromise;if(this.state==="finalizing"||this.state==="finalized"){console.warn("Output has already been finalized.");return}return this._cancelPromise=(async()=>{this.state="canceled";const e=await this._mutex.acquire(),i=this._tracks.map(r=>r.source._flushOrWaitForOngoingClose(!0));await Promise.all(i),await this._writer.close(),e()})()}async finalize(){if(this.state==="pending")throw new Error("Cannot finalize before starting.");if(this.state==="canceled")throw new Error("Cannot finalize after canceling.");return this._finalizePromise?(console.warn("Output has already been finalized."),this._finalizePromise):this._finalizePromise=(async()=>{this.state="finalizing";const e=await this._mutex.acquire(),i=this._tracks.map(r=>r.source._flushOrWaitForOngoingClose(!1));await Promise.all(i),await this._muxer.finalize(),await this._writer.flush(),await this._writer.finalize(),this.state="finalized",e()})()}};function Qt(t,e,i){const r=window.devicePixelRatio||1;t.style.width=`${e/r}px`,t.style.height=`${i/r}px`,t.width=e,t.height=i}function Ss(t,e,i){for(const r of t.query([Ue,Ze]))if(Ze.from[r]===e&&Ze.to[r]===i)return r;return null}function to(t,e){t.__recordSequence__=async(i,r)=>{const n=Ss(e,i.fromStep,i.toStep);if(n===null)return null;const s=t.width,o=t.height,a=t.style.cssText;Qt(t,i.width,i.height),await new Promise(p=>requestAnimationFrame(p)),Ue.state[n]=At.IDLE,Ue.elapsed[n]=0;for(const p of e.query([It(O.relation,n),Me]))Me.state[p]=Gi.IDLE,Me.elapsed[p]=0;Ue.state[n]=At.PLAYING;let l=0;for(const p of e.query([It(O.relation,n),Me]))l=Math.max(l,Me.duration[p]);const c=l+.1,d=Math.ceil(c*i.fps),f=new Es({format:new Oi({fastStart:"in-memory"}),target:new Fi}),g=new Ts(t,{codec:"avc",bitrate:i.bitrate});f.addVideoTrack(g),await f.start();const h=1/i.fps;for(let p=0;p<d;p++){Qt(t,i.width,i.height),e.step(h);const x=p/i.fps;await g.add(x,h),p%30===0&&(r?.(p,d),await new Promise(B=>setTimeout(B,0)))}return await f.finalize(),t.width=s,t.height=o,t.style.cssText=a,new Blob([f.target.buffer],{type:"video/mp4"})}}const Zt=2771565,_s=12093002,Ps=4175994,Bs=14440536,Ye=7041664,ve={padding:[],color:[],thickness:[],transition:[]};le(ve,{defaults:()=>({padding:.15,color:Ye,thickness:2,transition:1})});const He={},ks=.55,As={group:"simulation",update(t){for(const e of t.query([ve,ae,m])){const i=ae.content[e]??"",r=ae.fontSize[e]||1,n=ve.padding[e],s=ve.color[e],o=ve.thickness[e],a=Math.min(1,ve.transition[e]),l=i.length*r*ks,c=r,d=l/2+n,f=c/2+n;if([...t.query([P(O.relation,e),He,S])].length===0)for(let p=0;p<4;p++){const x=t.addEntity();t.addComponent(x,m),t.addComponent(x,S),t.addComponent(x,He),t.addComponent(x,P(O.relation,e)),S.color[x]=s,S.thickness[x]=o,S.visible[x]=1,S.opacity[x]=1}const h=[...t.query([P(O.relation,e),He,S])];m.posX[h[0]]=-d,m.posY[h[0]]=-f,m.posZ[h[0]]=0,S.offsetX[h[0]]=d*2*a,S.offsetY[h[0]]=0,S.offsetZ[h[0]]=0,m.posX[h[1]]=-d,m.posY[h[1]]=f,m.posZ[h[1]]=0,S.offsetX[h[1]]=d*2*a,S.offsetY[h[1]]=0,S.offsetZ[h[1]]=0,m.posX[h[2]]=-d,m.posY[h[2]]=-f,m.posZ[h[2]]=0,S.offsetX[h[2]]=0,S.offsetY[h[2]]=f*2*a,S.offsetZ[h[2]]=0,m.posX[h[3]]=d,m.posY[h[3]]=-f,m.posZ[h[3]]=0,S.offsetX[h[3]]=0,S.offsetY[h[3]]=f*2*a,S.offsetZ[h[3]]=0}}},io={components:{Border:ve,BorderLine:He},systems:[As]},R={barCount:[],transition:[],blend:[],smoothness:[],comparisonTransition:[],comparisonZ:[],acceptanceTransition:[],acceptanceYOffset:[],acceptanceSize:[],residualTransition:[],minTransition:[],excessDraftTransition:[],excessTargetTransition:[],transferProgress:[]};le(R,{defaults:()=>({barCount:5,transition:1,blend:0,smoothness:.15,comparisonTransition:0,comparisonZ:-.6,acceptanceTransition:0,acceptanceYOffset:.5,acceptanceSize:.35,residualTransition:0,minTransition:0,excessDraftTransition:0,excessTargetTransition:0,transferProgress:0})});const Q={index:[],probability:[],goalProbability:[]};le(Q,{defaults:()=>({index:0,probability:.2,goalProbability:.2})});const ht=ue("distribution-bar-owner",{exclusive:!0}),Kt=ue("comparison-bar-owner",{exclusive:!0}),Jt=ue("acceptance-marker-owner",{exclusive:!0}),ei=ue("residual-bar-owner",{exclusive:!0}),ti=ue("min-bar-owner",{exclusive:!0}),ii=ue("excess-draft-bar-owner",{exclusive:!0}),ri=ue("excess-target-bar-owner",{exclusive:!0}),Re={index:[]};le(Re,{defaults:()=>({index:0})});const ke={distribution:[],barIndex:[],yOffset:[]};le(ke,{defaults:()=>({distribution:0,barIndex:0,yOffset:.7})});const Ni=new Map,Ui=new Map;function ro(t,e,i){Ni.set(t,e),i&&Ui.set(t,i)}function ft(t,e,i){const r=t>>16&255,n=t>>8&255,s=t&255,o=e>>16&255,a=e>>8&255,l=e&255,c=Math.round(r+(o-r)*i),d=Math.round(n+(a-n)*i),f=Math.round(s+(l-s)*i);return c<<16|d<<8|f}const Is=14440536,ni=15048768,Ms=4175994;function Fs(t){return t<.9?ft(Is,ni,t/.9):ft(ni,Ms,(t-.9)/.1)}const je=8,se=5.5;function zs(t,e){const i=Math.max(0,Math.min(1,t));return 1-Math.pow(1-i,e*60)}const Rs={group:"simulation",update(t){const e=t.time.deltaTime;for(const i of t.query([R,m])){const r=R.barCount[i],n=R.transition[i],s=R.blend[i],o=R.smoothness[i],a=R.comparisonTransition[i],l=R.comparisonZ[i],c=[...t.query([P(ht.relation,i),Q,T,m])];for(;c.length<r;){const u=t.addEntity();t.addComponent(u,m),t.addComponent(u,T),t.addComponent(u,Q),t.addComponent(u,P(O.relation,i)),t.addComponent(u,P(ht.relation,i)),T.shape[u]=be.Box,Q.index[u]=c.length,c.push(u)}const d=je/r,f=d*.7,g=-je/2+d/2,h=Ni.get(i),p=Ui.get(i),x=zs(o,e),B=ft(Zt,_s,s);for(let u=0;u<r;u++){const b=c[u],I=h&&h.length>u?h[u]:.2,F=p&&p.length>u?p[u]:I,Y=I+(F-I)*s;Q.goalProbability[b]=Y,Q.probability[b]+=(Y-Q.probability[b])*x;const H=Q.probability[b],J=Math.max(.05,H*se);m.posX[b]=g+u*d,m.posY[b]=J/2*n,m.posZ[b]=0,T.sizeX[b]=f*n,T.sizeY[b]=J*n,T.sizeZ[b]=f*n,T.color[b]=B}const _=[...t.query([P(Kt.relation,i),T,m])];if(a>0){for(;_.length<r;){const u=t.addEntity();t.addComponent(u,m),t.addComponent(u,T),t.addComponent(u,P(O.relation,i)),t.addComponent(u,P(Kt.relation,i)),T.shape[u]=be.Box,_.push(u)}for(let u=0;u<r;u++){const b=_[u],I=h&&h.length>u?h[u]:.2,F=Math.max(.05,I*se);m.posX[b]=g+u*d,m.posY[b]=F/2*a,m.posZ[b]=l,T.sizeX[b]=f*a,T.sizeY[b]=F*a,T.sizeZ[b]=f*a,T.color[b]=Zt}}else for(const u of _)T.sizeX[u]=0,T.sizeY[u]=0,T.sizeZ[u]=0;const D=R.acceptanceTransition[i],N=R.acceptanceYOffset[i],he=R.acceptanceSize[i],X=[...t.query([P(Jt.relation,i),Re,T,m])];if(D>0){for(;X.length<r;){const u=t.addEntity();t.addComponent(u,m),t.addComponent(u,T),t.addComponent(u,Re),t.addComponent(u,P(O.relation,i)),t.addComponent(u,P(Jt.relation,i)),T.shape[u]=be.Sphere,Re.index[u]=X.length,X.push(u)}for(let u=0;u<r;u++){const b=X[u],I=h&&h.length>u?h[u]:.2,F=p&&p.length>u?p[u]:I,Y=Math.max(I,F)*se,H=F>0?Math.min(1,I/F):1;m.posX[b]=g+u*d,m.posY[b]=Y+N,m.posZ[b]=l/2;const J=he*D;T.sizeX[b]=J,T.sizeY[b]=J,T.sizeZ[b]=J,T.color[b]=Fs(H)}}else for(const u of X)T.sizeX[u]=0,T.sizeY[u]=0,T.sizeZ[u]=0;const ie=R.residualTransition[i],j=[...t.query([P(ei.relation,i),T,m])];if(ie>0){for(;j.length<r;){const u=t.addEntity();t.addComponent(u,m),t.addComponent(u,T),t.addComponent(u,P(O.relation,i)),t.addComponent(u,P(ei.relation,i)),T.shape[u]=be.Box,j.push(u)}for(let u=0;u<r;u++){const b=j[u],I=h&&h.length>u?h[u]:.2,F=p&&p.length>u?p[u]:I,Y=Math.max(0,I-F);if(Y<=.001){T.sizeX[b]=0,T.sizeY[b]=0,T.sizeZ[b]=0;continue}const H=Y*se*ie;m.posX[b]=g+u*d,m.posY[b]=H/2,m.posZ[b]=0,T.sizeX[b]=f*ie,T.sizeY[b]=H,T.sizeZ[b]=f*ie,T.color[b]=9647082}}else for(const u of j)T.sizeX[u]=0,T.sizeY[u]=0,T.sizeZ[u]=0;const $=R.minTransition[i],pe=[...t.query([P(ti.relation,i),T,m])];if($>0){for(;pe.length<r;){const u=t.addEntity();t.addComponent(u,m),t.addComponent(u,T),t.addComponent(u,P(O.relation,i)),t.addComponent(u,P(ti.relation,i)),T.shape[u]=be.Box,pe.push(u)}for(let u=0;u<r;u++){const b=pe[u],I=h&&h.length>u?h[u]:.2,F=p&&p.length>u?p[u]:I,Y=Math.min(I,F),H=Math.max(.05,Y*se*$);m.posX[b]=g+u*d,m.posY[b]=H/2,m.posZ[b]=0,T.sizeX[b]=f*$,T.sizeY[b]=H,T.sizeZ[b]=f*$,T.color[b]=Ps}}else for(const u of pe)T.sizeX[u]=0,T.sizeY[u]=0,T.sizeZ[u]=0;const q=R.excessDraftTransition[i],M=R.transferProgress[i],U=[...t.query([P(ii.relation,i),T,m])];if(q>0){for(;U.length<r;){const u=t.addEntity();t.addComponent(u,m),t.addComponent(u,T),t.addComponent(u,P(O.relation,i)),t.addComponent(u,P(ii.relation,i)),T.shape[u]=be.Box,U.push(u)}for(let u=0;u<r;u++){const b=U[u],I=h&&h.length>u?h[u]:.2,F=p&&p.length>u?p[u]:I,Y=Math.min(I,F),H=Math.max(0,F-I);if(H<=.001){T.sizeX[b]=0,T.sizeY[b]=0,T.sizeZ[b]=0;continue}const J=1-M,Ie=H*se*q*J,Qe=Y*se,kt=f*q*J;m.posX[b]=g+u*d,m.posY[b]=Qe+Ie/2,m.posZ[b]=0,T.sizeX[b]=kt,T.sizeY[b]=Ie,T.sizeZ[b]=kt,T.color[b]=Bs}}else for(const u of U)T.sizeX[u]=0,T.sizeY[u]=0,T.sizeZ[u]=0;const G=R.excessTargetTransition[i],V=[...t.query([P(ri.relation,i),T,m])];if(G>0){for(;V.length<r;){const u=t.addEntity();t.addComponent(u,m),t.addComponent(u,T),t.addComponent(u,P(O.relation,i)),t.addComponent(u,P(ri.relation,i)),T.shape[u]=be.Box,V.push(u)}for(let u=0;u<r;u++){const b=V[u],I=h&&h.length>u?h[u]:.2,F=p&&p.length>u?p[u]:I,Y=Math.min(I,F),H=Math.max(0,I-F);if(H<=.001){T.sizeX[b]=0,T.sizeY[b]=0,T.sizeZ[b]=0;continue}const J=M,Ie=H*se*G*J,Qe=Y*se;m.posX[b]=g+u*d,m.posY[b]=Qe+Ie/2,m.posZ[b]=0,T.sizeX[b]=f*G,T.sizeY[b]=Ie,T.sizeZ[b]=f*G,T.color[b]=9647082}}else for(const u of V)T.sizeX[u]=0,T.sizeY[u]=0,T.sizeZ[u]=0}}},Os={group:"simulation",update(t){for(const e of t.query([ke,m])){const i=ke.distribution[e],r=ke.barIndex[e],n=ke.yOffset[e];if(!t.hasComponent(i,R))continue;const s=R.barCount[i],a=[...t.query([P(ht.relation,i),Q])].find(h=>Q.index[h]===r);if(a===void 0)continue;const l=Q.probability[a],c=je/s,f=-je/2+c/2+r*c,g=l*se;m.posX[e]=f,m.posY[e]=.5+g+n}}},no={components:{ProbabilityDistribution:R,DistributionBar:Q,BarHighlight:ke,AcceptanceMarker:Re},systems:[Rs,Os]},Hi={data:new Float32Array(De*4)};function at(t){const e=Hi.data;function i(n){return e[n*4+t]}function r(n,s){e[n*4+t]=s}return new Proxy([],{get(n,s){if(s==="get")return i;if(s==="set")return r;const o=Number(s);if(!Number.isNaN(o))return i(o)},set(n,s,o){const a=Number(s);return Number.isNaN(a)?!1:(r(a,o),!0)}})}const xe={transition:at(0),width:at(1),height:at(2)};le(xe,{defaults:()=>({transition:0,width:.5,height:5}),accessors:{transition:xe.transition,width:xe.width,height:xe.height}});const Ls=`
struct VertexOutput {
  @builtin(position) position: vec4<f32>,
  @location(0) uv: vec2<f32>,
  @location(1) transition: f32,
}

struct Scene {
  viewProj: mat4x4<f32>,
  cameraWorld: mat4x4<f32>,
  ambientColor: vec4<f32>,
  sunDirection: vec4<f32>,
  sunColor: vec4<f32>,
  cameraMode: f32,
  cameraSize: f32,
  viewport: vec2<f32>,
}

struct LegendData {
  transition: f32,
  width: f32,
  height: f32,
  _pad: f32,
}

@group(0) @binding(0) var<uniform> scene: Scene;
@group(0) @binding(1) var<storage, read> entityIds: array<u32>;
@group(0) @binding(2) var<storage, read> legends: array<LegendData>;
@group(0) @binding(3) var<storage, read> matrices: array<mat4x4<f32>>;

@vertex
fn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VertexOutput {
  let eid = entityIds[iid];
  let legend = legends[eid];
  let transform = matrices[eid];

  let halfW = legend.width * 0.5 * legend.transition;
  let halfH = legend.height * 0.5 * legend.transition;

  var localPos: vec2<f32>;
  var uv: vec2<f32>;
  switch vid {
    case 0u: { localPos = vec2(-halfW, -halfH); uv = vec2(0.0, 0.0); }
    case 1u: { localPos = vec2(halfW, -halfH); uv = vec2(1.0, 0.0); }
    case 2u: { localPos = vec2(halfW, halfH); uv = vec2(1.0, 1.0); }
    case 3u: { localPos = vec2(-halfW, -halfH); uv = vec2(0.0, 0.0); }
    case 4u: { localPos = vec2(halfW, halfH); uv = vec2(1.0, 1.0); }
    case 5u: { localPos = vec2(-halfW, halfH); uv = vec2(0.0, 1.0); }
    default: { localPos = vec2(0.0, 0.0); uv = vec2(0.0, 0.0); }
  }

  let worldPos = transform[3].xyz + vec3(localPos, 0.0);
  let clipPos = scene.viewProj * vec4(worldPos, 1.0);

  var out: VertexOutput;
  out.position = clipPos;
  out.uv = uv;
  out.transition = legend.transition;
  return out;
}

struct FragmentOutput {
  @location(0) color: vec4<f32>,
  @location(1) mask: f32,
}

@fragment
fn fs(input: VertexOutput) -> FragmentOutput {
  let t = input.uv.y;

  // Nonlinear: Red -> Yellow at 90%, Yellow -> Green in top 10%
  var color: vec3<f32>;
  let red = vec3(0.863, 0.345, 0.345);
  let yellow = vec3(0.898, 0.627, 0.251);
  let green = vec3(0.247, 0.722, 0.478);
  if (t < 0.9) {
    color = mix(red, yellow, t / 0.9);
  } else {
    color = mix(yellow, green, (t - 0.9) / 0.1);
  }

  var out: FragmentOutput;
  out.color = vec4(color, input.transition);
  out.mask = select(0.0, 1.0, input.transition > 0.01);
  return out;
}
`;function Vs(t,e,i){const r=t.createShaderModule({code:Ls});return t.createRenderPipeline({layout:"auto",vertex:{module:r,entryPoint:"vs"},fragment:{module:r,entryPoint:"fs",targets:[{format:e,blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha",operation:"add"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha",operation:"add"}}},{format:i,writeMask:GPUColorWrite.RED}]},primitive:{topology:"triangle-list"},depthStencil:{format:tr,depthCompare:"less",depthWriteEnabled:!1}})}function Ws(t){let e=null,i=null;return{id:"gradient-legend",order:1,draw(r,n){e||(e=Vs(n.device,n.format,n.maskFormat)),i||(i=n.device.createBindGroup({layout:e.getBindGroupLayout(0),entries:[{binding:0,resource:{buffer:t.scene}},{binding:1,resource:{buffer:t.entityIds}},{binding:2,resource:{buffer:t.legends}},{binding:3,resource:{buffer:t.matrices}}]}));const s=t.getCount();s!==0&&(r.setPipeline(e),r.setBindGroup(0,i),r.draw(6,s))}}}const Di=Yi("gradient-legends"),si=new Uint32Array(De),Ns={group:"draw",update(t){const e=ui.from(t),i=Di.from(t);if(!e||!i)return;const{device:r}=e;let n=0;for(const s of t.query([xe,m]))xe.transition[s]<=0||(si[n++]=s);r.queue.writeBuffer(i.buffer,0,Hi.data),r.queue.writeBuffer(i.entityIds,0,si,0,n),i.count=n}},so={systems:[Ns],components:{GradientLegend:xe},dependencies:[Qi,Zi],initialize(t){const e=ui.from(t),i=Ki.from(t);if(!e||!i)return;const{device:r}=e,n={buffer:r.createBuffer({label:"gradient-legends",size:De*4*4,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST}),entityIds:Ji(r,De),count:0};t.setResource(Di,n),er(t,Ws({scene:i.scene,legends:n.buffer,entityIds:n.entityIds,matrices:i.matrices,getCount:()=>n.count}))}},Ge={trigger:[]};le(Ge,{defaults:()=>({trigger:0})});const $i=new Map;function oo(t,e,i){$i.set(t,{original:e,replacement:i})}const Ve={active:[],lineTransition:[]};le(Ve,{defaults:()=>({active:0,lineTransition:1})});const Us={},qi={},Xi={},K={index:[],transition:[]};le(K,{defaults:()=>({index:0,transition:1})});const ji={},mt={},Hs={valid:[],transition:[]};le(Hs,{defaults:()=>({valid:1,transition:0})});const oi=-4,Ds=.55,ct=.7,$s=1.4,Bt=2;function ai(t,e){for(const i of t.query([P(O.relation,e),ae])){const r=ae.content[i]??"",n=ae.fontSize[i]||1;return r.length*n*Ds}return 1}const qs={group:"simulation",update(t){for(const e of t.query([K,m])){const i=K.transition[e];m.scaleX[e]=i,m.scaleY[e]=i,m.scaleZ[e]=i}}},Xs={group:"simulation",update(t){for(const e of t.query([Ve,m])){const i=[...t.query([P(O.relation,e),K,m])];if(i.length===0)continue;i.sort((l,c)=>K.index[l]-K.index[c]);const r=i.filter(l=>!t.hasComponent(l,mt)),n=i.filter(l=>t.hasComponent(l,mt)),s=r.map(l=>ai(t,l)),o=s.reduce((l,c)=>l+c,0)+ct*Math.max(0,r.length-1);let a=-o/2;for(let l=0;l<r.length;l++){const c=r[l],d=s[l];m.posX[c]=a+d/2,m.posY[c]=0,m.posZ[c]=oi,a+=d+ct}a=o/2+$s;for(let l=0;l<n.length;l++){const c=n[l],d=ai(t,c);m.posX[c]=a+d/2,m.posY[c]=0,m.posZ[c]=oi,a+=d+ct}}}},pt={},ci=ue("network-line-target",{exclusive:!0}),js={group:"simulation",update(t){for(const e of t.query([Ve,m])){const i=Ve.lineTransition[e];for(const r of t.query([P(O.relation,e),K,m])){const n=[...t.query([P(ci.relation,r),pt,S])];let s;n.length===0?(s=t.addEntity(),t.addComponent(s,m),t.addComponent(s,S),t.addComponent(s,Z),t.addComponent(s,pt),t.addComponent(s,P(O.relation,e)),t.addComponent(s,P(ci.relation,r)),S.color[s]=Ye,S.thickness[s]=Bt,S.visible[s]=1,Z.start[s]=0,Z.end[s]=1,Z.size[s]=1):s=n[0];const o=m.posX[r],a=m.posY[r],l=m.posZ[r],c=Math.min(1,K.transition[r]);S.offsetX[s]=o*c,S.offsetY[s]=a*c,S.offsetZ[s]=l*c,S.opacity[s]=i}}}},gt={},di=ue("latent-arrow-owner",{exclusive:!0}),wt={},li=ue("validation-line-target",{exclusive:!0}),Gs={group:"simulation",update(t){for(const e of t.query([K,m])){const i=[...t.query([P(O.relation,e),ji,m])];if(i.length===0)continue;const r=i[0],n=[...t.query([P(di.relation,e),gt,S])];let s;n.length===0?(s=t.addEntity(),t.addComponent(s,m),t.addComponent(s,S),t.addComponent(s,Z),t.addComponent(s,gt),t.addComponent(s,P(O.relation,e)),t.addComponent(s,P(di.relation,e)),S.color[s]=Ye,S.thickness[s]=Bt,S.visible[s]=1,S.opacity[s]=1,Z.start[s]=0,Z.end[s]=1,Z.size[s]=1):s=n[0];const o=m.posZ[r]-3.5;m.posX[s]=0,m.posY[s]=0,m.posZ[s]=o,S.offsetX[s]=0,S.offsetY[s]=0,S.offsetZ[s]=-.8}}},Ys={group:"simulation",update(t){for(const e of t.query([Xi,m])){const i=m.scaleX[e];if(!(i<.01))for(const r of t.query([qi,m])){const n=[...t.query([P(O.relation,r),K,m])];if(n.length===0)continue;const s=m.posX[r],o=m.posY[r],a=m.posZ[r];for(const l of n){const c=Math.max(0,Math.min(1,K.transition[l])),d=[...t.query([P(li.relation,l),wt,S])];let f;if(d.length===0?(f=t.addEntity(),t.addComponent(f,m),t.addComponent(f,S),t.addComponent(f,Z),t.addComponent(f,wt),t.addComponent(f,P(li.relation,l)),S.color[f]=Ye,S.thickness[f]=Bt,S.visible[f]=1,Z.start[f]=0,Z.end[f]=1,Z.size[f]=1):f=d[0],c<.01){S.opacity[f]=0;continue}const g=m.posX[l],h=m.posZ[l],p=s+g*c,x=o,B=a+h*c,_=m.posX[e],D=m.posY[e],N=m.posZ[e];m.posX[f]=_,m.posY[f]=D,m.posZ[f]=N,S.offsetX[f]=(p-_)*i,S.offsetY[f]=(x-D)*i,S.offsetZ[f]=(B-N)*i,S.opacity[f]=i*c}}}}},Qs={group:"simulation",update(t){for(const e of t.query([Ge,ae])){const i=Ge.trigger[e],r=$i.get(e);if(!r)continue;const n=ae.content[e]??"",{original:s,replacement:o}=r;i>.5&&n!==o&&o?ae.content[e]=o:i<=.5&&n!==s&&s&&(ae.content[e]=s)}}},ao={components:{Network:Ve,TargetModel:Us,DraftModel:qi,ValidationModel:Xi,Slot:K,Latent:ji,Output:mt,NetworkLine:pt,LatentArrow:gt,ValidationLine:wt,TokenReplacement:Ge},systems:[qs,Xs,js,Gs,Ys,Qs]};export{io as B,so as G,no as P,ao as S,Ge as T,Js as a,R as b,ke as c,ro as d,oo as e,Ks as f,to as s};
//# sourceMappingURL=index-CjkBKNG3.js.map
