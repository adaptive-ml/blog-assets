{"version":3,"file":"index-D5b1YJF_.js","sources":["../../src/colors.ts","../../src/border.ts","../../src/probability-distribution.ts","../../src/gradient-legend.ts","../../src/index.ts"],"sourcesContent":["// Speculative Decoding Color Scheme\n// Scientific visualization palette with warm/cool semantic distinction\n\n// === MODEL PAIR (Complementary: Navy vs Amber) ===\n// Target: Cool navy = slow, authoritative, \"ground truth\"\n// Draft: Warm amber = fast, speculative, \"educated guess\"\nexport const TARGET_MODEL = 0x2a4a6d; // Deep navy (H≈210)\nexport const DRAFT_MODEL = 0xb8864a;  // Warm amber (H≈35) - distinct hue\n\n// === DATA PAIR (Teal/Green family, H≈155-180) ===\n// Input: teal, Output: green-teal (shows transformation)\nexport const INPUT = 0x6b9ea0;        // Muted teal (H≈182)\nexport const INPUT_TEXT = 0x4a7072;   // Darker teal for readability\n\nexport const OUTPUT = 0x5aaa8f;       // Green-teal (H≈155) - \"generated\"\nexport const OUTPUT_TEXT = 0x3d7560;  // Darker green for readability\n\n// === DISTRIBUTION ANALYSIS ===\nexport const MIN_REGION = 0x14b8a6;  // Teal - common ground between draft/target\n\n// === VALIDATION ===\nexport const VALID = 0x3fb87a;       // Soft sage-green - correct prediction\nexport const INVALID = 0xdc5858;     // Soft coral - incorrect prediction\n\n// === SUPPORTING ===\nexport const LINE = 0x6b7280;\nexport const LINE_ACTIVE = 0x4b5563;\nexport const SURFACE = 0xffffff;\nexport const SURFACE_ALT = 0xf8f9fa;\nexport const TEXT = 0x212529;\n\n// Hex string versions for CSS\nexport const hex = {\n  targetModel: '#2a4a6d',\n  draftModel: '#b8864a',\n  input: '#6b9ea0',\n  inputText: '#4a7072',\n  output: '#5aaa8f',\n  outputText: '#3d7560',\n  minRegion: '#14b8a6',\n  line: '#6b7280',\n  lineActive: '#4b5563',\n  surface: '#ffffff',\n  surfaceAlt: '#f8f9fa',\n  text: '#212529',\n} as const;\n","import { setTraits, ChildOf, Pair, Transform, type Plugin, type State, type System } from '@multiplekex/shallot';\nimport { Line, Text } from '@multiplekex/shallot/extras';\nimport { LINE } from './colors';\n\nexport const Border = {\n  padding: [] as number[],\n  color: [] as number[],\n  thickness: [] as number[],\n  transition: [] as number[],\n};\n\nsetTraits(Border, {\n  defaults: () => ({\n    padding: 0.15,\n    color: LINE,\n    thickness: 2,\n    transition: 1,\n  }),\n});\n\nexport const BorderLine = {};\n\nconst CHAR_WIDTH_RATIO = 0.55;\n\nconst BorderSystem: System = {\n  group: 'simulation',\n  update(state: State) {\n    for (const eid of state.query([Border, Text, Transform])) {\n      const content = Text.content[eid] ?? '';\n      const fontSize = Text.fontSize[eid] || 1;\n      const padding = Border.padding[eid];\n      const color = Border.color[eid];\n      const thickness = Border.thickness[eid];\n      const t = Math.min(1, Border.transition[eid]);\n\n      const textWidth = content.length * fontSize * CHAR_WIDTH_RATIO;\n      const textHeight = fontSize;\n\n      const w = textWidth / 2 + padding;\n      const h = textHeight / 2 + padding;\n\n      const existingLines = [...state.query([Pair(ChildOf.relation, eid), BorderLine, Line])];\n\n      if (existingLines.length === 0) {\n        for (let i = 0; i < 4; i++) {\n          const lineEid = state.addEntity();\n          state.addComponent(lineEid, Transform);\n          state.addComponent(lineEid, Line);\n          state.addComponent(lineEid, BorderLine);\n          state.addComponent(lineEid, Pair(ChildOf.relation, eid));\n\n          Line.color[lineEid] = color;\n          Line.thickness[lineEid] = thickness;\n          Line.visible[lineEid] = 1;\n          Line.opacity[lineEid] = 1;\n        }\n      }\n\n      const lines = [...state.query([Pair(ChildOf.relation, eid), BorderLine, Line])];\n\n      // Bottom line (local coords relative to parent)\n      Transform.posX[lines[0]] = -w;\n      Transform.posY[lines[0]] = -h;\n      Transform.posZ[lines[0]] = 0;\n      Line.offsetX[lines[0]] = w * 2 * t;\n      Line.offsetY[lines[0]] = 0;\n      Line.offsetZ[lines[0]] = 0;\n\n      // Top line\n      Transform.posX[lines[1]] = -w;\n      Transform.posY[lines[1]] = h;\n      Transform.posZ[lines[1]] = 0;\n      Line.offsetX[lines[1]] = w * 2 * t;\n      Line.offsetY[lines[1]] = 0;\n      Line.offsetZ[lines[1]] = 0;\n\n      // Left line\n      Transform.posX[lines[2]] = -w;\n      Transform.posY[lines[2]] = -h;\n      Transform.posZ[lines[2]] = 0;\n      Line.offsetX[lines[2]] = 0;\n      Line.offsetY[lines[2]] = h * 2 * t;\n      Line.offsetZ[lines[2]] = 0;\n\n      // Right line\n      Transform.posX[lines[3]] = w;\n      Transform.posY[lines[3]] = -h;\n      Transform.posZ[lines[3]] = 0;\n      Line.offsetX[lines[3]] = 0;\n      Line.offsetY[lines[3]] = h * 2 * t;\n      Line.offsetZ[lines[3]] = 0;\n    }\n  },\n};\n\nexport const BorderPlugin: Plugin = {\n  components: { Border, BorderLine },\n  systems: [BorderSystem],\n};\n","import { setTraits, ChildOf, Pair, Transform, Mesh, MeshShape, defineRelation, type Plugin, type State, type System } from '@multiplekex/shallot';\nimport { TARGET_MODEL, DRAFT_MODEL, VALID, INVALID } from './colors';\n\nexport const ProbabilityDistribution = {\n  barCount: [] as number[],\n  transition: [] as number[],\n  blend: [] as number[],\n  smoothness: [] as number[],\n  comparisonTransition: [] as number[],\n  comparisonZ: [] as number[],\n  acceptanceTransition: [] as number[],\n  acceptanceYOffset: [] as number[],\n  acceptanceSize: [] as number[],\n  residualTransition: [] as number[],\n  minTransition: [] as number[],\n  excessDraftTransition: [] as number[],\n  excessTargetTransition: [] as number[],\n  transferProgress: [] as number[],\n};\n\nsetTraits(ProbabilityDistribution, {\n  defaults: () => ({\n    barCount: 5,\n    transition: 1,\n    blend: 0,\n    smoothness: 0.15,\n    comparisonTransition: 0,\n    comparisonZ: -0.6,\n    acceptanceTransition: 0,\n    acceptanceYOffset: 0.5,\n    acceptanceSize: 0.35,\n    residualTransition: 0,\n    minTransition: 0,\n    excessDraftTransition: 0,\n    excessTargetTransition: 0,\n    transferProgress: 0,\n  }),\n});\n\nexport const DistributionBar = {\n  index: [] as number[],\n  probability: [] as number[],\n  goalProbability: [] as number[],\n};\n\nsetTraits(DistributionBar, {\n  defaults: () => ({\n    index: 0,\n    probability: 0.2,\n    goalProbability: 0.2,\n  }),\n});\n\nconst DistributionBarOwner = defineRelation('distribution-bar-owner', { exclusive: true });\nconst ComparisonBarOwner = defineRelation('comparison-bar-owner', { exclusive: true });\nconst AcceptanceMarkerOwner = defineRelation('acceptance-marker-owner', { exclusive: true });\nconst ResidualBarOwner = defineRelation('residual-bar-owner', { exclusive: true });\nconst MinBarOwner = defineRelation('min-bar-owner', { exclusive: true });\nconst ExcessDraftBarOwner = defineRelation('excess-draft-bar-owner', { exclusive: true });\nconst ExcessTargetBarOwner = defineRelation('excess-target-bar-owner', { exclusive: true });\n\nexport const AcceptanceMarker = {\n  index: [] as number[],\n};\n\nsetTraits(AcceptanceMarker, {\n  defaults: () => ({\n    index: 0,\n  }),\n});\n\nexport const BarHighlight = {\n  distribution: [] as number[],\n  barIndex: [] as number[],\n  yOffset: [] as number[],\n};\n\nsetTraits(BarHighlight, {\n  defaults: () => ({\n    distribution: 0,\n    barIndex: 0,\n    yOffset: 0.7,\n  }),\n});\n\nconst targetDistributions = new Map<number, number[]>();\nconst draftDistributions = new Map<number, number[]>();\n\nexport function setDistributionProbabilities(distEid: number, targetProbs: number[], draftProbs?: number[]): void {\n  targetDistributions.set(distEid, targetProbs);\n  if (draftProbs) {\n    draftDistributions.set(distEid, draftProbs);\n  }\n}\n\nfunction lerpColor(c1: number, c2: number, t: number): number {\n  const r1 = (c1 >> 16) & 0xff;\n  const g1 = (c1 >> 8) & 0xff;\n  const b1 = c1 & 0xff;\n  const r2 = (c2 >> 16) & 0xff;\n  const g2 = (c2 >> 8) & 0xff;\n  const b2 = c2 & 0xff;\n  const r = Math.round(r1 + (r2 - r1) * t);\n  const g = Math.round(g1 + (g2 - g1) * t);\n  const b = Math.round(b1 + (b2 - b1) * t);\n  return (r << 16) | (g << 8) | b;\n}\n\nconst RED = 0xdc5858;\nconst YELLOW = 0xe5a040;\nconst GREEN = 0x3fb87a;\n\nfunction acceptanceColor(acceptance: number): number {\n  // Nonlinear: yellow at 90%, making lower acceptance more obvious\n  if (acceptance < 0.9) {\n    return lerpColor(RED, YELLOW, acceptance / 0.9);\n  } else {\n    return lerpColor(YELLOW, GREEN, (acceptance - 0.9) / 0.1);\n  }\n}\n\nconst CHART_WIDTH = 8;\nconst MAX_HEIGHT = 5.5;\n\nfunction smoothLerp(smoothness: number, dt: number): number {\n  const s = Math.max(0, Math.min(1, smoothness));\n  return 1 - Math.pow(1 - s, dt * 60);\n}\n\nconst ProbabilityDistributionSystem: System = {\n  group: 'simulation',\n  update(state: State) {\n    const dt = state.time.deltaTime;\n\n    for (const distEid of state.query([ProbabilityDistribution, Transform])) {\n      const barCount = ProbabilityDistribution.barCount[distEid];\n      const transition = ProbabilityDistribution.transition[distEid];\n      const blend = ProbabilityDistribution.blend[distEid];\n      const smoothness = ProbabilityDistribution.smoothness[distEid];\n      const comparisonTransition = ProbabilityDistribution.comparisonTransition[distEid];\n      const comparisonZ = ProbabilityDistribution.comparisonZ[distEid];\n\n      const existingBars = [...state.query([Pair(DistributionBarOwner.relation, distEid), DistributionBar, Mesh, Transform])];\n\n      while (existingBars.length < barCount) {\n        const barEid = state.addEntity();\n        state.addComponent(barEid, Transform);\n        state.addComponent(barEid, Mesh);\n        state.addComponent(barEid, DistributionBar);\n        state.addComponent(barEid, Pair(ChildOf.relation, distEid));\n        state.addComponent(barEid, Pair(DistributionBarOwner.relation, distEid));\n\n        Mesh.shape[barEid] = MeshShape.Box;\n        DistributionBar.index[barEid] = existingBars.length;\n        existingBars.push(barEid);\n      }\n\n      const barSpacing = CHART_WIDTH / barCount;\n      const barWidth = barSpacing * 0.7;\n      const startX = -CHART_WIDTH / 2 + barSpacing / 2;\n\n      const targetProbs = targetDistributions.get(distEid);\n      const draftProbs = draftDistributions.get(distEid);\n      const t = smoothLerp(smoothness, dt);\n      const color = lerpColor(TARGET_MODEL, DRAFT_MODEL, blend);\n\n      for (let i = 0; i < barCount; i++) {\n        const barEid = existingBars[i];\n\n        const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\n        const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\n        const goalP = targetP + (draftP - targetP) * blend;\n\n        DistributionBar.goalProbability[barEid] = goalP;\n        DistributionBar.probability[barEid] += (goalP - DistributionBar.probability[barEid]) * t;\n\n        const probability = DistributionBar.probability[barEid];\n        const height = Math.max(0.05, probability * MAX_HEIGHT);\n\n        Transform.posX[barEid] = startX + i * barSpacing;\n        Transform.posY[barEid] = (height / 2) * transition;\n        Transform.posZ[barEid] = 0;\n\n        Mesh.sizeX[barEid] = barWidth * transition;\n        Mesh.sizeY[barEid] = height * transition;\n        Mesh.sizeZ[barEid] = barWidth * transition;\n\n        Mesh.color[barEid] = color;\n      }\n\n      const existingComparisonBars = [...state.query([Pair(ComparisonBarOwner.relation, distEid), Mesh, Transform])];\n\n      if (comparisonTransition > 0) {\n        while (existingComparisonBars.length < barCount) {\n          const barEid = state.addEntity();\n          state.addComponent(barEid, Transform);\n          state.addComponent(barEid, Mesh);\n          state.addComponent(barEid, Pair(ChildOf.relation, distEid));\n          state.addComponent(barEid, Pair(ComparisonBarOwner.relation, distEid));\n          Mesh.shape[barEid] = MeshShape.Box;\n          existingComparisonBars.push(barEid);\n        }\n\n        for (let i = 0; i < barCount; i++) {\n          const compBarEid = existingComparisonBars[i];\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\n          const height = Math.max(0.05, targetP * MAX_HEIGHT);\n\n          Transform.posX[compBarEid] = startX + i * barSpacing;\n          Transform.posY[compBarEid] = (height / 2) * comparisonTransition;\n          Transform.posZ[compBarEid] = comparisonZ;\n\n          Mesh.sizeX[compBarEid] = barWidth * comparisonTransition;\n          Mesh.sizeY[compBarEid] = height * comparisonTransition;\n          Mesh.sizeZ[compBarEid] = barWidth * comparisonTransition;\n\n          Mesh.color[compBarEid] = TARGET_MODEL;\n        }\n      } else {\n        for (const compBarEid of existingComparisonBars) {\n          Mesh.sizeX[compBarEid] = 0;\n          Mesh.sizeY[compBarEid] = 0;\n          Mesh.sizeZ[compBarEid] = 0;\n        }\n      }\n\n      const acceptanceTransition = ProbabilityDistribution.acceptanceTransition[distEid];\n      const acceptanceYOffset = ProbabilityDistribution.acceptanceYOffset[distEid];\n      const acceptanceSize = ProbabilityDistribution.acceptanceSize[distEid];\n\n      const existingMarkers = [...state.query([Pair(AcceptanceMarkerOwner.relation, distEid), AcceptanceMarker, Mesh, Transform])];\n\n      if (acceptanceTransition > 0) {\n        while (existingMarkers.length < barCount) {\n          const markerEid = state.addEntity();\n          state.addComponent(markerEid, Transform);\n          state.addComponent(markerEid, Mesh);\n          state.addComponent(markerEid, AcceptanceMarker);\n          state.addComponent(markerEid, Pair(ChildOf.relation, distEid));\n          state.addComponent(markerEid, Pair(AcceptanceMarkerOwner.relation, distEid));\n          Mesh.shape[markerEid] = MeshShape.Sphere;\n          AcceptanceMarker.index[markerEid] = existingMarkers.length;\n          existingMarkers.push(markerEid);\n        }\n\n        for (let i = 0; i < barCount; i++) {\n          const markerEid = existingMarkers[i];\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\n          const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\n          const maxHeight = Math.max(targetP, draftP) * MAX_HEIGHT;\n          const acceptance = draftP > 0 ? Math.min(1, targetP / draftP) : 1;\n\n          Transform.posX[markerEid] = startX + i * barSpacing;\n          Transform.posY[markerEid] = maxHeight + acceptanceYOffset;\n          Transform.posZ[markerEid] = comparisonZ / 2;\n\n          const scaledSize = acceptanceSize * acceptanceTransition;\n          Mesh.sizeX[markerEid] = scaledSize;\n          Mesh.sizeY[markerEid] = scaledSize;\n          Mesh.sizeZ[markerEid] = scaledSize;\n\n          Mesh.color[markerEid] = acceptanceColor(acceptance);\n        }\n      } else {\n        for (const markerEid of existingMarkers) {\n          Mesh.sizeX[markerEid] = 0;\n          Mesh.sizeY[markerEid] = 0;\n          Mesh.sizeZ[markerEid] = 0;\n        }\n      }\n\n      const residualTransition = ProbabilityDistribution.residualTransition[distEid];\n      const existingResidualBars = [...state.query([Pair(ResidualBarOwner.relation, distEid), Mesh, Transform])];\n\n      if (residualTransition > 0) {\n        while (existingResidualBars.length < barCount) {\n          const barEid = state.addEntity();\n          state.addComponent(barEid, Transform);\n          state.addComponent(barEid, Mesh);\n          state.addComponent(barEid, Pair(ChildOf.relation, distEid));\n          state.addComponent(barEid, Pair(ResidualBarOwner.relation, distEid));\n          Mesh.shape[barEid] = MeshShape.Box;\n          existingResidualBars.push(barEid);\n        }\n\n        for (let i = 0; i < barCount; i++) {\n          const barEid = existingResidualBars[i];\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\n          const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\n          const residualP = Math.max(0, targetP - draftP);\n\n          if (residualP <= 0.001) {\n            Mesh.sizeX[barEid] = 0;\n            Mesh.sizeY[barEid] = 0;\n            Mesh.sizeZ[barEid] = 0;\n            continue;\n          }\n\n          const height = residualP * MAX_HEIGHT * residualTransition;\n\n          Transform.posX[barEid] = startX + i * barSpacing;\n          Transform.posY[barEid] = height / 2;\n          Transform.posZ[barEid] = 0;\n\n          Mesh.sizeX[barEid] = barWidth * residualTransition;\n          Mesh.sizeY[barEid] = height;\n          Mesh.sizeZ[barEid] = barWidth * residualTransition;\n\n          Mesh.color[barEid] = 0x9333ea;\n        }\n      } else {\n        for (const barEid of existingResidualBars) {\n          Mesh.sizeX[barEid] = 0;\n          Mesh.sizeY[barEid] = 0;\n          Mesh.sizeZ[barEid] = 0;\n        }\n      }\n\n      // Min bars (green/accepted) - from y=0 to min(draft, target)\n      const minTransition = ProbabilityDistribution.minTransition[distEid];\n      const existingMinBars = [...state.query([Pair(MinBarOwner.relation, distEid), Mesh, Transform])];\n\n      if (minTransition > 0) {\n        while (existingMinBars.length < barCount) {\n          const barEid = state.addEntity();\n          state.addComponent(barEid, Transform);\n          state.addComponent(barEid, Mesh);\n          state.addComponent(barEid, Pair(ChildOf.relation, distEid));\n          state.addComponent(barEid, Pair(MinBarOwner.relation, distEid));\n          Mesh.shape[barEid] = MeshShape.Box;\n          existingMinBars.push(barEid);\n        }\n\n        for (let i = 0; i < barCount; i++) {\n          const barEid = existingMinBars[i];\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\n          const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\n          const minP = Math.min(targetP, draftP);\n\n          const height = Math.max(0.05, minP * MAX_HEIGHT * minTransition);\n\n          Transform.posX[barEid] = startX + i * barSpacing;\n          Transform.posY[barEid] = height / 2;\n          Transform.posZ[barEid] = 0;\n\n          Mesh.sizeX[barEid] = barWidth * minTransition;\n          Mesh.sizeY[barEid] = height;\n          Mesh.sizeZ[barEid] = barWidth * minTransition;\n\n          Mesh.color[barEid] = VALID;\n        }\n      } else {\n        for (const barEid of existingMinBars) {\n          Mesh.sizeX[barEid] = 0;\n          Mesh.sizeY[barEid] = 0;\n          Mesh.sizeZ[barEid] = 0;\n        }\n      }\n\n      // Excess draft bars (red/rejected) - from y=min to y=draft when draft > target\n      const excessDraftTransition = ProbabilityDistribution.excessDraftTransition[distEid];\n      const transferProgress = ProbabilityDistribution.transferProgress[distEid];\n      const existingExcessDraftBars = [...state.query([Pair(ExcessDraftBarOwner.relation, distEid), Mesh, Transform])];\n\n      if (excessDraftTransition > 0) {\n        while (existingExcessDraftBars.length < barCount) {\n          const barEid = state.addEntity();\n          state.addComponent(barEid, Transform);\n          state.addComponent(barEid, Mesh);\n          state.addComponent(barEid, Pair(ChildOf.relation, distEid));\n          state.addComponent(barEid, Pair(ExcessDraftBarOwner.relation, distEid));\n          Mesh.shape[barEid] = MeshShape.Box;\n          existingExcessDraftBars.push(barEid);\n        }\n\n        for (let i = 0; i < barCount; i++) {\n          const barEid = existingExcessDraftBars[i];\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\n          const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\n          const minP = Math.min(targetP, draftP);\n          const excessP = Math.max(0, draftP - targetP);\n\n          if (excessP <= 0.001) {\n            Mesh.sizeX[barEid] = 0;\n            Mesh.sizeY[barEid] = 0;\n            Mesh.sizeZ[barEid] = 0;\n            continue;\n          }\n\n          // Smooth fade out as transfer progresses - scale all dimensions\n          const fadeScale = 1 - transferProgress;\n          const height = excessP * MAX_HEIGHT * excessDraftTransition * fadeScale;\n          const baseHeight = minP * MAX_HEIGHT;\n          const widthScale = barWidth * excessDraftTransition * fadeScale;\n\n          Transform.posX[barEid] = startX + i * barSpacing;\n          Transform.posY[barEid] = baseHeight + height / 2;\n          Transform.posZ[barEid] = 0;\n\n          Mesh.sizeX[barEid] = widthScale;\n          Mesh.sizeY[barEid] = height;\n          Mesh.sizeZ[barEid] = widthScale;\n\n          Mesh.color[barEid] = INVALID;\n        }\n      } else {\n        for (const barEid of existingExcessDraftBars) {\n          Mesh.sizeX[barEid] = 0;\n          Mesh.sizeY[barEid] = 0;\n          Mesh.sizeZ[barEid] = 0;\n        }\n      }\n\n      // Excess target bars (purple) - from y=min to y=target when target > draft\n      const excessTargetTransition = ProbabilityDistribution.excessTargetTransition[distEid];\n      const existingExcessTargetBars = [...state.query([Pair(ExcessTargetBarOwner.relation, distEid), Mesh, Transform])];\n\n      if (excessTargetTransition > 0) {\n        while (existingExcessTargetBars.length < barCount) {\n          const barEid = state.addEntity();\n          state.addComponent(barEid, Transform);\n          state.addComponent(barEid, Mesh);\n          state.addComponent(barEid, Pair(ChildOf.relation, distEid));\n          state.addComponent(barEid, Pair(ExcessTargetBarOwner.relation, distEid));\n          Mesh.shape[barEid] = MeshShape.Box;\n          existingExcessTargetBars.push(barEid);\n        }\n\n        for (let i = 0; i < barCount; i++) {\n          const barEid = existingExcessTargetBars[i];\n          const targetP = targetProbs && targetProbs.length > i ? targetProbs[i] : 0.2;\n          const draftP = draftProbs && draftProbs.length > i ? draftProbs[i] : targetP;\n          const minP = Math.min(targetP, draftP);\n          const excessP = Math.max(0, targetP - draftP);\n\n          if (excessP <= 0.001) {\n            Mesh.sizeX[barEid] = 0;\n            Mesh.sizeY[barEid] = 0;\n            Mesh.sizeZ[barEid] = 0;\n            continue;\n          }\n\n          // Fade in as transfer progresses\n          const fadeScale = transferProgress;\n          const height = excessP * MAX_HEIGHT * excessTargetTransition * fadeScale;\n          const baseHeight = minP * MAX_HEIGHT;\n\n          Transform.posX[barEid] = startX + i * barSpacing;\n          Transform.posY[barEid] = baseHeight + height / 2;\n          Transform.posZ[barEid] = 0;\n\n          Mesh.sizeX[barEid] = barWidth * excessTargetTransition;\n          Mesh.sizeY[barEid] = height;\n          Mesh.sizeZ[barEid] = barWidth * excessTargetTransition;\n\n          Mesh.color[barEid] = 0x9333ea; // Purple\n        }\n      } else {\n        for (const barEid of existingExcessTargetBars) {\n          Mesh.sizeX[barEid] = 0;\n          Mesh.sizeY[barEid] = 0;\n          Mesh.sizeZ[barEid] = 0;\n        }\n      }\n    }\n  },\n};\n\nconst BarHighlightSystem: System = {\n  group: 'simulation',\n  update(state: State) {\n    for (const highlightEid of state.query([BarHighlight, Transform])) {\n      const distEid = BarHighlight.distribution[highlightEid];\n      const barIndex = BarHighlight.barIndex[highlightEid];\n      const yOffset = BarHighlight.yOffset[highlightEid];\n\n      if (!state.hasComponent(distEid, ProbabilityDistribution)) continue;\n\n      const barCount = ProbabilityDistribution.barCount[distEid];\n\n      const bars = [...state.query([Pair(DistributionBarOwner.relation, distEid), DistributionBar])];\n      const barEid = bars.find(eid => DistributionBar.index[eid] === barIndex);\n      if (barEid === undefined) continue;\n\n      const probability = DistributionBar.probability[barEid];\n\n      const barSpacing = CHART_WIDTH / barCount;\n      const startX = -CHART_WIDTH / 2 + barSpacing / 2;\n      const barX = startX + barIndex * barSpacing;\n      const barHeight = probability * MAX_HEIGHT;\n\n      Transform.posX[highlightEid] = barX;\n      Transform.posY[highlightEid] = 0.5 + barHeight + yOffset;\n    }\n  },\n};\n\nexport const ProbabilityDistributionPlugin: Plugin = {\n  components: { ProbabilityDistribution, DistributionBar, BarHighlight, AcceptanceMarker },\n  systems: [ProbabilityDistributionSystem, BarHighlightSystem],\n};\n","import { MAX_ENTITIES, resource, type Plugin, type State, type System } from '@multiplekex/shallot';\nimport { setTraits, type FieldAccessor } from '@multiplekex/shallot';\nimport { Compute, ComputePlugin, createEntityIdBuffer } from '@multiplekex/shallot';\nimport {\n  Render,\n  RenderPlugin,\n  Pass,\n  registerDraw,\n  type Draw,\n  type SharedPassContext,\n} from '@multiplekex/shallot';\nimport { Transform } from '@multiplekex/shallot';\n\nexport const GradientLegendData = {\n  data: new Float32Array(MAX_ENTITIES * 4),\n};\n\ninterface GradientLegendProxy extends Array<number>, FieldAccessor {}\n\nfunction legendProxy(offset: number): GradientLegendProxy {\n  const data = GradientLegendData.data;\n\n  function getValue(eid: number): number {\n    return data[eid * 4 + offset];\n  }\n\n  function setValue(eid: number, value: number): void {\n    data[eid * 4 + offset] = value;\n  }\n\n  return new Proxy([] as unknown as GradientLegendProxy, {\n    get(_, prop) {\n      if (prop === 'get') return getValue;\n      if (prop === 'set') return setValue;\n      const eid = Number(prop);\n      if (Number.isNaN(eid)) return undefined;\n      return getValue(eid);\n    },\n    set(_, prop, value) {\n      const eid = Number(prop);\n      if (Number.isNaN(eid)) return false;\n      setValue(eid, value);\n      return true;\n    },\n  });\n}\n\nexport const GradientLegend: {\n  transition: GradientLegendProxy;\n  width: GradientLegendProxy;\n  height: GradientLegendProxy;\n} = {\n  transition: legendProxy(0),\n  width: legendProxy(1),\n  height: legendProxy(2),\n};\n\nsetTraits(GradientLegend, {\n  defaults: () => ({\n    transition: 0,\n    width: 0.5,\n    height: 5,\n  }),\n});\n\nexport interface GradientLegendConfig {\n  scene: GPUBuffer;\n  legends: GPUBuffer;\n  entityIds: GPUBuffer;\n  matrices: GPUBuffer;\n  getCount: () => number;\n}\n\nexport const gradientLegendShader = /* wgsl */ `\nstruct VertexOutput {\n  @builtin(position) position: vec4<f32>,\n  @location(0) uv: vec2<f32>,\n  @location(1) transition: f32,\n}\n\nstruct Scene {\n  viewProj: mat4x4<f32>,\n  cameraWorld: mat4x4<f32>,\n  ambientColor: vec4<f32>,\n  sunDirection: vec4<f32>,\n  sunColor: vec4<f32>,\n  cameraMode: f32,\n  cameraSize: f32,\n  viewport: vec2<f32>,\n}\n\nstruct LegendData {\n  transition: f32,\n  width: f32,\n  height: f32,\n  _pad: f32,\n}\n\n@group(0) @binding(0) var<uniform> scene: Scene;\n@group(0) @binding(1) var<storage, read> entityIds: array<u32>;\n@group(0) @binding(2) var<storage, read> legends: array<LegendData>;\n@group(0) @binding(3) var<storage, read> matrices: array<mat4x4<f32>>;\n\n@vertex\nfn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VertexOutput {\n  let eid = entityIds[iid];\n  let legend = legends[eid];\n  let transform = matrices[eid];\n\n  let halfW = legend.width * 0.5 * legend.transition;\n  let halfH = legend.height * 0.5 * legend.transition;\n\n  var localPos: vec2<f32>;\n  var uv: vec2<f32>;\n  switch vid {\n    case 0u: { localPos = vec2(-halfW, -halfH); uv = vec2(0.0, 0.0); }\n    case 1u: { localPos = vec2(halfW, -halfH); uv = vec2(1.0, 0.0); }\n    case 2u: { localPos = vec2(halfW, halfH); uv = vec2(1.0, 1.0); }\n    case 3u: { localPos = vec2(-halfW, -halfH); uv = vec2(0.0, 0.0); }\n    case 4u: { localPos = vec2(halfW, halfH); uv = vec2(1.0, 1.0); }\n    case 5u: { localPos = vec2(-halfW, halfH); uv = vec2(0.0, 1.0); }\n    default: { localPos = vec2(0.0, 0.0); uv = vec2(0.0, 0.0); }\n  }\n\n  let worldPos = transform[3].xyz + vec3(localPos, 0.0);\n  let clipPos = scene.viewProj * vec4(worldPos, 1.0);\n\n  var out: VertexOutput;\n  out.position = clipPos;\n  out.uv = uv;\n  out.transition = legend.transition;\n  return out;\n}\n\nstruct FragmentOutput {\n  @location(0) color: vec4<f32>,\n  @location(1) mask: f32,\n}\n\n@fragment\nfn fs(input: VertexOutput) -> FragmentOutput {\n  let t = input.uv.y;\n\n  // Nonlinear: Red -> Yellow at 90%, Yellow -> Green in top 10%\n  var color: vec3<f32>;\n  let red = vec3(0.863, 0.345, 0.345);\n  let yellow = vec3(0.898, 0.627, 0.251);\n  let green = vec3(0.247, 0.722, 0.478);\n  if (t < 0.9) {\n    color = mix(red, yellow, t / 0.9);\n  } else {\n    color = mix(yellow, green, (t - 0.9) / 0.1);\n  }\n\n  var out: FragmentOutput;\n  out.color = vec4(color, input.transition);\n  out.mask = select(0.0, 1.0, input.transition > 0.01);\n  return out;\n}\n`;\n\nexport function createGradientLegendPipeline(\n  device: GPUDevice,\n  format: GPUTextureFormat,\n  maskFormat: GPUTextureFormat\n): GPURenderPipeline {\n  const module = device.createShaderModule({ code: gradientLegendShader });\n\n  return device.createRenderPipeline({\n    layout: 'auto',\n    vertex: {\n      module,\n      entryPoint: 'vs',\n    },\n    fragment: {\n      module,\n      entryPoint: 'fs',\n      targets: [\n        {\n          format,\n          blend: {\n            color: {\n              srcFactor: 'src-alpha',\n              dstFactor: 'one-minus-src-alpha',\n              operation: 'add',\n            },\n            alpha: {\n              srcFactor: 'one',\n              dstFactor: 'one-minus-src-alpha',\n              operation: 'add',\n            },\n          },\n        },\n        {\n          format: maskFormat,\n          writeMask: GPUColorWrite.RED,\n        },\n      ],\n    },\n    primitive: {\n      topology: 'triangle-list',\n    },\n    depthStencil: {\n      format: 'depth24plus',\n      depthCompare: 'less',\n      depthWriteEnabled: false,\n    },\n  });\n}\n\nfunction createGradientLegendDraw(config: GradientLegendConfig): Draw {\n  let pipeline: GPURenderPipeline | null = null;\n  let bindGroup: GPUBindGroup | null = null;\n\n  return {\n    id: 'gradient-legend',\n    pass: Pass.Overlay,\n    order: 1,\n\n    execute() {},\n\n    draw(pass: GPURenderPassEncoder, ctx: SharedPassContext) {\n      const count = config.getCount();\n      if (count === 0) return;\n\n      if (!pipeline) {\n        pipeline = createGradientLegendPipeline(ctx.device, ctx.format, ctx.maskFormat);\n      }\n\n      if (!bindGroup) {\n        bindGroup = ctx.device.createBindGroup({\n          layout: pipeline.getBindGroupLayout(0),\n          entries: [\n            { binding: 0, resource: { buffer: config.scene } },\n            { binding: 1, resource: { buffer: config.entityIds } },\n            { binding: 2, resource: { buffer: config.legends } },\n            { binding: 3, resource: { buffer: config.matrices } },\n          ],\n        });\n      }\n\n      pass.setPipeline(pipeline);\n      pass.setBindGroup(0, bindGroup);\n      pass.draw(6, count);\n    },\n  };\n}\n\nexport interface GradientLegendState {\n  buffer: GPUBuffer;\n  entityIds: GPUBuffer;\n  count: number;\n}\n\nexport const GradientLegends = resource<GradientLegendState>('gradient-legends');\n\nconst entityIdArray = new Uint32Array(MAX_ENTITIES);\n\nconst GradientLegendSystem: System = {\n  group: 'draw',\n\n  update(state: State) {\n    const compute = Compute.from(state);\n    const legends = GradientLegends.from(state);\n    if (!compute || !legends) return;\n\n    const { device } = compute;\n\n    let count = 0;\n    for (const eid of state.query([GradientLegend, Transform])) {\n      if (GradientLegend.transition[eid] <= 0) continue;\n      entityIdArray[count++] = eid;\n    }\n\n    device.queue.writeBuffer(legends.buffer, 0, GradientLegendData.data);\n    device.queue.writeBuffer(legends.entityIds, 0, entityIdArray, 0, count);\n    legends.count = count;\n  },\n};\n\nexport const GradientLegendPlugin: Plugin = {\n  systems: [GradientLegendSystem],\n  components: { GradientLegend },\n  dependencies: [ComputePlugin, RenderPlugin],\n\n  initialize(state: State) {\n    const compute = Compute.from(state);\n    const render = Render.from(state);\n    if (!compute || !render) return;\n\n    const { device } = compute;\n\n    const legendState: GradientLegendState = {\n      buffer: device.createBuffer({\n        label: 'gradient-legends',\n        size: MAX_ENTITIES * 4 * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n      }),\n      entityIds: createEntityIdBuffer(device, MAX_ENTITIES),\n      count: 0,\n    };\n\n    state.setResource(GradientLegends, legendState);\n\n    registerDraw(\n      state,\n      createGradientLegendDraw({\n        scene: render.scene,\n        legends: legendState.buffer,\n        entityIds: legendState.entityIds,\n        matrices: render.matrices,\n        getCount: () => legendState.count,\n      })\n    );\n  },\n};\n","import { setTraits, ChildOf, Pair, Transform, defineRelation, type Plugin, type State, type System } from '@multiplekex/shallot';\nimport { Text, Line, Arrow } from '@multiplekex/shallot/extras';\nimport { LINE, VALID, INVALID } from './colors';\n\nexport const TokenReplacement = {\n  trigger: [] as number[],\n};\n\nsetTraits(TokenReplacement, {\n  defaults: () => ({ trigger: 0 }),\n});\n\nconst tokenReplacementTexts = new Map<number, { original: string; replacement: string }>();\n\nexport function setTokenReplacementTexts(eid: number, original: string, replacement: string): void {\n  tokenReplacementTexts.set(eid, { original, replacement });\n}\n\nexport { Border, BorderPlugin } from './border';\nexport { ProbabilityDistribution, DistributionBar, BarHighlight, ProbabilityDistributionPlugin, setDistributionProbabilities } from './probability-distribution';\nexport { GradientLegend, GradientLegendPlugin } from './gradient-legend';\n\nexport const Network = {\n  active: [] as number[],\n  lineTransition: [] as number[],\n};\n\nsetTraits(Network, {\n  defaults: () => ({ active: 0, lineTransition: 1 }),\n});\n\nexport const TargetModel = {};\nexport const DraftModel = {};\nexport const ValidationModel = {};\n\nexport const Slot = {\n  index: [] as number[],\n  transition: [] as number[],\n};\n\nsetTraits(Slot, {\n  defaults: () => ({ index: 0, transition: 1 }),\n});\n\nexport const Latent = {};\nexport const Output = {};\n\nexport const ValidationMark = {\n  valid: [] as number[],\n  transition: [] as number[],\n};\n\nsetTraits(ValidationMark, {\n  defaults: () => ({ valid: 1, transition: 0 }),\n});\n\nconst SLOT_OFFSET_Z = -4;\nconst CHAR_WIDTH_RATIO = 0.55;\nconst WORD_GAP = 0.7;\nconst OUTPUT_GAP = 1.4;\nconst LINE_THICKNESS = 2;\n\nfunction getSlotTextWidth(state: State, slotEid: number): number {\n  for (const textEid of state.query([Pair(ChildOf.relation, slotEid), Text])) {\n    const content = Text.content[textEid] ?? '';\n    const fontSize = Text.fontSize[textEid] || 1;\n    return content.length * fontSize * CHAR_WIDTH_RATIO;\n  }\n  return 1;\n}\n\nconst SlotTransitionSystem: System = {\n  group: 'simulation',\n  update(state: State) {\n    for (const slotEid of state.query([Slot, Transform])) {\n      const t = Slot.transition[slotEid];\n      Transform.scaleX[slotEid] = t;\n      Transform.scaleY[slotEid] = t;\n      Transform.scaleZ[slotEid] = t;\n    }\n  },\n};\n\nconst SlotArrangementSystem: System = {\n  group: 'simulation',\n  update(state: State) {\n    for (const networkEid of state.query([Network, Transform])) {\n      const allSlots = [...state.query([Pair(ChildOf.relation, networkEid), Slot, Transform])];\n      if (allSlots.length === 0) continue;\n\n      allSlots.sort((a, b) => Slot.index[a] - Slot.index[b]);\n\n      const inputs = allSlots.filter((eid) => !state.hasComponent(eid, Output));\n      const outputs = allSlots.filter((eid) => state.hasComponent(eid, Output));\n\n      const inputWidths = inputs.map((eid) => getSlotTextWidth(state, eid));\n      const inputTotalWidth = inputWidths.reduce((sum, w) => sum + w, 0) + WORD_GAP * Math.max(0, inputs.length - 1);\n\n      let x = -inputTotalWidth / 2;\n      for (let i = 0; i < inputs.length; i++) {\n        const slotEid = inputs[i];\n        const w = inputWidths[i];\n        Transform.posX[slotEid] = x + w / 2;\n        Transform.posY[slotEid] = 0;\n        Transform.posZ[slotEid] = SLOT_OFFSET_Z;\n        x += w + WORD_GAP;\n      }\n\n      x = inputTotalWidth / 2 + OUTPUT_GAP;\n      for (let i = 0; i < outputs.length; i++) {\n        const slotEid = outputs[i];\n        const w = getSlotTextWidth(state, slotEid);\n        Transform.posX[slotEid] = x + w / 2;\n        Transform.posY[slotEid] = 0;\n        Transform.posZ[slotEid] = SLOT_OFFSET_Z;\n        x += w + WORD_GAP;\n      }\n    }\n  },\n};\n\nconst NetworkLine = {};\nconst NetworkLineTarget = defineRelation('network-line-target', { exclusive: true });\n\nconst NetworkLinesSystem: System = {\n  group: 'simulation',\n  update(state: State) {\n    for (const networkEid of state.query([Network, Transform])) {\n      const lineTransition = Network.lineTransition[networkEid];\n\n      for (const slotEid of state.query([Pair(ChildOf.relation, networkEid), Slot, Transform])) {\n        const existingLines = [...state.query([Pair(NetworkLineTarget.relation, slotEid), NetworkLine, Line])];\n\n        let lineEid: number;\n        if (existingLines.length === 0) {\n          lineEid = state.addEntity();\n          state.addComponent(lineEid, Transform);\n          state.addComponent(lineEid, Line);\n          state.addComponent(lineEid, Arrow);\n          state.addComponent(lineEid, NetworkLine);\n          state.addComponent(lineEid, Pair(ChildOf.relation, networkEid));\n          state.addComponent(lineEid, Pair(NetworkLineTarget.relation, slotEid));\n\n          Line.color[lineEid] = LINE;\n          Line.thickness[lineEid] = LINE_THICKNESS;\n          Line.visible[lineEid] = 1;\n\n          Arrow.start[lineEid] = 0;\n          Arrow.end[lineEid] = 1;\n          Arrow.size[lineEid] = 1;\n        } else {\n          lineEid = existingLines[0];\n        }\n\n        const slotX = Transform.posX[slotEid];\n        const slotY = Transform.posY[slotEid];\n        const slotZ = Transform.posZ[slotEid];\n        const t = Math.min(1, Slot.transition[slotEid]);\n\n        Line.offsetX[lineEid] = slotX * t;\n        Line.offsetY[lineEid] = slotY * t;\n        Line.offsetZ[lineEid] = slotZ * t;\n        Line.opacity[lineEid] = lineTransition;\n      }\n    }\n  },\n};\n\nconst LatentArrow = {};\nconst LatentArrowOwner = defineRelation('latent-arrow-owner', { exclusive: true });\n\nconst ValidationLine = {};\nconst ValidationLineTarget = defineRelation('validation-line-target', { exclusive: true });\n\nconst LatentArrowsSystem: System = {\n  group: 'simulation',\n  update(state: State) {\n    for (const slotEid of state.query([Slot, Transform])) {\n      const latents = [...state.query([Pair(ChildOf.relation, slotEid), Latent, Transform])];\n      if (latents.length === 0) continue;\n\n      const latentEid = latents[0];\n\n      const existingArrows = [...state.query([Pair(LatentArrowOwner.relation, slotEid), LatentArrow, Line])];\n\n      let arrowEid: number;\n      if (existingArrows.length === 0) {\n        arrowEid = state.addEntity();\n        state.addComponent(arrowEid, Transform);\n        state.addComponent(arrowEid, Line);\n        state.addComponent(arrowEid, Arrow);\n        state.addComponent(arrowEid, LatentArrow);\n        state.addComponent(arrowEid, Pair(ChildOf.relation, slotEid));\n        state.addComponent(arrowEid, Pair(LatentArrowOwner.relation, slotEid));\n\n        Line.color[arrowEid] = LINE;\n        Line.thickness[arrowEid] = LINE_THICKNESS;\n        Line.visible[arrowEid] = 1;\n        Line.opacity[arrowEid] = 1;\n\n        Arrow.start[arrowEid] = 0;\n        Arrow.end[arrowEid] = 1;\n        Arrow.size[arrowEid] = 1;\n      } else {\n        arrowEid = existingArrows[0];\n      }\n\n      const latentZ = Transform.posZ[latentEid] - 3.5;\n\n      Transform.posX[arrowEid] = 0;\n      Transform.posY[arrowEid] = 0;\n      Transform.posZ[arrowEid] = latentZ;\n\n      Line.offsetX[arrowEid] = 0;\n      Line.offsetY[arrowEid] = 0;\n      Line.offsetZ[arrowEid] = -0.8;\n    }\n  },\n};\n\nconst ValidationLinesSystem: System = {\n  group: 'simulation',\n  update(state: State) {\n    for (const validationEid of state.query([ValidationModel, Transform])) {\n      const validationScale = Transform.scaleX[validationEid];\n      if (validationScale < 0.01) continue;\n\n      for (const draftEid of state.query([DraftModel, Transform])) {\n        const draftSlots = [...state.query([Pair(ChildOf.relation, draftEid), Slot, Transform])];\n        if (draftSlots.length === 0) continue;\n\n        const draftX = Transform.posX[draftEid];\n        const draftY = Transform.posY[draftEid];\n        const draftZ = Transform.posZ[draftEid];\n\n        for (const slotEid of draftSlots) {\n          const slotTransition = Math.max(0, Math.min(1, Slot.transition[slotEid]));\n\n          const existingLines = [...state.query([Pair(ValidationLineTarget.relation, slotEid), ValidationLine, Line])];\n\n          let lineEid: number;\n          if (existingLines.length === 0) {\n            lineEid = state.addEntity();\n            state.addComponent(lineEid, Transform);\n            state.addComponent(lineEid, Line);\n            state.addComponent(lineEid, Arrow);\n            state.addComponent(lineEid, ValidationLine);\n            state.addComponent(lineEid, Pair(ValidationLineTarget.relation, slotEid));\n\n            Line.color[lineEid] = LINE;\n            Line.thickness[lineEid] = LINE_THICKNESS;\n            Line.visible[lineEid] = 1;\n\n            Arrow.start[lineEid] = 0;\n            Arrow.end[lineEid] = 1;\n            Arrow.size[lineEid] = 1;\n          } else {\n            lineEid = existingLines[0];\n          }\n\n          if (slotTransition < 0.01) {\n            Line.opacity[lineEid] = 0;\n            continue;\n          }\n\n          const slotX = Transform.posX[slotEid];\n          const slotZ = Transform.posZ[slotEid];\n          const worldSlotX = draftX + slotX * slotTransition;\n          const worldSlotY = draftY;\n          const worldSlotZ = draftZ + slotZ * slotTransition;\n\n          const validationX = Transform.posX[validationEid];\n          const validationY = Transform.posY[validationEid];\n          const validationZ = Transform.posZ[validationEid];\n\n          Transform.posX[lineEid] = validationX;\n          Transform.posY[lineEid] = validationY;\n          Transform.posZ[lineEid] = validationZ;\n\n          Line.offsetX[lineEid] = (worldSlotX - validationX) * validationScale;\n          Line.offsetY[lineEid] = (worldSlotY - validationY) * validationScale;\n          Line.offsetZ[lineEid] = (worldSlotZ - validationZ) * validationScale;\n          Line.opacity[lineEid] = validationScale * slotTransition;\n        }\n      }\n    }\n  },\n};\n\nconst TokenReplacementSystem: System = {\n  group: 'simulation',\n  update(state: State) {\n    for (const eid of state.query([TokenReplacement, Text])) {\n      const trigger = TokenReplacement.trigger[eid];\n      const texts = tokenReplacementTexts.get(eid);\n      if (!texts) continue;\n\n      const currentText = Text.content[eid] ?? '';\n      const { original, replacement } = texts;\n\n      if (trigger > 0.5 && currentText !== replacement && replacement) {\n        Text.content[eid] = replacement;\n      } else if (trigger <= 0.5 && currentText !== original && original) {\n        Text.content[eid] = original;\n      }\n    }\n  },\n};\n\nexport const SpecdecPlugin: Plugin = {\n  components: { Network, TargetModel, DraftModel, ValidationModel, Slot, Latent, Output, NetworkLine, LatentArrow, ValidationLine, TokenReplacement },\n  systems: [SlotTransitionSystem, SlotArrangementSystem, NetworkLinesSystem, LatentArrowsSystem, ValidationLinesSystem, TokenReplacementSystem],\n};\n"],"names":["TARGET_MODEL","DRAFT_MODEL","VALID","INVALID","LINE","Border","setTraits","BorderLine","CHAR_WIDTH_RATIO","BorderSystem","state","eid","Text","Transform","content","fontSize","padding","color","thickness","t","textWidth","textHeight","w","h","Pair","ChildOf","Line","i","lineEid","lines","BorderPlugin","ProbabilityDistribution","DistributionBar","DistributionBarOwner","defineRelation","ComparisonBarOwner","AcceptanceMarkerOwner","ResidualBarOwner","MinBarOwner","ExcessDraftBarOwner","ExcessTargetBarOwner","AcceptanceMarker","BarHighlight","targetDistributions","draftDistributions","setDistributionProbabilities","distEid","targetProbs","draftProbs","lerpColor","c1","c2","r1","g1","b1","r2","g2","b2","r","g","b","RED","YELLOW","GREEN","acceptanceColor","acceptance","CHART_WIDTH","MAX_HEIGHT","smoothLerp","smoothness","dt","s","ProbabilityDistributionSystem","barCount","transition","blend","comparisonTransition","comparisonZ","existingBars","Mesh","barEid","MeshShape","barSpacing","barWidth","startX","targetP","draftP","goalP","probability","height","existingComparisonBars","compBarEid","acceptanceTransition","acceptanceYOffset","acceptanceSize","existingMarkers","markerEid","maxHeight","scaledSize","residualTransition","existingResidualBars","residualP","minTransition","existingMinBars","minP","excessDraftTransition","transferProgress","existingExcessDraftBars","excessP","fadeScale","baseHeight","widthScale","excessTargetTransition","existingExcessTargetBars","BarHighlightSystem","highlightEid","barIndex","yOffset","barX","barHeight","ProbabilityDistributionPlugin","GradientLegendData","MAX_ENTITIES","legendProxy","offset","data","getValue","setValue","value","_","prop","GradientLegend","gradientLegendShader","createGradientLegendPipeline","device","format","maskFormat","module","createGradientLegendDraw","config","pipeline","bindGroup","Pass","pass","ctx","count","GradientLegends","resource","entityIdArray","GradientLegendSystem","compute","Compute","legends","GradientLegendPlugin","ComputePlugin","RenderPlugin","render","Render","legendState","createEntityIdBuffer","registerDraw","TokenReplacement","tokenReplacementTexts","setTokenReplacementTexts","original","replacement","Network","TargetModel","DraftModel","ValidationModel","Slot","Latent","Output","ValidationMark","SLOT_OFFSET_Z","WORD_GAP","OUTPUT_GAP","LINE_THICKNESS","getSlotTextWidth","slotEid","textEid","SlotTransitionSystem","SlotArrangementSystem","networkEid","allSlots","a","inputs","outputs","inputWidths","inputTotalWidth","sum","x","NetworkLine","NetworkLineTarget","NetworkLinesSystem","lineTransition","existingLines","Arrow","slotX","slotY","slotZ","LatentArrow","LatentArrowOwner","ValidationLine","ValidationLineTarget","LatentArrowsSystem","latents","latentEid","existingArrows","arrowEid","latentZ","ValidationLinesSystem","validationEid","validationScale","draftEid","draftSlots","draftX","draftY","draftZ","slotTransition","worldSlotX","worldSlotY","worldSlotZ","validationX","validationY","validationZ","TokenReplacementSystem","trigger","texts","currentText","SpecdecPlugin"],"mappings":"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"}