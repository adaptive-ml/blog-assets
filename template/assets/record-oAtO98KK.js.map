{"version":3,"file":"record-oAtO98KK.js","sources":["../../../src/recording/blog-recorder.ts","../../src/record.ts"],"sourcesContent":["import { Pair } from 'bitecs';\r\nimport { Muxer, ArrayBufferTarget } from 'mp4-muxer';\r\nimport type { State } from '@multiplekex/shallot';\r\nimport { Sequence, SequenceState, Tween, TweenState, ChildOf } from '@multiplekex/shallot';\r\nimport type { RecordingConfig } from './types';\r\nimport { DEFAULT_CONFIG } from './types';\r\nimport { downloadBlob } from './encoder';\r\nimport { StepController, getEntityByName, type SequenceMap } from '@blog-components/sequence';\r\nimport { createRecorderUI, type RecorderUIState } from './ui';\r\n\r\nexport interface BlogCanvasConfig {\r\n  canvasId: string;\r\n  controllerName: string;\r\n  sequenceMap: SequenceMap;\r\n  iframeSelector?: string;\r\n  displayName?: string;\r\n}\r\n\r\nfunction getDisplayName(config: BlogCanvasConfig): string {\r\n  if (config.displayName) return config.displayName;\r\n  if (config.iframeSelector) {\r\n    const match = config.iframeSelector.match(/\\*=\"?([^\"\"\\]]+)/);\r\n    return match ? match[1] : config.canvasId;\r\n  }\r\n  return config.canvasId;\r\n}\r\n\r\nfunction getConfigKey(config: BlogCanvasConfig): string {\r\n  if (config.iframeSelector) {\r\n    const match = config.iframeSelector.match(/\\*=\"?([^\"\"\\]]+)/);\r\n    const selectorPart = match ? match[1] : config.iframeSelector.replace(/[^a-zA-Z0-9]/g, '');\r\n    return `${selectorPart}:${config.canvasId}`;\r\n  }\r\n  return config.canvasId;\r\n}\r\n\r\ninterface CanvasHandle {\r\n  canvas: HTMLCanvasElement;\r\n  config: BlogCanvasConfig;\r\n  controllerEid: number;\r\n  isIframe: boolean;\r\n}\r\n\r\nlet isRecording = false;\r\nlet activeCanvas: CanvasHandle | null = null;\r\nlet handles: CanvasHandle[] = [];\r\nlet uiUpdate: ((state: RecorderUIState) => void) | null = null;\r\nlet statusText = 'Waiting...';\r\n\r\nfunction getStep(handle: CanvasHandle): number {\r\n  if (handle.isIframe && handle.canvas.__getStep__) {\r\n    return handle.canvas.__getStep__();\r\n  }\r\n  return StepController.target[handle.controllerEid];\r\n}\r\n\r\nfunction setStep(handle: CanvasHandle, step: number): void {\r\n  if (handle.isIframe && handle.canvas.__setStep__) {\r\n    handle.canvas.__setStep__(step);\r\n  } else {\r\n    StepController.target[handle.controllerEid] = step;\r\n  }\r\n}\r\n\r\nfunction getMaxStepForHandle(handle: CanvasHandle): number {\r\n  if (handle.isIframe && handle.canvas.__maxStep__ !== undefined) {\r\n    return handle.canvas.__maxStep__;\r\n  }\r\n  return getMaxStep(handle.config.sequenceMap);\r\n}\r\n\r\nfunction updateStatus(msg: string): void {\r\n  statusText = msg;\r\n  updateUI();\r\n}\r\n\r\nfunction getMaxStep(sequenceMap: SequenceMap): number {\r\n  let max = 0;\r\n  for (const key of Object.keys(sequenceMap)) {\r\n    const [from, to] = key.split('-').map(Number);\r\n    max = Math.max(max, from, to);\r\n  }\r\n  return max;\r\n}\r\n\r\nasync function encodeSequenceFrames(\r\n  canvas: HTMLCanvasElement,\r\n  state: State,\r\n  seqEid: number,\r\n  config: RecordingConfig,\r\n  onProgress?: (frame: number, total: number) => void\r\n): Promise<Blob> {\r\n  Sequence.state[seqEid] = SequenceState.IDLE;\r\n  Sequence.elapsed[seqEid] = 0;\r\n  for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\r\n    Tween.state[childEid] = TweenState.IDLE;\r\n    Tween.elapsed[childEid] = 0;\r\n  }\r\n  Sequence.state[seqEid] = SequenceState.PLAYING;\r\n\r\n  let maxDuration = 0;\r\n  for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\r\n    maxDuration = Math.max(maxDuration, Tween.duration[childEid]);\r\n  }\r\n  const duration = maxDuration + 0.1;\r\n  const totalFrames = Math.ceil(duration * config.fps);\r\n\r\n  const muxer = new Muxer({\r\n    target: new ArrayBufferTarget(),\r\n    video: { codec: 'avc', width: config.width, height: config.height },\r\n    fastStart: 'in-memory',\r\n  });\r\n\r\n  const encoder = new VideoEncoder({\r\n    output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),\r\n    error: (e) => console.error('Encoder error:', e),\r\n  });\r\n\r\n  encoder.configure({\r\n    codec: 'avc1.640032',\r\n    width: config.width,\r\n    height: config.height,\r\n    bitrate: config.bitrate,\r\n    framerate: config.fps,\r\n  });\r\n\r\n  const stepTime = 1 / config.fps;\r\n\r\n  for (let i = 0; i < totalFrames; i++) {\r\n    state.step(stepTime);\r\n\r\n    const videoFrame = new VideoFrame(canvas, {\r\n      timestamp: (i * 1_000_000) / config.fps,\r\n    });\r\n    encoder.encode(videoFrame);\r\n    videoFrame.close();\r\n\r\n    if (i % 30 === 0) {\r\n      onProgress?.(i, totalFrames);\r\n      await new Promise((r) => setTimeout(r, 0));\r\n    }\r\n  }\r\n\r\n  await encoder.flush();\r\n  muxer.finalize();\r\n\r\n  return new Blob([muxer.target.buffer], { type: 'video/mp4' });\r\n}\r\n\r\nasync function recordSequence(\r\n  handle: CanvasHandle,\r\n  fromStep: number,\r\n  toStep: number,\r\n  config: RecordingConfig\r\n): Promise<void> {\r\n  if (isRecording) return;\r\n  isRecording = true;\r\n  updateUI();\r\n\r\n  const { canvas, config: canvasConfig } = handle;\r\n  const seqName = canvasConfig.sequenceMap[`${fromStep}-${toStep}`];\r\n\r\n  if (!seqName) {\r\n    updateStatus(`No seq ${fromStep}-${toStep}`);\r\n    isRecording = false;\r\n    updateUI();\r\n    return;\r\n  }\r\n\r\n  const filename = `${getDisplayName(canvasConfig)}-step-${fromStep}-${toStep}`;\r\n  updateStatus(`Recording...`);\r\n\r\n  let blob: Blob | null = null;\r\n\r\n  if (handle.isIframe && canvas.__recordSequence__) {\r\n    blob = await canvas.__recordSequence__(\r\n      { seqName, width: config.width, height: config.height, fps: config.fps, bitrate: config.bitrate },\r\n      (frame, total) => updateStatus(`${frame}/${total}`)\r\n    );\r\n  } else {\r\n    const state = canvas.__state__;\r\n    if (!state) {\r\n      updateStatus('No state');\r\n      isRecording = false;\r\n      updateUI();\r\n      return;\r\n    }\r\n\r\n    const seqEid = getEntityByName(seqName);\r\n    if (seqEid === null) {\r\n      updateStatus('Seq not found');\r\n      isRecording = false;\r\n      updateUI();\r\n      return;\r\n    }\r\n\r\n    const origWidth = canvas.width;\r\n    const origHeight = canvas.height;\r\n    const origStyle = canvas.style.cssText;\r\n\r\n    document.body.classList.add('recording-mode');\r\n    canvas.classList.add('recording-target');\r\n    canvas.width = config.width;\r\n    canvas.height = config.height;\r\n    canvas.style.cssText = `width:${config.width}px;height:${config.height}px;display:block`;\r\n    window.dispatchEvent(new Event('resize'));\r\n\r\n    await new Promise((r) => requestAnimationFrame(r));\r\n\r\n    blob = await encodeSequenceFrames(canvas, state, seqEid, config, (frame, total) => {\r\n      updateStatus(`${frame}/${total}`);\r\n    });\r\n\r\n    document.body.classList.remove('recording-mode');\r\n    canvas.classList.remove('recording-target');\r\n    canvas.width = origWidth;\r\n    canvas.height = origHeight;\r\n    canvas.style.cssText = origStyle;\r\n    window.dispatchEvent(new Event('resize'));\r\n  }\r\n\r\n  if (blob) {\r\n    setStep(handle, toStep);\r\n    downloadBlob(blob, `${filename}.mp4`);\r\n    updateStatus(`${(blob.size / 1024 / 1024).toFixed(1)}MB`);\r\n  } else {\r\n    updateStatus('Failed');\r\n  }\r\n\r\n  isRecording = false;\r\n  updateUI();\r\n}\r\n\r\nfunction updateUI(): void {\r\n  if (!uiUpdate) return;\r\n\r\n  const state: RecorderUIState = {\r\n    status: statusText,\r\n    isRecording,\r\n    hasCanvas: !!activeCanvas,\r\n    currentStep: activeCanvas ? getStep(activeCanvas) : 0,\r\n    maxStep: activeCanvas ? getMaxStepForHandle(activeCanvas) : 0,\r\n    canvases: handles.map((h) => ({\r\n      key: getConfigKey(h.config),\r\n      label: getDisplayName(h.config),\r\n    })),\r\n  };\r\n\r\n  uiUpdate(state);\r\n}\r\n\r\nfunction selectCanvas(key: string): void {\r\n  const handle = handles.find((h) => getConfigKey(h.config) === key);\r\n  if (handle) {\r\n    activeCanvas = handle;\r\n    updateUI();\r\n  }\r\n}\r\n\r\nfunction findCanvas(canvasConfig: BlogCanvasConfig): HTMLCanvasElement | null {\r\n  if (canvasConfig.iframeSelector) {\r\n    const iframe = document.querySelector(canvasConfig.iframeSelector) as HTMLIFrameElement;\r\n    if (!iframe?.contentDocument) return null;\r\n    return iframe.contentDocument.querySelector(`#${canvasConfig.canvasId}`) as HTMLCanvasElement;\r\n  }\r\n  return document.querySelector(`#${canvasConfig.canvasId}`) as HTMLCanvasElement;\r\n}\r\n\r\nfunction tryRegisterCanvas(canvasConfig: BlogCanvasConfig): boolean {\r\n  const canvas = findCanvas(canvasConfig);\r\n  if (!canvas?.__state__) return false;\r\n\r\n  const state = canvas.__state__;\r\n\r\n  let controllerEid: number | null = null;\r\n  if (canvasConfig.iframeSelector) {\r\n    controllerEid = canvas.__controllerEid__ ?? null;\r\n  } else {\r\n    controllerEid = getEntityByName(canvasConfig.controllerName);\r\n    if (controllerEid !== null && !state.hasComponent(controllerEid, StepController)) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  if (controllerEid === null) return false;\r\n\r\n  const existingHandle = handles.find((h) => getConfigKey(h.config) === getConfigKey(canvasConfig));\r\n  if (existingHandle) return true;\r\n\r\n  handles.push({\r\n    canvas,\r\n    config: canvasConfig,\r\n    controllerEid,\r\n    isIframe: !!canvasConfig.iframeSelector,\r\n  });\r\n  return true;\r\n}\r\n\r\nexport function setupBlogRecording(\r\n  canvasConfigs: BlogCanvasConfig[],\r\n  config: Partial<RecordingConfig> = {}\r\n): void {\r\n  const fullConfig = { ...DEFAULT_CONFIG, ...config };\r\n  const pending = new Set(canvasConfigs.map((c) => getConfigKey(c)));\r\n\r\n  const doRecord = async () => {\r\n    if (!activeCanvas || isRecording) return;\r\n    const from = getStep(activeCanvas);\r\n    const max = getMaxStepForHandle(activeCanvas);\r\n    if (from >= max) return;\r\n    await recordSequence(activeCanvas, from, from + 1, fullConfig);\r\n  };\r\n\r\n  const doPrev = () => {\r\n    if (!activeCanvas || isRecording) return;\r\n    const step = getStep(activeCanvas);\r\n    if (step > 0) {\r\n      setStep(activeCanvas, step - 1);\r\n      updateUI();\r\n    }\r\n  };\r\n\r\n  const doNext = () => {\r\n    if (!activeCanvas || isRecording) return;\r\n    const step = getStep(activeCanvas);\r\n    const max = getMaxStepForHandle(activeCanvas);\r\n    if (step < max) {\r\n      setStep(activeCanvas, step + 1);\r\n      updateUI();\r\n    }\r\n  };\r\n\r\n  const { element, update } = createRecorderUI({\r\n    onRecord: doRecord,\r\n    onPrev: doPrev,\r\n    onNext: doNext,\r\n    onCanvasChange: selectCanvas,\r\n    showSteps: true,\r\n    showCanvasSelect: canvasConfigs.length > 1,\r\n  });\r\n\r\n  uiUpdate = update;\r\n  document.body.appendChild(element);\r\n\r\n  const checkReady = setInterval(() => {\r\n    for (const canvasConfig of canvasConfigs) {\r\n      if (!pending.has(getConfigKey(canvasConfig))) continue;\r\n      if (tryRegisterCanvas(canvasConfig)) {\r\n        pending.delete(getConfigKey(canvasConfig));\r\n\r\n        if (!activeCanvas && handles.length > 0) {\r\n          activeCanvas = handles[0];\r\n          statusText = 'Ready';\r\n        }\r\n        updateUI();\r\n      }\r\n    }\r\n\r\n    if (pending.size === 0) clearInterval(checkReady);\r\n  }, 100);\r\n\r\n  setInterval(updateUI, 100);\r\n}\r\n","import '@blog-components/sequence/theme.css';\r\nimport { setupBlogRecording, type BlogCanvasConfig } from '@blog-components/recording';\r\nimport type { SequenceMap } from '@blog-components/sequence';\r\nimport './main';\r\n\r\nconst STEP_SEQUENCES: SequenceMap = {\r\n  '0-1': 'step-0-1',\r\n  '1-0': 'step-1-0',\r\n};\r\n\r\nconst canvasConfigs: BlogCanvasConfig[] = [\r\n  {\r\n    canvasId: 'canvas',\r\n    controllerName: 'controller',\r\n    sequenceMap: STEP_SEQUENCES,\r\n    iframeSelector: 'iframe[src*=\"steps\"]',\r\n  },\r\n  {\r\n    canvasId: 'canvas',\r\n    controllerName: 'controller',\r\n    sequenceMap: STEP_SEQUENCES,\r\n    iframeSelector: 'iframe[src*=\"grid\"]',\r\n  },\r\n];\r\n\r\nsetupBlogRecording(canvasConfigs);\r\n"],"names":["getDisplayName","config","match","getConfigKey","isRecording","activeCanvas","handles","uiUpdate","statusText","getStep","handle","StepController","setStep","step","getMaxStepForHandle","getMaxStep","updateStatus","msg","updateUI","sequenceMap","max","key","from","to","encodeSequenceFrames","canvas","state","seqEid","onProgress","Sequence","SequenceState","childEid","Pair","ChildOf","Tween","TweenState","maxDuration","duration","totalFrames","muxer","Muxer","ArrayBufferTarget","encoder","chunk","meta","e","stepTime","i","videoFrame","r","recordSequence","fromStep","toStep","canvasConfig","seqName","filename","blob","frame","total","getEntityByName","origWidth","origHeight","origStyle","downloadBlob","h","selectCanvas","findCanvas","iframe","tryRegisterCanvas","controllerEid","setupBlogRecording","canvasConfigs","fullConfig","DEFAULT_CONFIG","pending","c","doRecord","doPrev","doNext","element","update","createRecorderUI","checkReady","STEP_SEQUENCES"],"mappings":"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"}