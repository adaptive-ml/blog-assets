{"version":3,"mappings":"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","names":["A","k","T","U","x","Y","o","y","r","b","Re","rt","at","st","it","pe","fe","Ke","z","a","s","ue","de","K","u","Ye","Je","nt","M","p","c","me","X","f","d","P","i","ye","le","he","be","I","L","xe","ot","n","B","pt","g","ge","ve","Ce","ft","ne","Te","Z","oe","ut","$","te","Ie","J","Ee","We","Se","Me","De","Oe","H","re","W","l","R","Qe","v","D","se","He","ae","$e","qe","je","F","Pe","ie","E","ee","m","h","S","_e","Ge","ze","Q","ce","O","q","V","w","Be","It","_","Fe","we","j","N","G","C","Mt","Ne","Le","CycleError","message","toposort","nodes","edges","graph","inDegree","node","from","to","detectCycle","queue","sorted","dep","newDegree","visited","stack","hasCycle","Time","OrderingError","Scheduler","system","state","deltaTime","fixedDt","group","cached","all","filtered","sortSystems","systems","allSystems","validateSystems","first","last","normal","buildEdges","target","ref","checkGroup","refGroup","detectTarget","createWebRuntime","path","response","callback","createHeadlessRuntime","isWebviewResource","createStandaloneRuntime","readTextFile","readFile","_runtime","createRuntime","_initPromise","initRuntime","toKebabCase","str","toCamelCase","letter","traitsMap","setTraits","component","traits","getTraits","registry","registerComponent","name","kebabName","getRegisteredComponent","directAccessor","data","stride","offset","eid","resource","key","resourceKey","MAX_ENTITIES","State","canvas","createWorld","value","runtime","now","dt","pluginOrSystem","plugin","addEntity","removeEntity","entityExists","getAllEntities","terms","query","getEntityComponents","addComponent","defaults","comp","field","arr","components","removeComponent","removeComponents","hasComponent","getComponent","subject","relation","getRelationTargets","targets","dotIndex","bindingId","componentName","fieldPath","registered","camelPath","accessor","array","StateBuilder","plugins","loading","cleanup","pluginSet","allPlugins","completed","total","loadSceneFile","__vitePreload","xml","scenePath","result","defineRelation","options","bitecsCreateRelation","def","getRelationDef","ChildOf","DEG_TO_RAD","RAD_TO_DEG","clamp","min","max","eulerToQuaternion","hx","hy","hz","cx","sx","cy","sy","cz","sz","quaternionToEuler","x2","y2","z2","xx","xy","xz","yy","yz","zz","wx","wy","wz","m13","ey","lookAt","eyeX","eyeY","eyeZ","targetX","targetY","targetZ","upX","upY","upZ","zx","zy","zLen","xLen","yx","trace","qw","qx","qy","qz","nameStartChar","nameChar","nameRegexp","regexName","getAllMatches","string","regex","matches","match","allmatches","len","index","isName","isExist","defaultOptions","validate","xmlData","tags","tagFound","reachedRoot","readPI","tagStartPos","readCommentAndCDATA","closingTag","tagName","validateTagName","msg","getErrorObject","getLineNumberForPosition","readAttributeStr","attrStr","attrStrStart","isValid","validateAttributeString","otg","openPos","afterAmp","validateAmpersand","isWhiteSpace","t","char","start","tagname","angleBracketsCount","doubleQuote","singleQuote","startChar","tagClosed","validAttrStrRegxp","attrNames","getPositionFromMatch","attrName","validateAttrName","validateNumberAmpersand","count","code","lineNumber","lines","val","jPath","attrs","buildOptions","METADATA_SYMBOL","XmlNode","startIndex","DocTypeReader","processEntities","entities","hasBody","comment","exp","hasSeq","entityName","skipWhitespace","validateEntityName","entityValue","notationName","identifierType","publicIdentifier","systemIdentifier","type","identifierVal","elementName","contentModel","attributeName","attributeType","allowedNotations","notation","validTypes","defaultValue","seq","hexRegex","numRegex","consider","toNumber","trimmedStr","parse_int","resolveEnotation","sign","leadingZeros","numTrimmedByZeros","trimZeros","decimalAdjacentToLeadingZeros","num","parsedStr","eNotationRegx","eChar","eAdjacentToLeadingZeros","numStr","base","getIgnoreAttributesFn","ignoreAttributes","pattern","OrderedObjParser","addExternalEntities","parseXml","parseTextData","resolveNameSpace","buildAttributesMap","isItStopNode","replaceEntitiesValue","readStopNodeData","saveTextToParentTag","addChild","stopNodeExp","externalEntities","entKeys","ent","dontTrim","hasAttributes","isLeafNode","escapeEntities","newval","parseValue","prefix","attrsRegx","oldVal","aName","newVal","attrCollection","xmlObj","xmlNode","currentNode","textData","docTypeReader","closeIndex","findClosingIndex","colonIndex","lastTagName","propIndex","tagData","readTagExp","childNode","endIndex","tagExp","rawTagName","attrExpPresent","newTagName","lastTag","tagContent","entity","stopNodesExact","stopNodesWildcard","currentTagName","tagExpWithClosingIndex","closingChar","attrBoundary","ch","errMsg","closingIndex","removeNSPrefix","separatorIndex","openTagCount","shouldParse","prettify","compress","text","compressedObj","tagObj","property","propName","newJpath","isLeaf","isLeafTag","assignAttributes","obj","keys","attrMap","jpath","atrrName","textNodeName","propCount","XMLParser","validationOption","orderedObjParser","orderedResult","levenshtein","matrix","cost","findClosestMatch","input","candidates","inputKebab","bestMatch","bestScore","candidate","candidateKebab","distance","maxLen","threshold","errors","warnings","parser","raw","e","elements","normalizeRaw","el","child","parseEntityElement","isEntityRef","children","entityRefs","shorthands","entityId","attrValue","camel","matched","id","childEntity","item","rawAttrs","attrKey","attrVal","postLoadHooks","registerPostLoadHook","hook","LoadParseContext","loadScene","parseResult","instantiateScene","entityDefs","parseErrors","context","roots","entityDef","createEntityTree","parent","Pair","applyRelation","compDef","applyComponent","childDef","relationDef","targetEid","setFieldValue","values","parseAttrs","err","allValues","allErrors","isCSSAttrSyntax","parsePropertyString","detectVec2","detectVec3","detectVec4","parseNumber","parseValues","valueStr","trimmed","isWhitespace","isEnd","splitProperties","prop","propertyString","properties","colonIdx","rawName","parsed","nums","fieldNames","suggestion","PHASE_ORDER","inspect","nodeInfos","producers","out","inp","producer","byPhase","phase","executionOrder","topoSortIds","output","adjacency","phaseNodes","phaseInDegree","degree","topoSort","compile","ComputeGraph","removed","inspectGraph","createTimingCollector","nodeTimings","nodeId","timing","frameIndex","totalCpuMs","cpuMs","MIN_CANVAS_SIZE","syncCanvasSize","dpr","rect","width","height","resizeObserver","observedCanvas","createEntityIdBuffer","device","maxInstances","requestGPU","adapter","maxTextureDimension2D","Compute","ComputeSystem","compute","format","resources","plan","canvasView","encoder","ctx","texture","view","buffer","collector","ComputePlugin","Input","keysPressed","keysReleased","mouse","inputState","lastPointerX","lastPointerY","activePointerId","activeButton","handleKeyDown","handleKeyUp","setButtonState","button","pressed","clearPointerState","handlePointerDown","handlePointerUp","handlePointerCancel","handlePointerMove","handleWheel","handleContextMenu","resetFrameState","clearAllState","InputSystem","InputResetSystem","InputPlugin","linear","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInSine","easeOutSine","easeInOutSine","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInBack","easeOutBack","easeInOutBack","easeInElastic","easeOutElastic","easeInOutElastic","easeOutBounce","easeInBounce","easeInOutBounce","EASING_FUNCTIONS","EASING_INDEX","getEasingIndex","getEasing","compareNumbers","compareByEndTime","childrenBuffer","tweensBuffer","Pause","SequenceState","Sequence","getChildrenSorted","parentEid","childEid","computeTweenDelays","seqEid","cumulativeDelay","Tween","updateSequencePlayheads","prevElapsed","elapsed","TweenState","delay","shouldStart","wasStarted","captureFromValue","ensureSequenceResolved","duration","ensureResolved","ensureSequencesResolved","checkSequenceCompletion","allComplete","hasChildren","updateSequences","parseTweenAttrs","part","setupTweenFromXml","TweenTarget","parseTargetPath","rest","firstDot","pendingXmlTweens","_state","_context","tweenEid","finalizePendingTweens","pending","toValue","binding","updateTweens","tweenState","rawProgress","easedProgress","TweenSystem","TweenPlugin","wasm","compute_transforms","get_indices_ptr","get_matrices_ptr","get_max_entities","get_no_parent","get_parents_ptr","get_pos_x_ptr","get_pos_y_ptr","get_pos_z_ptr","get_quat_w_ptr","get_quat_x_ptr","get_quat_y_ptr","get_quat_z_ptr","get_scale_x_ptr","get_scale_y_ptr","get_scale_z_ptr","init_data","EXPECTED_RESPONSE_TYPES","__wbg_load","module","imports","bytes","instance","__wbg_get_imports","__wbg_finalize_init","__wbg_init","module_or_path","posX","posY","posZ","quatX","quatY","quatZ","quatW","scaleX","scaleY","scaleZ","matrices","indices","parents","NoParent","init","wasmInit","maxEntities","eulerProxy","axis","getValue","Transform","setValue","WorldTransform","wasm.init","wasm.posX","wasm.posY","wasm.posZ","wasm.quatX","wasm.quatY","wasm.quatZ","wasm.quatW","wasm.scaleX","wasm.scaleY","wasm.scaleZ","wasm.matrices","TransformSystem","Not","Wildcard","wasm.indices","wasm.parents","wasm.NoParent","Hierarchy","wasm.compute","TransformsPlugin","SCENE_UNIFORM_SIZE","DEPTH_FORMAT","MASK_FORMAT","createSceneBuffer","ensureRenderTextures","textures","textureViews","existing","scene","depth","mask","perspective","fov","aspect","near","far","nf","orthographic","size","lr","bt","multiply","invert","r00","r01","r02","r10","r11","r12","r20","r21","r22","tx","ty","tz","INDIRECT_SIZE","createIndirectBuffer","slotCount","writeIndirect","slot","args","litShader","createForwardPipeline","clearColor","createForwardNode","config","pipeline","bindGroups","targetView","depthView","pass","callbacks","preCallbacks","postCallbacks","drawCtx","batch","bindGroup","RenderMode","DebugMode","CameraMode","Camera","Tonemap","FXAA","Vignette","unpackColor","packed","uploadCamera","color","proj","world","viewProj","AmbientLight","DirectionalLight","normalizeDirection","packLightUniforms","ambient","directional","ambientRgb","dx","dy","dz","sunRgb","createBox","vertices","createSphere","segments","rings","theta","phi","nx","ny","nz","createPlane","meshes","initBuiltIns","MeshShape","getMesh","MeshColors","MeshSizes","colorProxy","colorChannelProxy","channelIndex","sizeProxy","Mesh","createMeshBuffers","mesh","vertex","collectByShape","byShape","shape","list","updateBatches","indirect","buffers","materials","MaterialType","MaterialIds","Material","hexToRgb","hex","packMaterials","mat","emissionColor","emissionIntensity","rgb","shader","FLAG_TONEMAP","FLAG_FXAA","FLAG_VIGNETTE","createPostProcessNode","uniforms","uniformBuffer","sampler","sceneView","maskView","flags","floats","uints","TransparentPass","createTransparentNode","contributors","contributor","OpaquePass","getOpaqueCallbacks","Render","RenderSystem","render","ambientData","directionalData","lightUniforms","meshEntities","DefaultMaterialSystem","RenderPlugin","createPropertyBuffer","renderState","opaqueState","transparentState","dark","light","LOGO_SVG","createOverlay","bg","overlay","createProgressBar","theme","track","bar","shallotLoading","logo","progressBar","progress","minimalLoading","shallotDark","minimalLight","DEFAULT_PLUGINS","canvasLoading","Tau","OrbitButton","Orbit","smoothLerp","smoothness","normalizeAngle","angleDiff","diff","isOrbitButton","OrbitSystem","sensitivity","zoomSpeed","minPitch","maxPitch","minDistance","maxDistance","currentDistance","distanceScale","zoomDelta","yaw","pitch","camX","camY","camZ","rotation","OrbitPlugin","LineData","lineProxy","Line","ArrowData","arrowProxy","Arrow","TextData","textProxy","Text","StepController","entityLookup","captureEntityLookup","getEntityByName","createStepControllerSystem","sequenceMap","isTransitioning","current","seqName","targetSeqEid","createStepPlugin"],"ignoreList":[0,1,11,12,13,14,15,16,17,18,19,20],"sources":["../../../node_modules/bitecs/dist/core/index.min.mjs","../../../../shallot/node_modules/bitecs/dist/core/index.min.mjs","../../../../shallot/packages/shallot/src/core/scheduler.ts","../../../../shallot/packages/shallot/src/core/runtime.ts","../../../../shallot/packages/shallot/src/core/strings.ts","../../../../shallot/packages/shallot/src/core/component.ts","../../../../shallot/packages/shallot/src/core/resource.ts","../../../../shallot/packages/shallot/src/core/state.ts","../../../../shallot/packages/shallot/src/core/builder.ts","../../../../shallot/packages/shallot/src/core/relation.ts","../../../../shallot/packages/shallot/src/core/math.ts","../../../../shallot/node_modules/fast-xml-parser/src/util.js","../../../../shallot/node_modules/fast-xml-parser/src/validator.js","../../../../shallot/node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js","../../../../shallot/node_modules/fast-xml-parser/src/xmlparser/xmlNode.js","../../../../shallot/node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js","../../../../shallot/node_modules/strnum/strnum.js","../../../../shallot/node_modules/fast-xml-parser/src/ignoreAttributes.js","../../../../shallot/node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js","../../../../shallot/node_modules/fast-xml-parser/src/xmlparser/node2json.js","../../../../shallot/node_modules/fast-xml-parser/src/xmlparser/XMLParser.js","../../../../shallot/packages/shallot/src/core/xml.ts","../../../../shallot/packages/shallot/src/standard/compute/inspect.ts","../../../../shallot/packages/shallot/src/standard/compute/graph.ts","../../../../shallot/packages/shallot/src/standard/compute/timing.ts","../../../../shallot/packages/shallot/src/standard/compute/index.ts","../../../../shallot/packages/shallot/src/standard/input/index.ts","../../../../shallot/packages/shallot/src/standard/tween/easing.ts","../../../../shallot/packages/shallot/src/standard/tween/sequence.ts","../../../../shallot/packages/shallot/src/standard/tween/tween.ts","../../../../shallot/packages/shallot/rust/transforms/pkg/shallot_transforms.js","../../../../shallot/packages/shallot/src/standard/transforms/wasm.ts","../../../../shallot/packages/shallot/src/standard/transforms/index.ts","../../../../shallot/packages/shallot/src/standard/render/scene.ts","../../../../shallot/packages/shallot/src/standard/render/forward.ts","../../../../shallot/packages/shallot/src/standard/render/camera.ts","../../../../shallot/packages/shallot/src/standard/render/light.ts","../../../../shallot/packages/shallot/src/standard/render/mesh/box.ts","../../../../shallot/packages/shallot/src/standard/render/mesh/sphere.ts","../../../../shallot/packages/shallot/src/standard/render/mesh/plane.ts","../../../../shallot/packages/shallot/src/standard/render/mesh/index.ts","../../../../shallot/packages/shallot/src/standard/render/material/index.ts","../../../../shallot/packages/shallot/src/standard/render/postprocess.ts","../../../../shallot/packages/shallot/src/standard/render/transparent.ts","../../../../shallot/packages/shallot/src/standard/render/opaque.ts","../../../../shallot/packages/shallot/src/standard/render/index.ts","../../../../shallot/packages/shallot/src/standard/loading/index.ts","../../../../shallot/packages/shallot/src/standard/defaults.ts","../../../../shallot/packages/shallot/src/extras/orbit/index.ts","../../../../shallot/packages/shallot/src/extras/lines/index.ts","../../../../shallot/packages/shallot/src/extras/arrows/index.ts","../../../../shallot/packages/shallot/src/extras/text/index.ts","../../../src/sequence/step-plugin.ts"],"sourcesContent":["var A=(e,t,n)=>Object.defineProperty(e,t,{value:n,enumerable:!1,writable:!0,configurable:!0});var pe=(e,t)=>t&e.entityMask,fe=(e,t)=>t>>>e.versionShift&(1<<e.versionBits)-1,Ke=(e,t)=>{let o=fe(e,t)+1&(1<<e.versionBits)-1;return t&e.entityMask|o<<e.versionShift},Xe=e=>({versioning:!0,versionBits:e}),z=e=>{let t=e?typeof e==\"function\"?e():e:{versioning:!1,versionBits:8},n=t.versionBits??8,o=t.versioning??!1,r=32-n,a=(1<<r)-1,i=r,s=(1<<n)-1<<i;return{aliveCount:0,dense:[],sparse:[],maxId:0,versioning:o,versionBits:n,entityMask:a,versionShift:i,versionMask:s}},ue=e=>{if(e.aliveCount<e.dense.length){let n=e.dense[e.aliveCount],o=n;return e.sparse[o]=e.aliveCount,e.aliveCount++,n}let t=++e.maxId;return e.dense.push(t),e.sparse[t]=e.aliveCount,e.aliveCount++,t},de=(e,t)=>{let n=e.sparse[t];if(n===void 0||n>=e.aliveCount)return;let o=e.aliveCount-1,r=e.dense[o];if(e.sparse[r]=n,e.dense[n]=r,e.sparse[t]=o,e.dense[o]=t,e.versioning){let a=Ke(e,t);e.dense[o]=a}e.aliveCount--},K=(e,t)=>{let n=pe(e,t),o=e.sparse[n];return o!==void 0&&o<e.aliveCount&&e.dense[o]===t};var u=Symbol.for(\"bitecs_internal\"),Ye=(e,t)=>A(e||{},u,{entityIndex:t||z(),entityMasks:[[]],entityComponents:new Map,bitflag:1,componentMap:new Map,componentCount:0,queries:new Set,queriesHashMap:new Map,notQueries:new Set,dirtyQueries:new Set,entitiesWithRelations:new Set,hierarchyData:new Map,hierarchyActiveRelations:new Set,hierarchyQueryCache:new Map});function Je(...e){let t,n;return e.forEach(o=>{typeof o==\"object\"&&\"dense\"in o&&\"sparse\"in o&&\"aliveCount\"in o?t=o:typeof o==\"object\"&&(n=o)}),Ye(n,t)}var Ze=e=>{let t=e[u];return t.entityIndex=z(),t.entityMasks=[[]],t.entityComponents=new Map,t.bitflag=1,t.componentMap=new Map,t.componentCount=0,t.queries=new Set,t.queriesHashMap=new Map,t.notQueries=new Set,t.dirtyQueries=new Set,t.entitiesWithRelations=new Set,t.hierarchyData=new Map,t.hierarchyActiveRelations=new Set,t.hierarchyQueryCache=new Map,e},et=e=>{delete e[u]},tt=e=>Array.from(e[u].componentMap.keys()),nt=e=>Array.from(e[u].entityComponents.keys());var M=()=>{let e=[],t=[],n=s=>e[t[s]]===s;return{add:s=>{n(s)||(t[s]=e.push(s)-1)},remove:s=>{if(!n(s))return;let p=t[s],c=e.pop();c!==s&&(e[p]=c,t[c]=p)},has:n,sparse:t,dense:e,reset:()=>{e.length=0,t.length=0},sort:s=>{e.sort(s);for(let p=0;p<e.length;p++)t[e[p]]=p}}},me=typeof SharedArrayBuffer<\"u\"?SharedArrayBuffer:ArrayBuffer,X=(e=1e3)=>{let t=[],n=0,o=new Uint32Array(new me(e*4)),r=c=>c<t.length&&t[c]<n&&o[t[c]]===c;return{add:c=>{if(!r(c)){if(n>=o.length){let f=new Uint32Array(new me(o.length*2*4));f.set(o),o=f}o[n]=c,t[c]=n,n++}},remove:c=>{if(!r(c))return;n--;let f=t[c],d=o[n];o[f]=d,t[d]=f},has:r,sparse:t,get dense(){return new Uint32Array(o.buffer,0,n)},reset:()=>{n=0,t.length=0},sort:c=>{let f=Array.from(o.subarray(0,n));f.sort(c);for(let d=0;d<f.length;d++)o[d]=f[d];for(let d=0;d<n;d++)t[o[d]]=d}}};var P=()=>{let e=new Set;return{subscribe:o=>(e.add(o),()=>{e.delete(o)}),notify:(o,...r)=>Array.from(e).reduce((a,i)=>{let s=i(o,...r);return s&&typeof s==\"object\"?{...a,...s}:a},{})}};var k=Symbol.for(\"bitecs-relation\"),T=Symbol.for(\"bitecs-pairTarget\"),U=Symbol.for(\"bitecs-isPairComponent\"),x=Symbol.for(\"bitecs-relationData\"),Y=()=>{let e={pairsMap:new Map,initStore:void 0,exclusiveRelation:!1,autoRemoveSubject:!1,onTargetRemoved:void 0},t=n=>{if(n===void 0)throw Error(\"Relation target is undefined\");let o=n===\"*\"?y:n;if(!e.pairsMap.has(o)){let r=e.initStore?e.initStore(n):{};A(r,k,t),A(r,T,o),A(r,U,!0),e.pairsMap.set(o,r)}return e.pairsMap.get(o)};return A(t,x,e),t},ye=e=>t=>{let n=t[x];return n.initStore=e,t},le=e=>{let t=e[x];return t.exclusiveRelation=!0,e},he=e=>{let t=e[x];return t.autoRemoveSubject=!0,e},be=e=>t=>{let n=t[x];return n.onTargetRemoved=e,t};var b=(e,t)=>{if(e===void 0)throw Error(\"Relation is undefined\");return e(t)},I=(e,t,n)=>{let o=L(e,t),r=[];for(let a of o)a[k]===n&&a[T]!==y&&!xe(a[T])&&r.push(a[T]);return r};function ot(...e){if(e.length===1&&typeof e[0]==\"object\"){let{store:t,exclusive:n,autoRemoveSubject:o,onTargetRemoved:r}=e[0];return[t&&ye(t),n&&le,o&&he,r&&be(r)].filter(Boolean).reduce((i,s)=>s(i),Y())}else return e.reduce((n,o)=>o(n),Y())}var Re=Symbol.for(\"bitecs-wildcard\");function rt(){let e=Y();return Object.defineProperty(e,Re,{value:!0,enumerable:!1,writable:!1,configurable:!1}),e}function at(){let e=Symbol.for(\"bitecs-global-wildcard\");return globalThis[e]||(globalThis[e]=rt()),globalThis[e]}var y=at();function st(){return Y()}function it(){let e=Symbol.for(\"bitecs-global-isa\");return globalThis[e]||(globalThis[e]=st()),globalThis[e]}var B=it();function ct(e){return e?Object.getOwnPropertySymbols(e).includes(Re):!1}function xe(e){return e?Object.getOwnPropertySymbols(e).includes(x):!1}var pt=64,g=4294967295,ge=1024;function ve(e,t){let{depths:n}=e;if(t<n.length)return n;let o=Math.max(t+1,n.length*2,n.length+ge),r=new Uint32Array(o);return r.fill(g),r.set(n),e.depths=r,r}function Ce(e,t,n,o){let{depthToEntities:r}=e;if(o!==void 0&&o!==g){let a=r.get(o);a&&(a.remove(t),a.dense.length===0&&r.delete(o))}n!==g&&(r.has(n)||r.set(n,X()),r.get(n).add(t))}function ft(e,t){t>e.maxDepth&&(e.maxDepth=t)}function ne(e,t,n,o){e.depths[t]=n,Ce(e,t,n,o),ft(e,n)}function Te(e,t){e[u].hierarchyQueryCache.delete(t)}function Z(e,t){let n=e[u];return n.hierarchyActiveRelations.has(t)||(n.hierarchyActiveRelations.add(t),oe(e,t),ut(e,t)),n.hierarchyData.get(t)}function ut(e,t){let n=$(e,[b(t,y)]);for(let r of n)te(e,t,r);let o=new Set;for(let r of n)for(let a of I(e,r,t))o.has(a)||(o.add(a),te(e,t,a))}function oe(e,t){let n=e[u];if(!n.hierarchyData.has(t)){let o=Math.max(ge,n.entityIndex.dense.length*2),r=new Uint32Array(o);r.fill(g),n.hierarchyData.set(t,{depths:r,dirty:M(),depthToEntities:new Map,maxDepth:0})}}function Ie(e,t,n,o=new Set){if(o.has(n))return 0;o.add(n);let r=I(e,n,t);if(r.length===0)return 0;if(r.length===1)return J(e,t,r[0],o)+1;let a=1/0;for(let i of r){let s=J(e,t,i,o);if(s<a&&(a=s,a===0))break}return a===1/0?0:a+1}function J(e,t,n,o){let r=e[u];oe(e,t);let a=r.hierarchyData.get(t),{depths:i}=a;if(i=ve(a,n),i[n]===g){let s=Ie(e,t,n,o);return ne(a,n,s),s}return i[n]}function te(e,t,n){return J(e,t,n,new Set)}function Ee(e,t,n,o,r=M()){if(r.has(n))return;r.add(n);let a=$(e,[t(n)]);for(let i of a)o.add(i),Ee(e,t,i,o,r)}function We(e,t,n,o,r=new Set){let a=e[u];if(!a.hierarchyActiveRelations.has(t))return;oe(e,t);let i=a.hierarchyData.get(t);if(r.has(n)){i.dirty.add(n);return}r.add(n);let{depths:s,dirty:p}=i,c=o!==void 0?te(e,t,o)+1:0;if(c>pt)return;let f=s[n];ne(i,n,c,f===g?void 0:f),f!==c&&(Ee(e,t,n,p,M()),Te(e,t))}function Se(e,t,n){let o=e[u];if(!o.hierarchyActiveRelations.has(t))return;let r=o.hierarchyData.get(t),{depths:a}=r;a=ve(r,n),Me(e,t,n,a,M()),Te(e,t)}function Me(e,t,n,o,r){if(r.has(n))return;r.add(n);let i=e[u].hierarchyData.get(t);if(n<o.length){let p=o[n];p!==g&&(i.depths[n]=g,Ce(i,n,g,p))}let s=$(e,[t(n)]);for(let p of s)Me(e,t,p,o,r)}function De(e,t){let o=e[u].hierarchyData.get(t);if(!o)return;let{dirty:r,depths:a}=o;if(r.dense.length!==0){for(let i of r.dense)if(a[i]===g){let s=Ie(e,t,i);ne(o,i,s)}r.reset()}}function Oe(e,t,n,o={}){let r=e[u];Z(e,t);let a=H(e,[t,...n]),i=r.hierarchyQueryCache.get(t);if(i&&i.hash===a)return i.result;De(e,t),re(e,n,o);let s=r.queriesHashMap.get(H(e,n)),p=r.hierarchyData.get(t),{depths:c}=p;s.sort((d,W)=>{let l=c[d],R=c[W];return l!==R?l-R:d-W});let f=(o.buffered,s.dense);return r.hierarchyQueryCache.set(t,{hash:a,result:f}),f}function Qe(e,t,n,o={}){let r=Z(e,t);De(e,t);let a=r.depthToEntities.get(n);return a?(o.buffered,a.dense):o.buffered?new Uint32Array(0):[]}function dt(e,t,n){return Z(e,n),J(e,n,t,new Set)}function mt(e,t){return Z(e,t).maxDepth}var v=Symbol.for(\"bitecs-opType\"),D=Symbol.for(\"bitecs-opTerms\"),se=e=>(...t)=>({[v]:e,[D]:t}),Ae=se(\"Or\"),ke=se(\"And\"),He=se(\"Not\"),yt=Ae,lt=ke,ht=He,ae=Symbol.for(\"bitecs-hierarchyType\"),$e=Symbol.for(\"bitecs-hierarchyRel\"),qe=Symbol.for(\"bitecs-hierarchyDepth\"),je=(e,t)=>({[ae]:\"Hierarchy\",[$e]:e,[qe]:t}),bt=je,F=Symbol.for(\"bitecs-modifierType\"),Rt={[F]:\"buffer\"},Pe={[F]:\"nested\"},ie=Pe,Ue=e=>(...t)=>({[v]:e,[D]:t}),xt=Ue(\"add\"),gt=Ue(\"remove\"),vt=e=>({[v]:\"set\",[D]:[e]}),Ct=e=>({[v]:\"get\",[D]:[e]});function Tt(e,t,n){let o=e[u],{[v]:r,[D]:a}=t;if(r===\"add\"||r===\"remove\")return(o.queriesHashMap.get(H(e,a))||ee(e,a))[r===\"add\"?\"addObservable\":\"removeObservable\"].subscribe(n);if(r===\"set\"||r===\"get\"){if(a.length!==1)throw new Error(\"Set and Get hooks can only observe a single component\");return(o.componentMap.get(a[0])||E(e,a[0]))[r===\"set\"?\"setObservable\":\"getObservable\"].subscribe(n)}throw new Error(`Invalid hook type: ${r}`)}var H=(e,t)=>{let n=e[u],o=a=>(n.componentMap.has(a)||E(e,a),n.componentMap.get(a).id),r=a=>v in a?`${a[v].toLowerCase()}(${a[D].map(r).sort().join(\",\")})`:o(a).toString();return t.map(r).sort().join(\"-\")},ee=(e,t,n={})=>{let o=e[u],r=H(e,t),a=[],i=m=>{v in m?m[D].forEach(i):(o.componentMap.has(m)||E(e,m),a.push(m))};t.forEach(i);let s=[],p=[],c=[],f=(m,h)=>{h.forEach(S=>{o.componentMap.has(S)||E(e,S),m.push(S)})};t.forEach(m=>{if(v in m){let{[v]:h,[D]:S}=m;if(h===\"Not\")f(p,S);else if(h===\"Or\")f(c,S);else if(h===\"And\")f(s,S);else throw new Error(`Nested combinator ${h} not supported yet - use simple queries for best performance`)}else o.componentMap.has(m)||E(e,m),s.push(m)});let d=a.map(m=>o.componentMap.get(m)),W=[...new Set(d.map(m=>m.generationId))],l=(m,h)=>(m[h.generationId]=(m[h.generationId]||0)|h.bitflag,m),R=s.map(m=>o.componentMap.get(m)).reduce(l,{}),_e=p.map(m=>o.componentMap.get(m)).reduce(l,{}),Ge=c.map(m=>o.componentMap.get(m)).reduce(l,{}),ze=d.reduce(l,{}),Q=Object.assign(n.buffered?X():M(),{allComponents:a,orComponents:c,notComponents:p,masks:R,notMasks:_e,orMasks:Ge,hasMasks:ze,generations:W,toRemove:M(),addObservable:P(),removeObservable:P(),queues:{}});o.queries.add(Q),o.queriesHashMap.set(r,Q),d.forEach(m=>{m.queries.add(Q)}),p.length&&o.notQueries.add(Q);let ce=o.entityIndex;for(let m=0;m<ce.aliveCount;m++){let h=ce.dense[m];if(O(e,h,q))continue;V(e,Q,h)&&w(Q,h)}return Q};function re(e,t,n={}){let o=e[u],r=H(e,t),a=o.queriesHashMap.get(r);return a?n.buffered&&!(\"buffer\"in a.dense)&&(a=ee(e,t,{buffered:!0})):a=ee(e,t,n),n.buffered,a.dense}function $(e,t,...n){let o=t.find(p=>p&&typeof p==\"object\"&&ae in p),r=t.filter(p=>!(p&&typeof p==\"object\"&&ae in p)),a=!1,i=!0,s=n.some(p=>p&&typeof p==\"object\"&&F in p);for(let p of n)if(s&&p&&typeof p==\"object\"&&F in p){let c=p;c[F]===\"buffer\"&&(a=!0),c[F]===\"nested\"&&(i=!1)}else if(!s){let c=p;c.buffered!==void 0&&(a=c.buffered),c.commit!==void 0&&(i=c.commit)}if(o){let{[$e]:p,[qe]:c}=o;return c!==void 0?Qe(e,p,c,{buffered:a}):Oe(e,p,r,{buffered:a})}return i&&Be(e),re(e,r,{buffered:a})}function V(e,t,n){let o=e[u],{masks:r,notMasks:a,orMasks:i,generations:s}=t,p=Object.keys(i).length===0;for(let c=0;c<s.length;c++){let f=s[c],d=r[f],W=a[f],l=i[f],R=o.entityMasks[f][n];if(W&&R&W||d&&(R&d)!==d)return!1;l&&R&l&&(p=!0)}return p}var w=(e,t)=>{if(e.toRemove.has(t)){e.toRemove.remove(t),e.addObservable.notify(t);return}e.has(t)||(e.add(t),e.addObservable.notify(t))},It=e=>{for(let t=0;t<e.toRemove.dense.length;t++){let n=e.toRemove.dense[t];e.remove(n)}e.toRemove.reset()},Be=e=>{let t=e[u];t.dirtyQueries.size&&(t.dirtyQueries.forEach(It),t.dirtyQueries.clear())},_=(e,t,n)=>{let o=e[u];!t.has(n)||t.toRemove.has(n)||(t.toRemove.add(n),o.dirtyQueries.add(t),t.removeObservable.notify(n))},Et=(e,t)=>{let n=e[u],o=H(e,t),r=n.queriesHashMap.get(o);r&&(n.queries.delete(r),n.queriesHashMap.delete(o))};var E=(e,t)=>{if(!t)throw new Error(\"bitECS - Cannot register null or undefined component\");let n=e[u],o=new Set,r={id:n.componentCount++,generationId:n.entityMasks.length-1,bitflag:n.bitflag,ref:t,queries:o,setObservable:P(),getObservable:P()};return n.componentMap.set(t,r),n.bitflag*=2,n.bitflag>=2**31&&(n.bitflag=1,n.entityMasks.push([])),r},Wt=(e,t)=>{t.forEach(n=>E(e,n))},O=(e,t,n)=>{let o=e[u],r=o.componentMap.get(n);if(!r)return!1;let{generationId:a,bitflag:i}=r;return(o.entityMasks[a][t]&i)===i},Fe=(e,t,n)=>{let r=e[u].componentMap.get(n);if(r&&O(e,t,n))return r.getObservable.notify(t)},Ve=(e,t)=>({component:e,data:t}),we=(e,t,n,o,r=new Set)=>{if(!r.has(o)){r.add(o),j(t,n,B(o));for(let a of L(t,o))if(a!==q&&!O(t,n,a)){j(t,n,a);let i=e.componentMap.get(a);if(i?.setObservable){let s=Fe(t,o,a);i.setObservable.notify(n,s)}}for(let a of I(t,o,B))we(e,t,n,a,r)}},St=(e,t,n,o)=>{j(e,t,Ve(n,o))},j=(e,t,n)=>{if(!N(e,t))throw new Error(`Cannot add component - entity ${t} does not exist in the world.`);let o=e[u],r=\"component\"in n?n.component:n,a=\"data\"in n?n.data:void 0;o.componentMap.has(r)||E(e,r);let i=o.componentMap.get(r);if(O(e,t,r))return a!==void 0&&i.setObservable.notify(t,a),!1;let{generationId:s,bitflag:p,queries:c}=i;if(o.entityMasks[s][t]|=p,O(e,t,q)||c.forEach(f=>{V(e,f,t)?w(f,t):_(e,f,t)}),o.entityComponents.get(t).add(r),a!==void 0&&i.setObservable.notify(t,a),r[U]){let f=r[k],d=r[T];if(G(e,t,b(f,y),b(y,d)),typeof d==\"number\"&&(G(e,d,b(y,t),b(y,f)),o.entitiesWithRelations.add(d),o.entitiesWithRelations.add(t)),o.entitiesWithRelations.add(d),f[x].exclusiveRelation===!0&&d!==y){let l=I(e,t,f)[0];l!=null&&l!==d&&C(e,t,f(l))}if(f===B){let l=I(e,t,B);for(let R of l)we(o,e,t,R)}We(e,f,t,typeof d==\"number\"?d:void 0)}return!0};function G(e,t,...n){(Array.isArray(n[0])?n[0]:n).forEach(r=>{j(e,t,r)})}var C=(e,t,...n)=>{let o=e[u];if(!N(e,t))throw new Error(`Cannot remove component - entity ${t} does not exist in the world.`);n.forEach(r=>{if(!O(e,t,r))return;let a=o.componentMap.get(r),{generationId:i,bitflag:s,queries:p}=a;if(o.entityMasks[i][t]&=~s,p.forEach(c=>{c.toRemove.remove(t),V(e,c,t)?w(c,t):_(e,c,t)}),o.entityComponents.get(t).delete(r),r[U]){let c=r[T],f=r[k];Se(e,f,t),C(e,t,b(y,c)),typeof c==\"number\"&&N(e,c)&&(C(e,c,b(y,t)),C(e,c,b(y,f))),I(e,t,f).length===0&&C(e,t,b(f,y))}})},Mt=C;var q={},Dt=e=>{let t=Ne(e);return j(e,t,q),t};function Ne(e,...t){let n=e[u],o=ue(n.entityIndex);return n.notQueries.forEach(r=>{V(e,r,o)&&w(r,o)}),n.entityComponents.set(o,new Set),t.length>0&&G(e,o,t),o}var Le=(e,t)=>{let n=e[u];if(!K(n.entityIndex,t))return;let o=[t],r=new Set;for(;o.length>0;){let a=o.shift();if(r.has(a))continue;r.add(a);let i=[];if(n.entitiesWithRelations.has(a)){for(let s of $(e,[y(a)],ie))if(N(e,s))for(let p of n.entityComponents.get(s)){if(!p[U])continue;let f=p[k][x];i.push(()=>C(e,s,b(y,a))),p[T]===a&&(i.push(()=>C(e,s,p)),f.autoRemoveSubject&&o.push(s),f.onTargetRemoved&&i.push(()=>f.onTargetRemoved(e,s,a)))}n.entitiesWithRelations.delete(a)}for(let s of i)s();for(let s of o)Le(e,s);for(let s of n.queries)_(e,s,a);de(n.entityIndex,a),n.entityComponents.delete(a);for(let s=0;s<n.entityMasks.length;s++)n.entityMasks[s][a]=0}},L=(e,t)=>{let n=e[u];if(t===void 0)throw new Error(\"getEntityComponents: entity id is undefined.\");if(!K(n.entityIndex,t))throw new Error(`getEntityComponents: entity ${t} does not exist in the world.`);return Array.from(n.entityComponents.get(t))},N=(e,t)=>K(e[u].entityIndex,t);var Ot=(...e)=>(...t)=>e.reduce((n,o)=>[o(...n)],t)[0];var Qt=e=>e;function At(e){let t=[];return e?Object.assign(t,e):t}export{u as $internal,lt as All,ke as And,yt as Any,bt as Cascade,je as Hierarchy,B as IsA,ht as None,He as Not,Ae as Or,b as Pair,q as Prefab,y as Wildcard,j as addComponent,G as addComponents,Ne as addEntity,Dt as addPrefab,At as aos,Rt as asBuffer,Be as commitRemovals,z as createEntityIndex,ot as createRelation,Je as createWorld,et as deleteWorld,N as entityExists,nt as getAllEntities,Fe as getComponent,L as getEntityComponents,dt as getHierarchyDepth,pe as getId,mt as getMaxHierarchyDepth,I as getRelationTargets,fe as getVersion,tt as getWorldComponents,O as hasComponent,Pe as isNested,xe as isRelation,ct as isWildcard,le as makeExclusive,ie as noCommit,Tt as observe,xt as onAdd,Ct as onGet,gt as onRemove,vt as onSet,Ot as pipe,$ as query,E as registerComponent,Wt as registerComponents,ee as registerQuery,C as removeComponent,Mt as removeComponents,Le as removeEntity,Et as removeQuery,Ze as resetWorld,Ve as set,St as setComponent,Qt as soa,he as withAutoRemoveSubject,be as withOnTargetRemoved,ye as withStore,Xe as withVersioning};\n//# sourceMappingURL=index.min.mjs.map\n","var A=(e,t,n)=>Object.defineProperty(e,t,{value:n,enumerable:!1,writable:!0,configurable:!0});var pe=(e,t)=>t&e.entityMask,fe=(e,t)=>t>>>e.versionShift&(1<<e.versionBits)-1,Ke=(e,t)=>{let o=fe(e,t)+1&(1<<e.versionBits)-1;return t&e.entityMask|o<<e.versionShift},Xe=e=>({versioning:!0,versionBits:e}),z=e=>{let t=e?typeof e==\"function\"?e():e:{versioning:!1,versionBits:8},n=t.versionBits??8,o=t.versioning??!1,r=32-n,a=(1<<r)-1,i=r,s=(1<<n)-1<<i;return{aliveCount:0,dense:[],sparse:[],maxId:0,versioning:o,versionBits:n,entityMask:a,versionShift:i,versionMask:s}},ue=e=>{if(e.aliveCount<e.dense.length){let n=e.dense[e.aliveCount],o=n;return e.sparse[o]=e.aliveCount,e.aliveCount++,n}let t=++e.maxId;return e.dense.push(t),e.sparse[t]=e.aliveCount,e.aliveCount++,t},de=(e,t)=>{let n=e.sparse[t];if(n===void 0||n>=e.aliveCount)return;let o=e.aliveCount-1,r=e.dense[o];if(e.sparse[r]=n,e.dense[n]=r,e.sparse[t]=o,e.dense[o]=t,e.versioning){let a=Ke(e,t);e.dense[o]=a}e.aliveCount--},K=(e,t)=>{let n=pe(e,t),o=e.sparse[n];return o!==void 0&&o<e.aliveCount&&e.dense[o]===t};var u=Symbol.for(\"bitecs_internal\"),Ye=(e,t)=>A(e||{},u,{entityIndex:t||z(),entityMasks:[[]],entityComponents:new Map,bitflag:1,componentMap:new Map,componentCount:0,queries:new Set,queriesHashMap:new Map,notQueries:new Set,dirtyQueries:new Set,entitiesWithRelations:new Set,hierarchyData:new Map,hierarchyActiveRelations:new Set,hierarchyQueryCache:new Map});function Je(...e){let t,n;return e.forEach(o=>{typeof o==\"object\"&&\"dense\"in o&&\"sparse\"in o&&\"aliveCount\"in o?t=o:typeof o==\"object\"&&(n=o)}),Ye(n,t)}var Ze=e=>{let t=e[u];return t.entityIndex=z(),t.entityMasks=[[]],t.entityComponents=new Map,t.bitflag=1,t.componentMap=new Map,t.componentCount=0,t.queries=new Set,t.queriesHashMap=new Map,t.notQueries=new Set,t.dirtyQueries=new Set,t.entitiesWithRelations=new Set,t.hierarchyData=new Map,t.hierarchyActiveRelations=new Set,t.hierarchyQueryCache=new Map,e},et=e=>{delete e[u]},tt=e=>Array.from(e[u].componentMap.keys()),nt=e=>Array.from(e[u].entityComponents.keys());var M=()=>{let e=[],t=[],n=s=>e[t[s]]===s;return{add:s=>{n(s)||(t[s]=e.push(s)-1)},remove:s=>{if(!n(s))return;let p=t[s],c=e.pop();c!==s&&(e[p]=c,t[c]=p)},has:n,sparse:t,dense:e,reset:()=>{e.length=0,t.length=0},sort:s=>{e.sort(s);for(let p=0;p<e.length;p++)t[e[p]]=p}}},me=typeof SharedArrayBuffer<\"u\"?SharedArrayBuffer:ArrayBuffer,X=(e=1e3)=>{let t=[],n=0,o=new Uint32Array(new me(e*4)),r=c=>c<t.length&&t[c]<n&&o[t[c]]===c;return{add:c=>{if(!r(c)){if(n>=o.length){let f=new Uint32Array(new me(o.length*2*4));f.set(o),o=f}o[n]=c,t[c]=n,n++}},remove:c=>{if(!r(c))return;n--;let f=t[c],d=o[n];o[f]=d,t[d]=f},has:r,sparse:t,get dense(){return new Uint32Array(o.buffer,0,n)},reset:()=>{n=0,t.length=0},sort:c=>{let f=Array.from(o.subarray(0,n));f.sort(c);for(let d=0;d<f.length;d++)o[d]=f[d];for(let d=0;d<n;d++)t[o[d]]=d}}};var P=()=>{let e=new Set;return{subscribe:o=>(e.add(o),()=>{e.delete(o)}),notify:(o,...r)=>Array.from(e).reduce((a,i)=>{let s=i(o,...r);return s&&typeof s==\"object\"?{...a,...s}:a},{})}};var k=Symbol.for(\"bitecs-relation\"),T=Symbol.for(\"bitecs-pairTarget\"),U=Symbol.for(\"bitecs-isPairComponent\"),x=Symbol.for(\"bitecs-relationData\"),Y=()=>{let e={pairsMap:new Map,initStore:void 0,exclusiveRelation:!1,autoRemoveSubject:!1,onTargetRemoved:void 0},t=n=>{if(n===void 0)throw Error(\"Relation target is undefined\");let o=n===\"*\"?y:n;if(!e.pairsMap.has(o)){let r=e.initStore?e.initStore(n):{};A(r,k,t),A(r,T,o),A(r,U,!0),e.pairsMap.set(o,r)}return e.pairsMap.get(o)};return A(t,x,e),t},ye=e=>t=>{let n=t[x];return n.initStore=e,t},le=e=>{let t=e[x];return t.exclusiveRelation=!0,e},he=e=>{let t=e[x];return t.autoRemoveSubject=!0,e},be=e=>t=>{let n=t[x];return n.onTargetRemoved=e,t};var b=(e,t)=>{if(e===void 0)throw Error(\"Relation is undefined\");return e(t)},I=(e,t,n)=>{let o=L(e,t),r=[];for(let a of o)a[k]===n&&a[T]!==y&&!xe(a[T])&&r.push(a[T]);return r};function ot(...e){if(e.length===1&&typeof e[0]==\"object\"){let{store:t,exclusive:n,autoRemoveSubject:o,onTargetRemoved:r}=e[0];return[t&&ye(t),n&&le,o&&he,r&&be(r)].filter(Boolean).reduce((i,s)=>s(i),Y())}else return e.reduce((n,o)=>o(n),Y())}var Re=Symbol.for(\"bitecs-wildcard\");function rt(){let e=Y();return Object.defineProperty(e,Re,{value:!0,enumerable:!1,writable:!1,configurable:!1}),e}function at(){let e=Symbol.for(\"bitecs-global-wildcard\");return globalThis[e]||(globalThis[e]=rt()),globalThis[e]}var y=at();function st(){return Y()}function it(){let e=Symbol.for(\"bitecs-global-isa\");return globalThis[e]||(globalThis[e]=st()),globalThis[e]}var B=it();function ct(e){return e?Object.getOwnPropertySymbols(e).includes(Re):!1}function xe(e){return e?Object.getOwnPropertySymbols(e).includes(x):!1}var pt=64,g=4294967295,ge=1024;function ve(e,t){let{depths:n}=e;if(t<n.length)return n;let o=Math.max(t+1,n.length*2,n.length+ge),r=new Uint32Array(o);return r.fill(g),r.set(n),e.depths=r,r}function Ce(e,t,n,o){let{depthToEntities:r}=e;if(o!==void 0&&o!==g){let a=r.get(o);a&&(a.remove(t),a.dense.length===0&&r.delete(o))}n!==g&&(r.has(n)||r.set(n,X()),r.get(n).add(t))}function ft(e,t){t>e.maxDepth&&(e.maxDepth=t)}function ne(e,t,n,o){e.depths[t]=n,Ce(e,t,n,o),ft(e,n)}function Te(e,t){e[u].hierarchyQueryCache.delete(t)}function Z(e,t){let n=e[u];return n.hierarchyActiveRelations.has(t)||(n.hierarchyActiveRelations.add(t),oe(e,t),ut(e,t)),n.hierarchyData.get(t)}function ut(e,t){let n=$(e,[b(t,y)]);for(let r of n)te(e,t,r);let o=new Set;for(let r of n)for(let a of I(e,r,t))o.has(a)||(o.add(a),te(e,t,a))}function oe(e,t){let n=e[u];if(!n.hierarchyData.has(t)){let o=Math.max(ge,n.entityIndex.dense.length*2),r=new Uint32Array(o);r.fill(g),n.hierarchyData.set(t,{depths:r,dirty:M(),depthToEntities:new Map,maxDepth:0})}}function Ie(e,t,n,o=new Set){if(o.has(n))return 0;o.add(n);let r=I(e,n,t);if(r.length===0)return 0;if(r.length===1)return J(e,t,r[0],o)+1;let a=1/0;for(let i of r){let s=J(e,t,i,o);if(s<a&&(a=s,a===0))break}return a===1/0?0:a+1}function J(e,t,n,o){let r=e[u];oe(e,t);let a=r.hierarchyData.get(t),{depths:i}=a;if(i=ve(a,n),i[n]===g){let s=Ie(e,t,n,o);return ne(a,n,s),s}return i[n]}function te(e,t,n){return J(e,t,n,new Set)}function Ee(e,t,n,o,r=M()){if(r.has(n))return;r.add(n);let a=$(e,[t(n)]);for(let i of a)o.add(i),Ee(e,t,i,o,r)}function We(e,t,n,o,r=new Set){let a=e[u];if(!a.hierarchyActiveRelations.has(t))return;oe(e,t);let i=a.hierarchyData.get(t);if(r.has(n)){i.dirty.add(n);return}r.add(n);let{depths:s,dirty:p}=i,c=o!==void 0?te(e,t,o)+1:0;if(c>pt)return;let f=s[n];ne(i,n,c,f===g?void 0:f),f!==c&&(Ee(e,t,n,p,M()),Te(e,t))}function Se(e,t,n){let o=e[u];if(!o.hierarchyActiveRelations.has(t))return;let r=o.hierarchyData.get(t),{depths:a}=r;a=ve(r,n),Me(e,t,n,a,M()),Te(e,t)}function Me(e,t,n,o,r){if(r.has(n))return;r.add(n);let i=e[u].hierarchyData.get(t);if(n<o.length){let p=o[n];p!==g&&(i.depths[n]=g,Ce(i,n,g,p))}let s=$(e,[t(n)]);for(let p of s)Me(e,t,p,o,r)}function De(e,t){let o=e[u].hierarchyData.get(t);if(!o)return;let{dirty:r,depths:a}=o;if(r.dense.length!==0){for(let i of r.dense)if(a[i]===g){let s=Ie(e,t,i);ne(o,i,s)}r.reset()}}function Oe(e,t,n,o={}){let r=e[u];Z(e,t);let a=H(e,[t,...n]),i=r.hierarchyQueryCache.get(t);if(i&&i.hash===a)return i.result;De(e,t),re(e,n,o);let s=r.queriesHashMap.get(H(e,n)),p=r.hierarchyData.get(t),{depths:c}=p;s.sort((d,W)=>{let l=c[d],R=c[W];return l!==R?l-R:d-W});let f=(o.buffered,s.dense);return r.hierarchyQueryCache.set(t,{hash:a,result:f}),f}function Qe(e,t,n,o={}){let r=Z(e,t);De(e,t);let a=r.depthToEntities.get(n);return a?(o.buffered,a.dense):o.buffered?new Uint32Array(0):[]}function dt(e,t,n){return Z(e,n),J(e,n,t,new Set)}function mt(e,t){return Z(e,t).maxDepth}var v=Symbol.for(\"bitecs-opType\"),D=Symbol.for(\"bitecs-opTerms\"),se=e=>(...t)=>({[v]:e,[D]:t}),Ae=se(\"Or\"),ke=se(\"And\"),He=se(\"Not\"),yt=Ae,lt=ke,ht=He,ae=Symbol.for(\"bitecs-hierarchyType\"),$e=Symbol.for(\"bitecs-hierarchyRel\"),qe=Symbol.for(\"bitecs-hierarchyDepth\"),je=(e,t)=>({[ae]:\"Hierarchy\",[$e]:e,[qe]:t}),bt=je,F=Symbol.for(\"bitecs-modifierType\"),Rt={[F]:\"buffer\"},Pe={[F]:\"nested\"},ie=Pe,Ue=e=>(...t)=>({[v]:e,[D]:t}),xt=Ue(\"add\"),gt=Ue(\"remove\"),vt=e=>({[v]:\"set\",[D]:[e]}),Ct=e=>({[v]:\"get\",[D]:[e]});function Tt(e,t,n){let o=e[u],{[v]:r,[D]:a}=t;if(r===\"add\"||r===\"remove\")return(o.queriesHashMap.get(H(e,a))||ee(e,a))[r===\"add\"?\"addObservable\":\"removeObservable\"].subscribe(n);if(r===\"set\"||r===\"get\"){if(a.length!==1)throw new Error(\"Set and Get hooks can only observe a single component\");return(o.componentMap.get(a[0])||E(e,a[0]))[r===\"set\"?\"setObservable\":\"getObservable\"].subscribe(n)}throw new Error(`Invalid hook type: ${r}`)}var H=(e,t)=>{let n=e[u],o=a=>(n.componentMap.has(a)||E(e,a),n.componentMap.get(a).id),r=a=>v in a?`${a[v].toLowerCase()}(${a[D].map(r).sort().join(\",\")})`:o(a).toString();return t.map(r).sort().join(\"-\")},ee=(e,t,n={})=>{let o=e[u],r=H(e,t),a=[],i=m=>{v in m?m[D].forEach(i):(o.componentMap.has(m)||E(e,m),a.push(m))};t.forEach(i);let s=[],p=[],c=[],f=(m,h)=>{h.forEach(S=>{o.componentMap.has(S)||E(e,S),m.push(S)})};t.forEach(m=>{if(v in m){let{[v]:h,[D]:S}=m;if(h===\"Not\")f(p,S);else if(h===\"Or\")f(c,S);else if(h===\"And\")f(s,S);else throw new Error(`Nested combinator ${h} not supported yet - use simple queries for best performance`)}else o.componentMap.has(m)||E(e,m),s.push(m)});let d=a.map(m=>o.componentMap.get(m)),W=[...new Set(d.map(m=>m.generationId))],l=(m,h)=>(m[h.generationId]=(m[h.generationId]||0)|h.bitflag,m),R=s.map(m=>o.componentMap.get(m)).reduce(l,{}),_e=p.map(m=>o.componentMap.get(m)).reduce(l,{}),Ge=c.map(m=>o.componentMap.get(m)).reduce(l,{}),ze=d.reduce(l,{}),Q=Object.assign(n.buffered?X():M(),{allComponents:a,orComponents:c,notComponents:p,masks:R,notMasks:_e,orMasks:Ge,hasMasks:ze,generations:W,toRemove:M(),addObservable:P(),removeObservable:P(),queues:{}});o.queries.add(Q),o.queriesHashMap.set(r,Q),d.forEach(m=>{m.queries.add(Q)}),p.length&&o.notQueries.add(Q);let ce=o.entityIndex;for(let m=0;m<ce.aliveCount;m++){let h=ce.dense[m];if(O(e,h,q))continue;V(e,Q,h)&&w(Q,h)}return Q};function re(e,t,n={}){let o=e[u],r=H(e,t),a=o.queriesHashMap.get(r);return a?n.buffered&&!(\"buffer\"in a.dense)&&(a=ee(e,t,{buffered:!0})):a=ee(e,t,n),n.buffered,a.dense}function $(e,t,...n){let o=t.find(p=>p&&typeof p==\"object\"&&ae in p),r=t.filter(p=>!(p&&typeof p==\"object\"&&ae in p)),a=!1,i=!0,s=n.some(p=>p&&typeof p==\"object\"&&F in p);for(let p of n)if(s&&p&&typeof p==\"object\"&&F in p){let c=p;c[F]===\"buffer\"&&(a=!0),c[F]===\"nested\"&&(i=!1)}else if(!s){let c=p;c.buffered!==void 0&&(a=c.buffered),c.commit!==void 0&&(i=c.commit)}if(o){let{[$e]:p,[qe]:c}=o;return c!==void 0?Qe(e,p,c,{buffered:a}):Oe(e,p,r,{buffered:a})}return i&&Be(e),re(e,r,{buffered:a})}function V(e,t,n){let o=e[u],{masks:r,notMasks:a,orMasks:i,generations:s}=t,p=Object.keys(i).length===0;for(let c=0;c<s.length;c++){let f=s[c],d=r[f],W=a[f],l=i[f],R=o.entityMasks[f][n];if(W&&R&W||d&&(R&d)!==d)return!1;l&&R&l&&(p=!0)}return p}var w=(e,t)=>{if(e.toRemove.has(t)){e.toRemove.remove(t),e.addObservable.notify(t);return}e.has(t)||(e.add(t),e.addObservable.notify(t))},It=e=>{for(let t=0;t<e.toRemove.dense.length;t++){let n=e.toRemove.dense[t];e.remove(n)}e.toRemove.reset()},Be=e=>{let t=e[u];t.dirtyQueries.size&&(t.dirtyQueries.forEach(It),t.dirtyQueries.clear())},_=(e,t,n)=>{let o=e[u];!t.has(n)||t.toRemove.has(n)||(t.toRemove.add(n),o.dirtyQueries.add(t),t.removeObservable.notify(n))},Et=(e,t)=>{let n=e[u],o=H(e,t),r=n.queriesHashMap.get(o);r&&(n.queries.delete(r),n.queriesHashMap.delete(o))};var E=(e,t)=>{if(!t)throw new Error(\"bitECS - Cannot register null or undefined component\");let n=e[u],o=new Set,r={id:n.componentCount++,generationId:n.entityMasks.length-1,bitflag:n.bitflag,ref:t,queries:o,setObservable:P(),getObservable:P()};return n.componentMap.set(t,r),n.bitflag*=2,n.bitflag>=2**31&&(n.bitflag=1,n.entityMasks.push([])),r},Wt=(e,t)=>{t.forEach(n=>E(e,n))},O=(e,t,n)=>{let o=e[u],r=o.componentMap.get(n);if(!r)return!1;let{generationId:a,bitflag:i}=r;return(o.entityMasks[a][t]&i)===i},Fe=(e,t,n)=>{let r=e[u].componentMap.get(n);if(r&&O(e,t,n))return r.getObservable.notify(t)},Ve=(e,t)=>({component:e,data:t}),we=(e,t,n,o,r=new Set)=>{if(!r.has(o)){r.add(o),j(t,n,B(o));for(let a of L(t,o))if(a!==q&&!O(t,n,a)){j(t,n,a);let i=e.componentMap.get(a);if(i?.setObservable){let s=Fe(t,o,a);i.setObservable.notify(n,s)}}for(let a of I(t,o,B))we(e,t,n,a,r)}},St=(e,t,n,o)=>{j(e,t,Ve(n,o))},j=(e,t,n)=>{if(!N(e,t))throw new Error(`Cannot add component - entity ${t} does not exist in the world.`);let o=e[u],r=\"component\"in n?n.component:n,a=\"data\"in n?n.data:void 0;o.componentMap.has(r)||E(e,r);let i=o.componentMap.get(r);if(O(e,t,r))return a!==void 0&&i.setObservable.notify(t,a),!1;let{generationId:s,bitflag:p,queries:c}=i;if(o.entityMasks[s][t]|=p,O(e,t,q)||c.forEach(f=>{V(e,f,t)?w(f,t):_(e,f,t)}),o.entityComponents.get(t).add(r),a!==void 0&&i.setObservable.notify(t,a),r[U]){let f=r[k],d=r[T];if(G(e,t,b(f,y),b(y,d)),typeof d==\"number\"&&(G(e,d,b(y,t),b(y,f)),o.entitiesWithRelations.add(d),o.entitiesWithRelations.add(t)),o.entitiesWithRelations.add(d),f[x].exclusiveRelation===!0&&d!==y){let l=I(e,t,f)[0];l!=null&&l!==d&&C(e,t,f(l))}if(f===B){let l=I(e,t,B);for(let R of l)we(o,e,t,R)}We(e,f,t,typeof d==\"number\"?d:void 0)}return!0};function G(e,t,...n){(Array.isArray(n[0])?n[0]:n).forEach(r=>{j(e,t,r)})}var C=(e,t,...n)=>{let o=e[u];if(!N(e,t))throw new Error(`Cannot remove component - entity ${t} does not exist in the world.`);n.forEach(r=>{if(!O(e,t,r))return;let a=o.componentMap.get(r),{generationId:i,bitflag:s,queries:p}=a;if(o.entityMasks[i][t]&=~s,p.forEach(c=>{c.toRemove.remove(t),V(e,c,t)?w(c,t):_(e,c,t)}),o.entityComponents.get(t).delete(r),r[U]){let c=r[T],f=r[k];Se(e,f,t),C(e,t,b(y,c)),typeof c==\"number\"&&N(e,c)&&(C(e,c,b(y,t)),C(e,c,b(y,f))),I(e,t,f).length===0&&C(e,t,b(f,y))}})},Mt=C;var q={},Dt=e=>{let t=Ne(e);return j(e,t,q),t};function Ne(e,...t){let n=e[u],o=ue(n.entityIndex);return n.notQueries.forEach(r=>{V(e,r,o)&&w(r,o)}),n.entityComponents.set(o,new Set),t.length>0&&G(e,o,t),o}var Le=(e,t)=>{let n=e[u];if(!K(n.entityIndex,t))return;let o=[t],r=new Set;for(;o.length>0;){let a=o.shift();if(r.has(a))continue;r.add(a);let i=[];if(n.entitiesWithRelations.has(a)){for(let s of $(e,[y(a)],ie))if(N(e,s))for(let p of n.entityComponents.get(s)){if(!p[U])continue;let f=p[k][x];i.push(()=>C(e,s,b(y,a))),p[T]===a&&(i.push(()=>C(e,s,p)),f.autoRemoveSubject&&o.push(s),f.onTargetRemoved&&i.push(()=>f.onTargetRemoved(e,s,a)))}n.entitiesWithRelations.delete(a)}for(let s of i)s();for(let s of o)Le(e,s);for(let s of n.queries)_(e,s,a);de(n.entityIndex,a),n.entityComponents.delete(a);for(let s=0;s<n.entityMasks.length;s++)n.entityMasks[s][a]=0}},L=(e,t)=>{let n=e[u];if(t===void 0)throw new Error(\"getEntityComponents: entity id is undefined.\");if(!K(n.entityIndex,t))throw new Error(`getEntityComponents: entity ${t} does not exist in the world.`);return Array.from(n.entityComponents.get(t))},N=(e,t)=>K(e[u].entityIndex,t);var Ot=(...e)=>(...t)=>e.reduce((n,o)=>[o(...n)],t)[0];var Qt=e=>e;function At(e){let t=[];return e?Object.assign(t,e):t}export{u as $internal,lt as All,ke as And,yt as Any,bt as Cascade,je as Hierarchy,B as IsA,ht as None,He as Not,Ae as Or,b as Pair,q as Prefab,y as Wildcard,j as addComponent,G as addComponents,Ne as addEntity,Dt as addPrefab,At as aos,Rt as asBuffer,Be as commitRemovals,z as createEntityIndex,ot as createRelation,Je as createWorld,et as deleteWorld,N as entityExists,nt as getAllEntities,Fe as getComponent,L as getEntityComponents,dt as getHierarchyDepth,pe as getId,mt as getMaxHierarchyDepth,I as getRelationTargets,fe as getVersion,tt as getWorldComponents,O as hasComponent,Pe as isNested,xe as isRelation,ct as isWildcard,le as makeExclusive,ie as noCommit,Tt as observe,xt as onAdd,Ct as onGet,gt as onRemove,vt as onSet,Ot as pipe,$ as query,E as registerComponent,Wt as registerComponents,ee as registerQuery,C as removeComponent,Mt as removeComponents,Le as removeEntity,Et as removeQuery,Ze as resetWorld,Ve as set,St as setComponent,Qt as soa,he as withAutoRemoveSubject,be as withOnTargetRemoved,ye as withStore,Xe as withVersioning};\n//# sourceMappingURL=index.min.mjs.map\n","import type { State } from \"./state\";\n\nexport class CycleError extends Error {\n    constructor(message = \"Circular dependency detected\") {\n        super(message);\n        this.name = \"CycleError\";\n    }\n}\n\nexport function toposort<T>(nodes: T[], edges: [T, T][]): T[] {\n    if (nodes.length === 0) return [];\n\n    const graph = new Map<T, Set<T>>();\n    const inDegree = new Map<T, number>();\n\n    for (const node of nodes) {\n        graph.set(node, new Set());\n        inDegree.set(node, 0);\n    }\n\n    for (const [from, to] of edges) {\n        if (!graph.has(from) || !graph.has(to)) continue;\n        graph.get(from)!.add(to);\n        inDegree.set(to, inDegree.get(to)! + 1);\n    }\n\n    detectCycle(nodes, graph);\n\n    const queue: T[] = [];\n    const sorted: T[] = [];\n\n    for (const node of nodes) {\n        if (inDegree.get(node) === 0) queue.push(node);\n    }\n\n    while (queue.length > 0) {\n        const node = queue.shift()!;\n        sorted.push(node);\n\n        for (const dep of graph.get(node)!) {\n            const newDegree = inDegree.get(dep)! - 1;\n            inDegree.set(dep, newDegree);\n            if (newDegree === 0) queue.push(dep);\n        }\n    }\n\n    return sorted;\n}\n\nfunction detectCycle<T>(nodes: T[], graph: Map<T, Set<T>>): void {\n    const visited = new Set<T>();\n    const stack = new Set<T>();\n\n    function hasCycle(node: T): boolean {\n        if (stack.has(node)) return true;\n        if (visited.has(node)) return false;\n\n        visited.add(node);\n        stack.add(node);\n\n        for (const dep of graph.get(node)!) {\n            if (hasCycle(dep)) return true;\n        }\n\n        stack.delete(node);\n        return false;\n    }\n\n    for (const node of nodes) {\n        if (hasCycle(node)) throw new CycleError();\n    }\n}\n\nexport const Time = {\n    FIXED_DT: 1 / 50,\n    DEFAULT_DT: 1 / 60,\n} as const;\n\nexport interface GameTime {\n    deltaTime: number;\n    fixedDeltaTime: number;\n    elapsed: number;\n}\n\nexport type SystemGroup = \"setup\" | \"fixed\" | \"simulation\" | \"draw\";\n\nexport interface System {\n    readonly update?: (state: State) => void;\n    readonly setup?: (state: State) => void;\n    readonly dispose?: (state: State) => void;\n    readonly group?: SystemGroup;\n    readonly first?: boolean;\n    readonly last?: boolean;\n    readonly before?: readonly System[];\n    readonly after?: readonly System[];\n}\n\nexport class OrderingError extends Error {\n    constructor(message: string) {\n        super(message);\n        this.name = \"OrderingError\";\n    }\n}\n\nexport class Scheduler {\n    private readonly _systems = new Set<System>();\n    private _systemsVersion = 0;\n    private _accumulator = 0;\n    private readonly _initialized = new WeakSet<System>();\n    private _cache = new Map<SystemGroup, System[]>();\n    private _cacheVersion = -1;\n    private _time: GameTime = {\n        deltaTime: 0,\n        fixedDeltaTime: Time.FIXED_DT,\n        elapsed: 0,\n    };\n\n    get systems(): ReadonlySet<System> {\n        return this._systems;\n    }\n\n    get systemsVersion(): number {\n        return this._systemsVersion;\n    }\n\n    get accumulator(): number {\n        return this._accumulator;\n    }\n\n    get time(): Readonly<GameTime> {\n        return this._time;\n    }\n\n    register(system: System): void {\n        this._systems.add(system);\n        this._systemsVersion++;\n    }\n\n    unregister(system: System): void {\n        if (this._systems.delete(system)) {\n            this._systemsVersion++;\n        }\n    }\n\n    step(state: State, deltaTime = Time.DEFAULT_DT): void {\n        const fixedDt = Time.FIXED_DT;\n\n        this._time.deltaTime = deltaTime;\n        this._time.elapsed += deltaTime;\n        this._accumulator += deltaTime;\n\n        this.runGroup(state, \"setup\");\n\n        while (this._accumulator >= fixedDt) {\n            this._time.deltaTime = fixedDt;\n            this.runGroup(state, \"fixed\");\n            this._accumulator -= fixedDt;\n        }\n\n        this._time.deltaTime = deltaTime;\n        this.runGroup(state, \"simulation\");\n        this.runGroup(state, \"draw\");\n    }\n\n    private runGroup(state: State, group: SystemGroup): void {\n        for (const system of this.getSorted(group)) {\n            if (!this._initialized.has(system)) {\n                system.setup?.(state);\n                this._initialized.add(system);\n            }\n            system.update?.(state);\n        }\n    }\n\n    private getSorted(group: SystemGroup): System[] {\n        if (this._systemsVersion !== this._cacheVersion) {\n            this._cache.clear();\n            this._cacheVersion = this._systemsVersion;\n        }\n\n        const cached = this._cache.get(group);\n        if (cached) return cached;\n\n        const all = Array.from(this._systems);\n        const filtered = all.filter((s) => (s.group ?? \"simulation\") === group);\n        const sorted = sortSystems(filtered, all);\n        this._cache.set(group, sorted);\n        return sorted;\n    }\n}\n\nfunction sortSystems(systems: System[], allSystems?: System[]): System[] {\n    const all = allSystems ?? systems;\n    validateSystems(systems, all);\n\n    const first = systems.filter((s) => s.first);\n    const last = systems.filter((s) => s.last);\n    const normal = systems.filter((s) => !s.first && !s.last);\n\n    return [\n        ...toposort(first, buildEdges(first)),\n        ...toposort(normal, buildEdges(normal)),\n        ...toposort(last, buildEdges(last)),\n    ];\n}\n\nfunction buildEdges(systems: System[]): [System, System][] {\n    const edges: [System, System][] = [];\n    for (const system of systems) {\n        for (const target of system.before ?? []) {\n            if (systems.includes(target)) edges.push([system, target]);\n        }\n        for (const target of system.after ?? []) {\n            if (systems.includes(target)) edges.push([target, system]);\n        }\n    }\n    return edges;\n}\n\nfunction validateSystems(systems: System[], all: System[]): void {\n    for (const s of systems) {\n        if (s.first && s.last) {\n            throw new OrderingError(\"System cannot have both first and last constraints\");\n        }\n\n        const group = s.group ?? \"simulation\";\n        for (const ref of s.before ?? []) checkGroup(ref, group, all);\n        for (const ref of s.after ?? []) checkGroup(ref, group, all);\n    }\n}\n\nfunction checkGroup(ref: System, group: string, all: System[]): void {\n    if (!all.includes(ref)) return;\n    const refGroup = ref.group ?? \"simulation\";\n    if (refGroup !== group) {\n        throw new OrderingError(`Cross-group constraint: ${group} references ${refGroup}`);\n    }\n}\n","export type RuntimeTarget = \"headless\" | \"standalone\" | \"web\";\n\nexport interface Runtime {\n    readonly target: RuntimeTarget;\n    readFile(path: string): Promise<string>;\n    readBinary(path: string): Promise<ArrayBuffer>;\n    requestFrame(callback: () => void): void;\n    now(): number;\n}\n\ndeclare const __TAURI_INTERNALS__: unknown;\ndeclare const Bun: unknown;\n\nexport function detectTarget(): RuntimeTarget {\n    if (typeof __TAURI_INTERNALS__ !== \"undefined\") {\n        return \"standalone\";\n    }\n\n    if (typeof Bun !== \"undefined\") {\n        return \"headless\";\n    }\n\n    if (typeof window !== \"undefined\" && typeof fetch === \"function\") {\n        return \"web\";\n    }\n\n    throw new Error(\"Unknown runtime environment\");\n}\n\nfunction createWebRuntime(): Runtime {\n    return {\n        target: \"web\",\n\n        async readFile(path: string): Promise<string> {\n            const response = await fetch(path);\n            if (!response.ok) {\n                throw new Error(`Failed to load ${path}: ${response.status}`);\n            }\n            return response.text();\n        },\n\n        async readBinary(path: string): Promise<ArrayBuffer> {\n            const response = await fetch(path);\n            if (!response.ok) {\n                throw new Error(`Failed to load ${path}: ${response.status}`);\n            }\n            return response.arrayBuffer();\n        },\n\n        requestFrame(callback: () => void): void {\n            requestAnimationFrame(callback);\n        },\n\n        now(): number {\n            return performance.now();\n        },\n    };\n}\n\nfunction createHeadlessRuntime(): Runtime {\n    return {\n        target: \"headless\",\n\n        async readFile(path: string): Promise<string> {\n            const file = (\n                Bun as {\n                    file: (path: string) => {\n                        text: () => Promise<string>;\n                        arrayBuffer: () => Promise<ArrayBuffer>;\n                    };\n                }\n            ).file(path);\n            return file.text();\n        },\n\n        async readBinary(path: string): Promise<ArrayBuffer> {\n            const file = (\n                Bun as {\n                    file: (path: string) => {\n                        text: () => Promise<string>;\n                        arrayBuffer: () => Promise<ArrayBuffer>;\n                    };\n                }\n            ).file(path);\n            return file.arrayBuffer();\n        },\n\n        requestFrame(callback: () => void): void {\n            setTimeout(callback, 0);\n        },\n\n        now(): number {\n            return performance.now();\n        },\n    };\n}\n\nfunction isWebviewResource(path: string): boolean {\n    return path.startsWith(\"/\") || path.startsWith(\"./\") || path.startsWith(\"../\");\n}\n\nfunction createStandaloneRuntime(): Runtime {\n    return {\n        target: \"standalone\",\n\n        async readFile(path: string): Promise<string> {\n            if (isWebviewResource(path)) {\n                const response = await fetch(path);\n                if (!response.ok) {\n                    throw new Error(`Failed to load ${path}: ${response.status}`);\n                }\n                return response.text();\n            }\n            const { readTextFile } = await import(/* @vite-ignore */ \"@tauri-apps/plugin-fs\");\n            return readTextFile(path);\n        },\n\n        async readBinary(path: string): Promise<ArrayBuffer> {\n            if (isWebviewResource(path)) {\n                const response = await fetch(path);\n                if (!response.ok) {\n                    throw new Error(`Failed to load ${path}: ${response.status}`);\n                }\n                return response.arrayBuffer();\n            }\n            const { readFile } = await import(/* @vite-ignore */ \"@tauri-apps/plugin-fs\");\n            const bytes = await readFile(path);\n            return bytes.buffer;\n        },\n\n        requestFrame(callback: () => void): void {\n            requestAnimationFrame(callback);\n        },\n\n        now(): number {\n            return performance.now();\n        },\n    };\n}\n\nlet _runtime: Runtime | undefined;\n\nasync function createRuntime(): Promise<Runtime> {\n    const target = detectTarget();\n\n    switch (target) {\n        case \"headless\":\n            return createHeadlessRuntime();\n        case \"standalone\":\n            return createStandaloneRuntime();\n        case \"web\":\n            return createWebRuntime();\n    }\n}\n\nlet _initPromise: Promise<Runtime> | undefined;\n\nexport function getRuntime(): Runtime {\n    if (_runtime) return _runtime;\n\n    if (!_initPromise) {\n        _initPromise = createRuntime().then((r) => {\n            _runtime = r;\n            return r;\n        });\n    }\n\n    throw new Error(\"Runtime not initialized. Call initRuntime() first.\");\n}\n\nexport async function initRuntime(): Promise<Runtime> {\n    if (_runtime) return _runtime;\n\n    if (!_initPromise) {\n        _initPromise = createRuntime();\n    }\n\n    _runtime = await _initPromise;\n    return _runtime;\n}\n\nexport function resetRuntime(): void {\n    _runtime = undefined;\n    _initPromise = undefined;\n}\n","export function toKebabCase(str: string): string {\n    return str\n        .replace(/([a-z])([A-Z])/g, \"$1-$2\")\n        .replace(/[\\s_]+/g, \"-\")\n        .toLowerCase();\n}\n\nexport function toCamelCase(str: string): string {\n    return str.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());\n}\n","import type { State } from \"./state\";\nimport { toKebabCase } from \"./strings\";\n\nexport type ComponentArray = number[] | Float32Array | Uint32Array;\nexport type ComponentData = Record<string, ComponentArray>;\n\nexport interface ParseContext {\n    readonly currentEid: number;\n    getEntityByName(name: string): number | null;\n    setName(name: string, eid: number): void;\n}\n\nexport interface FieldAccessor {\n    get(eid: number): number;\n    set(eid: number, value: number): void;\n}\n\nexport interface ComponentTraits {\n    defaults?: () => Record<string, number>;\n    adapter?: (\n        attrs: Record<string, string>,\n        state: State,\n        context: ParseContext\n    ) => Record<string, number>;\n    accessors?: Record<string, FieldAccessor>;\n}\n\nconst traitsMap = new WeakMap<ComponentData, ComponentTraits>();\n\nexport function setTraits(component: ComponentData, traits: ComponentTraits): void {\n    traitsMap.set(component, traits);\n}\n\nexport function getTraits(component: ComponentData): ComponentTraits | undefined {\n    return traitsMap.get(component);\n}\n\nexport interface RegisteredComponent {\n    readonly component: ComponentData;\n    readonly name: string;\n    readonly traits?: ComponentTraits;\n}\n\nconst registry = new Map<string, RegisteredComponent>();\n\nexport function registerComponent(name: string, component: ComponentData): void {\n    const kebabName = toKebabCase(name);\n    const traits = traitsMap.get(component);\n    registry.set(kebabName, { component, name: kebabName, traits });\n}\n\nexport function getRegisteredComponent(name: string): RegisteredComponent | undefined {\n    return registry.get(toKebabCase(name));\n}\n\nexport function clearRegistry(): void {\n    registry.clear();\n}\n\nexport function directAccessor(\n    data: ComponentArray,\n    stride: number,\n    offset: number\n): FieldAccessor {\n    return {\n        get: (eid) => data[eid * stride + offset],\n        set: (eid, v) => {\n            data[eid * stride + offset] = v;\n        },\n    };\n}\n","export interface ResourceContainer {\n    getResource<T>(key: ResourceKey<T>): T | undefined;\n}\n\nexport type ResourceKey<T> = symbol & {\n    __type?: T;\n    from(state: ResourceContainer): T | undefined;\n};\n\nexport function resource<T>(name: string): ResourceKey<T> {\n    const key = Symbol(name) as symbol;\n    const resourceKey = Object.assign(key, {\n        from(state: ResourceContainer): T | undefined {\n            return state.getResource(resourceKey);\n        },\n    });\n    return resourceKey as ResourceKey<T>;\n}\n","import {\n    addComponent,\n    addEntity,\n    createWorld,\n    entityExists,\n    getAllEntities,\n    getComponent,\n    getEntityComponents,\n    getRelationTargets,\n    hasComponent,\n    query,\n    removeComponent,\n    removeComponents,\n    removeEntity,\n    type ComponentRef,\n    type World,\n} from \"bitecs\";\nimport { Scheduler, Time, type GameTime, type System } from \"./scheduler\";\nimport type { RelationDef } from \"./relation\";\nimport type { Plugin } from \"./types\";\nimport type { StateBuilder } from \"./builder\";\nimport { initRuntime, type Runtime } from \"./runtime\";\nimport {\n    registerComponent,\n    getTraits,\n    getRegisteredComponent,\n    directAccessor,\n    type ComponentData,\n    type FieldAccessor,\n} from \"./component\";\nimport { type ResourceKey } from \"./resource\";\nimport { toCamelCase } from \"./strings\";\n\nexport const MAX_ENTITIES = 65536;\n\nexport class State {\n    readonly world: World;\n    readonly scheduler = new Scheduler();\n    readonly canvas: HTMLCanvasElement | null;\n\n    private _resources = new Map<symbol, unknown>();\n    private _disposed = false;\n    private _running = false;\n    private _runtime: Runtime | null = null;\n    private _lastTime = 0;\n    private _fieldAccessors: Map<number, FieldAccessor> | null = null;\n\n    get time(): Readonly<GameTime> {\n        return this.scheduler.time;\n    }\n\n    get running(): boolean {\n        return this._running;\n    }\n\n    static Builder: (new () => StateBuilder) | null = null;\n\n    static new(): StateBuilder {\n        if (!State.Builder) {\n            throw new Error(\"StateBuilder not injected. Import from 'shallot' or 'shallot/core'.\");\n        }\n        return new State.Builder();\n    }\n\n    constructor(canvas: HTMLCanvasElement | null = null) {\n        this.world = createWorld();\n        this.canvas = canvas;\n    }\n\n    setResource<T>(key: ResourceKey<T>, value: T): void {\n        this._resources.set(key, value);\n    }\n\n    getResource<T>(key: ResourceKey<T>): T | undefined {\n        return this._resources.get(key) as T | undefined;\n    }\n\n    deleteResource<T>(key: ResourceKey<T>): boolean {\n        return this._resources.delete(key);\n    }\n\n    async start(runtime?: Runtime): Promise<void> {\n        if (this._running) return;\n        this._runtime = runtime ?? (await initRuntime());\n        this._running = true;\n        this._lastTime = this._runtime.now();\n        this.scheduleFrame();\n    }\n\n    stop(): void {\n        this._running = false;\n    }\n\n    private scheduleFrame(): void {\n        if (!this._running || !this._runtime) return;\n        this._runtime.requestFrame(() => this.tick());\n    }\n\n    private tick(): void {\n        if (!this._running || !this._runtime) return;\n        const now = this._runtime.now();\n        const dt = (now - this._lastTime) / 1000;\n        this._lastTime = now;\n        this.step(dt);\n        this.scheduleFrame();\n    }\n\n    register(pluginOrSystem: Plugin | System): void {\n        if (\n            \"update\" in pluginOrSystem ||\n            \"setup\" in pluginOrSystem ||\n            \"dispose\" in pluginOrSystem\n        ) {\n            this.scheduler.register(pluginOrSystem as System);\n        } else {\n            const plugin = pluginOrSystem as Plugin;\n            if (plugin.components) {\n                for (const [name, component] of Object.entries(plugin.components)) {\n                    registerComponent(name, component);\n                }\n            }\n            if (plugin.systems) {\n                for (const system of plugin.systems) {\n                    this.scheduler.register(system);\n                }\n            }\n        }\n    }\n\n    unregister(system: System): void {\n        this.scheduler.unregister(system);\n    }\n\n    step(deltaTime = Time.DEFAULT_DT): void {\n        this.scheduler.step(this, deltaTime);\n    }\n\n    addEntity(): number {\n        const eid = addEntity(this.world);\n        if (eid >= MAX_ENTITIES) {\n            throw new Error(`Entity limit exceeded: ${eid} >= ${MAX_ENTITIES}`);\n        }\n        return eid;\n    }\n\n    removeEntity(eid: number): void {\n        this._fieldAccessors?.delete(eid);\n        removeEntity(this.world, eid);\n    }\n\n    entityExists(eid: number): boolean {\n        return entityExists(this.world, eid);\n    }\n\n    getAllEntities(): readonly number[] {\n        return getAllEntities(this.world);\n    }\n\n    query(terms: ComponentRef[]): Iterable<number> {\n        return query(this.world, terms);\n    }\n\n    getEntityComponents(eid: number): ComponentRef[] {\n        return getEntityComponents(this.world, eid);\n    }\n\n    addComponent<T extends ComponentRef>(eid: number, component: T): void {\n        addComponent(this.world, eid, component);\n\n        const traits = getTraits(component as ComponentData);\n        if (traits?.defaults) {\n            const defaults = traits.defaults();\n            const comp = component as ComponentData;\n            for (const [field, value] of Object.entries(defaults)) {\n                const arr = comp[field];\n                if (arr != null) {\n                    arr[eid] = value;\n                }\n            }\n        }\n    }\n\n    addComponents(eid: number, ...components: ComponentRef[]): void {\n        for (const component of components) {\n            this.addComponent(eid, component);\n        }\n    }\n\n    removeComponent(eid: number, ...components: ComponentRef[]): void {\n        removeComponent(this.world, eid, ...components);\n    }\n\n    removeComponents(eid: number, ...components: ComponentRef[]): void {\n        removeComponents(this.world, eid, ...components);\n    }\n\n    hasComponent<T extends ComponentRef>(eid: number, component: T): boolean {\n        return hasComponent(this.world, eid, component);\n    }\n\n    getComponent<T extends ComponentRef>(eid: number, component: T) {\n        return getComponent(this.world, eid, component);\n    }\n\n    setComponent<T extends ComponentRef>(\n        eid: number,\n        component: T,\n        data: Record<string, number>\n    ): void {\n        this.addComponent(eid, component);\n        const comp = component as Record<string, number[]>;\n        for (const [field, value] of Object.entries(data)) {\n            const arr = comp[field];\n            if (arr != null) {\n                arr[eid] = value;\n            }\n        }\n    }\n\n    addRelation(subject: number, relation: RelationDef, target: number): void {\n        addComponent(this.world, subject, relation.relation(target));\n    }\n\n    hasRelation(subject: number, relation: RelationDef, target: number): boolean {\n        return hasComponent(this.world, subject, relation.relation(target));\n    }\n\n    getRelationTargets(subject: number, relation: RelationDef): number[] {\n        return getRelationTargets(this.world, subject, relation.relation);\n    }\n\n    getFirstRelationTarget(subject: number, relation: RelationDef): number {\n        const targets = getRelationTargets(this.world, subject, relation.relation);\n        return targets.length > 0 ? targets[0] : -1;\n    }\n\n    private ensureFieldAccessors(): Map<number, FieldAccessor> {\n        if (!this._fieldAccessors) {\n            this._fieldAccessors = new Map();\n        }\n        return this._fieldAccessors;\n    }\n\n    resolveFieldPath(path: string): { component: string; field: string } | null {\n        const dotIndex = path.lastIndexOf(\".\");\n        if (dotIndex === -1) return null;\n        return {\n            component: path.slice(0, dotIndex),\n            field: path.slice(dotIndex + 1),\n        };\n    }\n\n    bindFieldAccessor(\n        bindingId: number,\n        componentName: string,\n        fieldPath: string\n    ): FieldAccessor | null {\n        const registered = getRegisteredComponent(componentName);\n        if (!registered) return null;\n\n        const camelPath = toCamelCase(fieldPath);\n\n        const traits = getTraits(registered.component);\n        if (traits?.accessors?.[camelPath]) {\n            const accessor = traits.accessors[camelPath];\n            this.ensureFieldAccessors().set(bindingId, accessor);\n            return accessor;\n        }\n\n        const array = registered.component[camelPath];\n        if (array == null) return null;\n\n        const accessor = directAccessor(array, 1, 0);\n        this.ensureFieldAccessors().set(bindingId, accessor);\n        return accessor;\n    }\n\n    getFieldAccessor(bindingId: number): FieldAccessor | undefined {\n        return this._fieldAccessors?.get(bindingId);\n    }\n\n    removeFieldAccessor(bindingId: number): boolean {\n        return this._fieldAccessors?.delete(bindingId) ?? false;\n    }\n\n    dispose(): void {\n        if (this._disposed) return;\n        this.stop();\n        this._fieldAccessors = null;\n        for (const system of this.scheduler.systems) {\n            system.dispose?.(this);\n        }\n        this._disposed = true;\n    }\n}\n","import { State } from \"./state\";\nimport type { Plugin, Loading } from \"./types\";\nimport { toposort, type System } from \"./scheduler\";\nimport { registerComponent } from \"./component\";\nimport { initRuntime } from \"./runtime\";\n\nexport class StateBuilder {\n    static defaultPlugins: readonly Plugin[] = [];\n    static loading: ((canvas: HTMLCanvasElement) => Loading) | null = null;\n\n    private readonly _plugins: Plugin[] = [];\n    private readonly _systems: System[] = [];\n    private readonly _scenes: string[] = [];\n    private readonly _excludedPlugins = new Set<Plugin>();\n    private _useDefaultPlugins = true;\n    private _canvas: HTMLCanvasElement | null = null;\n    private _loading: Loading | null | undefined = undefined;\n\n    withCanvas(canvas: HTMLCanvasElement): this {\n        this._canvas = canvas;\n        return this;\n    }\n\n    withPlugins(...plugins: Plugin[]): this {\n        this._plugins.push(...plugins);\n        return this;\n    }\n\n    withoutPlugin(plugin: Plugin): this {\n        this._excludedPlugins.add(plugin);\n        return this;\n    }\n\n    withoutPlugins(...plugins: Plugin[]): this {\n        for (const p of plugins) this._excludedPlugins.add(p);\n        return this;\n    }\n\n    withoutDefaultPlugins(): this {\n        this._useDefaultPlugins = false;\n        return this;\n    }\n\n    withSystems(...systems: System[]): this {\n        this._systems.push(...systems);\n        return this;\n    }\n\n    withScene(path: string): this {\n        this._scenes.push(path);\n        return this;\n    }\n\n    withLoading(loading: Loading | null): this {\n        this._loading = loading;\n        return this;\n    }\n\n    async build(): Promise<State> {\n        const loading =\n            this._loading === undefined && this._canvas\n                ? (StateBuilder.loading?.(this._canvas) ?? null)\n                : this._loading;\n\n        const cleanup = loading?.show();\n\n        const state = new State(this._canvas);\n\n        const pluginSet = new Set<Plugin>();\n\n        if (this._useDefaultPlugins) {\n            for (const plugin of StateBuilder.defaultPlugins) {\n                if (!this._excludedPlugins.has(plugin)) {\n                    pluginSet.add(plugin);\n                }\n            }\n        }\n\n        for (const plugin of this._plugins) {\n            pluginSet.add(plugin);\n        }\n\n        const allPlugins = [...pluginSet];\n\n        for (const plugin of allPlugins) {\n            if (plugin.components) {\n                for (const [name, component] of Object.entries(plugin.components)) {\n                    registerComponent(name, component);\n                }\n            }\n            if (plugin.systems) {\n                for (const system of plugin.systems) {\n                    state.scheduler.register(system);\n                }\n            }\n        }\n\n        const edges: [Plugin, Plugin][] = [];\n        for (const plugin of allPlugins) {\n            for (const dep of plugin.dependencies ?? []) {\n                if (allPlugins.includes(dep)) {\n                    edges.push([dep, plugin]);\n                }\n            }\n        }\n        const sorted = toposort(allPlugins, edges);\n\n        let completed = 0;\n        const total = sorted.length;\n\n        for (const plugin of sorted) {\n            await plugin.initialize?.(state);\n            completed++;\n            loading?.update(completed / total);\n        }\n\n        for (const system of this._systems) {\n            state.scheduler.register(system);\n        }\n\n        if (this._scenes.length > 0) {\n            const { loadSceneFile } = await import(\"./xml\");\n            const runtime = await initRuntime();\n            for (const scenePath of this._scenes) {\n                const result = await loadSceneFile(\n                    state,\n                    scenePath,\n                    runtime.readFile.bind(runtime)\n                );\n                if (result.errors.length > 0) {\n                    console.warn(`Scene \"${scenePath}\" loaded with errors:`, result.errors);\n                }\n            }\n        }\n\n        cleanup?.();\n\n        return state;\n    }\n\n    async run(): Promise<State> {\n        const state = await this.build();\n        await state.start();\n        return state;\n    }\n}\n\nState.Builder = StateBuilder;\n","import { createRelation as bitecsCreateRelation, type Relation } from \"bitecs\";\nimport { toKebabCase } from \"./strings\";\n\nexport interface RelationOptions {\n    readonly exclusive?: boolean;\n    readonly autoRemoveSubject?: boolean;\n}\n\nexport interface RelationDef {\n    readonly name: string;\n    readonly relation: Relation<unknown>;\n    readonly exclusive?: boolean;\n    readonly autoRemoveSubject?: boolean;\n}\n\nconst registry = new Map<string, RelationDef>();\n\nexport function defineRelation(name: string, options?: RelationOptions): RelationDef {\n    const relation = bitecsCreateRelation({\n        exclusive: options?.exclusive,\n        autoRemoveSubject: options?.autoRemoveSubject,\n    });\n\n    const def: RelationDef = {\n        name: toKebabCase(name),\n        relation,\n        exclusive: options?.exclusive,\n        autoRemoveSubject: options?.autoRemoveSubject,\n    };\n\n    registry.set(def.name, def);\n    return def;\n}\n\nexport function getRelationDef(name: string): RelationDef | undefined {\n    return registry.get(toKebabCase(name));\n}\n\nexport function clearRelationDefs(): void {\n    registry.clear();\n}\n\nexport const ChildOf = defineRelation(\"child-of\", {\n    exclusive: true,\n    autoRemoveSubject: true,\n});\n","const DEG_TO_RAD = Math.PI / 180;\nconst RAD_TO_DEG = 180 / Math.PI;\n\nexport function clamp(value: number, min: number, max: number): number {\n    return value < min ? min : value > max ? max : value;\n}\n\nexport function lerp(a: number, b: number, t: number): number {\n    return a + (b - a) * t;\n}\n\nexport function slerp(\n    fromX: number,\n    fromY: number,\n    fromZ: number,\n    fromW: number,\n    toX: number,\n    toY: number,\n    toZ: number,\n    toW: number,\n    t: number\n): { x: number; y: number; z: number; w: number } {\n    if (!Number.isFinite(t) || !Number.isFinite(fromW) || !Number.isFinite(toW)) {\n        throw new Error(\n            `slerp received NaN: from=[${fromX},${fromY},${fromZ},${fromW}], to=[${toX},${toY},${toZ},${toW}], t=${t}`\n        );\n    }\n\n    let dot = fromX * toX + fromY * toY + fromZ * toZ + fromW * toW;\n\n    if (dot < 0) {\n        dot = -dot;\n        toX = -toX;\n        toY = -toY;\n        toZ = -toZ;\n        toW = -toW;\n    }\n\n    let s0: number, s1: number;\n    if (dot > 0.9995) {\n        s0 = 1 - t;\n        s1 = t;\n    } else {\n        const theta0 = Math.acos(dot);\n        const sinTheta0 = Math.sqrt(1 - dot * dot);\n        const theta = theta0 * t;\n        const sinTheta = Math.sin(theta);\n        s0 = Math.cos(theta) - (dot * sinTheta) / sinTheta0;\n        s1 = sinTheta / sinTheta0;\n    }\n\n    return {\n        x: s0 * fromX + s1 * toX,\n        y: s0 * fromY + s1 * toY,\n        z: s0 * fromZ + s1 * toZ,\n        w: s0 * fromW + s1 * toW,\n    };\n}\n\nexport function rotateQuaternion(\n    qx: number,\n    qy: number,\n    qz: number,\n    qw: number,\n    dx: number,\n    dy: number,\n    dz: number\n): { x: number; y: number; z: number; w: number } {\n    const hx = dx * DEG_TO_RAD * 0.5;\n    const hy = dy * DEG_TO_RAD * 0.5;\n    const hz = dz * DEG_TO_RAD * 0.5;\n    const cx = Math.cos(hx),\n        sx = Math.sin(hx);\n    const cy = Math.cos(hy),\n        sy = Math.sin(hy);\n    const cz = Math.cos(hz),\n        sz = Math.sin(hz);\n\n    const bx = sx * cy * cz + cx * sy * sz;\n    const by = cx * sy * cz - sx * cy * sz;\n    const bz = cx * cy * sz + sx * sy * cz;\n    const bw = cx * cy * cz - sx * sy * sz;\n\n    return {\n        x: qw * bx + qx * bw + qy * bz - qz * by,\n        y: qw * by - qx * bz + qy * bw + qz * bx,\n        z: qw * bz + qx * by - qy * bx + qz * bw,\n        w: qw * bw - qx * bx - qy * by - qz * bz,\n    };\n}\n\nexport function eulerToQuaternion(\n    x: number,\n    y: number,\n    z: number\n): { x: number; y: number; z: number; w: number } {\n    const hx = x * DEG_TO_RAD * 0.5;\n    const hy = y * DEG_TO_RAD * 0.5;\n    const hz = z * DEG_TO_RAD * 0.5;\n    const cx = Math.cos(hx),\n        sx = Math.sin(hx);\n    const cy = Math.cos(hy),\n        sy = Math.sin(hy);\n    const cz = Math.cos(hz),\n        sz = Math.sin(hz);\n\n    return {\n        x: sx * cy * cz + cx * sy * sz,\n        y: cx * sy * cz - sx * cy * sz,\n        z: cx * cy * sz + sx * sy * cz,\n        w: cx * cy * cz - sx * sy * sz,\n    };\n}\n\nexport function quaternionToEuler(\n    x: number,\n    y: number,\n    z: number,\n    w: number\n): { x: number; y: number; z: number } {\n    const x2 = x + x,\n        y2 = y + y,\n        z2 = z + z;\n    const xx = x * x2,\n        xy = x * y2,\n        xz = x * z2;\n    const yy = y * y2,\n        yz = y * z2,\n        zz = z * z2;\n    const wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    const m13 = xz + wy;\n    const ey = Math.asin(m13 < -1 ? -1 : m13 > 1 ? 1 : m13);\n\n    if (m13 > -0.9999999 && m13 < 0.9999999) {\n        return {\n            x: Math.atan2(wx - yz, 1 - (xx + yy)) * RAD_TO_DEG,\n            y: ey * RAD_TO_DEG,\n            z: Math.atan2(wz - xy, 1 - (yy + zz)) * RAD_TO_DEG,\n        };\n    } else {\n        return {\n            x: Math.atan2(yz + wx, 1 - (xx + zz)) * RAD_TO_DEG,\n            y: ey * RAD_TO_DEG,\n            z: 0,\n        };\n    }\n}\n\nexport function lookAt(\n    eyeX: number,\n    eyeY: number,\n    eyeZ: number,\n    targetX: number,\n    targetY: number,\n    targetZ: number,\n    upX = 0,\n    upY = 1,\n    upZ = 0\n): { x: number; y: number; z: number; w: number } {\n    if (\n        !Number.isFinite(eyeX) ||\n        !Number.isFinite(eyeY) ||\n        !Number.isFinite(eyeZ) ||\n        !Number.isFinite(targetX) ||\n        !Number.isFinite(targetY) ||\n        !Number.isFinite(targetZ)\n    ) {\n        throw new Error(\n            `lookAt received NaN: eye=[${eyeX},${eyeY},${eyeZ}], target=[${targetX},${targetY},${targetZ}]`\n        );\n    }\n\n    let zx = eyeX - targetX;\n    let zy = eyeY - targetY;\n    let zz = eyeZ - targetZ;\n    let zLen = Math.sqrt(zx * zx + zy * zy + zz * zz);\n\n    if (zLen === 0) {\n        zz = 1;\n    } else {\n        zLen = 1 / zLen;\n        zx *= zLen;\n        zy *= zLen;\n        zz *= zLen;\n    }\n\n    let xx = upY * zz - upZ * zy;\n    let xy = upZ * zx - upX * zz;\n    let xz = upX * zy - upY * zx;\n    let xLen = Math.sqrt(xx * xx + xy * xy + xz * xz);\n\n    if (xLen < 1e-6) {\n        if (Math.abs(zz) > Math.abs(zx)) {\n            upX += 1e-4;\n        } else {\n            upZ += 1e-4;\n        }\n        xx = upY * zz - upZ * zy;\n        xy = upZ * zx - upX * zz;\n        xz = upX * zy - upY * zx;\n        xLen = Math.sqrt(xx * xx + xy * xy + xz * xz);\n    }\n\n    if (xLen < 1e-6) {\n        xx = 1;\n        xy = 0;\n        xz = 0;\n    } else {\n        xLen = 1 / xLen;\n        xx *= xLen;\n        xy *= xLen;\n        xz *= xLen;\n    }\n\n    const yx = zy * xz - zz * xy;\n    const yy = zz * xx - zx * xz;\n    const yz = zx * xy - zy * xx;\n\n    const trace = xx + yy + zz;\n    let qw: number, qx: number, qy: number, qz: number;\n\n    if (trace > 0) {\n        const s = 0.5 / Math.sqrt(trace + 1);\n        qw = 0.25 / s;\n        qx = (yz - zy) * s;\n        qy = (zx - xz) * s;\n        qz = (xy - yx) * s;\n    } else if (xx > yy && xx > zz) {\n        const s = 2 * Math.sqrt(1 + xx - yy - zz);\n        qw = (yz - zy) / s;\n        qx = 0.25 * s;\n        qy = (yx + xy) / s;\n        qz = (zx + xz) / s;\n    } else if (yy > zz) {\n        const s = 2 * Math.sqrt(1 + yy - xx - zz);\n        qw = (zx - xz) / s;\n        qx = (yx + xy) / s;\n        qy = 0.25 * s;\n        qz = (yz + zy) / s;\n    } else {\n        const s = 2 * Math.sqrt(1 + zz - xx - yy);\n        qw = (xy - yx) / s;\n        qx = (zx + xz) / s;\n        qy = (yz + zy) / s;\n        qz = 0.25 * s;\n    }\n\n    return { x: qx, y: qy, z: qz, w: qw };\n}\n","'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nexport const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*';\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nexport function getAllMatches(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n}\n\nexport const isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n}\n\nexport function isExist(v) {\n  return typeof v !== 'undefined';\n}\n\nexport function isEmptyObject(obj) {\n  return Object.keys(obj).length === 0;\n}\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexport function merge(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n}\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexport function getValue(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n}\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};","'use strict';\n\nimport {getAllMatches, isName} from './util.js';\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexport function validate(xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else if (tags.length === 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' has not been opened.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n","\nexport const defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n    captureMetaData: false,\n};\n   \nexport const buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n","'use strict';\n\nlet METADATA_SYMBOL;\n\nif (typeof Symbol !== \"function\") {\n  METADATA_SYMBOL = \"@@xmlMetadata\";\n} else {\n  METADATA_SYMBOL = Symbol(\"XML Node Metadata\");\n}\n\nexport default class XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node, startIndex) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n    // if requested, add the startIndex\n    if (startIndex !== undefined) {\n      // Note: for now we just overwrite the metadata. If we had more complex metadata,\n      // we might need to do an object append here:  metadata = { ...metadata, startIndex }\n      this.child[this.child.length - 1][METADATA_SYMBOL] = { startIndex };\n    }\n  }\n  /** symbol used for metadata */\n  static getMetaDataSymbol() {\n    return METADATA_SYMBOL;\n  }\n}\n","import {isName} from '../util.js';\n\nexport default class DocTypeReader{\n    constructor(processEntities){\n        this.suppressValidationErr = !processEntities;\n    }\n    \n    readDocType(xmlData, i){\n    \n        const entities = {};\n        if( xmlData[i + 3] === 'O' &&\n            xmlData[i + 4] === 'C' &&\n            xmlData[i + 5] === 'T' &&\n            xmlData[i + 6] === 'Y' &&\n            xmlData[i + 7] === 'P' &&\n            xmlData[i + 8] === 'E')\n        {    \n            i = i+9;\n            let angleBracketsCount = 1;\n            let hasBody = false, comment = false;\n            let exp = \"\";\n            for(;i<xmlData.length;i++){\n                if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                    if( hasBody && hasSeq(xmlData, \"!ENTITY\",i)){\n                        i += 7; \n                        let entityName, val;\n                        [entityName, val,i] = this.readEntityExp(xmlData,i+1,this.suppressValidationErr);\n                        if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                            entities[ entityName ] = {\n                                regx : RegExp( `&${entityName};`,\"g\"),\n                                val: val\n                            };\n                    }\n                    else if( hasBody && hasSeq(xmlData, \"!ELEMENT\",i))  {\n                        i += 8;//Not supported\n                        const {index} = this.readElementExp(xmlData,i+1);\n                        i = index;\n                    }else if( hasBody && hasSeq(xmlData, \"!ATTLIST\",i)){\n                        i += 8;//Not supported\n                        // const {index} = this.readAttlistExp(xmlData,i+1);\n                        // i = index;\n                    }else if( hasBody && hasSeq(xmlData, \"!NOTATION\",i)) {\n                        i += 9;//Not supported\n                        const {index} = this.readNotationExp(xmlData,i+1,this.suppressValidationErr);\n                        i = index;\n                    }else if( hasSeq(xmlData, \"!--\",i) ) comment = true;\n                    else throw new Error(`Invalid DOCTYPE`);\n\n                    angleBracketsCount++;\n                    exp = \"\";\n                } else if (xmlData[i] === '>') { //Read tag content\n                    if(comment){\n                        if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                            comment = false;\n                            angleBracketsCount--;\n                        }\n                    }else{\n                        angleBracketsCount--;\n                    }\n                    if (angleBracketsCount === 0) {\n                    break;\n                    }\n                }else if( xmlData[i] === '['){\n                    hasBody = true;\n                }else{\n                    exp += xmlData[i];\n                }\n            }\n            if(angleBracketsCount !== 0){\n                throw new Error(`Unclosed DOCTYPE`);\n            }\n        }else{\n            throw new Error(`Invalid Tag instead of DOCTYPE`);\n        }\n        return {entities, i};\n    }\n    readEntityExp(xmlData, i) {    \n        //External entities are not supported\n        //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n        //Parameter entities are not supported\n        //    <!ENTITY entityname \"&anotherElement;\">\n\n        //Internal entities are supported\n        //    <!ENTITY entityname \"replacement text\">\n\n        // Skip leading whitespace after <!ENTITY\n        i = skipWhitespace(xmlData, i);\n\n        // Read entity name\n        let entityName = \"\";\n        while (i < xmlData.length && !/\\s/.test(xmlData[i]) && xmlData[i] !== '\"' && xmlData[i] !== \"'\") {\n            entityName += xmlData[i];\n            i++;\n        }\n        validateEntityName(entityName);\n\n        // Skip whitespace after entity name\n        i = skipWhitespace(xmlData, i);\n\n        // Check for unsupported constructs (external entities or parameter entities)\n        if(!this.suppressValidationErr){\n            if (xmlData.substring(i, i + 6).toUpperCase() === \"SYSTEM\") {\n                throw new Error(\"External entities are not supported\");\n            }else if (xmlData[i] === \"%\") {\n                throw new Error(\"Parameter entities are not supported\");\n            }\n        }\n\n        // Read entity value (internal entity)\n        let entityValue = \"\";\n        [i, entityValue] = this.readIdentifierVal(xmlData, i, \"entity\");\n        i--;\n        return [entityName, entityValue, i ];\n    }\n\n    readNotationExp(xmlData, i) {\n        // Skip leading whitespace after <!NOTATION\n        i = skipWhitespace(xmlData, i);\n\n        // Read notation name\n        let notationName = \"\";\n        while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n            notationName += xmlData[i];\n            i++;\n        }\n        !this.suppressValidationErr && validateEntityName(notationName);\n\n        // Skip whitespace after notation name\n        i = skipWhitespace(xmlData, i);\n\n        // Check identifier type (SYSTEM or PUBLIC)\n        const identifierType = xmlData.substring(i, i + 6).toUpperCase();\n        if (!this.suppressValidationErr && identifierType !== \"SYSTEM\" && identifierType !== \"PUBLIC\") {\n            throw new Error(`Expected SYSTEM or PUBLIC, found \"${identifierType}\"`);\n        }\n        i += identifierType.length;\n\n        // Skip whitespace after identifier type\n        i = skipWhitespace(xmlData, i);\n\n        // Read public identifier (if PUBLIC)\n        let publicIdentifier = null;\n        let systemIdentifier = null;\n\n        if (identifierType === \"PUBLIC\") {\n            [i, publicIdentifier ] = this.readIdentifierVal(xmlData, i, \"publicIdentifier\");\n\n            // Skip whitespace after public identifier\n            i = skipWhitespace(xmlData, i);\n\n            // Optionally read system identifier\n            if (xmlData[i] === '\"' || xmlData[i] === \"'\") {\n                [i, systemIdentifier ] = this.readIdentifierVal(xmlData, i,\"systemIdentifier\");\n            }\n        } else if (identifierType === \"SYSTEM\") {\n            // Read system identifier (mandatory for SYSTEM)\n            [i, systemIdentifier ] = this.readIdentifierVal(xmlData, i, \"systemIdentifier\");\n\n            if (!this.suppressValidationErr && !systemIdentifier) {\n                throw new Error(\"Missing mandatory system identifier for SYSTEM notation\");\n            }\n        }\n        \n        return {notationName, publicIdentifier, systemIdentifier, index: --i};\n    }\n\n    readIdentifierVal(xmlData, i, type) {\n        let identifierVal = \"\";\n        const startChar = xmlData[i];\n        if (startChar !== '\"' && startChar !== \"'\") {\n            throw new Error(`Expected quoted string, found \"${startChar}\"`);\n        }\n        i++;\n\n        while (i < xmlData.length && xmlData[i] !== startChar) {\n            identifierVal += xmlData[i];\n            i++;\n        }\n\n        if (xmlData[i] !== startChar) {\n            throw new Error(`Unterminated ${type} value`);\n        }\n        i++;\n        return [i, identifierVal];\n    }\n\n    readElementExp(xmlData, i) {\n        // <!ELEMENT br EMPTY>\n        // <!ELEMENT div ANY>\n        // <!ELEMENT title (#PCDATA)>\n        // <!ELEMENT book (title, author+)>\n        // <!ELEMENT name (content-model)>\n        \n        // Skip leading whitespace after <!ELEMENT\n        i = skipWhitespace(xmlData, i);\n\n        // Read element name\n        let elementName = \"\";\n        while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n            elementName += xmlData[i];\n            i++;\n        }\n\n        // Validate element name\n        if (!this.suppressValidationErr && !isName(elementName)) {\n            throw new Error(`Invalid element name: \"${elementName}\"`);\n        }\n\n        // Skip whitespace after element name\n        i = skipWhitespace(xmlData, i);\n        let contentModel = \"\";\n        // Expect '(' to start content model\n        if(xmlData[i] === \"E\" && hasSeq(xmlData, \"MPTY\",i)) i+=4;\n        else if(xmlData[i] === \"A\" && hasSeq(xmlData, \"NY\",i)) i+=2;\n        else if (xmlData[i] === \"(\") {\n            i++; // Move past '('\n\n            // Read content model\n            while (i < xmlData.length && xmlData[i] !== \")\") {\n                contentModel += xmlData[i];\n                i++;\n            }\n            if (xmlData[i] !== \")\") {\n                throw new Error(\"Unterminated content model\");\n            }\n\n        }else if(!this.suppressValidationErr){\n            throw new Error(`Invalid Element Expression, found \"${xmlData[i]}\"`);\n        }\n        \n        return {\n            elementName,\n            contentModel: contentModel.trim(),\n            index: i\n        };\n    }\n\n    readAttlistExp(xmlData, i) {\n        // Skip leading whitespace after <!ATTLIST\n        i = skipWhitespace(xmlData, i);\n\n        // Read element name\n        let elementName = \"\";\n        while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n            elementName += xmlData[i];\n            i++;\n        }\n\n        // Validate element name\n        validateEntityName(elementName)\n\n        // Skip whitespace after element name\n        i = skipWhitespace(xmlData, i);\n\n        // Read attribute name\n        let attributeName = \"\";\n        while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n            attributeName += xmlData[i];\n            i++;\n        }\n\n        // Validate attribute name\n        if (!validateEntityName(attributeName)) {\n            throw new Error(`Invalid attribute name: \"${attributeName}\"`);\n        }\n\n        // Skip whitespace after attribute name\n        i = skipWhitespace(xmlData, i);\n\n        // Read attribute type\n        let attributeType = \"\";\n        if (xmlData.substring(i, i + 8).toUpperCase() === \"NOTATION\") {\n            attributeType = \"NOTATION\";\n            i += 8; // Move past \"NOTATION\"\n\n            // Skip whitespace after \"NOTATION\"\n            i = skipWhitespace(xmlData, i);\n\n            // Expect '(' to start the list of notations\n            if (xmlData[i] !== \"(\") {\n                throw new Error(`Expected '(', found \"${xmlData[i]}\"`);\n            }\n            i++; // Move past '('\n\n            // Read the list of allowed notations\n            let allowedNotations = [];\n            while (i < xmlData.length && xmlData[i] !== \")\") {\n                let notation = \"\";\n                while (i < xmlData.length && xmlData[i] !== \"|\" && xmlData[i] !== \")\") {\n                    notation += xmlData[i];\n                    i++;\n                }\n\n                // Validate notation name\n                notation = notation.trim();\n                if (!validateEntityName(notation)) {\n                    throw new Error(`Invalid notation name: \"${notation}\"`);\n                }\n\n                allowedNotations.push(notation);\n\n                // Skip '|' separator or exit loop\n                if (xmlData[i] === \"|\") {\n                    i++; // Move past '|'\n                    i = skipWhitespace(xmlData, i); // Skip optional whitespace after '|'\n                }\n            }\n\n            if (xmlData[i] !== \")\") {\n                throw new Error(\"Unterminated list of notations\");\n            }\n            i++; // Move past ')'\n\n            // Store the allowed notations as part of the attribute type\n            attributeType += \" (\" + allowedNotations.join(\"|\") + \")\";\n        } else {\n            // Handle simple types (e.g., CDATA, ID, IDREF, etc.)\n            while (i < xmlData.length && !/\\s/.test(xmlData[i])) {\n                attributeType += xmlData[i];\n                i++;\n            }\n\n            // Validate simple attribute type\n            const validTypes = [\"CDATA\", \"ID\", \"IDREF\", \"IDREFS\", \"ENTITY\", \"ENTITIES\", \"NMTOKEN\", \"NMTOKENS\"];\n            if (!this.suppressValidationErr && !validTypes.includes(attributeType.toUpperCase())) {\n                throw new Error(`Invalid attribute type: \"${attributeType}\"`);\n            }\n        }\n\n        // Skip whitespace after attribute type\n        i = skipWhitespace(xmlData, i);\n\n        // Read default value\n        let defaultValue = \"\";\n        if (xmlData.substring(i, i + 8).toUpperCase() === \"#REQUIRED\") {\n            defaultValue = \"#REQUIRED\";\n            i += 8;\n        } else if (xmlData.substring(i, i + 7).toUpperCase() === \"#IMPLIED\") {\n            defaultValue = \"#IMPLIED\";\n            i += 7;\n        } else {\n            [i, defaultValue] = this.readIdentifierVal(xmlData, i, \"ATTLIST\");\n        }\n\n        return {\n            elementName,\n            attributeName,\n            attributeType,\n            defaultValue,\n            index: i\n        }\n    }\n}\n\n\n\nconst skipWhitespace = (data, index) => {\n    while (index < data.length && /\\s/.test(data[index])) {\n        index++;\n    }\n    return index;\n};\n\n\n\nfunction hasSeq(data, seq,i){\n    for(let j=0;j<seq.length;j++){\n        if(seq[j]!==data[i+j+1]) return false;\n    }\n    return true;\n}\n\nfunction validateEntityName(name){\n    if (isName(name))\n\t    return name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n","const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)([0-9]*(\\.[0-9]*)?)$/;\n// const octRegex = /^0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n \nconst consider = {\n    hex :  true,\n    // oct: false,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true,\n    //skipLike: /regex/\n};\n\nexport default function toNumber(str, options = {}){\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    \n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if(str===\"0\") return 0;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return parse_int(trimmedStr, 16);\n    // }else if (options.oct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    }else if (trimmedStr.includes('e') || trimmedStr.includes('E')) { //eNotation\n        return resolveEnotation(str,trimmedStr,options);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        // +00.123 => [ , '+', '00', '.123', ..\n        if(match){\n            const sign = match[1] || \"\";\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            const decimalAdjacentToLeadingZeros = sign ? // 0., -00., 000.\n                str[leadingZeros.length+1] === \".\" \n                : str[leadingZeros.length] === \".\";\n\n            //trim ending zeros for floating number\n            if(!options.leadingZeros //leading zeros are not allowed\n                && (leadingZeros.length > 1 \n                    || (leadingZeros.length === 1 && !decimalAdjacentToLeadingZeros))){\n                // 00, 00.3, +03.24, 03, 03.24\n                return str;\n            }\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const parsedStr = String(num);\n\n                if( num === 0) return num;\n                if(parsedStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    if(parsedStr === \"0\") return num; //0.0\n                    else if(parsedStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( parsedStr === `${sign}${numTrimmedByZeros}`) return num;\n                    else return str;\n                }\n                \n                let n = leadingZeros? numTrimmedByZeros : trimmedStr;\n                if(leadingZeros){\n                    // -009 => -9\n                    return (n === parsedStr) || (sign+n === parsedStr) ? num : str\n                }else  {\n                    // +9\n                    return (n === parsedStr) || (n === sign+parsedStr) ? num : str\n                }\n            }\n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\nconst eNotationRegx = /^([-+])?(0*)(\\d*(\\.\\d*)?[eE][-\\+]?\\d+)$/;\nfunction resolveEnotation(str,trimmedStr,options){\n    if(!options.eNotation) return str;\n    const notation = trimmedStr.match(eNotationRegx); \n    if(notation){\n        let sign = notation[1] || \"\";\n        const eChar = notation[3].indexOf(\"e\") === -1 ? \"E\" : \"e\";\n        const leadingZeros = notation[2];\n        const eAdjacentToLeadingZeros = sign ? // 0E.\n            str[leadingZeros.length+1] === eChar \n            : str[leadingZeros.length] === eChar;\n\n        if(leadingZeros.length > 1 && eAdjacentToLeadingZeros) return str;\n        else if(leadingZeros.length === 1 \n            && (notation[3].startsWith(`.${eChar}`) || notation[3][0] === eChar)){\n                return Number(trimmedStr);\n        }else if(options.leadingZeros && !eAdjacentToLeadingZeros){ //accept with leading zeros\n            //remove leading 0s\n            trimmedStr = (notation[1] || \"\") + notation[3];\n            return Number(trimmedStr);\n        }else return str;\n    }else{\n        return str;\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substring(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\n\nfunction parse_int(numStr, base){\n    //polyfill\n    if(parseInt) return parseInt(numStr, base);\n    else if(Number.parseInt) return Number.parseInt(numStr, base);\n    else if(window && window.parseInt) return window.parseInt(numStr, base);\n    else throw new Error(\"parseInt, Number.parseInt, window.parseInt are not supported\")\n}","export default function getIgnoreAttributesFn(ignoreAttributes) {\n    if (typeof ignoreAttributes === 'function') {\n        return ignoreAttributes\n    }\n    if (Array.isArray(ignoreAttributes)) {\n        return (attrName) => {\n            for (const pattern of ignoreAttributes) {\n                if (typeof pattern === 'string' && attrName === pattern) {\n                    return true\n                }\n                if (pattern instanceof RegExp && pattern.test(attrName)) {\n                    return true\n                }\n            }\n        }\n    }\n    return () => false\n}","'use strict';\n///@ts-check\n\nimport {getAllMatches, isExist} from '../util.js';\nimport xmlNode from './xmlNode.js';\nimport DocTypeReader from './DocTypeReader.js';\nimport toNumber from \"strnum\";\nimport getIgnoreAttributesFn from \"../ignoreAttributes.js\";\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nexport default class OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"\" },\n      \"num_dec\": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCodePoint(Number.parseInt(str, 10)) },\n      \"num_hex\": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCodePoint(Number.parseInt(str, 16)) },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)\n\n    if(this.options.stopNodes && this.options.stopNodes.length > 0){\n      this.stopNodesExact = new Set();\n      this.stopNodesWildcard = new Set();\n      for(let i = 0; i < this.options.stopNodes.length; i++){\n        const stopNodeExp = this.options.stopNodes[i];\n        if(typeof stopNodeExp !== 'string') continue;\n        if(stopNodeExp.startsWith(\"*.\")){\n          this.stopNodesWildcard.add(stopNodeExp.substring(2));\n        }else{\n          this.stopNodesExact.add(stopNodeExp);\n        }\n      }\n    }\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath) {\n  if (this.options.ignoreAttributes !== true && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      if (this.ignoreAttributesFn(attrName, jPath)) {\n        continue\n      }\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  const docTypeReader = new DocTypeReader(this.options.processEntities);\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n          //do nothing\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath);\n          }\n          this.addChild(currentNode, childNode, jPath, i);\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = docTypeReader.readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n        if(val == undefined) val = \"\";\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          //console.log(tagExp, tagName)\n          const newTagName = this.options.transformTagName(tagName);\n          if(tagExp === tagName) {\n            tagExp = newTagName\n          }\n          tagName = newTagName;\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        const startIndex = i;\n        if (this.isItStopNode(this.stopNodesExact, this.stopNodesWildcard, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            \n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath\n            );\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath, startIndex);\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              const newTagName = this.options.transformTagName(tagName);\n              if(tagExp === tagName) {\n                tagExp = newTagName\n              }\n              tagName = newTagName;\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath);\n            }\n            this.addChild(currentNode, childNode, jPath, startIndex);\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath);\n            }\n            this.addChild(currentNode, childNode, jPath, startIndex);\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath, startIndex){\n  // unset startIndex if not requested\n  if (!this.options.captureMetaData) startIndex = undefined;\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n    //do nothing\n  } else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode, startIndex);\n  }else{\n    currentNode.addChild(childNode, startIndex);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = currentNode.child.length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * @param {Set} stopNodesExact\n * @param {Set} stopNodesWildcard\n * @param {string} jPath\n * @param {string} currentTagName\n */\nfunction isItStopNode(stopNodesExact, stopNodesWildcard, jPath, currentTagName){\n  if(stopNodesWildcard && stopNodesWildcard.has(currentTagName)) return true;\n  if(stopNodesExact && stopNodesExact.has(jPath)) return true;\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n","'use strict';\n\nimport XmlNode from './xmlNode.js';\n\nconst METADATA_SYMBOL = XmlNode.getMetaDataSymbol();\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nexport default function prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n      if (tagObj[METADATA_SYMBOL] !== undefined) {\n        val[METADATA_SYMBOL] = tagObj[METADATA_SYMBOL]; // copy over metadata\n      }\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\n","import { buildOptions} from './OptionsBuilder.js';\nimport OrderedObjParser from './OrderedObjParser.js';\nimport prettify from './node2json.js';\nimport {validate} from \"../validator.js\";\nimport XmlNode from './xmlNode.js';\n\nexport default class XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Uint8Array} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData !== \"string\" && xmlData.toString){\n            xmlData = xmlData.toString();\n        }else if(typeof xmlData !== \"string\"){\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        \n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n\n    /**\n     * Returns a Symbol that can be used to access the metadata\n     * property on a node.\n     * \n     * If Symbol is not available in the environment, an ordinary property is used\n     * and the name of the property is here returned.\n     * \n     * The XMLMetaData property is only present when `captureMetaData`\n     * is true in the options.\n     */\n    static getMetaDataSymbol() {\n        return XmlNode.getMetaDataSymbol();\n    }\n}\n","import { XMLParser } from \"fast-xml-parser\";\nimport { addComponent, Pair } from \"bitecs\";\nimport type { State } from \"./state\";\nimport {\n    getRegisteredComponent,\n    type ParseContext,\n    type ComponentData,\n    type RegisteredComponent,\n} from \"./component\";\nimport { getRelationDef, ChildOf } from \"./relation\";\nimport { toKebabCase, toCamelCase } from \"./strings\";\n\nfunction levenshtein(a: string, b: string): number {\n    if (a.length === 0) return b.length;\n    if (b.length === 0) return a.length;\n\n    const matrix: number[][] = [];\n    for (let i = 0; i <= b.length; i++) {\n        matrix[i] = [i];\n    }\n    for (let j = 0; j <= a.length; j++) {\n        matrix[0][j] = j;\n    }\n\n    for (let i = 1; i <= b.length; i++) {\n        for (let j = 1; j <= a.length; j++) {\n            const cost = a[j - 1] === b[i - 1] ? 0 : 1;\n            matrix[i][j] = Math.min(\n                matrix[i - 1][j] + 1,\n                matrix[i][j - 1] + 1,\n                matrix[i - 1][j - 1] + cost\n            );\n        }\n    }\n\n    return matrix[b.length][a.length];\n}\n\nfunction findClosestMatch(input: string, candidates: string[]): string | null {\n    const inputKebab = toKebabCase(input);\n\n    let bestMatch: string | null = null;\n    let bestScore = Infinity;\n\n    for (const candidate of candidates) {\n        const candidateKebab = toKebabCase(candidate);\n\n        if (inputKebab === candidateKebab) {\n            return candidate;\n        }\n\n        if (inputKebab.endsWith(candidateKebab) || inputKebab.endsWith(\"-\" + candidateKebab)) {\n            return candidate;\n        }\n\n        const distance = levenshtein(inputKebab, candidateKebab);\n        const maxLen = Math.max(inputKebab.length, candidateKebab.length);\n        const threshold = Math.ceil(maxLen * 0.5);\n\n        if (distance < bestScore && distance <= threshold) {\n            bestScore = distance;\n            bestMatch = candidate;\n        }\n    }\n\n    return bestMatch;\n}\n\nexport interface ParsedElement {\n    readonly tag: string;\n    readonly attrs: Readonly<Record<string, string>>;\n    readonly children: readonly ParsedElement[];\n}\n\nexport interface EntityRef {\n    readonly attrName: string;\n    readonly targetName: string;\n}\n\nexport interface EntityDef {\n    readonly id?: string;\n    readonly components: readonly ComponentDef[];\n    readonly children: readonly EntityDef[];\n    readonly entityRefs: readonly EntityRef[];\n}\n\nexport interface ComponentDef {\n    readonly def: RegisteredComponent;\n    readonly attrs: Record<string, string>;\n}\n\nexport interface ParseResult {\n    readonly entities: readonly EntityDef[];\n    readonly errors: readonly ParseError[];\n    readonly warnings: readonly string[];\n}\n\nexport interface ParseError {\n    readonly message: string;\n    readonly path?: string;\n}\n\nexport function parseXml(xml: string): ParseResult {\n    const errors: ParseError[] = [];\n    const warnings: string[] = [];\n\n    const parser = new XMLParser({\n        ignoreAttributes: false,\n        attributeNamePrefix: \"\",\n        preserveOrder: true,\n        trimValues: true,\n        allowBooleanAttributes: true,\n    });\n\n    let raw: unknown;\n    try {\n        raw = parser.parse(xml, { allowBooleanAttributes: true });\n    } catch (e) {\n        return {\n            entities: [],\n            errors: [{ message: `xml parse error: ${(e as Error).message}` }],\n            warnings: [],\n        };\n    }\n\n    const elements = normalizeRaw(raw);\n    const entities: EntityDef[] = [];\n\n    for (const el of elements) {\n        if (el.tag === \"scene\") {\n            for (const child of el.children) {\n                const result = parseEntityElement(child, errors, warnings);\n                if (result) entities.push(result);\n            }\n        } else if (el.tag === \"a\") {\n            const result = parseEntityElement(el, errors, warnings);\n            if (result) entities.push(result);\n        } else if (el.tag.toLowerCase() === \"scene\" || el.tag.toLowerCase() === \"world\") {\n            errors.push({ message: `Invalid tag \"${el.tag}\". Use lowercase <scene>` });\n        }\n    }\n\n    return { entities, errors, warnings };\n}\n\nfunction isEntityRef(value: string): boolean {\n    return value.startsWith(\"@\") && value.length > 1;\n}\n\nfunction parseEntityElement(\n    el: ParsedElement,\n    errors: ParseError[],\n    warnings: string[]\n): EntityDef | null {\n    if (el.tag !== \"a\") {\n        if (el.tag.toLowerCase() === \"a\") {\n            errors.push({ message: `Invalid tag \"${el.tag}\". Use lowercase <a>` });\n        }\n        return null;\n    }\n\n    const components: ComponentDef[] = [];\n    const children: EntityDef[] = [];\n    const entityRefs: EntityRef[] = [];\n    const shorthands: Array<{ name: string; value: string }> = [];\n    let entityId: string | undefined;\n\n    for (const [attrName, attrValue] of Object.entries(el.attrs)) {\n        if (attrName === \"id\") {\n            entityId = attrValue;\n            continue;\n        }\n\n        if (typeof attrValue === \"string\" && isEntityRef(attrValue)) {\n            entityRefs.push({\n                attrName,\n                targetName: attrValue.slice(1),\n            });\n            continue;\n        }\n\n        const registered = getRegisteredComponent(attrName);\n        if (registered) {\n            const attrs: Record<string, string> = {};\n            if (typeof attrValue === \"string\" && attrValue !== \"\") {\n                attrs[\"_value\"] = attrValue;\n            }\n            components.push({ def: registered, attrs });\n            continue;\n        }\n\n        if (typeof attrValue === \"string\" && attrValue !== \"\") {\n            shorthands.push({ name: attrName, value: attrValue });\n        }\n    }\n\n    for (const { name, value } of shorthands) {\n        const camel = toCamelCase(name);\n        let matched = false;\n\n        for (const comp of components) {\n            const component = comp.def.component;\n            const hasField = camel in component || `${camel}X` in component;\n\n            if (hasField) {\n                matched = true;\n                if (!comp.attrs._value) {\n                    comp.attrs[name] = value;\n                }\n            }\n        }\n\n        if (!matched) {\n            const id = entityId ? ` (${entityId})` : \"\";\n            warnings.push(`shorthand \"${name}\" matches no declared component${id}`);\n        }\n    }\n\n    for (const child of el.children) {\n        if (child.tag === \"a\") {\n            const childEntity = parseEntityElement(child, errors, warnings);\n            if (childEntity) children.push(childEntity);\n        } else if (child.tag.toLowerCase() === \"a\") {\n            errors.push({ message: `Invalid tag \"${child.tag}\". Use lowercase <a>` });\n        } else {\n            errors.push({ message: `Only <a> children allowed, found <${child.tag}>` });\n        }\n    }\n\n    return { id: entityId, components, children, entityRefs };\n}\n\ninterface RawElement {\n    [key: string]: unknown;\n    \":@\"?: Record<string, string>;\n}\n\nfunction normalizeRaw(raw: unknown): ParsedElement[] {\n    if (!Array.isArray(raw)) return [];\n\n    const result: ParsedElement[] = [];\n\n    for (const item of raw as RawElement[]) {\n        if (typeof item !== \"object\" || item === null) continue;\n\n        for (const [key, value] of Object.entries(item)) {\n            if (key === \":@\") continue;\n\n            const rawAttrs = item[\":@\"] ?? {};\n            const attrs: Record<string, string> = {};\n\n            for (const [attrKey, attrVal] of Object.entries(rawAttrs)) {\n                if (typeof attrVal === \"string\") {\n                    attrs[attrKey] = attrVal;\n                } else if (attrVal === true || attrVal === \"\") {\n                    attrs[attrKey] = \"\";\n                }\n            }\n\n            const children = normalizeRaw(value as unknown);\n\n            result.push({\n                tag: key,\n                attrs,\n                children,\n            });\n        }\n    }\n\n    return result;\n}\n\nexport interface LoadResult {\n    readonly entities: Map<string, number>;\n    readonly roots: readonly number[];\n    readonly errors: readonly ParseError[];\n}\n\nexport type PostLoadHook = (state: State, context: ParseContext) => void;\n\nconst postLoadHooks: PostLoadHook[] = [];\n\nexport function registerPostLoadHook(hook: PostLoadHook): void {\n    postLoadHooks.push(hook);\n}\n\nexport function unregisterPostLoadHook(hook: PostLoadHook): void {\n    const idx = postLoadHooks.indexOf(hook);\n    if (idx !== -1) postLoadHooks.splice(idx, 1);\n}\n\nclass LoadParseContext implements ParseContext {\n    private readonly nameToEntity = new Map<string, number>();\n    private _currentEid = 0;\n\n    get currentEid(): number {\n        return this._currentEid;\n    }\n\n    setCurrentEid(eid: number): void {\n        this._currentEid = eid;\n    }\n\n    getEntityByName(name: string): number | null {\n        return this.nameToEntity.get(name) ?? null;\n    }\n\n    setName(name: string, eid: number): void {\n        this.nameToEntity.set(name, eid);\n    }\n\n    getEntityMap(): Map<string, number> {\n        return new Map(this.nameToEntity);\n    }\n}\n\nexport function loadScene(state: State, xml: string): LoadResult {\n    const parseResult = parseXml(xml);\n    return instantiateScene(state, parseResult.entities, parseResult.errors);\n}\n\nexport async function loadSceneFile(\n    state: State,\n    path: string,\n    readFile: (path: string) => Promise<string>\n): Promise<LoadResult> {\n    const xml = await readFile(path);\n    return loadScene(state, xml);\n}\n\ninterface QueuedEntity {\n    readonly def: EntityDef;\n    readonly eid: number;\n    readonly parent?: number;\n}\n\nfunction instantiateScene(\n    state: State,\n    entityDefs: readonly EntityDef[],\n    parseErrors: readonly ParseError[]\n): LoadResult {\n    const context = new LoadParseContext();\n    const errors: ParseError[] = [...parseErrors];\n    const queue: QueuedEntity[] = [];\n    const roots: number[] = [];\n\n    for (const entityDef of entityDefs) {\n        const eid = createEntityTree(state, entityDef, context, undefined, queue);\n        roots.push(eid);\n    }\n\n    for (const { def, eid, parent } of queue) {\n        if (parent !== undefined) {\n            addComponent(state.world, eid, Pair(ChildOf.relation, parent));\n        }\n\n        for (const ref of def.entityRefs) {\n            applyRelation(state, eid, ref, context, errors);\n        }\n\n        for (const compDef of def.components) {\n            applyComponent(state, eid, compDef, context, errors);\n        }\n    }\n\n    for (const hook of postLoadHooks) {\n        hook(state, context);\n    }\n\n    return {\n        entities: context.getEntityMap(),\n        roots,\n        errors,\n    };\n}\n\nfunction createEntityTree(\n    state: State,\n    def: EntityDef,\n    context: LoadParseContext,\n    parent: number | undefined,\n    queue: QueuedEntity[]\n): number {\n    const eid = state.addEntity();\n\n    if (def.id) {\n        context.setName(def.id, eid);\n    }\n\n    queue.push({ def, eid, parent });\n\n    for (const childDef of def.children) {\n        createEntityTree(state, childDef, context, eid, queue);\n    }\n\n    return eid;\n}\n\nfunction applyRelation(\n    state: State,\n    eid: number,\n    ref: EntityRef,\n    context: LoadParseContext,\n    errors: ParseError[]\n): void {\n    const relationDef = getRelationDef(ref.attrName);\n    if (!relationDef) {\n        errors.push({ message: `Unknown relation: \"${ref.attrName}\"` });\n        return;\n    }\n\n    const targetEid = context.getEntityByName(ref.targetName);\n    if (targetEid === null) {\n        errors.push({ message: `Unknown entity: \"@${ref.targetName}\"` });\n        return;\n    }\n\n    state.addRelation(eid, relationDef, targetEid);\n}\n\nfunction applyComponent(\n    state: State,\n    eid: number,\n    compDef: ComponentDef,\n    context: LoadParseContext,\n    errors: ParseError[]\n): void {\n    const { def, attrs } = compDef;\n    const { component, name, traits } = def;\n\n    state.addComponent(eid, component as never);\n\n    const defaults = traits?.defaults?.() ?? {};\n    for (const [field, value] of Object.entries(defaults)) {\n        setFieldValue(component, field, eid, value as number);\n    }\n\n    let values: Record<string, number>;\n\n    context.setCurrentEid(eid);\n    if (traits?.adapter) {\n        values = traits.adapter(attrs, state, context) as Record<string, number>;\n    } else {\n        const result = parseAttrs(def, attrs);\n        values = result.values;\n        for (const err of result.errors) {\n            errors.push({ message: `<${name}> ${err}` });\n        }\n    }\n\n    for (const [field, value] of Object.entries(values)) {\n        setFieldValue(component, field, eid, value);\n    }\n}\n\nfunction parseAttrs(\n    def: RegisteredComponent,\n    attrs: Record<string, string>\n): { values: Record<string, number>; errors: string[] } {\n    const allValues: Record<string, number> = {};\n    const allErrors: string[] = [];\n\n    if (attrs._value) {\n        if (isCSSAttrSyntax(attrs._value)) {\n            const result = parsePropertyString(def.name, attrs._value, def.component);\n            Object.assign(allValues, result.values);\n            allErrors.push(...result.errors);\n        }\n    }\n\n    for (const [attrName, attrValue] of Object.entries(attrs)) {\n        if (attrName === \"_value\") continue;\n        if (!attrValue) continue;\n\n        if (isCSSAttrSyntax(attrValue)) {\n            const result = parsePropertyString(def.name, attrValue, def.component);\n            Object.assign(allValues, result.values);\n            allErrors.push(...result.errors);\n        } else {\n            const result = parsePropertyString(\n                def.name,\n                `${attrName}: ${attrValue}`,\n                def.component\n            );\n            Object.assign(allValues, result.values);\n            allErrors.push(...result.errors);\n        }\n    }\n\n    return { values: allValues, errors: allErrors };\n}\n\nfunction setFieldValue(component: ComponentData, field: string, eid: number, value: number): void {\n    const arr = component[field];\n    if (arr != null && (ArrayBuffer.isView(arr) || Array.isArray(arr))) {\n        arr[eid] = value;\n    }\n}\n\ninterface PropertyParseResult {\n    readonly values: Record<string, number>;\n    readonly errors: readonly string[];\n}\n\nfunction detectVec2(component: ComponentData, base: string): boolean {\n    return `${base}X` in component && `${base}Y` in component;\n}\n\nfunction detectVec3(component: ComponentData, base: string): boolean {\n    return detectVec2(component, base) && `${base}Z` in component;\n}\n\nfunction detectVec4(component: ComponentData, base: string): boolean {\n    return detectVec3(component, base) && `${base}W` in component;\n}\n\nfunction parseNumber(value: string): number | null {\n    value = value.trim();\n\n    if (value.startsWith(\"0x\") || value.startsWith(\"0X\")) {\n        return parseInt(value, 16);\n    }\n\n    if (value.startsWith(\"#\")) {\n        return parseInt(value.slice(1), 16);\n    }\n\n    if (value === \"true\") return 1;\n    if (value === \"false\") return 0;\n\n    const num = parseFloat(value);\n    return isNaN(num) ? null : num;\n}\n\nfunction parseValues(valueStr: string): (number | null)[] {\n    const result: (number | null)[] = [];\n    const trimmed = valueStr.trim();\n    let start = 0;\n    for (let i = 0; i <= trimmed.length; i++) {\n        const isWhitespace = i < trimmed.length && /\\s/.test(trimmed[i]);\n        const isEnd = i === trimmed.length;\n        if (isWhitespace || isEnd) {\n            if (start < i) {\n                result.push(parseNumber(trimmed.slice(start, i)));\n            }\n            start = i + 1;\n        }\n    }\n    return result;\n}\n\nfunction splitProperties(str: string): string[] {\n    const result: string[] = [];\n    let start = 0;\n    for (let i = 0; i <= str.length; i++) {\n        if (i === str.length || str[i] === \";\") {\n            const prop = str.slice(start, i).trim();\n            if (prop) result.push(prop);\n            start = i + 1;\n        }\n    }\n    return result;\n}\n\nfunction parsePropertyString(\n    componentName: string,\n    propertyString: string,\n    component: ComponentData\n): PropertyParseResult {\n    const values: Record<string, number> = {};\n    const errors: string[] = [];\n\n    const properties = splitProperties(propertyString);\n\n    for (const prop of properties) {\n        const colonIdx = prop.indexOf(\":\");\n        if (colonIdx === -1) {\n            errors.push(`Invalid syntax: \"${prop}\" (expected \"field: value\")`);\n            continue;\n        }\n\n        const rawName = prop.slice(0, colonIdx).trim();\n        const valueStr = prop.slice(colonIdx + 1).trim();\n\n        if (!rawName || !valueStr) {\n            errors.push(`Invalid syntax: \"${prop}\" (empty field or value)`);\n            continue;\n        }\n\n        const name = toCamelCase(rawName);\n        const parsed = parseValues(valueStr);\n\n        if (parsed.some((v) => v === null)) {\n            errors.push(`Invalid number in \"${prop}\"`);\n            continue;\n        }\n\n        const nums = parsed as number[];\n\n        if (detectVec4(component, name)) {\n            if (nums.length === 4) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[1];\n                values[`${name}Z`] = nums[2];\n                values[`${name}W`] = nums[3];\n            } else if (nums.length === 1) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[0];\n                values[`${name}Z`] = nums[0];\n                values[`${name}W`] = nums[0];\n            } else {\n                errors.push(\n                    `${componentName}.${rawName}: expected 1 or 4 values, got ${nums.length}`\n                );\n            }\n            continue;\n        }\n\n        if (detectVec3(component, name)) {\n            if (nums.length === 3) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[1];\n                values[`${name}Z`] = nums[2];\n            } else if (nums.length === 1) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[0];\n                values[`${name}Z`] = nums[0];\n            } else {\n                errors.push(\n                    `${componentName}.${rawName}: expected 1 or 3 values, got ${nums.length}`\n                );\n            }\n            continue;\n        }\n\n        if (detectVec2(component, name)) {\n            if (nums.length === 2) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[1];\n            } else if (nums.length === 1) {\n                values[`${name}X`] = nums[0];\n                values[`${name}Y`] = nums[0];\n            } else {\n                errors.push(\n                    `${componentName}.${rawName}: expected 1 or 2 values, got ${nums.length}`\n                );\n            }\n            continue;\n        }\n\n        if (name in component) {\n            if (nums.length === 1) {\n                values[name] = nums[0];\n            } else {\n                errors.push(`${componentName}.${rawName}: expected 1 value, got ${nums.length}`);\n            }\n            continue;\n        }\n\n        const fieldNames = Object.keys(component);\n        const suggestion = findClosestMatch(rawName, fieldNames);\n        if (suggestion) {\n            errors.push(\n                `${componentName}: unknown field \"${rawName}\", did you mean \"${toKebabCase(suggestion)}\"?`\n            );\n        } else {\n            errors.push(`${componentName}: unknown field \"${rawName}\"`);\n        }\n    }\n\n    return { values, errors };\n}\n\nfunction isCSSAttrSyntax(value: string): boolean {\n    return value.includes(\":\") && (value.includes(\";\") || /^[\\w-]+\\s*:/.test(value));\n}\n","import type { ComputeNode, NodeId, Phase, ResourceId, ResourceRef } from \"./graph\";\nimport type { FrameTiming } from \"./timing\";\n\nexport interface NodeInfo {\n    readonly id: NodeId;\n    readonly phase: Phase;\n    readonly inputs: readonly ResourceRef[];\n    readonly outputs: readonly ResourceRef[];\n}\n\nexport interface EdgeInfo {\n    readonly from: NodeId;\n    readonly to: NodeId;\n    readonly resource: ResourceId;\n}\n\nexport interface GraphInspection {\n    readonly nodes: readonly NodeInfo[];\n    readonly edges: readonly EdgeInfo[];\n    readonly executionOrder: readonly NodeId[];\n    readonly byPhase: ReadonlyMap<Phase, readonly NodeId[]>;\n}\n\nconst PHASE_ORDER: Phase[] = [\"opaque\", \"transparent\", \"postprocess\"];\n\nexport function inspect(nodes: readonly ComputeNode[]): GraphInspection {\n    const nodeInfos: NodeInfo[] = nodes.map((n) => ({\n        id: n.id,\n        phase: n.phase ?? \"opaque\",\n        inputs: n.inputs,\n        outputs: n.outputs,\n    }));\n\n    const producers = new Map<ResourceId, NodeId>();\n    for (const n of nodes) {\n        for (const out of n.outputs) {\n            producers.set(out.id, n.id);\n        }\n    }\n\n    const edges: EdgeInfo[] = [];\n    for (const n of nodes) {\n        for (const inp of n.inputs) {\n            const producer = producers.get(inp.id);\n            if (producer) {\n                edges.push({\n                    from: producer,\n                    to: n.id,\n                    resource: inp.id,\n                });\n            }\n        }\n    }\n\n    const byPhase = new Map<Phase, NodeId[]>();\n    for (const phase of PHASE_ORDER) {\n        byPhase.set(phase, []);\n    }\n    for (const n of nodeInfos) {\n        byPhase.get(n.phase)!.push(n.id);\n    }\n\n    const executionOrder = topoSortIds(nodes);\n\n    return { nodes: nodeInfos, edges, executionOrder, byPhase };\n}\n\nfunction topoSortIds(nodes: readonly ComputeNode[]): NodeId[] {\n    if (nodes.length === 0) return [];\n\n    const producers = new Map<ResourceId, ComputeNode>();\n    for (const node of nodes) {\n        for (const output of node.outputs) {\n            producers.set(output.id, node);\n        }\n    }\n\n    const adjacency = new Map<ComputeNode, ComputeNode[]>();\n    const inDegree = new Map<ComputeNode, number>();\n\n    for (const node of nodes) {\n        adjacency.set(node, []);\n        inDegree.set(node, 0);\n    }\n\n    for (const node of nodes) {\n        for (const input of node.inputs) {\n            const producer = producers.get(input.id);\n            if (producer) {\n                adjacency.get(producer)!.push(node);\n                inDegree.set(node, inDegree.get(node)! + 1);\n            }\n        }\n    }\n\n    const byPhase = new Map<Phase, ComputeNode[]>();\n    for (const phase of PHASE_ORDER) {\n        byPhase.set(phase, []);\n    }\n    for (const node of nodes) {\n        const phase = node.phase ?? \"opaque\";\n        byPhase.get(phase)!.push(node);\n    }\n\n    const sorted: NodeId[] = [];\n    for (const phase of PHASE_ORDER) {\n        const phaseNodes = byPhase.get(phase)!;\n        const phaseInDegree = new Map<ComputeNode, number>();\n\n        for (const node of phaseNodes) {\n            let degree = 0;\n            for (const input of node.inputs) {\n                const producer = producers.get(input.id);\n                if (producer && phaseNodes.includes(producer)) {\n                    degree++;\n                }\n            }\n            phaseInDegree.set(node, degree);\n        }\n\n        const queue: ComputeNode[] = [];\n        for (const node of phaseNodes) {\n            if (phaseInDegree.get(node) === 0) {\n                queue.push(node);\n            }\n        }\n\n        let i = 0;\n        while (i < queue.length) {\n            const node = queue[i++];\n            sorted.push(node.id);\n\n            for (const dep of phaseNodes) {\n                for (const input of dep.inputs) {\n                    const producer = producers.get(input.id);\n                    if (producer === node) {\n                        const newDegree = phaseInDegree.get(dep)! - 1;\n                        phaseInDegree.set(dep, newDegree);\n                        if (newDegree === 0) {\n                            queue.push(dep);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return sorted;\n}\n\nexport function formatGraph(info: GraphInspection, timing?: FrameTiming): string {\n    const lines: string[] = [];\n    lines.push(\"=== Compute Graph ===\");\n    lines.push(\"\");\n\n    const nodeMap = new Map(info.nodes.map((n) => [n.id, n]));\n    const timingMap = new Map(timing?.nodes.map((t) => [t.nodeId, t]));\n\n    for (const phase of PHASE_ORDER) {\n        const nodeIds = info.byPhase.get(phase) ?? [];\n        if (nodeIds.length === 0) continue;\n\n        lines.push(`[${phase}]`);\n        for (const id of nodeIds) {\n            const node = nodeMap.get(id)!;\n            const ins = node.inputs.map((r) => r.id).join(\", \") || \"none\";\n            const outs = node.outputs.map((r) => r.id).join(\", \") || \"none\";\n            lines.push(`  ${id}: ${ins} -> ${outs}`);\n        }\n        lines.push(\"\");\n    }\n\n    lines.push(\"Execution Order:\");\n    info.executionOrder.forEach((id, i) => {\n        lines.push(`  ${i + 1}. ${id}`);\n    });\n\n    if (timing) {\n        lines.push(\"\");\n        lines.push(\"Timing:\");\n        for (const nodeId of info.executionOrder) {\n            const nodeTiming = timingMap.get(nodeId);\n            if (nodeTiming) {\n                lines.push(`  ${nodeId}: ${nodeTiming.cpuMs.toFixed(2)}ms`);\n            }\n        }\n        lines.push(`  Total: ${timing.totalCpuMs.toFixed(2)}ms`);\n    }\n\n    return lines.join(\"\\n\");\n}\n\nexport function toDot(info: GraphInspection): string {\n    const lines: string[] = [\"digraph ComputeGraph {\"];\n    lines.push(\"  rankdir=LR;\");\n    lines.push(\"  node [shape=box];\");\n    lines.push(\"\");\n\n    for (const phase of PHASE_ORDER) {\n        const nodeIds = info.byPhase.get(phase) ?? [];\n        if (nodeIds.length === 0) continue;\n\n        lines.push(`  subgraph cluster_${phase} {`);\n        lines.push(`    label=\"${phase}\";`);\n        for (const id of nodeIds) {\n            lines.push(`    \"${id}\";`);\n        }\n        lines.push(\"  }\");\n    }\n\n    lines.push(\"\");\n\n    for (const edge of info.edges) {\n        lines.push(`  \"${edge.from}\" -> \"${edge.to}\" [label=\"${edge.resource}\"];`);\n    }\n\n    lines.push(\"}\");\n    return lines.join(\"\\n\");\n}\n","import { CycleError } from \"../../core\";\nimport { inspect as inspectGraph, type GraphInspection } from \"./inspect\";\n\nexport type ResourceId = string;\nexport type NodeId = string;\nexport type Phase = \"opaque\" | \"transparent\" | \"postprocess\";\n\nconst PHASE_ORDER: Phase[] = [\"opaque\", \"transparent\", \"postprocess\"];\n\nexport interface ResourceRef {\n    id: ResourceId;\n    access: \"read\" | \"write\";\n}\n\nexport interface ExecutionContext {\n    readonly device: GPUDevice;\n    readonly queue: GPUQueue;\n    readonly encoder: GPUCommandEncoder;\n    readonly context: GPUCanvasContext;\n    readonly format: GPUTextureFormat;\n    readonly canvasView: GPUTextureView;\n    getTexture(id: ResourceId): GPUTexture | null;\n    getTextureView(id: ResourceId): GPUTextureView | null;\n    getBuffer(id: ResourceId): GPUBuffer | null;\n    setTexture(id: ResourceId, texture: GPUTexture): void;\n    setTextureView(id: ResourceId, view: GPUTextureView): void;\n    setBuffer(id: ResourceId, buffer: GPUBuffer): void;\n}\n\nexport interface ComputeNode {\n    readonly id: NodeId;\n    readonly phase?: Phase;\n    readonly inputs: readonly ResourceRef[];\n    readonly outputs: readonly ResourceRef[];\n    readonly execute: (ctx: ExecutionContext) => void;\n}\n\nexport interface ExecutionPlan {\n    readonly sorted: readonly ComputeNode[];\n}\n\nfunction buildEdges(nodes: ComputeNode[]): [ComputeNode, ComputeNode][] {\n    const edges: [ComputeNode, ComputeNode][] = [];\n    const producers = new Map<ResourceId, ComputeNode>();\n\n    for (const node of nodes) {\n        for (const output of node.outputs) {\n            producers.set(output.id, node);\n        }\n    }\n\n    for (const node of nodes) {\n        for (const input of node.inputs) {\n            const producer = producers.get(input.id);\n            if (producer) {\n                edges.push([producer, node]);\n            }\n        }\n    }\n\n    return edges;\n}\n\nfunction topoSort(nodes: ComputeNode[]): ComputeNode[] {\n    if (nodes.length === 0) return [];\n\n    const edges = buildEdges(nodes);\n    const adjacency = new Map<ComputeNode, ComputeNode[]>();\n    const inDegree = new Map<ComputeNode, number>();\n\n    for (const node of nodes) {\n        adjacency.set(node, []);\n        inDegree.set(node, 0);\n    }\n\n    for (const [from, to] of edges) {\n        adjacency.get(from)!.push(to);\n        inDegree.set(to, inDegree.get(to)! + 1);\n    }\n\n    const queue: ComputeNode[] = [];\n    for (const node of nodes) {\n        if (inDegree.get(node) === 0) {\n            queue.push(node);\n        }\n    }\n\n    const sorted: ComputeNode[] = [];\n    let i = 0;\n\n    while (i < queue.length) {\n        const node = queue[i++];\n        sorted.push(node);\n\n        for (const dep of adjacency.get(node)!) {\n            const newDegree = inDegree.get(dep)! - 1;\n            inDegree.set(dep, newDegree);\n            if (newDegree === 0) {\n                queue.push(dep);\n            }\n        }\n    }\n\n    if (sorted.length !== nodes.length) {\n        throw new CycleError();\n    }\n\n    return sorted;\n}\n\nfunction compile(nodes: ComputeNode[]): ExecutionPlan {\n    if (nodes.length === 0) {\n        return { sorted: [] };\n    }\n\n    const byPhase = new Map<Phase, ComputeNode[]>();\n    for (const phase of PHASE_ORDER) {\n        byPhase.set(phase, []);\n    }\n\n    for (const node of nodes) {\n        const phase = node.phase ?? \"opaque\";\n        byPhase.get(phase)!.push(node);\n    }\n\n    const sorted: ComputeNode[] = [];\n    for (const phase of PHASE_ORDER) {\n        const phaseNodes = byPhase.get(phase)!;\n        sorted.push(...topoSort(phaseNodes));\n    }\n\n    return { sorted };\n}\n\nexport class ComputeGraph {\n    readonly nodes = new Map<NodeId, ComputeNode>();\n    private _plan: ExecutionPlan | null = null;\n\n    add(node: ComputeNode): void {\n        if (this.nodes.has(node.id)) {\n            throw new Error(`Node '${node.id}' already exists`);\n        }\n        this.nodes.set(node.id, node);\n        this._plan = null;\n    }\n\n    set(id: NodeId, node: ComputeNode): void {\n        if (node.id !== id) {\n            throw new Error(`Node id '${node.id}' must match slot id '${id}'`);\n        }\n        this.nodes.set(id, node);\n        this._plan = null;\n    }\n\n    remove(id: NodeId): boolean {\n        const removed = this.nodes.delete(id);\n        if (removed) {\n            this._plan = null;\n        }\n        return removed;\n    }\n\n    compile(): ExecutionPlan {\n        if (!this._plan) {\n            this._plan = compile(Array.from(this.nodes.values()));\n        }\n        return this._plan;\n    }\n\n    inspect(): GraphInspection {\n        return inspectGraph(Array.from(this.nodes.values()));\n    }\n}\n","import type { NodeId } from \"./graph\";\n\nexport interface NodeTiming {\n    readonly nodeId: NodeId;\n    readonly cpuMs: number;\n    readonly gpuNs?: number;\n}\n\nexport interface FrameTiming {\n    readonly frameIndex: number;\n    readonly nodes: readonly NodeTiming[];\n    readonly totalCpuMs: number;\n    readonly totalGpuNs?: number;\n}\n\nexport interface TimingConfig {\n    readonly enabled: boolean;\n    readonly gpuTimestamps: boolean;\n    readonly historySize: number;\n}\n\nexport interface TimingState {\n    readonly config: TimingConfig;\n    readonly history: FrameTiming[];\n    readonly querySet?: GPUQuerySet;\n    readonly resolveBuffer?: GPUBuffer;\n    readonly readBuffer?: GPUBuffer;\n}\n\nexport function supportsTimestampQuery(device: GPUDevice): boolean {\n    return device.features.has(\"timestamp-query\");\n}\n\nexport function createTimingState(\n    device: GPUDevice,\n    maxNodes: number,\n    historySize = 60\n): TimingState {\n    const gpuTimestamps = supportsTimestampQuery(device);\n\n    let querySet: GPUQuerySet | undefined;\n    let resolveBuffer: GPUBuffer | undefined;\n    let readBuffer: GPUBuffer | undefined;\n\n    if (gpuTimestamps) {\n        const queryCount = maxNodes * 2;\n        querySet = device.createQuerySet({\n            label: \"timing-queries\",\n            type: \"timestamp\",\n            count: queryCount,\n        });\n\n        resolveBuffer = device.createBuffer({\n            label: \"timing-resolve\",\n            size: queryCount * 8,\n            usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC,\n        });\n\n        readBuffer = device.createBuffer({\n            label: \"timing-read\",\n            size: queryCount * 8,\n            usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n        });\n    }\n\n    return {\n        config: { enabled: true, gpuTimestamps, historySize },\n        history: [],\n        querySet,\n        resolveBuffer,\n        readBuffer,\n    };\n}\n\nexport async function readTimestamps(\n    device: GPUDevice,\n    timing: TimingState,\n    nodeCount: number\n): Promise<BigUint64Array | null> {\n    if (!timing.querySet || !timing.resolveBuffer || !timing.readBuffer) {\n        return null;\n    }\n\n    const encoder = device.createCommandEncoder();\n    encoder.resolveQuerySet(timing.querySet, 0, nodeCount * 2, timing.resolveBuffer, 0);\n    encoder.copyBufferToBuffer(timing.resolveBuffer, 0, timing.readBuffer, 0, nodeCount * 2 * 8);\n    device.queue.submit([encoder.finish()]);\n\n    await timing.readBuffer.mapAsync(GPUMapMode.READ);\n    const data = new BigUint64Array(timing.readBuffer.getMappedRange().slice(0));\n    timing.readBuffer.unmap();\n\n    return data;\n}\n\nexport function disposeTimingState(timing: TimingState): void {\n    timing.querySet?.destroy();\n    timing.resolveBuffer?.destroy();\n    timing.readBuffer?.destroy();\n}\n\nexport interface TimingCollector {\n    readonly nodeTimings: Map<NodeId, { start: number; end: number }>;\n    beginNode(nodeId: NodeId): void;\n    endNode(nodeId: NodeId): void;\n    finish(frameIndex: number): FrameTiming;\n}\n\nexport function createTimingCollector(): TimingCollector {\n    const nodeTimings = new Map<NodeId, { start: number; end: number }>();\n\n    return {\n        nodeTimings,\n\n        beginNode(nodeId: NodeId): void {\n            nodeTimings.set(nodeId, { start: performance.now(), end: 0 });\n        },\n\n        endNode(nodeId: NodeId): void {\n            const timing = nodeTimings.get(nodeId);\n            if (timing) {\n                timing.end = performance.now();\n            }\n        },\n\n        finish(frameIndex: number): FrameTiming {\n            const nodes: NodeTiming[] = [];\n            let totalCpuMs = 0;\n\n            for (const [nodeId, timing] of nodeTimings) {\n                const cpuMs = timing.end - timing.start;\n                totalCpuMs += cpuMs;\n                nodes.push({ nodeId, cpuMs });\n            }\n\n            return { frameIndex, nodes, totalCpuMs };\n        },\n    };\n}\n","import { resource, type Plugin, type State, type System } from \"../../core\";\nimport { ComputeGraph, type ExecutionContext, type ResourceId } from \"./graph\";\nimport { createTimingCollector, type FrameTiming } from \"./timing\";\n\nexport * from \"./graph\";\nexport * from \"./inspect\";\nexport * from \"./readback\";\nexport * from \"./timing\";\n\nconst MIN_CANVAS_SIZE = 1;\n\nfunction syncCanvasSize(canvas: HTMLCanvasElement): void {\n    const dpr = window.devicePixelRatio || 1;\n    const rect = canvas.getBoundingClientRect();\n\n    const width = Math.max(MIN_CANVAS_SIZE, Math.floor(rect.width * dpr));\n    const height = Math.max(MIN_CANVAS_SIZE, Math.floor(rect.height * dpr));\n\n    if (canvas.width !== width || canvas.height !== height) {\n        canvas.width = width;\n        canvas.height = height;\n    }\n}\n\nlet resizeObserver: ResizeObserver | null = null;\nlet observedCanvas: HTMLCanvasElement | null = null;\n\nexport function createEntityIdBuffer(device: GPUDevice, maxInstances: number): GPUBuffer {\n    return device.createBuffer({\n        label: \"entityIds\",\n        size: maxInstances * 4,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n}\n\nexport async function requestGPU(): Promise<GPUDevice> {\n    if (!navigator.gpu) {\n        throw new Error(\"WebGPU not supported\");\n    }\n\n    const adapter = await navigator.gpu.requestAdapter();\n    if (!adapter) {\n        throw new Error(\"No GPU adapter found\");\n    }\n\n    const maxTextureDimension2D = adapter.limits.maxTextureDimension2D;\n\n    return adapter.requestDevice({\n        requiredLimits: {\n            maxTextureDimension2D,\n        },\n    });\n}\n\nexport interface ComputeResources {\n    textures: Map<ResourceId, GPUTexture>;\n    textureViews: Map<ResourceId, GPUTextureView>;\n    buffers: Map<ResourceId, GPUBuffer>;\n}\n\nexport interface ComputeState {\n    readonly device: GPUDevice;\n    readonly context: GPUCanvasContext;\n    readonly format: GPUTextureFormat;\n    readonly graph: ComputeGraph;\n    readonly resources: ComputeResources;\n    lastFrameTiming: FrameTiming | null;\n    frameIndex: number;\n}\n\nexport const Compute = resource<ComputeState>(\"compute\");\n\nexport const ComputeSystem: System = {\n    group: \"draw\",\n\n    setup(state: State) {\n        if (!state.canvas) return;\n\n        observedCanvas = state.canvas;\n        syncCanvasSize(observedCanvas);\n\n        resizeObserver = new ResizeObserver(() => {\n            if (observedCanvas) syncCanvasSize(observedCanvas);\n        });\n        resizeObserver.observe(observedCanvas);\n    },\n\n    update(state: State) {\n        const compute = Compute.from(state);\n        if (!compute) return;\n\n        const { device, context, format, graph, resources } = compute;\n        const plan = graph.compile();\n\n        if (plan.sorted.length === 0) return;\n\n        const canvasTexture = context.getCurrentTexture();\n        const canvasView = canvasTexture.createView();\n        const encoder = device.createCommandEncoder();\n\n        const ctx: ExecutionContext = {\n            device,\n            queue: device.queue,\n            encoder,\n            context,\n            format,\n            canvasView,\n            getTexture(id: ResourceId) {\n                return resources.textures.get(id) ?? null;\n            },\n            getTextureView(id: ResourceId) {\n                return resources.textureViews.get(id) ?? null;\n            },\n            getBuffer(id: ResourceId) {\n                return resources.buffers.get(id) ?? null;\n            },\n            setTexture(id: ResourceId, texture: GPUTexture) {\n                resources.textures.set(id, texture);\n            },\n            setTextureView(id: ResourceId, view: GPUTextureView) {\n                resources.textureViews.set(id, view);\n            },\n            setBuffer(id: ResourceId, buffer: GPUBuffer) {\n                resources.buffers.set(id, buffer);\n            },\n        };\n\n        const collector = createTimingCollector();\n\n        for (const node of plan.sorted) {\n            collector.beginNode(node.id);\n            node.execute(ctx);\n            collector.endNode(node.id);\n        }\n\n        device.queue.submit([encoder.finish()]);\n\n        compute.lastFrameTiming = collector.finish(compute.frameIndex);\n        compute.frameIndex++;\n    },\n\n    dispose() {\n        resizeObserver?.disconnect();\n        resizeObserver = null;\n        observedCanvas = null;\n    },\n};\n\nexport const ComputePlugin: Plugin = {\n    systems: [ComputeSystem],\n\n    async initialize(state: State) {\n        if (!state.canvas) {\n            throw new Error(\"ComputePlugin requires a canvas\");\n        }\n\n        const device = await requestGPU();\n\n        const context = state.canvas.getContext(\"webgpu\");\n        if (!context) {\n            throw new Error(\"Failed to get WebGPU context\");\n        }\n\n        const format = navigator.gpu.getPreferredCanvasFormat();\n        context.configure({\n            device,\n            format,\n            alphaMode: \"premultiplied\",\n        });\n\n        const graph = new ComputeGraph();\n        const resources: ComputeResources = {\n            textures: new Map(),\n            textureViews: new Map(),\n            buffers: new Map(),\n        };\n\n        state.setResource(Compute, {\n            device,\n            context,\n            format,\n            graph,\n            resources,\n            lastFrameTiming: null,\n            frameIndex: 0,\n        });\n    },\n};\n","import {\n    resource,\n    type State,\n    type System,\n    type Plugin,\n    type InputState,\n    type MouseState,\n} from \"../../core\";\n\nexport const Input = resource<InputState>(\"input\");\n\nconst keys = new Set<string>();\nconst keysPressed = new Set<string>();\nconst keysReleased = new Set<string>();\n\nconst mouse: MouseState = {\n    deltaX: 0,\n    deltaY: 0,\n    scrollDelta: 0,\n    left: false,\n    right: false,\n    middle: false,\n};\n\nconst inputState: InputState = {\n    mouse,\n    isKeyDown: (code: string) => keys.has(code),\n    isKeyPressed: (code: string) => keysPressed.has(code),\n    isKeyReleased: (code: string) => keysReleased.has(code),\n};\n\nlet canvas: HTMLCanvasElement | null = null;\nlet lastPointerX = 0;\nlet lastPointerY = 0;\nlet activePointerId: number | null = null;\nlet activeButton: number | null = null;\n\nfunction handleKeyDown(e: KeyboardEvent): void {\n    if (!keys.has(e.code)) {\n        keysPressed.add(e.code);\n    }\n    keys.add(e.code);\n}\n\nfunction handleKeyUp(e: KeyboardEvent): void {\n    keys.delete(e.code);\n    keysReleased.add(e.code);\n}\n\nfunction setButtonState(button: number, pressed: boolean): void {\n    if (button === 0) mouse.left = pressed;\n    if (button === 1) mouse.middle = pressed;\n    if (button === 2) mouse.right = pressed;\n}\n\nfunction clearPointerState(): void {\n    if (activeButton !== null) {\n        setButtonState(activeButton, false);\n    }\n    activePointerId = null;\n    activeButton = null;\n    lastPointerX = 0;\n    lastPointerY = 0;\n}\n\nfunction handlePointerDown(e: PointerEvent): void {\n    if (e.target !== canvas) return;\n    if (activePointerId === null) {\n        activePointerId = e.pointerId;\n        activeButton = e.button;\n        lastPointerX = e.clientX;\n        lastPointerY = e.clientY;\n        setButtonState(e.button, true);\n        canvas!.setPointerCapture(e.pointerId);\n        e.preventDefault();\n    }\n}\n\nfunction handlePointerUp(e: PointerEvent): void {\n    if (e.pointerId === activePointerId) {\n        canvas?.releasePointerCapture(e.pointerId);\n        clearPointerState();\n    }\n}\n\nfunction handlePointerCancel(e: PointerEvent): void {\n    if (e.pointerId === activePointerId) {\n        clearPointerState();\n    }\n}\n\nfunction handlePointerMove(e: PointerEvent): void {\n    if (e.pointerId !== activePointerId) return;\n    e.preventDefault();\n    mouse.deltaX += e.clientX - lastPointerX;\n    mouse.deltaY += e.clientY - lastPointerY;\n    lastPointerX = e.clientX;\n    lastPointerY = e.clientY;\n}\n\nfunction handleWheel(e: WheelEvent): void {\n    if (e.target !== canvas) return;\n    mouse.scrollDelta += e.deltaY;\n    e.preventDefault();\n}\n\nfunction handleContextMenu(e: Event): void {\n    if (e.target === canvas) {\n        e.preventDefault();\n    }\n}\n\nfunction resetFrameState(): void {\n    keysPressed.clear();\n    keysReleased.clear();\n    mouse.deltaX = 0;\n    mouse.deltaY = 0;\n    mouse.scrollDelta = 0;\n}\n\nfunction clearAllState(): void {\n    keys.clear();\n    keysPressed.clear();\n    keysReleased.clear();\n    mouse.deltaX = 0;\n    mouse.deltaY = 0;\n    mouse.scrollDelta = 0;\n    mouse.left = false;\n    mouse.right = false;\n    mouse.middle = false;\n    activePointerId = null;\n    activeButton = null;\n    lastPointerX = 0;\n    lastPointerY = 0;\n}\n\nexport const InputSystem: System = {\n    group: \"simulation\",\n\n    setup(state: State) {\n        if (!state.canvas) return;\n        canvas = state.canvas;\n        canvas.style.touchAction = \"none\";\n\n        window.addEventListener(\"keydown\", handleKeyDown);\n        window.addEventListener(\"keyup\", handleKeyUp);\n        canvas.addEventListener(\"pointerdown\", handlePointerDown);\n        window.addEventListener(\"pointerup\", handlePointerUp);\n        window.addEventListener(\"pointercancel\", handlePointerCancel);\n        window.addEventListener(\"pointermove\", handlePointerMove);\n        canvas.addEventListener(\"wheel\", handleWheel, { passive: false });\n        canvas.addEventListener(\"contextmenu\", handleContextMenu);\n\n        state.setResource(Input, inputState);\n    },\n\n    dispose(state: State) {\n        if (canvas) {\n            window.removeEventListener(\"keydown\", handleKeyDown);\n            window.removeEventListener(\"keyup\", handleKeyUp);\n            canvas.removeEventListener(\"pointerdown\", handlePointerDown);\n            window.removeEventListener(\"pointerup\", handlePointerUp);\n            window.removeEventListener(\"pointercancel\", handlePointerCancel);\n            window.removeEventListener(\"pointermove\", handlePointerMove);\n            canvas.removeEventListener(\"wheel\", handleWheel);\n            canvas.removeEventListener(\"contextmenu\", handleContextMenu);\n            canvas = null;\n        }\n\n        clearAllState();\n        state.deleteResource(Input);\n    },\n};\n\nconst InputResetSystem: System = {\n    group: \"draw\",\n    last: true,\n\n    update() {\n        resetFrameState();\n    },\n};\n\nexport const InputPlugin: Plugin = {\n    systems: [InputSystem, InputResetSystem],\n};\n","export type EasingFn = (t: number) => number;\n\nconst linear: EasingFn = (t) => t;\n\nconst easeInQuad: EasingFn = (t) => t * t;\nconst easeOutQuad: EasingFn = (t) => t * (2 - t);\nconst easeInOutQuad: EasingFn = (t) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t);\n\nconst easeInCubic: EasingFn = (t) => t * t * t;\nconst easeOutCubic: EasingFn = (t) => --t * t * t + 1;\nconst easeInOutCubic: EasingFn = (t) =>\n    t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;\n\nconst easeInQuart: EasingFn = (t) => t * t * t * t;\nconst easeOutQuart: EasingFn = (t) => 1 - --t * t * t * t;\nconst easeInOutQuart: EasingFn = (t) => (t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t);\n\nconst easeInQuint: EasingFn = (t) => t * t * t * t * t;\nconst easeOutQuint: EasingFn = (t) => 1 + --t * t * t * t * t;\nconst easeInOutQuint: EasingFn = (t) =>\n    t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;\n\nconst easeInSine: EasingFn = (t) => 1 - Math.cos((t * Math.PI) / 2);\nconst easeOutSine: EasingFn = (t) => Math.sin((t * Math.PI) / 2);\nconst easeInOutSine: EasingFn = (t) => -(Math.cos(Math.PI * t) - 1) / 2;\n\nconst easeInExpo: EasingFn = (t) => (t === 0 ? 0 : Math.pow(2, 10 * t - 10));\nconst easeOutExpo: EasingFn = (t) => (t === 1 ? 1 : 1 - Math.pow(2, -10 * t));\nconst easeInOutExpo: EasingFn = (t) =>\n    t === 0\n        ? 0\n        : t === 1\n          ? 1\n          : t < 0.5\n            ? Math.pow(2, 20 * t - 10) / 2\n            : (2 - Math.pow(2, -20 * t + 10)) / 2;\n\nconst easeInCirc: EasingFn = (t) => 1 - Math.sqrt(1 - t * t);\nconst easeOutCirc: EasingFn = (t) => Math.sqrt(1 - --t * t);\nconst easeInOutCirc: EasingFn = (t) =>\n    t < 0.5\n        ? (1 - Math.sqrt(1 - 4 * t * t)) / 2\n        : (Math.sqrt(1 - (-2 * t + 2) * (-2 * t + 2)) + 1) / 2;\n\nconst easeInBack: EasingFn = (t) => {\n    const c = 1.70158;\n    return (c + 1) * t * t * t - c * t * t;\n};\nconst easeOutBack: EasingFn = (t) => {\n    const c = 1.70158;\n    return 1 + (c + 1) * Math.pow(t - 1, 3) + c * Math.pow(t - 1, 2);\n};\nconst easeInOutBack: EasingFn = (t) => {\n    const c = 1.70158 * 1.525;\n    return t < 0.5\n        ? (Math.pow(2 * t, 2) * ((c + 1) * 2 * t - c)) / 2\n        : (Math.pow(2 * t - 2, 2) * ((c + 1) * (t * 2 - 2) + c) + 2) / 2;\n};\n\nconst easeInElastic: EasingFn = (t) =>\n    t === 0\n        ? 0\n        : t === 1\n          ? 1\n          : -Math.pow(2, 10 * t - 10) * Math.sin((t * 10 - 10.75) * ((2 * Math.PI) / 3));\nconst easeOutElastic: EasingFn = (t) =>\n    t === 0\n        ? 0\n        : t === 1\n          ? 1\n          : Math.pow(2, -10 * t) * Math.sin((t * 10 - 0.75) * ((2 * Math.PI) / 3)) + 1;\nconst easeInOutElastic: EasingFn = (t) =>\n    t === 0\n        ? 0\n        : t === 1\n          ? 1\n          : t < 0.5\n            ? -(Math.pow(2, 20 * t - 10) * Math.sin((20 * t - 11.125) * ((2 * Math.PI) / 4.5))) / 2\n            : (Math.pow(2, -20 * t + 10) * Math.sin((20 * t - 11.125) * ((2 * Math.PI) / 4.5))) /\n                  2 +\n              1;\n\nconst easeOutBounce: EasingFn = (t) => {\n    const n1 = 7.5625;\n    const d1 = 2.75;\n    if (t < 1 / d1) return n1 * t * t;\n    if (t < 2 / d1) return n1 * (t -= 1.5 / d1) * t + 0.75;\n    if (t < 2.5 / d1) return n1 * (t -= 2.25 / d1) * t + 0.9375;\n    return n1 * (t -= 2.625 / d1) * t + 0.984375;\n};\nconst easeInBounce: EasingFn = (t) => 1 - easeOutBounce(1 - t);\nconst easeInOutBounce: EasingFn = (t) =>\n    t < 0.5 ? (1 - easeOutBounce(1 - 2 * t)) / 2 : (1 + easeOutBounce(2 * t - 1)) / 2;\n\nexport const EASING_FUNCTIONS: readonly EasingFn[] = [\n    linear,\n    easeInQuad,\n    easeOutQuad,\n    easeInOutQuad,\n    easeInCubic,\n    easeOutCubic,\n    easeInOutCubic,\n    easeInQuart,\n    easeOutQuart,\n    easeInOutQuart,\n    easeInQuint,\n    easeOutQuint,\n    easeInOutQuint,\n    easeInSine,\n    easeOutSine,\n    easeInOutSine,\n    easeInExpo,\n    easeOutExpo,\n    easeInOutExpo,\n    easeInCirc,\n    easeOutCirc,\n    easeInOutCirc,\n    easeInBack,\n    easeOutBack,\n    easeInOutBack,\n    easeInElastic,\n    easeOutElastic,\n    easeInOutElastic,\n    easeInBounce,\n    easeOutBounce,\n    easeInOutBounce,\n] as const;\n\nconst EASING_INDEX: Record<string, number> = {\n    linear: 0,\n    \"ease-in-quad\": 1,\n    \"ease-out-quad\": 2,\n    \"ease-in-out-quad\": 3,\n    \"ease-in-cubic\": 4,\n    \"ease-out-cubic\": 5,\n    \"ease-in-out-cubic\": 6,\n    \"ease-in-quart\": 7,\n    \"ease-out-quart\": 8,\n    \"ease-in-out-quart\": 9,\n    \"ease-in-quint\": 10,\n    \"ease-out-quint\": 11,\n    \"ease-in-out-quint\": 12,\n    \"ease-in-sine\": 13,\n    \"ease-out-sine\": 14,\n    \"ease-in-out-sine\": 15,\n    \"ease-in-expo\": 16,\n    \"ease-out-expo\": 17,\n    \"ease-in-out-expo\": 18,\n    \"ease-in-circ\": 19,\n    \"ease-out-circ\": 20,\n    \"ease-in-out-circ\": 21,\n    \"ease-in-back\": 22,\n    \"ease-out-back\": 23,\n    \"ease-in-out-back\": 24,\n    \"ease-in-elastic\": 25,\n    \"ease-out-elastic\": 26,\n    \"ease-in-out-elastic\": 27,\n    \"ease-in-bounce\": 28,\n    \"ease-out-bounce\": 29,\n    \"ease-in-out-bounce\": 30,\n};\n\nexport function getEasingIndex(name: string): number {\n    return EASING_INDEX[name] ?? 0;\n}\n\nexport function getEasing(index: number): EasingFn {\n    return EASING_FUNCTIONS[index] ?? linear;\n}\n","import { Pair } from \"bitecs\";\nimport { setTraits } from \"../../core/component\";\nimport { ChildOf, type State, type ParseContext } from \"../../core\";\nimport { Tween, TweenState, ensureResolved, captureFromValue } from \"./tween\";\n\nconst compareNumbers = (a: number, b: number) => a - b;\nconst compareByEndTime = (a: { endTime: number }, b: { endTime: number }) => a.endTime - b.endTime;\n\nconst childrenBuffer: number[] = [];\nconst tweensBuffer: { eid: number; endTime: number }[] = [];\n\nexport const Pause = {\n    duration: [] as number[],\n};\n\nsetTraits(Pause, {\n    defaults: () => ({ duration: 0.5 }),\n});\n\nexport const SequenceState = {\n    IDLE: 0,\n    PLAYING: 1,\n    COMPLETE: 2,\n} as const;\n\nexport const Sequence = {\n    state: [] as number[],\n    elapsed: [] as number[],\n};\n\nsetTraits(Sequence, {\n    defaults: () => ({\n        state: SequenceState.IDLE,\n        elapsed: 0,\n    }),\n});\n\nexport function finalizeSequences(_state: State, _context: ParseContext): void {}\n\nfunction getChildrenSorted(state: State, parentEid: number): number[] {\n    childrenBuffer.length = 0;\n    for (const childEid of state.query([Pair(ChildOf.relation, parentEid)])) {\n        childrenBuffer.push(childEid);\n    }\n    childrenBuffer.sort(compareNumbers);\n    return childrenBuffer;\n}\n\nexport function computeTweenDelays(state: State, seqEid: number): void {\n    const children = getChildrenSorted(state, seqEid);\n    let cumulativeDelay = 0;\n\n    for (const childEid of children) {\n        if (state.hasComponent(childEid, Pause)) {\n            cumulativeDelay += Pause.duration[childEid] ?? 0;\n        } else if (state.hasComponent(childEid, Tween)) {\n            Tween.delay[childEid] = cumulativeDelay;\n        }\n    }\n}\n\nfunction updateSequencePlayheads(state: State, dt: number): void {\n    for (const seqEid of state.query([Sequence])) {\n        if (Sequence.state[seqEid] !== SequenceState.PLAYING) continue;\n\n        const prevElapsed = Sequence.elapsed[seqEid] ?? 0;\n\n        if (prevElapsed === 0) {\n            computeTweenDelays(state, seqEid);\n        }\n        const elapsed = prevElapsed + dt;\n        Sequence.elapsed[seqEid] = elapsed;\n\n        for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\n            if (Tween.state[childEid] !== TweenState.IDLE) continue;\n\n            const delay = Tween.delay[childEid] ?? 0;\n            const shouldStart = elapsed >= delay;\n            const wasStarted = prevElapsed >= delay;\n\n            if (shouldStart) {\n                captureFromValue(state, childEid);\n                Tween.state[childEid] = TweenState.PLAYING;\n                Tween.elapsed[childEid] = wasStarted ? 0 : elapsed - delay - dt;\n            }\n        }\n    }\n}\n\nfunction ensureSequenceResolved(state: State, seqEid: number): void {\n    tweensBuffer.length = 0;\n\n    for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\n        if (\n            Tween.state[childEid] === TweenState.COMPLETE &&\n            Tween.elapsed[childEid] >= Tween.duration[childEid]\n        ) {\n            continue;\n        }\n        const delay = Tween.delay[childEid] ?? 0;\n        const duration = Tween.duration[childEid] ?? 0;\n        tweensBuffer.push({ eid: childEid, endTime: delay + duration });\n    }\n\n    tweensBuffer.sort(compareByEndTime);\n\n    for (const { eid } of tweensBuffer) {\n        Tween.state[eid] = TweenState.COMPLETE;\n        ensureResolved(state, eid);\n    }\n}\n\nfunction ensureSequencesResolved(state: State): void {\n    for (const seqEid of state.query([Sequence])) {\n        if (Sequence.state[seqEid] === SequenceState.COMPLETE) {\n            ensureSequenceResolved(state, seqEid);\n        }\n    }\n}\n\nfunction checkSequenceCompletion(state: State): void {\n    for (const seqEid of state.query([Sequence])) {\n        if (Sequence.state[seqEid] !== SequenceState.PLAYING) continue;\n\n        let allComplete = true;\n        let hasChildren = false;\n\n        for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\n            hasChildren = true;\n            if (Tween.state[childEid] !== TweenState.COMPLETE) {\n                allComplete = false;\n                break;\n            }\n        }\n\n        if (hasChildren && allComplete) {\n            Sequence.state[seqEid] = SequenceState.COMPLETE;\n        }\n    }\n}\n\nexport function updateSequences(state: State, dt: number): void {\n    updateSequencePlayheads(state, dt);\n}\n\nexport { ensureSequencesResolved, checkSequenceCompletion };\n","import {\n    defineRelation,\n    registerPostLoadHook,\n    type State,\n    type System,\n    type ParseContext,\n    type Plugin,\n} from \"../../core\";\nimport { setTraits } from \"../../core/component\";\nimport { getEasingIndex, getEasing } from \"./easing\";\nimport {\n    Sequence,\n    Pause,\n    updateSequences,\n    ensureSequencesResolved,\n    checkSequenceCompletion,\n} from \"./sequence\";\n\nfunction parseTweenAttrs(attrs: Record<string, string>): Record<string, string> {\n    if (attrs._value) {\n        const parsed: Record<string, string> = {};\n        for (const part of attrs._value.split(\";\")) {\n            const colonIdx = part.indexOf(\":\");\n            if (colonIdx === -1) continue;\n            const key = part.slice(0, colonIdx).trim();\n            const value = part.slice(colonIdx + 1).trim();\n            if (key && value) parsed[key] = value;\n        }\n        return parsed;\n    }\n    return attrs;\n}\n\nexport const TweenState = {\n    IDLE: 0,\n    PLAYING: 1,\n    COMPLETE: 2,\n} as const;\n\nexport const Tween = {\n    state: [] as number[],\n    from: [] as number[],\n    to: [] as number[],\n    duration: [] as number[],\n    elapsed: [] as number[],\n    delay: [] as number[],\n    easingIndex: [] as number[],\n};\n\nsetTraits(Tween, {\n    defaults: () => ({\n        state: TweenState.IDLE,\n        from: 0,\n        to: 0,\n        duration: 1,\n        elapsed: 0,\n        delay: 0,\n        easingIndex: 0,\n    }),\n    adapter: (attrs: Record<string, string>, state: State, context: ParseContext) => {\n        const parsed = parseTweenAttrs(attrs);\n        const result: Record<string, number> = {};\n\n        if (parsed.duration) result.duration = parseFloat(parsed.duration);\n        if (parsed.delay) result.delay = parseFloat(parsed.delay);\n        if (parsed.easing) result.easingIndex = getEasingIndex(parsed.easing);\n\n        if (parsed.target) {\n            setupTweenFromXml(state, context, parsed, context.currentEid);\n        }\n\n        return result;\n    },\n});\n\nexport const TweenTarget = defineRelation(\"tween-target\", {\n    exclusive: true,\n});\n\ninterface ParsedTargetPath {\n    readonly entity: string;\n    readonly component: string;\n    readonly field: string;\n}\n\nfunction parseTargetPath(path: string): ParsedTargetPath | null {\n    if (!path.startsWith(\"@\")) return null;\n\n    const rest = path.slice(1);\n    const firstDot = rest.indexOf(\".\");\n    if (firstDot === -1) return null;\n\n    const entity = rest.slice(0, firstDot);\n    const fieldPath = rest.slice(firstDot + 1);\n    const dotIndex = fieldPath.lastIndexOf(\".\");\n    if (dotIndex === -1) return null;\n\n    return {\n        entity,\n        component: fieldPath.slice(0, dotIndex),\n        field: fieldPath.slice(dotIndex + 1),\n    };\n}\n\ninterface PendingTween {\n    readonly tweenEid: number;\n    readonly target: string;\n    readonly to: string;\n}\n\nlet pendingXmlTweens: PendingTween[] = [];\n\nfunction setupTweenFromXml(\n    _state: State,\n    _context: ParseContext,\n    attrs: Record<string, string>,\n    tweenEid: number\n): void {\n    pendingXmlTweens.push({\n        tweenEid,\n        target: attrs.target,\n        to: attrs.to,\n    });\n}\n\nexport function finalizePendingTweens(state: State, context: ParseContext): void {\n    for (const pending of pendingXmlTweens) {\n        const parsed = parseTargetPath(pending.target);\n        if (!parsed) continue;\n\n        const targetEid = context.getEntityByName(parsed.entity);\n        if (targetEid === null) continue;\n\n        const binding = state.bindFieldAccessor(pending.tweenEid, parsed.component, parsed.field);\n        if (!binding) continue;\n\n        state.addRelation(pending.tweenEid, TweenTarget, targetEid);\n        const toValue =\n            pending.to.startsWith(\"0x\") || pending.to.startsWith(\"0X\")\n                ? parseInt(pending.to, 16)\n                : parseFloat(pending.to);\n        if (!Number.isFinite(toValue)) {\n            throw new Error(`Tween has invalid 'to' value: \"${pending.to}\" (parsed as ${toValue})`);\n        }\n        Tween.to[pending.tweenEid] = toValue;\n    }\n    pendingXmlTweens = [];\n}\n\nexport function captureFromValue(state: State, tweenEid: number): void {\n    const targetEid = state.getFirstRelationTarget(tweenEid, TweenTarget);\n    const binding = state.getFieldAccessor(tweenEid);\n\n    if (binding && targetEid >= 0) {\n        Tween.from[tweenEid] = binding.get(targetEid) ?? 0;\n    }\n}\n\nexport function ensureResolved(state: State, tweenEid: number): void {\n    const elapsed = Tween.elapsed[tweenEid];\n    const duration = Tween.duration[tweenEid];\n\n    if (elapsed >= duration) return;\n\n    const targetEid = state.getFirstRelationTarget(tweenEid, TweenTarget);\n    const binding = state.getFieldAccessor(tweenEid);\n\n    if (binding && targetEid >= 0) {\n        const toValue = Tween.to[tweenEid];\n        if (!Number.isFinite(toValue)) {\n            throw new Error(`Tween ${tweenEid} has invalid to value: ${toValue}`);\n        }\n        Tween.from[tweenEid] = binding.get(targetEid) ?? 0;\n        binding.set(targetEid, toValue);\n    }\n\n    Tween.elapsed[tweenEid] = duration;\n}\n\nfunction updateTweens(state: State, dt: number): void {\n    for (const tweenEid of state.query([Tween])) {\n        const tweenState = Tween.state[tweenEid];\n\n        if (tweenState === TweenState.COMPLETE) {\n            ensureResolved(state, tweenEid);\n            continue;\n        }\n\n        if (tweenState !== TweenState.PLAYING) continue;\n\n        const targetEid = state.getFirstRelationTarget(tweenEid, TweenTarget);\n        const binding = state.getFieldAccessor(tweenEid);\n\n        if (Tween.elapsed[tweenEid] === 0 && binding && targetEid >= 0) {\n            Tween.from[tweenEid] = binding.get(targetEid) ?? 0;\n        }\n\n        Tween.elapsed[tweenEid] += dt;\n\n        const elapsed = Tween.elapsed[tweenEid];\n        const duration = Tween.duration[tweenEid];\n        const rawProgress = duration <= 0 ? 1 : Math.min(elapsed / duration, 1);\n\n        if (!Number.isFinite(rawProgress)) {\n            throw new Error(\n                `Tween ${tweenEid} invalid progress: elapsed=${elapsed}, duration=${duration}, dt=${dt}`\n            );\n        }\n\n        const easingFn = getEasing(Tween.easingIndex[tweenEid]);\n        const easedProgress = easingFn(rawProgress);\n\n        const from = Tween.from[tweenEid];\n        const to = Tween.to[tweenEid];\n        const value = from + (to - from) * easedProgress;\n\n        if (!Number.isFinite(value)) {\n            throw new Error(\n                `Tween ${tweenEid} computed NaN: from=${from}, to=${to}, eased=${easedProgress}, raw=${rawProgress}`\n            );\n        }\n\n        if (binding && targetEid >= 0) {\n            binding.set(targetEid, value);\n        }\n\n        if (rawProgress >= 1) {\n            Tween.state[tweenEid] = TweenState.COMPLETE;\n        }\n    }\n}\n\nexport interface TweenOptions {\n    readonly to: number;\n    readonly duration?: number;\n    readonly easing?: string;\n}\n\nexport function createTween(\n    state: State,\n    targetEid: number,\n    fieldPath: string,\n    options: TweenOptions\n): number | null {\n    const parsed = state.resolveFieldPath(fieldPath);\n    if (!parsed) return null;\n\n    const tweenEid = state.addEntity();\n    state.addComponent(tweenEid, Tween);\n\n    const binding = state.bindFieldAccessor(tweenEid, parsed.component, parsed.field);\n    if (!binding) {\n        state.removeEntity(tweenEid);\n        return null;\n    }\n\n    state.addRelation(tweenEid, TweenTarget, targetEid);\n\n    Tween.to[tweenEid] = options.to;\n    Tween.duration[tweenEid] = options.duration ?? 1;\n    Tween.elapsed[tweenEid] = 0;\n    Tween.easingIndex[tweenEid] = getEasingIndex(options.easing ?? \"linear\");\n\n    return tweenEid;\n}\n\nexport const TweenSystem: System = {\n    group: \"simulation\",\n\n    update(state: State) {\n        const dt = state.time.deltaTime;\n\n        ensureSequencesResolved(state);\n        updateSequences(state, dt);\n        updateTweens(state, dt);\n        checkSequenceCompletion(state);\n    },\n};\n\nexport const TweenPlugin: Plugin = {\n    systems: [TweenSystem],\n    components: { Tween, Sequence, Pause },\n    relations: [TweenTarget],\n    initialize() {\n        registerPostLoadHook(finalizePendingTweens);\n    },\n};\n","let wasm;\n\n/**\n * @param {number} count\n */\nexport function compute_transforms(count) {\n    wasm.compute_transforms(count);\n}\n\n/**\n * @returns {number}\n */\nexport function get_indices_ptr() {\n    const ret = wasm.get_indices_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_matrices_ptr() {\n    const ret = wasm.get_matrices_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_max_entities() {\n    const ret = wasm.get_max_entities();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_no_parent() {\n    const ret = wasm.get_no_parent();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_parents_ptr() {\n    const ret = wasm.get_parents_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_pos_x_ptr() {\n    const ret = wasm.get_pos_x_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_pos_y_ptr() {\n    const ret = wasm.get_pos_y_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_pos_z_ptr() {\n    const ret = wasm.get_pos_z_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_quat_w_ptr() {\n    const ret = wasm.get_quat_w_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_quat_x_ptr() {\n    const ret = wasm.get_quat_x_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_quat_y_ptr() {\n    const ret = wasm.get_quat_y_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_quat_z_ptr() {\n    const ret = wasm.get_quat_z_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_scale_x_ptr() {\n    const ret = wasm.get_scale_x_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_scale_y_ptr() {\n    const ret = wasm.get_scale_y_ptr();\n    return ret >>> 0;\n}\n\n/**\n * @returns {number}\n */\nexport function get_scale_z_ptr() {\n    const ret = wasm.get_scale_z_ptr();\n    return ret >>> 0;\n}\n\nexport function init_data() {\n    wasm.init_data();\n}\n\nconst EXPECTED_RESPONSE_TYPES = new Set(['basic', 'cors', 'default']);\n\nasync function __wbg_load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n            } catch (e) {\n                const validResponse = module.ok && EXPECTED_RESPONSE_TYPES.has(module.type);\n\n                if (validResponse && module.headers.get('Content-Type') !== 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n        } else {\n            return instance;\n        }\n    }\n}\n\nfunction __wbg_get_imports() {\n    const imports = {};\n    imports.wbg = {};\n\n    return imports;\n}\n\nfunction __wbg_finalize_init(instance, module) {\n    wasm = instance.exports;\n    __wbg_init.__wbindgen_wasm_module = module;\n\n\n\n    return wasm;\n}\n\nfunction initSync(module) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module !== 'undefined') {\n        if (Object.getPrototypeOf(module) === Object.prototype) {\n            ({module} = module)\n        } else {\n            console.warn('using deprecated parameters for `initSync()`; pass a single object instead')\n        }\n    }\n\n    const imports = __wbg_get_imports();\n    if (!(module instanceof WebAssembly.Module)) {\n        module = new WebAssembly.Module(module);\n    }\n    const instance = new WebAssembly.Instance(module, imports);\n    return __wbg_finalize_init(instance, module);\n}\n\nasync function __wbg_init(module_or_path) {\n    if (wasm !== undefined) return wasm;\n\n\n    if (typeof module_or_path !== 'undefined') {\n        if (Object.getPrototypeOf(module_or_path) === Object.prototype) {\n            ({module_or_path} = module_or_path)\n        } else {\n            console.warn('using deprecated parameters for the initialization function; pass a single object instead')\n        }\n    }\n\n    if (typeof module_or_path === 'undefined') {\n        module_or_path = new URL('shallot_transforms_bg.wasm', import.meta.url);\n    }\n    const imports = __wbg_get_imports();\n\n    if (typeof module_or_path === 'string' || (typeof Request === 'function' && module_or_path instanceof Request) || (typeof URL === 'function' && module_or_path instanceof URL)) {\n        module_or_path = fetch(module_or_path);\n    }\n\n    const { instance, module } = await __wbg_load(await module_or_path, imports);\n\n    return __wbg_finalize_init(instance, module);\n}\n\nexport { initSync };\nexport default __wbg_init;\n","import wasmInit, {\n    get_pos_x_ptr,\n    get_pos_y_ptr,\n    get_pos_z_ptr,\n    get_quat_x_ptr,\n    get_quat_y_ptr,\n    get_quat_z_ptr,\n    get_quat_w_ptr,\n    get_scale_x_ptr,\n    get_scale_y_ptr,\n    get_scale_z_ptr,\n    get_matrices_ptr,\n    get_indices_ptr,\n    get_parents_ptr,\n    get_max_entities,\n    get_no_parent,\n    init_data,\n    compute_transforms,\n} from \"../../../rust/transforms/pkg/shallot_transforms.js\";\n\nexport let posX: Float32Array;\nexport let posY: Float32Array;\nexport let posZ: Float32Array;\nexport let quatX: Float32Array;\nexport let quatY: Float32Array;\nexport let quatZ: Float32Array;\nexport let quatW: Float32Array;\nexport let scaleX: Float32Array;\nexport let scaleY: Float32Array;\nexport let scaleZ: Float32Array;\nexport let matrices: Float32Array;\nexport let indices: Uint32Array;\nexport let parents: Uint32Array;\nexport let NoParent: number;\n\nexport async function init(): Promise<void> {\n    if (posX) return;\n    const wasm = await wasmInit();\n    init_data();\n    const buffer = wasm.memory.buffer;\n    const maxEntities = get_max_entities();\n\n    posX = new Float32Array(buffer, get_pos_x_ptr(), maxEntities);\n    posY = new Float32Array(buffer, get_pos_y_ptr(), maxEntities);\n    posZ = new Float32Array(buffer, get_pos_z_ptr(), maxEntities);\n    quatX = new Float32Array(buffer, get_quat_x_ptr(), maxEntities);\n    quatY = new Float32Array(buffer, get_quat_y_ptr(), maxEntities);\n    quatZ = new Float32Array(buffer, get_quat_z_ptr(), maxEntities);\n    quatW = new Float32Array(buffer, get_quat_w_ptr(), maxEntities);\n    scaleX = new Float32Array(buffer, get_scale_x_ptr(), maxEntities);\n    scaleY = new Float32Array(buffer, get_scale_y_ptr(), maxEntities);\n    scaleZ = new Float32Array(buffer, get_scale_z_ptr(), maxEntities);\n    matrices = new Float32Array(buffer, get_matrices_ptr(), maxEntities * 16);\n    indices = new Uint32Array(buffer, get_indices_ptr(), maxEntities);\n    parents = new Uint32Array(buffer, get_parents_ptr(), maxEntities);\n    NoParent = get_no_parent();\n}\n\nexport function compute(count: number): void {\n    compute_transforms(count);\n}\n","import { Hierarchy, Not, Wildcard } from \"bitecs\";\nimport {\n    ChildOf,\n    MAX_ENTITIES,\n    rotateQuaternion,\n    eulerToQuaternion,\n    quaternionToEuler,\n    type State,\n    type System,\n    type Plugin,\n} from \"../../core\";\nimport { setTraits } from \"../../core/component\";\nimport * as wasm from \"./wasm\";\n\nexport function rotate(eid: number, dx: number, dy: number, dz: number): void {\n    const q = rotateQuaternion(\n        Transform.quatX[eid],\n        Transform.quatY[eid],\n        Transform.quatZ[eid],\n        Transform.quatW[eid],\n        dx,\n        dy,\n        dz\n    );\n    Transform.quatX[eid] = q.x;\n    Transform.quatY[eid] = q.y;\n    Transform.quatZ[eid] = q.z;\n    Transform.quatW[eid] = q.w;\n}\n\ninterface EulerProxy extends Array<number> {\n    get(eid: number): number;\n    set(eid: number, value: number): void;\n}\n\nfunction eulerProxy(axis: \"x\" | \"y\" | \"z\"): EulerProxy {\n    function getValue(eid: number): number {\n        const e = quaternionToEuler(\n            Transform.quatX[eid],\n            Transform.quatY[eid],\n            Transform.quatZ[eid],\n            Transform.quatW[eid]\n        );\n        return e[axis];\n    }\n\n    function setValue(eid: number, value: number): void {\n        const e = quaternionToEuler(\n            Transform.quatX[eid],\n            Transform.quatY[eid],\n            Transform.quatZ[eid],\n            Transform.quatW[eid]\n        );\n        e[axis] = value;\n        const q = eulerToQuaternion(e.x, e.y, e.z);\n        Transform.quatX[eid] = q.x;\n        Transform.quatY[eid] = q.y;\n        Transform.quatZ[eid] = q.z;\n        Transform.quatW[eid] = q.w;\n    }\n\n    return new Proxy([] as unknown as EulerProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nexport const Transform: {\n    posX: Float32Array;\n    posY: Float32Array;\n    posZ: Float32Array;\n    quatX: Float32Array;\n    quatY: Float32Array;\n    quatZ: Float32Array;\n    quatW: Float32Array;\n    scaleX: Float32Array;\n    scaleY: Float32Array;\n    scaleZ: Float32Array;\n    eulerX: EulerProxy;\n    eulerY: EulerProxy;\n    eulerZ: EulerProxy;\n} = {\n    posX: new Float32Array(MAX_ENTITIES),\n    posY: new Float32Array(MAX_ENTITIES),\n    posZ: new Float32Array(MAX_ENTITIES),\n    quatX: new Float32Array(MAX_ENTITIES),\n    quatY: new Float32Array(MAX_ENTITIES),\n    quatZ: new Float32Array(MAX_ENTITIES),\n    quatW: new Float32Array(MAX_ENTITIES),\n    scaleX: new Float32Array(MAX_ENTITIES),\n    scaleY: new Float32Array(MAX_ENTITIES),\n    scaleZ: new Float32Array(MAX_ENTITIES),\n    eulerX: eulerProxy(\"x\"),\n    eulerY: eulerProxy(\"y\"),\n    eulerZ: eulerProxy(\"z\"),\n};\n\nexport const WorldTransform: { data: Float32Array } = {\n    data: new Float32Array(MAX_ENTITIES * 16),\n};\n\nsetTraits(Transform, {\n    defaults: () => ({\n        posX: 0,\n        posY: 0,\n        posZ: 0,\n        quatX: 0,\n        quatY: 0,\n        quatZ: 0,\n        quatW: 1,\n        scaleX: 1,\n        scaleY: 1,\n        scaleZ: 1,\n    }),\n    accessors: {\n        eulerX: Transform.eulerX,\n        eulerY: Transform.eulerY,\n        eulerZ: Transform.eulerZ,\n    },\n});\n\nasync function init(): Promise<void> {\n    await wasm.init();\n\n    Transform.posX = wasm.posX;\n    Transform.posY = wasm.posY;\n    Transform.posZ = wasm.posZ;\n    Transform.quatX = wasm.quatX;\n    Transform.quatY = wasm.quatY;\n    Transform.quatZ = wasm.quatZ;\n    Transform.quatW = wasm.quatW;\n    Transform.scaleX = wasm.scaleX;\n    Transform.scaleY = wasm.scaleY;\n    Transform.scaleZ = wasm.scaleZ;\n    WorldTransform.data = wasm.matrices;\n}\n\nconst TransformSystem: System = {\n    group: \"simulation\",\n    last: true,\n\n    update(state: State) {\n        for (const eid of state.query([Transform, Not(WorldTransform)])) {\n            state.addComponent(eid, WorldTransform);\n        }\n\n        let count = 0;\n\n        for (const eid of state.query([Transform, Not(ChildOf.relation(Wildcard))])) {\n            wasm.indices[count] = eid;\n            wasm.parents[count] = wasm.NoParent;\n            count++;\n        }\n\n        for (const eid of state.query([\n            Transform,\n            ChildOf.relation(Wildcard),\n            Hierarchy(ChildOf.relation),\n        ])) {\n            wasm.indices[count] = eid;\n            wasm.parents[count] = state.getRelationTargets(eid, ChildOf)[0];\n            count++;\n        }\n\n        wasm.compute(count);\n    },\n};\n\nexport const TransformsPlugin: Plugin = {\n    systems: [TransformSystem],\n    components: { Transform, WorldTransform },\n    initialize: init,\n};\n","export const SCENE_UNIFORM_SIZE = 192; // viewProj (64) + cameraWorld (64) + ambient (16) + sunDir (16) + sunColor (16) + camera params (16)\nexport const DEPTH_FORMAT: GPUTextureFormat = \"depth24plus\";\nexport const MASK_FORMAT: GPUTextureFormat = \"r8unorm\";\n\nexport function createSceneBuffer(device: GPUDevice): GPUBuffer {\n    return device.createBuffer({\n        label: \"scene\",\n        size: SCENE_UNIFORM_SIZE,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n    });\n}\n\nexport function ensureRenderTextures(\n    device: GPUDevice,\n    format: GPUTextureFormat,\n    width: number,\n    height: number,\n    textures: Map<string, GPUTexture>,\n    textureViews: Map<string, GPUTextureView>\n): void {\n    const existing = textures.get(\"scene\");\n    if (existing && existing.width === width && existing.height === height) return;\n\n    existing?.destroy();\n    textures.get(\"depth\")?.destroy();\n    textures.get(\"mask\")?.destroy();\n\n    const scene = device.createTexture({\n        label: \"scene\",\n        size: { width, height },\n        format,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    const depth = device.createTexture({\n        label: \"depth\",\n        size: { width, height },\n        format: DEPTH_FORMAT,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT,\n    });\n\n    const mask = device.createTexture({\n        label: \"mask\",\n        size: { width, height },\n        format: MASK_FORMAT,\n        usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING,\n    });\n\n    textures.set(\"scene\", scene);\n    textureViews.set(\"scene\", scene.createView());\n    textures.set(\"depth\", depth);\n    textureViews.set(\"depth\", depth.createView());\n    textures.set(\"mask\", mask);\n    textureViews.set(\"mask\", mask.createView());\n}\n\nexport function perspective(fov: number, aspect: number, near: number, far: number): Float32Array {\n    if (fov <= 0) throw new Error(`Invalid FOV: ${fov} (must be > 0)`);\n    if (aspect <= 0) throw new Error(`Invalid aspect ratio: ${aspect} (must be > 0)`);\n    if (near === far) throw new Error(`Invalid depth planes: near === far (${near})`);\n    const f = 1 / Math.tan((fov * Math.PI) / 360);\n    const nf = 1 / (near - far);\n    return new Float32Array([\n        f / aspect,\n        0,\n        0,\n        0,\n        0,\n        f,\n        0,\n        0,\n        0,\n        0,\n        (far + near) * nf,\n        -1,\n        0,\n        0,\n        2 * far * near * nf,\n        0,\n    ]);\n}\n\nexport function orthographic(\n    size: number,\n    aspect: number,\n    near: number,\n    far: number\n): Float32Array {\n    if (size <= 0) throw new Error(`Invalid orthographic size: ${size} (must be > 0)`);\n    if (aspect <= 0) throw new Error(`Invalid aspect ratio: ${aspect} (must be > 0)`);\n    if (near === far) throw new Error(`Invalid depth planes: near === far (${near})`);\n    const lr = 1 / (size * aspect);\n    const bt = 1 / size;\n    const nf = 1 / (near - far);\n    return new Float32Array([lr, 0, 0, 0, 0, bt, 0, 0, 0, 0, nf, 0, 0, 0, near * nf, 1]);\n}\n\nexport function multiply(a: Float32Array, b: Float32Array): Float32Array {\n    const out = new Float32Array(16);\n    for (let i = 0; i < 4; i++) {\n        for (let j = 0; j < 4; j++) {\n            out[j * 4 + i] =\n                a[i] * b[j * 4] +\n                a[i + 4] * b[j * 4 + 1] +\n                a[i + 8] * b[j * 4 + 2] +\n                a[i + 12] * b[j * 4 + 3];\n        }\n    }\n    return out;\n}\n\nexport function invert(m: Float32Array): Float32Array {\n    const out = new Float32Array(16);\n    const r00 = m[0],\n        r01 = m[1],\n        r02 = m[2];\n    const r10 = m[4],\n        r11 = m[5],\n        r12 = m[6];\n    const r20 = m[8],\n        r21 = m[9],\n        r22 = m[10];\n    const tx = m[12],\n        ty = m[13],\n        tz = m[14];\n\n    out[0] = r00;\n    out[1] = r10;\n    out[2] = r20;\n    out[3] = 0;\n    out[4] = r01;\n    out[5] = r11;\n    out[6] = r21;\n    out[7] = 0;\n    out[8] = r02;\n    out[9] = r12;\n    out[10] = r22;\n    out[11] = 0;\n    out[12] = -(r00 * tx + r01 * ty + r02 * tz);\n    out[13] = -(r10 * tx + r11 * ty + r12 * tz);\n    out[14] = -(r20 * tx + r21 * ty + r22 * tz);\n    out[15] = 1;\n\n    return out;\n}\n","import type { ComputeNode, ExecutionContext } from \"../compute\";\nimport type { ShapeBatch } from \"./mesh\";\nimport { DEPTH_FORMAT } from \"./scene\";\nimport type { OpaqueDrawCallback, OpaqueDrawContext } from \"./opaque\";\n\nexport const INDIRECT_SIZE = 20;\n\nexport interface IndirectArgs {\n    indexCount: number;\n    instanceCount: number;\n    firstIndex: number;\n    baseVertex: number;\n    firstInstance: number;\n}\n\nexport function createIndirectBuffer(device: GPUDevice, slotCount: number): GPUBuffer {\n    return device.createBuffer({\n        label: \"indirect\",\n        size: slotCount * INDIRECT_SIZE,\n        usage:\n            GPUBufferUsage.INDIRECT |\n            GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_DST |\n            GPUBufferUsage.COPY_SRC,\n    });\n}\n\nexport function writeIndirect(\n    device: GPUDevice,\n    buffer: GPUBuffer,\n    slot: number,\n    args: IndirectArgs\n): void {\n    const offset = slot * INDIRECT_SIZE;\n    const data = new ArrayBuffer(INDIRECT_SIZE);\n    const view = new DataView(data);\n\n    view.setUint32(0, args.indexCount, true);\n    view.setUint32(4, args.instanceCount, true);\n    view.setUint32(8, args.firstIndex, true);\n    view.setInt32(12, args.baseVertex, true);\n    view.setUint32(16, args.firstInstance, true);\n\n    device.queue.writeBuffer(buffer, offset, data);\n}\n\nexport const litShader = /* wgsl */ `\nstruct VertexInput {\n    @location(0) position: vec3<f32>,\n    @location(1) normal: vec3<f32>,\n    @builtin(instance_index) instance: u32,\n}\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) color: vec4<f32>,\n    @location(1) worldNormal: vec3<f32>,\n    @location(2) @interpolate(flat) materialId: u32,\n}\n\nstruct Scene {\n    viewProj: mat4x4<f32>,\n    cameraWorld: mat4x4<f32>,\n    ambientColor: vec4<f32>,\n    sunDirection: vec4<f32>,\n    sunColor: vec4<f32>,\n    cameraMode: f32,\n    cameraSize: f32,\n    viewport: vec2<f32>,\n}\n\nstruct MaterialData {\n    emission: vec3<f32>,\n    roughness: f32,\n    metallic: f32,\n    _pad0: f32,\n    _pad1: f32,\n    _pad2: f32,\n}\n\n@group(0) @binding(0) var<uniform> scene: Scene;\n@group(0) @binding(1) var<storage, read> entityIds: array<u32>;\n@group(0) @binding(2) var<storage, read> matrices: array<mat4x4<f32>>;\n@group(0) @binding(3) var<storage, read> colors: array<vec4<f32>>;\n@group(0) @binding(4) var<storage, read> sizes: array<vec4<f32>>;\n@group(0) @binding(5) var<storage, read> materials: array<MaterialData>;\n@group(0) @binding(6) var<storage, read> matIds: array<u32>;\n\n@vertex\nfn vs(input: VertexInput) -> VertexOutput {\n    let eid = entityIds[input.instance];\n    let world = matrices[eid];\n    let scaledPos = input.position * sizes[eid].xyz;\n    let worldPos = world * vec4<f32>(scaledPos, 1.0);\n    let worldNormal = normalize((world * vec4<f32>(input.normal, 0.0)).xyz);\n\n    var output: VertexOutput;\n    output.position = scene.viewProj * worldPos;\n    output.color = colors[eid];\n    output.worldNormal = worldNormal;\n    output.materialId = matIds[eid];\n    return output;\n}\n\n@fragment\nfn fs(input: VertexOutput) -> @location(0) vec4<f32> {\n    let mat = materials[input.materialId];\n    let normal = normalize(input.worldNormal);\n    let NdotL = max(dot(normal, -scene.sunDirection.xyz), 0.0);\n\n    let ambient = scene.ambientColor.rgb * scene.ambientColor.a;\n    let diffuse = scene.sunColor.rgb * NdotL;\n    let diffuseFactor = 1.0 - mat.metallic * 0.9;\n    let lighting = ambient + diffuse * diffuseFactor;\n\n    return vec4<f32>(input.color.rgb * lighting + mat.emission, input.color.a);\n}\n`;\n\nexport function createForwardPipeline(\n    device: GPUDevice,\n    format: GPUTextureFormat\n): GPURenderPipeline {\n    const module = device.createShaderModule({ code: litShader });\n\n    return device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n            module,\n            entryPoint: \"vs\",\n            buffers: [\n                {\n                    arrayStride: 24,\n                    attributes: [\n                        { shaderLocation: 0, offset: 0, format: \"float32x3\" as const },\n                        { shaderLocation: 1, offset: 12, format: \"float32x3\" as const },\n                    ],\n                },\n            ],\n        },\n        fragment: {\n            module,\n            entryPoint: \"fs\",\n            targets: [{ format }],\n        },\n        primitive: {\n            topology: \"triangle-list\",\n            cullMode: \"back\",\n        },\n        depthStencil: {\n            format: DEPTH_FORMAT,\n            depthWriteEnabled: true,\n            depthCompare: \"less\",\n        },\n    });\n}\n\nexport const clearColor = { r: 0.1, g: 0.1, b: 0.1, a: 1 };\n\nexport interface ForwardConfig {\n    scene: GPUBuffer;\n    matrices: GPUBuffer;\n    colors: GPUBuffer;\n    sizes: GPUBuffer;\n    materials: GPUBuffer;\n    materialIds: GPUBuffer;\n    indirect: GPUBuffer;\n    batches: Map<number, ShapeBatch>;\n    getCallbacks: () => OpaqueDrawCallback[];\n}\n\nexport function createForwardNode(config: ForwardConfig): ComputeNode {\n    let pipeline: GPURenderPipeline | null = null;\n    const bindGroups = new Map<number, GPUBindGroup>();\n\n    return {\n        id: \"forward\",\n        inputs: [],\n        outputs: [\n            { id: \"scene\", access: \"write\" },\n            { id: \"depth\", access: \"write\" },\n        ],\n\n        execute(ctx: ExecutionContext) {\n            const { device, encoder, format } = ctx;\n            const targetView = ctx.getTextureView(\"scene\") ?? ctx.canvasView;\n            const depthView = ctx.getTextureView(\"depth\")!;\n\n            if (!pipeline) {\n                pipeline = createForwardPipeline(device, format);\n            }\n\n            const pass = encoder.beginRenderPass({\n                colorAttachments: [\n                    {\n                        view: targetView,\n                        clearValue: clearColor,\n                        loadOp: \"clear\" as const,\n                        storeOp: \"store\" as const,\n                    },\n                ],\n                depthStencilAttachment: {\n                    view: depthView,\n                    depthClearValue: 1.0,\n                    depthLoadOp: \"clear\" as const,\n                    depthStoreOp: \"store\" as const,\n                },\n            });\n\n            const callbacks = config.getCallbacks();\n            const preCallbacks = callbacks\n                .filter((c) => c.order < 0)\n                .sort((a, b) => a.order - b.order);\n            const postCallbacks = callbacks\n                .filter((c) => c.order >= 0)\n                .sort((a, b) => a.order - b.order);\n\n            const drawCtx: OpaqueDrawContext = {\n                device,\n                format,\n                depthFormat: DEPTH_FORMAT,\n                scene: config.scene,\n                matrices: config.matrices,\n            };\n\n            for (const callback of preCallbacks) {\n                callback.draw(pass, drawCtx);\n            }\n\n            pass.setPipeline(pipeline);\n\n            for (const batch of config.batches.values()) {\n                let bindGroup = bindGroups.get(batch.index);\n                if (!bindGroup) {\n                    bindGroup = device.createBindGroup({\n                        layout: pipeline.getBindGroupLayout(0),\n                        entries: [\n                            { binding: 0, resource: { buffer: config.scene } },\n                            { binding: 1, resource: { buffer: batch.entityIds } },\n                            { binding: 2, resource: { buffer: config.matrices } },\n                            { binding: 3, resource: { buffer: config.colors } },\n                            { binding: 4, resource: { buffer: config.sizes } },\n                            { binding: 5, resource: { buffer: config.materials } },\n                            { binding: 6, resource: { buffer: config.materialIds } },\n                        ],\n                    });\n                    bindGroups.set(batch.index, bindGroup);\n                }\n\n                pass.setBindGroup(0, bindGroup);\n                pass.setVertexBuffer(0, batch.buffers.vertex);\n                pass.setIndexBuffer(batch.buffers.index, \"uint16\");\n                pass.drawIndexedIndirect(config.indirect, batch.index * INDIRECT_SIZE);\n            }\n\n            for (const callback of postCallbacks) {\n                callback.draw(pass, drawCtx);\n            }\n\n            pass.end();\n        },\n    };\n}\n","import { setTraits } from \"../../core/component\";\nimport { WorldTransform } from \"../transforms\";\nimport { clearColor } from \"./forward\";\nimport { perspective, orthographic, multiply, invert } from \"./scene\";\n\nexport const RenderMode = {\n    Raster: 0,\n    Raytracing: 1,\n} as const;\n\nexport const DebugMode = {\n    Color: 0,\n    Depth: 1,\n    Normal: 2,\n    Material: 3,\n    Hit: 4,\n} as const;\n\nexport const CameraMode = {\n    Perspective: 0,\n    Orthographic: 1,\n} as const;\n\nexport const Camera = {\n    fov: [] as number[],\n    near: [] as number[],\n    far: [] as number[],\n    active: [] as number[],\n    clearColor: [] as number[],\n    renderMode: [] as number[],\n    debugMode: [] as number[],\n    mode: [] as number[],\n    size: [] as number[],\n};\n\nsetTraits(Camera, {\n    defaults: () => ({\n        fov: 60,\n        near: 0.1,\n        far: 1000,\n        active: 1,\n        clearColor: 0x1a1a1a,\n        renderMode: RenderMode.Raster,\n        debugMode: DebugMode.Color,\n        mode: CameraMode.Perspective,\n        size: 5,\n    }),\n});\n\nexport const Tonemap = {\n    exposure: [] as number[],\n};\n\nsetTraits(Tonemap, {\n    defaults: () => ({ exposure: 1.0 }),\n});\n\nexport const FXAA = {};\n\nexport const Vignette = {\n    strength: [] as number[],\n    inner: [] as number[],\n    outer: [] as number[],\n};\n\nsetTraits(Vignette, {\n    defaults: () => ({ strength: 0.5, inner: 0.4, outer: 0.8 }),\n});\n\nexport function unpackColor(packed: number): { r: number; g: number; b: number } {\n    return {\n        r: ((packed >> 16) & 0xff) / 255,\n        g: ((packed >> 8) & 0xff) / 255,\n        b: (packed & 0xff) / 255,\n    };\n}\n\nexport function uploadCamera(\n    device: GPUDevice,\n    buffer: GPUBuffer,\n    eid: number,\n    width: number,\n    height: number\n): void {\n    const color = unpackColor(Camera.clearColor[eid]);\n    clearColor.r = color.r;\n    clearColor.g = color.g;\n    clearColor.b = color.b;\n\n    const aspect = width / height;\n    const proj =\n        Camera.mode[eid] === CameraMode.Orthographic\n            ? orthographic(Camera.size[eid], aspect, Camera.near[eid], Camera.far[eid])\n            : perspective(Camera.fov[eid], aspect, Camera.near[eid], Camera.far[eid]);\n    const world = WorldTransform.data.subarray(eid * 16, eid * 16 + 16);\n    const view = invert(world);\n    const viewProj = multiply(proj, view);\n\n    device.queue.writeBuffer(buffer, 0, viewProj as Float32Array<ArrayBuffer>);\n    device.queue.writeBuffer(buffer, 64, world as Float32Array<ArrayBuffer>);\n    device.queue.writeBuffer(\n        buffer,\n        176,\n        new Float32Array([Camera.mode[eid], Camera.size[eid], width, height])\n    );\n}\n","import { setTraits } from \"../../core/component\";\nimport { unpackColor } from \"./camera\";\n\nexport const AmbientLight = {\n    color: [] as number[],\n    intensity: [] as number[],\n};\n\nsetTraits(AmbientLight, {\n    defaults: () => ({ color: 0x888888, intensity: 1.0 }),\n});\n\nexport const DirectionalLight = {\n    color: [] as number[],\n    intensity: [] as number[],\n    directionX: [] as number[],\n    directionY: [] as number[],\n    directionZ: [] as number[],\n};\n\nsetTraits(DirectionalLight, {\n    defaults: () => ({\n        color: 0xffffff,\n        intensity: 1.0,\n        directionX: -0.6,\n        directionY: -1.0,\n        directionZ: -0.8,\n    }),\n});\n\nexport function normalizeDirection(x: number, y: number, z: number): [number, number, number] {\n    const len = Math.sqrt(x * x + y * y + z * z);\n    if (len < 0.0001) {\n        return [0, -1, 0];\n    }\n    return [x / len, y / len, z / len];\n}\n\nexport interface AmbientLightData {\n    color: number;\n    intensity: number;\n}\n\nexport interface DirectionalLightData {\n    color: number;\n    intensity: number;\n    directionX: number;\n    directionY: number;\n    directionZ: number;\n}\n\nexport function packLightUniforms(\n    ambient: AmbientLightData,\n    directional: DirectionalLightData\n): Float32Array {\n    const data = new Float32Array(12);\n\n    const ambientRgb = unpackColor(ambient.color);\n    data[0] = ambientRgb.r;\n    data[1] = ambientRgb.g;\n    data[2] = ambientRgb.b;\n    data[3] = ambient.intensity;\n\n    const [dx, dy, dz] = normalizeDirection(\n        directional.directionX,\n        directional.directionY,\n        directional.directionZ\n    );\n    data[4] = dx;\n    data[5] = dy;\n    data[6] = dz;\n    data[7] = 0;\n\n    const sunRgb = unpackColor(directional.color);\n    data[8] = sunRgb.r * directional.intensity;\n    data[9] = sunRgb.g * directional.intensity;\n    data[10] = sunRgb.b * directional.intensity;\n    data[11] = 0;\n\n    return data;\n}\n","import type { MeshData } from \"./index\";\n\nexport function createBox(): MeshData {\n    const vertices = new Float32Array([\n        -0.5, -0.5, 0.5, 0, 0, 1, 0.5, -0.5, 0.5, 0, 0, 1, 0.5, 0.5, 0.5, 0, 0, 1, -0.5, 0.5, 0.5,\n        0, 0, 1, 0.5, -0.5, -0.5, 0, 0, -1, -0.5, -0.5, -0.5, 0, 0, -1, -0.5, 0.5, -0.5, 0, 0, -1,\n        0.5, 0.5, -0.5, 0, 0, -1, -0.5, 0.5, 0.5, 0, 1, 0, 0.5, 0.5, 0.5, 0, 1, 0, 0.5, 0.5, -0.5,\n        0, 1, 0, -0.5, 0.5, -0.5, 0, 1, 0, -0.5, -0.5, -0.5, 0, -1, 0, 0.5, -0.5, -0.5, 0, -1, 0,\n        0.5, -0.5, 0.5, 0, -1, 0, -0.5, -0.5, 0.5, 0, -1, 0, 0.5, -0.5, 0.5, 1, 0, 0, 0.5, -0.5,\n        -0.5, 1, 0, 0, 0.5, 0.5, -0.5, 1, 0, 0, 0.5, 0.5, 0.5, 1, 0, 0, -0.5, -0.5, -0.5, -1, 0, 0,\n        -0.5, -0.5, 0.5, -1, 0, 0, -0.5, 0.5, 0.5, -1, 0, 0, -0.5, 0.5, -0.5, -1, 0, 0,\n    ]);\n\n    const indices = new Uint16Array([\n        0, 1, 2, 0, 2, 3, 4, 5, 6, 4, 6, 7, 8, 9, 10, 8, 10, 11, 12, 13, 14, 12, 14, 15, 16, 17, 18,\n        16, 18, 19, 20, 21, 22, 20, 22, 23,\n    ]);\n\n    return { vertices, indices, vertexCount: 24, indexCount: 36 };\n}\n","import type { MeshData } from \"./index\";\n\nexport function createSphere(segments = 32, rings = 16): MeshData {\n    const vertices: number[] = [];\n    const indices: number[] = [];\n    const radius = 0.5;\n\n    for (let y = 0; y <= rings; y++) {\n        const v = y / rings;\n        const theta = v * Math.PI;\n\n        for (let x = 0; x <= segments; x++) {\n            const u = x / segments;\n            const phi = u * Math.PI * 2;\n\n            const nx = Math.sin(theta) * Math.cos(phi);\n            const ny = Math.cos(theta);\n            const nz = Math.sin(theta) * Math.sin(phi);\n\n            vertices.push(nx * radius, ny * radius, nz * radius, nx, ny, nz);\n        }\n    }\n\n    for (let y = 0; y < rings; y++) {\n        for (let x = 0; x < segments; x++) {\n            const a = y * (segments + 1) + x;\n            const b = a + segments + 1;\n\n            indices.push(a, a + 1, b);\n            indices.push(a + 1, b + 1, b);\n        }\n    }\n\n    return {\n        vertices: new Float32Array(vertices),\n        indices: new Uint16Array(indices),\n        vertexCount: (rings + 1) * (segments + 1),\n        indexCount: rings * segments * 6,\n    };\n}\n","import type { MeshData } from \"./index\";\n\nexport function createPlane(): MeshData {\n    const vertices = new Float32Array([\n        -0.5, 0, 0.5, 0, 1, 0, 0.5, 0, 0.5, 0, 1, 0, 0.5, 0, -0.5, 0, 1, 0, -0.5, 0, -0.5, 0, 1, 0,\n    ]);\n\n    const indices = new Uint16Array([0, 1, 2, 0, 2, 3]);\n\n    return { vertices, indices, vertexCount: 4, indexCount: 6 };\n}\n","import { MAX_ENTITIES } from \"../../../core\";\nimport { setTraits, type FieldAccessor } from \"../../../core/component\";\nimport { createEntityIdBuffer } from \"../../compute\";\nimport { writeIndirect } from \"../forward\";\nimport { createBox } from \"./box\";\nimport { createSphere } from \"./sphere\";\nimport { createPlane } from \"./plane\";\n\nexport interface MeshData {\n    vertices: Float32Array<ArrayBuffer>;\n    indices: Uint16Array<ArrayBuffer>;\n    vertexCount: number;\n    indexCount: number;\n}\n\nconst meshes: MeshData[] = [];\n\nfunction initBuiltIns(): void {\n    if (meshes.length === 0) {\n        meshes.push(createBox());\n        meshes.push(createSphere());\n        meshes.push(createPlane());\n    }\n}\n\ninitBuiltIns();\n\nexport const MeshShape = {\n    Box: 0,\n    Sphere: 1,\n    Plane: 2,\n} as const;\n\nexport function mesh(data: MeshData): number {\n    const id = meshes.length;\n    meshes.push(data);\n    return id;\n}\n\nexport function getMesh(id: number): MeshData | undefined {\n    return meshes[id];\n}\n\nexport function clearMeshes(): void {\n    meshes.length = 0;\n    initBuiltIns();\n}\n\nexport const MeshColors = {\n    data: new Float32Array(MAX_ENTITIES * 4),\n};\n\nexport const MeshSizes = {\n    data: new Float32Array(MAX_ENTITIES * 4),\n};\n\ninterface ColorProxy extends Array<number>, FieldAccessor {}\n\nfunction colorProxy(): ColorProxy {\n    const data = MeshColors.data;\n\n    function getValue(eid: number): number {\n        const offset = eid * 4;\n        const r = Math.round(data[offset] * 255);\n        const g = Math.round(data[offset + 1] * 255);\n        const b = Math.round(data[offset + 2] * 255);\n        return (r << 16) | (g << 8) | b;\n    }\n\n    function setValue(eid: number, value: number): void {\n        const offset = eid * 4;\n        data[offset] = ((value >> 16) & 0xff) / 255;\n        data[offset + 1] = ((value >> 8) & 0xff) / 255;\n        data[offset + 2] = (value & 0xff) / 255;\n        data[offset + 3] = 1;\n    }\n\n    return new Proxy([] as unknown as ColorProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\ninterface ColorChannelProxy extends Array<number>, FieldAccessor {}\n\nfunction colorChannelProxy(channelIndex: number): ColorChannelProxy {\n    const data = MeshColors.data;\n\n    function getValue(eid: number): number {\n        return data[eid * 4 + channelIndex];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * 4 + channelIndex] = value;\n    }\n\n    return new Proxy([] as unknown as ColorChannelProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\ninterface SizeProxy extends Array<number>, FieldAccessor {}\n\nfunction sizeProxy(component: number): SizeProxy {\n    const data = MeshSizes.data;\n\n    function getValue(eid: number): number {\n        return data[eid * 4 + component];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * 4 + component] = value;\n    }\n\n    return new Proxy([] as unknown as SizeProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nexport const Mesh: {\n    shape: number[];\n    color: ColorProxy;\n    colorR: ColorChannelProxy;\n    colorG: ColorChannelProxy;\n    colorB: ColorChannelProxy;\n    sizeX: SizeProxy;\n    sizeY: SizeProxy;\n    sizeZ: SizeProxy;\n} = {\n    shape: [],\n    color: colorProxy(),\n    colorR: colorChannelProxy(0),\n    colorG: colorChannelProxy(1),\n    colorB: colorChannelProxy(2),\n    sizeX: sizeProxy(0),\n    sizeY: sizeProxy(1),\n    sizeZ: sizeProxy(2),\n};\n\nsetTraits(Mesh, {\n    defaults: () => ({\n        shape: MeshShape.Box,\n        color: 0xffffff,\n        sizeX: 1,\n        sizeY: 1,\n        sizeZ: 1,\n    }),\n    accessors: {\n        color: Mesh.color,\n        colorR: Mesh.colorR,\n        colorG: Mesh.colorG,\n        colorB: Mesh.colorB,\n        sizeX: Mesh.sizeX,\n        sizeY: Mesh.sizeY,\n        sizeZ: Mesh.sizeZ,\n    },\n});\n\nexport interface MeshBuffers {\n    vertex: GPUBuffer;\n    index: GPUBuffer;\n    indexCount: number;\n}\n\nexport function createMeshBuffers(device: GPUDevice, mesh: MeshData): MeshBuffers {\n    const vertex = device.createBuffer({\n        label: \"vertex\",\n        size: mesh.vertices.byteLength,\n        usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(vertex, 0, mesh.vertices);\n\n    const index = device.createBuffer({\n        label: \"index\",\n        size: mesh.indices.byteLength,\n        usage: GPUBufferUsage.INDEX | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(index, 0, mesh.indices);\n\n    return { vertex, index, indexCount: mesh.indexCount };\n}\n\nexport function collectByShape(entities: Iterable<number>): Map<number, number[]> {\n    const byShape = new Map<number, number[]>();\n    for (const eid of entities) {\n        const shape = Mesh.shape[eid];\n        let list = byShape.get(shape);\n        if (!list) {\n            list = [];\n            byShape.set(shape, list);\n        }\n        list.push(eid);\n    }\n    return byShape;\n}\n\nexport interface ShapeBatch {\n    index: number;\n    buffers: MeshBuffers;\n    entityIds: GPUBuffer;\n    count: number;\n}\n\nexport interface BatchState {\n    batches: Map<number, ShapeBatch>;\n    buffers: Map<number, MeshBuffers>;\n}\n\nexport function updateBatches(\n    device: GPUDevice,\n    byShape: Map<number, number[]>,\n    state: BatchState,\n    indirect: GPUBuffer\n): void {\n    for (const [shape, entities] of byShape) {\n        let batch = state.batches.get(shape);\n        if (!batch) {\n            let buffers = state.buffers.get(shape);\n            if (!buffers) {\n                const data = getMesh(shape) ?? getMesh(MeshShape.Box)!;\n                buffers = createMeshBuffers(device, data);\n                state.buffers.set(shape, buffers);\n            }\n            batch = {\n                index: state.batches.size,\n                buffers,\n                entityIds: createEntityIdBuffer(device, MAX_ENTITIES),\n                count: 0,\n            };\n            state.batches.set(shape, batch);\n        }\n\n        device.queue.writeBuffer(batch.entityIds, 0, new Uint32Array(entities));\n        batch.count = entities.length;\n\n        writeIndirect(device, indirect, batch.index, {\n            indexCount: batch.buffers.indexCount,\n            instanceCount: entities.length,\n            firstIndex: 0,\n            baseVertex: 0,\n            firstInstance: 0,\n        });\n    }\n}\n\nexport { createBox } from \"./box\";\nexport { createSphere } from \"./sphere\";\nexport { createPlane } from \"./plane\";\n","import { MAX_ENTITIES } from \"../../../core\";\nimport { setTraits } from \"../../../core/component\";\n\nexport interface MaterialData {\n    roughness?: number;\n    metallic?: number;\n    emissionColor?: number;\n    emissionIntensity?: number;\n}\n\nconst materials: MaterialData[] = [];\n\nfunction initBuiltIns(): void {\n    if (materials.length === 0) {\n        materials.push({\n            roughness: 0.9,\n            metallic: 0.0,\n            emissionColor: 0x000000,\n            emissionIntensity: 0.0,\n        });\n    }\n}\n\ninitBuiltIns();\n\nexport const MaterialType = {\n    Default: 0,\n} as const;\n\nexport function material(data: MaterialData): number {\n    const id = materials.length;\n    materials.push(data);\n    return id;\n}\n\nexport function getMaterial(id: number): MaterialData | undefined {\n    return materials[id];\n}\n\nexport function clearMaterials(): void {\n    materials.length = 0;\n    initBuiltIns();\n}\n\nexport const MaterialIds = {\n    data: new Uint32Array(MAX_ENTITIES),\n};\n\nexport const Material: {\n    type: number[];\n} = {\n    type: [],\n};\n\nsetTraits(Material, {\n    defaults: () => ({\n        type: MaterialType.Default,\n    }),\n});\n\nfunction hexToRgb(hex: number): { r: number; g: number; b: number } {\n    return {\n        r: ((hex >> 16) & 0xff) / 255,\n        g: ((hex >> 8) & 0xff) / 255,\n        b: (hex & 0xff) / 255,\n    };\n}\n\nexport function packMaterials(): Float32Array {\n    const floatsPerMaterial = 8;\n    const buffer = new Float32Array(materials.length * floatsPerMaterial);\n\n    for (let i = 0; i < materials.length; i++) {\n        const mat = materials[i];\n        const offset = i * floatsPerMaterial;\n\n        const emissionColor = mat.emissionColor ?? 0x000000;\n        const emissionIntensity = mat.emissionIntensity ?? 0.0;\n        const rgb = hexToRgb(emissionColor);\n\n        buffer[offset + 0] = rgb.r * emissionIntensity;\n        buffer[offset + 1] = rgb.g * emissionIntensity;\n        buffer[offset + 2] = rgb.b * emissionIntensity;\n        buffer[offset + 3] = mat.roughness ?? 0.9;\n        buffer[offset + 4] = mat.metallic ?? 0.0;\n        buffer[offset + 5] = 0;\n        buffer[offset + 6] = 0;\n        buffer[offset + 7] = 0;\n    }\n\n    return buffer;\n}\n","import type { ComputeNode, ExecutionContext } from \"../compute\";\n\nconst shader = /* wgsl */ `\nstruct VertexOutput {\n    @builtin(position) position: vec4f,\n    @location(0) uv: vec2f,\n}\n\nstruct Uniforms {\n    exposure: f32,\n    vignetteStrength: f32,\n    vignetteInner: f32,\n    vignetteOuter: f32,\n    texelSizeX: f32,\n    texelSizeY: f32,\n    flags: u32,\n    _pad: u32,\n}\n\n@group(0) @binding(0) var inputTexture: texture_2d<f32>;\n@group(0) @binding(1) var inputSampler: sampler;\n@group(0) @binding(2) var<uniform> uniforms: Uniforms;\n@group(0) @binding(3) var maskTexture: texture_2d<f32>;\n\nconst FLAG_TONEMAP: u32 = 1u;\nconst FLAG_FXAA: u32 = 2u;\nconst FLAG_VIGNETTE: u32 = 4u;\n\n@vertex\nfn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> VertexOutput {\n    var positions = array<vec2f, 3>(\n        vec2f(-1.0, -1.0),\n        vec2f(3.0, -1.0),\n        vec2f(-1.0, 3.0)\n    );\n\n    let pos = positions[vertexIndex];\n\n    var output: VertexOutput;\n    output.position = vec4f(pos, 0.0, 1.0);\n    output.uv = (pos + 1.0) * 0.5;\n    output.uv.y = 1.0 - output.uv.y;\n    return output;\n}\n\nfn aces(x: vec3f) -> vec3f {\n    let a = 2.51;\n    let b = 0.03;\n    let c = 2.43;\n    let d = 0.59;\n    let e = 0.14;\n    return saturate((x * (a * x + b)) / (x * (c * x + d) + e));\n}\n\nfn luma(color: vec3f) -> f32 {\n    return dot(color, vec3f(0.299, 0.587, 0.114));\n}\n\nconst FXAA_REDUCE_MIN: f32 = 1.0 / 128.0;\nconst FXAA_REDUCE_MUL: f32 = 1.0 / 8.0;\nconst FXAA_SPAN_MAX: f32 = 8.0;\n\nfn applyFXAA(uv: vec2f, colorM: vec3f) -> vec3f {\n    let texelSize = vec2f(uniforms.texelSizeX, uniforms.texelSizeY);\n\n    let colorNW = textureSample(inputTexture, inputSampler, uv + vec2f(-1.0, -1.0) * texelSize).rgb;\n    let colorNE = textureSample(inputTexture, inputSampler, uv + vec2f(1.0, -1.0) * texelSize).rgb;\n    let colorSW = textureSample(inputTexture, inputSampler, uv + vec2f(-1.0, 1.0) * texelSize).rgb;\n    let colorSE = textureSample(inputTexture, inputSampler, uv + vec2f(1.0, 1.0) * texelSize).rgb;\n\n    let lumaM = luma(colorM);\n    let lumaNW = luma(colorNW);\n    let lumaNE = luma(colorNE);\n    let lumaSW = luma(colorSW);\n    let lumaSE = luma(colorSE);\n\n    let lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    let lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    var dir: vec2f;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y = ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\n    let dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) * 0.25 * FXAA_REDUCE_MUL, FXAA_REDUCE_MIN);\n    let rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n    dir = clamp(dir * rcpDirMin, vec2f(-FXAA_SPAN_MAX), vec2f(FXAA_SPAN_MAX)) * texelSize;\n\n    let colorA = 0.5 * (\n        textureSample(inputTexture, inputSampler, uv + dir * (1.0 / 3.0 - 0.5)).rgb +\n        textureSample(inputTexture, inputSampler, uv + dir * (2.0 / 3.0 - 0.5)).rgb\n    );\n\n    let colorB = colorA * 0.5 + 0.25 * (\n        textureSample(inputTexture, inputSampler, uv + dir * -0.5).rgb +\n        textureSample(inputTexture, inputSampler, uv + dir * 0.5).rgb\n    );\n\n    let lumaB = luma(colorB);\n\n    if lumaB < lumaMin || lumaB > lumaMax {\n        return colorA;\n    }\n    return colorB;\n}\n\nfn applyVignette(color: vec3f, uv: vec2f) -> vec3f {\n    let center = vec2f(0.5, 0.5);\n    let dist = distance(uv, center);\n    let vignette = 1.0 - smoothstep(uniforms.vignetteInner, uniforms.vignetteOuter, dist) * uniforms.vignetteStrength;\n    return color * vignette;\n}\n\n@fragment\nfn fragmentMain(input: VertexOutput) -> @location(0) vec4f {\n    var color = textureSample(inputTexture, inputSampler, input.uv).rgb;\n    let maskValue = textureSample(maskTexture, inputSampler, input.uv).r;\n\n    if (uniforms.flags & FLAG_FXAA) != 0u {\n        let fxaaColor = applyFXAA(input.uv, color);\n        color = select(fxaaColor, color, maskValue >= 0.5);\n    }\n\n    if (uniforms.flags & FLAG_TONEMAP) != 0u {\n        color = aces(color * uniforms.exposure);\n    }\n\n    if (uniforms.flags & FLAG_VIGNETTE) != 0u {\n        color = applyVignette(color, input.uv);\n    }\n\n    return vec4f(color, 1.0);\n}\n`;\n\nconst FLAG_TONEMAP = 1;\nconst FLAG_FXAA = 2;\nconst FLAG_VIGNETTE = 4;\n\nexport interface PostProcessUniforms {\n    tonemap: boolean;\n    exposure: number;\n    fxaa: boolean;\n    vignetteStrength: number;\n    vignetteInner: number;\n    vignetteOuter: number;\n}\n\nexport function createPostProcessNode(uniforms: PostProcessUniforms): ComputeNode {\n    let pipeline: GPURenderPipeline | null = null;\n    let uniformBuffer: GPUBuffer | null = null;\n    let sampler: GPUSampler | null = null;\n\n    return {\n        id: \"postprocess\",\n        phase: \"postprocess\",\n        inputs: [\n            { id: \"scene\", access: \"read\" },\n            { id: \"mask\", access: \"read\" },\n        ],\n        outputs: [{ id: \"framebuffer\", access: \"write\" }],\n\n        execute(ctx: ExecutionContext) {\n            const { device, encoder, canvasView, format, context } = ctx;\n            const width = context.canvas.width;\n            const height = context.canvas.height;\n            const sceneView = ctx.getTextureView(\"scene\")!;\n            const maskView = ctx.getTextureView(\"mask\")!;\n\n            if (!pipeline) {\n                const module = device.createShaderModule({ code: shader });\n                pipeline = device.createRenderPipeline({\n                    layout: \"auto\",\n                    vertex: { module, entryPoint: \"vertexMain\" },\n                    fragment: {\n                        module,\n                        entryPoint: \"fragmentMain\",\n                        targets: [{ format }],\n                    },\n                    primitive: { topology: \"triangle-list\" },\n                });\n            }\n\n            if (!uniformBuffer) {\n                uniformBuffer = device.createBuffer({\n                    size: 32,\n                    usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n                });\n            }\n\n            if (!sampler) {\n                sampler = device.createSampler({\n                    magFilter: \"linear\",\n                    minFilter: \"linear\",\n                });\n            }\n\n            let flags = 0;\n            if (uniforms.tonemap) flags |= FLAG_TONEMAP;\n            if (uniforms.fxaa) flags |= FLAG_FXAA;\n            if (uniforms.vignetteStrength > 0) flags |= FLAG_VIGNETTE;\n\n            const data = new ArrayBuffer(32);\n            const floats = new Float32Array(data);\n            const uints = new Uint32Array(data);\n            floats[0] = uniforms.exposure;\n            floats[1] = uniforms.vignetteStrength;\n            floats[2] = uniforms.vignetteInner;\n            floats[3] = uniforms.vignetteOuter;\n            floats[4] = 1.0 / width;\n            floats[5] = 1.0 / height;\n            uints[6] = flags;\n\n            device.queue.writeBuffer(uniformBuffer, 0, data);\n\n            const bindGroup = device.createBindGroup({\n                layout: pipeline.getBindGroupLayout(0),\n                entries: [\n                    { binding: 0, resource: sceneView },\n                    { binding: 1, resource: sampler },\n                    { binding: 2, resource: { buffer: uniformBuffer } },\n                    { binding: 3, resource: maskView },\n                ],\n            });\n\n            const pass = encoder.beginRenderPass({\n                colorAttachments: [\n                    {\n                        view: canvasView,\n                        loadOp: \"clear\" as const,\n                        storeOp: \"store\" as const,\n                        clearValue: { r: 0, g: 0, b: 0, a: 1 },\n                    },\n                ],\n            });\n\n            pass.setPipeline(pipeline);\n            pass.setBindGroup(0, bindGroup);\n            pass.draw(3);\n            pass.end();\n        },\n    };\n}\n","import { resource, type State } from \"../../core\";\nimport type { ComputeNode, ExecutionContext } from \"../compute\";\nimport { MASK_FORMAT } from \"./scene\";\n\nexport interface DrawContext {\n    readonly device: GPUDevice;\n    readonly format: GPUTextureFormat;\n    readonly maskFormat: GPUTextureFormat;\n}\n\nexport interface DrawContributor {\n    readonly id: string;\n    readonly order: number;\n    draw(pass: GPURenderPassEncoder, ctx: DrawContext): void;\n}\n\nexport interface TransparentPassState {\n    contributors: Map<string, DrawContributor>;\n}\n\nexport const TransparentPass = resource<TransparentPassState>(\"transparent-pass\");\n\nexport function registerDrawContributor(state: State, contributor: DrawContributor): void {\n    const pass = TransparentPass.from(state);\n    if (pass) {\n        pass.contributors.set(contributor.id, contributor);\n    }\n}\n\nexport function unregisterDrawContributor(state: State, id: string): void {\n    const pass = TransparentPass.from(state);\n    if (pass) {\n        pass.contributors.delete(id);\n    }\n}\n\nexport interface TransparentNodeConfig {\n    getContributors: () => DrawContributor[];\n}\n\nexport function createTransparentNode(config: TransparentNodeConfig): ComputeNode {\n    return {\n        id: \"transparent\",\n        phase: \"transparent\",\n        inputs: [{ id: \"depth\", access: \"read\" }],\n        outputs: [\n            { id: \"scene\", access: \"write\" },\n            { id: \"mask\", access: \"write\" },\n        ],\n\n        execute(ctx: ExecutionContext) {\n            const contributors = config.getContributors();\n            if (contributors.length === 0) return;\n\n            const targetView = ctx.getTextureView(\"scene\") ?? ctx.canvasView;\n            const depthView = ctx.getTextureView(\"depth\")!;\n            const maskView = ctx.getTextureView(\"mask\")!;\n\n            const pass = ctx.encoder.beginRenderPass({\n                colorAttachments: [\n                    {\n                        view: targetView,\n                        loadOp: \"load\" as const,\n                        storeOp: \"store\" as const,\n                    },\n                    {\n                        view: maskView,\n                        clearValue: { r: 0, g: 0, b: 0, a: 0 },\n                        loadOp: \"clear\" as const,\n                        storeOp: \"store\" as const,\n                    },\n                ],\n                depthStencilAttachment: {\n                    view: depthView,\n                    depthLoadOp: \"load\" as const,\n                    depthStoreOp: \"store\" as const,\n                },\n            });\n\n            const drawCtx: DrawContext = {\n                device: ctx.device,\n                format: ctx.format,\n                maskFormat: MASK_FORMAT,\n            };\n\n            const sorted = [...contributors].sort((a, b) => a.order - b.order);\n            for (const contributor of sorted) {\n                contributor.draw(pass, drawCtx);\n            }\n\n            pass.end();\n        },\n    };\n}\n","import { resource, type State } from \"../../core\";\nimport { DEPTH_FORMAT } from \"./scene\";\n\nexport interface OpaqueDrawContext {\n    readonly device: GPUDevice;\n    readonly format: GPUTextureFormat;\n    readonly depthFormat: GPUTextureFormat;\n    readonly scene: GPUBuffer;\n    readonly matrices: GPUBuffer;\n}\n\nexport interface OpaqueDrawCallback {\n    readonly id: string;\n    readonly order: number;\n    draw(pass: GPURenderPassEncoder, ctx: OpaqueDrawContext): void;\n}\n\nexport interface OpaquePassState {\n    callbacks: Map<string, OpaqueDrawCallback>;\n}\n\nexport const OpaquePass = resource<OpaquePassState>(\"opaque-pass\");\n\nexport function registerOpaqueCallback(state: State, callback: OpaqueDrawCallback): void {\n    const pass = OpaquePass.from(state);\n    if (pass) {\n        pass.callbacks.set(callback.id, callback);\n    }\n}\n\nexport function unregisterOpaqueCallback(state: State, id: string): void {\n    const pass = OpaquePass.from(state);\n    if (pass) {\n        pass.callbacks.delete(id);\n    }\n}\n\nexport function getOpaqueCallbacks(state: State): OpaqueDrawCallback[] {\n    const pass = OpaquePass.from(state);\n    if (!pass) return [];\n    return Array.from(pass.callbacks.values());\n}\n\nexport { DEPTH_FORMAT };\n","import type { Plugin, State, System } from \"../../core\";\nimport { MAX_ENTITIES, resource } from \"../../core\";\nimport { Compute, ComputePlugin } from \"../compute\";\nimport { WorldTransform } from \"../transforms\";\nimport { Camera, Tonemap, FXAA, Vignette, uploadCamera } from \"./camera\";\nimport { AmbientLight, DirectionalLight, packLightUniforms } from \"./light\";\nimport {\n    Mesh,\n    MeshColors,\n    MeshSizes,\n    collectByShape,\n    updateBatches,\n    type ShapeBatch,\n    type MeshBuffers,\n} from \"./mesh\";\nimport { Material, MaterialIds, packMaterials } from \"./material\";\nimport { createSceneBuffer, ensureRenderTextures } from \"./scene\";\nimport { createForwardNode, createIndirectBuffer } from \"./forward\";\nimport { createPostProcessNode, type PostProcessUniforms } from \"./postprocess\";\nimport { TransparentPass, createTransparentNode, type TransparentPassState } from \"./transparent\";\nimport { OpaquePass, getOpaqueCallbacks, type OpaquePassState } from \"./opaque\";\n\nexport * from \"./camera\";\nexport * from \"./light\";\nexport * from \"./mesh\";\nexport * from \"./material\";\nexport * from \"./scene\";\nexport * from \"./forward\";\nexport * from \"./postprocess\";\nexport * from \"./transparent\";\nexport * from \"./opaque\";\n\nexport interface RenderState {\n    scene: GPUBuffer;\n    matrices: GPUBuffer;\n    colors: GPUBuffer;\n    sizes: GPUBuffer;\n    materials: GPUBuffer;\n    materialIds: GPUBuffer;\n    indirect: GPUBuffer;\n    batches: Map<number, ShapeBatch>;\n    buffers: Map<number, MeshBuffers>;\n    postProcess: PostProcessUniforms;\n}\n\nexport const Render = resource<RenderState>(\"render\");\n\nconst RenderSystem: System = {\n    group: \"draw\",\n    first: true,\n\n    update(state: State) {\n        const render = Render.from(state);\n        const compute = Compute.from(state);\n        if (!render || !compute || !state.canvas) return;\n\n        const { device, format, resources } = compute;\n        const { width, height } = state.canvas;\n\n        ensureRenderTextures(\n            device,\n            format,\n            width,\n            height,\n            resources.textures,\n            resources.textureViews\n        );\n\n        for (const eid of state.query([Camera])) {\n            if (Camera.active[eid]) {\n                uploadCamera(device, render.scene, eid, width, height);\n\n                render.postProcess.tonemap = state.hasComponent(eid, Tonemap);\n                if (render.postProcess.tonemap) {\n                    render.postProcess.exposure = Tonemap.exposure[eid];\n                }\n                render.postProcess.fxaa = state.hasComponent(eid, FXAA);\n                if (state.hasComponent(eid, Vignette)) {\n                    render.postProcess.vignetteStrength = Vignette.strength[eid];\n                    render.postProcess.vignetteInner = Vignette.inner[eid];\n                    render.postProcess.vignetteOuter = Vignette.outer[eid];\n                } else {\n                    render.postProcess.vignetteStrength = 0;\n                }\n                break;\n            }\n        }\n\n        let ambientData = { color: 0x888888, intensity: 1.0 };\n        let directionalData = {\n            color: 0xffffff,\n            intensity: 1.0,\n            directionX: -0.5,\n            directionY: -1.0,\n            directionZ: -0.5,\n        };\n\n        for (const eid of state.query([AmbientLight])) {\n            ambientData = {\n                color: AmbientLight.color[eid],\n                intensity: AmbientLight.intensity[eid],\n            };\n            break;\n        }\n\n        for (const eid of state.query([DirectionalLight])) {\n            directionalData = {\n                color: DirectionalLight.color[eid],\n                intensity: DirectionalLight.intensity[eid],\n                directionX: DirectionalLight.directionX[eid],\n                directionY: DirectionalLight.directionY[eid],\n                directionZ: DirectionalLight.directionZ[eid],\n            };\n            break;\n        }\n\n        const lightUniforms = packLightUniforms(ambientData, directionalData);\n        device.queue.writeBuffer(render.scene, 128, lightUniforms as Float32Array<ArrayBuffer>);\n\n        device.queue.writeBuffer(\n            render.matrices,\n            0,\n            WorldTransform.data as Float32Array<ArrayBuffer>\n        );\n\n        const meshEntities = state.query([Mesh, WorldTransform]);\n        const byShape = collectByShape(meshEntities);\n        device.queue.writeBuffer(render.colors, 0, MeshColors.data);\n        device.queue.writeBuffer(render.sizes, 0, MeshSizes.data);\n\n        for (const eid of state.query([Material])) {\n            MaterialIds.data[eid] = Material.type[eid];\n        }\n        device.queue.writeBuffer(render.materials, 0, packMaterials() as Float32Array<ArrayBuffer>);\n        device.queue.writeBuffer(render.materialIds, 0, MaterialIds.data);\n\n        updateBatches(device, byShape, render, render.indirect);\n    },\n};\n\nconst DefaultMaterialSystem: System = {\n    group: \"setup\",\n    update(state: State) {\n        for (const eid of state.query([Mesh])) {\n            if (!state.hasComponent(eid, Material)) {\n                state.addComponent(eid, Material);\n            }\n        }\n    },\n};\n\nexport const RenderPlugin: Plugin = {\n    systems: [DefaultMaterialSystem, RenderSystem],\n    components: { Camera, Mesh, Material, AmbientLight, DirectionalLight, Tonemap, FXAA, Vignette },\n    dependencies: [ComputePlugin],\n\n    initialize(state: State) {\n        const compute = Compute.from(state);\n        if (!compute) return;\n\n        const { device } = compute;\n\n        const createPropertyBuffer = (size: number) =>\n            device.createBuffer({\n                label: \"property\",\n                size,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,\n            });\n\n        const renderState: RenderState = {\n            scene: createSceneBuffer(device),\n            matrices: createPropertyBuffer(MAX_ENTITIES * 64),\n            colors: createPropertyBuffer(MAX_ENTITIES * 16),\n            sizes: createPropertyBuffer(MAX_ENTITIES * 16),\n            materials: createPropertyBuffer(256 * 32),\n            materialIds: createPropertyBuffer(MAX_ENTITIES * 4),\n            indirect: createIndirectBuffer(device, 16),\n            batches: new Map(),\n            buffers: new Map(),\n            postProcess: {\n                tonemap: false,\n                exposure: 1.0,\n                fxaa: true,\n                vignetteStrength: 0,\n                vignetteInner: 0.4,\n                vignetteOuter: 0.8,\n            },\n        };\n\n        state.setResource(Render, renderState);\n\n        const opaqueState: OpaquePassState = {\n            callbacks: new Map(),\n        };\n        state.setResource(OpaquePass, opaqueState);\n\n        const transparentState: TransparentPassState = {\n            contributors: new Map(),\n        };\n        state.setResource(TransparentPass, transparentState);\n\n        compute.graph.add(\n            createForwardNode({\n                scene: renderState.scene,\n                matrices: renderState.matrices,\n                colors: renderState.colors,\n                sizes: renderState.sizes,\n                materials: renderState.materials,\n                materialIds: renderState.materialIds,\n                indirect: renderState.indirect,\n                batches: renderState.batches,\n                getCallbacks: () => getOpaqueCallbacks(state),\n            })\n        );\n\n        compute.graph.add(\n            createTransparentNode({\n                getContributors: () => Array.from(transparentState.contributors.values()),\n            })\n        );\n\n        compute.graph.add(createPostProcessNode(renderState.postProcess));\n    },\n};\n","import type { Loading } from \"../../core\";\n\ninterface Theme {\n    bg: string;\n    track: string;\n    bar: string;\n}\n\nconst dark: Theme = { bg: \"#1a1a1a\", track: \"#333\", bar: \"#E8A86B\" };\nconst light: Theme = { bg: \"#f5f5f5\", track: \"#ddd\", bar: \"#B87654\" };\n\nconst LOGO_SVG = `<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 80 80\">\n  <defs>\n    <radialGradient id=\"baseGradient\" cx=\"35%\" cy=\"30%\" r=\"70%\" fx=\"25%\" fy=\"20%\">\n      <stop offset=\"0%\" stop-color=\"#F5D4B8\"/>\n      <stop offset=\"45%\" stop-color=\"#E8A86B\"/>\n      <stop offset=\"100%\" stop-color=\"#B87654\"/>\n    </radialGradient>\n  </defs>\n  <g transform=\"rotate(35 40.0 40.0)\">\n    <path d=\"M40.0,2 C44.0,10 66.0,28 66.0,46 C66.0,60 48.0,70 40.0,78 C32.0,70 14.0,60 14.0,46 C14.0,28 36.0,10 40.0,2 Z\" fill=\"url(#baseGradient)\"/>\n    <path d=\"M40.0,6 C37.0,14 22.0,28 20.0,44 C20.0,52 28.0,62 36.0,70 C34.0,58 26.0,46 26.0,38 C26.0,26 38.0,12 40.0,6 Z\" fill=\"#B87654\" opacity=\"0.45\"/>\n    <path d=\"M40.0,6 C43.0,14 58.0,28 60.0,44 C60.0,52 52.0,62 44.0,70 C46.0,58 54.0,46 54.0,38 C54.0,26 42.0,12 40.0,6 Z\" fill=\"#B87654\" opacity=\"0.35\"/>\n    <path d=\"M40.0,8 C40.0,20 40.0,50 40.0,72\" stroke=\"#B87654\" stroke-width=\"1\" stroke-opacity=\"0.4\" fill=\"none\" stroke-linecap=\"round\"/>\n    <path d=\"M40.0,78 C48.0,70 66.0,60 66.0,46 C61.0,58 44.0,70 40.0,73 Z\" fill=\"#B87654\"/>\n    <path d=\"M40.0,2 C36.0,10 14.0,28 14.0,46 C19.0,30 41.0,8 40.0,7 Z\" fill=\"#F5D4B8\" opacity=\"0.7\"/>\n    <path d=\"M40.0,2 C44.0,10 66.0,28 66.0,46 C66.0,60 48.0,70 40.0,78 C32.0,70 14.0,60 14.0,46 C14.0,28 36.0,10 40.0,2 Z\" fill=\"none\" stroke=\"#6B4230\" stroke-width=\"2\"/>\n  </g>\n</svg>`;\n\nfunction createOverlay(canvas: HTMLCanvasElement, bg: string): HTMLDivElement {\n    const overlay = document.createElement(\"div\");\n    overlay.style.cssText = `\n        position: absolute;\n        inset: 0;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n        justify-content: center;\n        background: ${bg};\n        z-index: 1000;\n    `;\n\n    const parent = canvas.parentElement;\n    if (parent) {\n        if (getComputedStyle(parent).position === \"static\") {\n            parent.style.position = \"relative\";\n        }\n        parent.appendChild(overlay);\n    }\n\n    return overlay;\n}\n\nfunction createProgressBar(theme: Theme): { track: HTMLDivElement; bar: HTMLDivElement } {\n    const track = document.createElement(\"div\");\n    track.style.cssText = `\n        width: 200px;\n        height: 4px;\n        background: ${theme.track};\n        border-radius: 2px;\n        overflow: hidden;\n    `;\n\n    const bar = document.createElement(\"div\");\n    bar.style.cssText = `\n        width: 0%;\n        height: 100%;\n        background: ${theme.bar};\n        transition: width 0.15s ease-out;\n    `;\n    track.appendChild(bar);\n\n    return { track, bar };\n}\n\nfunction shallotLoading(canvas: HTMLCanvasElement, theme: Theme): Loading {\n    let overlay: HTMLDivElement | null = null;\n    let bar: HTMLDivElement | null = null;\n\n    return {\n        show() {\n            overlay = createOverlay(canvas, theme.bg);\n\n            const logo = document.createElement(\"div\");\n            logo.innerHTML = LOGO_SVG;\n            logo.style.cssText = \"width: 64px; height: 64px; margin-bottom: 24px;\";\n            overlay.appendChild(logo);\n\n            const progressBar = createProgressBar(theme);\n            bar = progressBar.bar;\n            overlay.appendChild(progressBar.track);\n\n            return () => {\n                overlay?.remove();\n                overlay = null;\n                bar = null;\n            };\n        },\n\n        update(progress) {\n            if (bar) bar.style.width = `${progress * 100}%`;\n        },\n    };\n}\n\nfunction minimalLoading(canvas: HTMLCanvasElement, theme: Theme): Loading {\n    let overlay: HTMLDivElement | null = null;\n    let bar: HTMLDivElement | null = null;\n\n    return {\n        show() {\n            overlay = createOverlay(canvas, theme.bg);\n            const progressBar = createProgressBar(theme);\n            bar = progressBar.bar;\n            overlay.appendChild(progressBar.track);\n\n            return () => {\n                overlay?.remove();\n                overlay = null;\n                bar = null;\n            };\n        },\n\n        update(progress) {\n            if (bar) bar.style.width = `${progress * 100}%`;\n        },\n    };\n}\n\nexport const shallotDark = (canvas: HTMLCanvasElement): Loading => shallotLoading(canvas, dark);\nexport const shallotLight = (canvas: HTMLCanvasElement): Loading => shallotLoading(canvas, light);\nexport const minimalDark = (canvas: HTMLCanvasElement): Loading => minimalLoading(canvas, dark);\nexport const minimalLight = (canvas: HTMLCanvasElement): Loading => minimalLoading(canvas, light);\n\nexport { shallotDark as canvasLoading };\n","import type { Plugin } from \"../core/types\";\nimport { StateBuilder } from \"../core/builder\";\nimport { TransformsPlugin } from \"./transforms\";\nimport { InputPlugin } from \"./input\";\nimport { canvasLoading } from \"./loading\";\nimport { ComputePlugin } from \"./compute\";\nimport { RenderPlugin } from \"./render\";\n\nexport const DEFAULT_PLUGINS: readonly Plugin[] = [\n    TransformsPlugin,\n    InputPlugin,\n    ComputePlugin,\n    RenderPlugin,\n];\n\nStateBuilder.defaultPlugins = DEFAULT_PLUGINS;\nStateBuilder.loading = canvasLoading;\n","import { setTraits } from \"../../core/component\";\nimport { clamp, lookAt, type State, type System, type Plugin, type MouseState } from \"../../core\";\nimport { Transform } from \"../../standard/transforms\";\nimport { Input, InputPlugin } from \"../../standard/input\";\n\nconst Tau = Math.PI * 2;\n\nexport const OrbitButton = {\n    Left: 0,\n    Middle: 1,\n    Right: 2,\n} as const;\n\nexport const Orbit = {\n    target: [] as number[],\n    yaw: [] as number[],\n    pitch: [] as number[],\n    distance: [] as number[],\n    targetYaw: [] as number[],\n    targetPitch: [] as number[],\n    targetDistance: [] as number[],\n    minPitch: [] as number[],\n    maxPitch: [] as number[],\n    minDistance: [] as number[],\n    maxDistance: [] as number[],\n    smoothness: [] as number[],\n    sensitivity: [] as number[],\n    zoomSpeed: [] as number[],\n    button: [] as number[],\n};\n\nsetTraits(Orbit, {\n    defaults: () => ({\n        target: 0,\n        yaw: 0,\n        pitch: Math.PI / 6,\n        distance: 8,\n        targetYaw: 0,\n        targetPitch: Math.PI / 6,\n        targetDistance: 10,\n        minPitch: -Math.PI / 2 + 0.01,\n        maxPitch: Math.PI / 2 - 0.01,\n        minDistance: 1,\n        maxDistance: 25,\n        smoothness: 0.3,\n        sensitivity: 0.005,\n        zoomSpeed: 0.025,\n        button: OrbitButton.Left,\n    }),\n});\n\nfunction smoothLerp(smoothness: number, dt: number): number {\n    const s = Math.max(0, Math.min(1, smoothness));\n    return 1 - Math.pow(1 - s, dt * 60);\n}\n\nfunction normalizeAngle(a: number): number {\n    return ((a % Tau) + Tau) % Tau;\n}\n\nfunction angleDiff(from: number, to: number): number {\n    const diff = normalizeAngle(to - from);\n    return diff > Math.PI ? diff - Tau : diff;\n}\n\nfunction isOrbitButton(mouse: Readonly<MouseState>, button: number): boolean {\n    if (button === OrbitButton.Left) return mouse.left;\n    if (button === OrbitButton.Middle) return mouse.middle;\n    return mouse.right;\n}\n\nexport const OrbitSystem: System = {\n    group: \"simulation\",\n\n    update(state: State) {\n        const input = Input.from(state);\n        const dt = state.time.deltaTime;\n\n        for (const eid of state.query([Orbit, Transform])) {\n            const sensitivity = Orbit.sensitivity[eid];\n            const zoomSpeed = Orbit.zoomSpeed[eid];\n            const minPitch = Orbit.minPitch[eid];\n            const maxPitch = Orbit.maxPitch[eid];\n            const minDistance = Orbit.minDistance[eid];\n            const maxDistance = Orbit.maxDistance[eid];\n            const smoothness = Orbit.smoothness[eid];\n\n            if (input && isOrbitButton(input.mouse, Orbit.button[eid])) {\n                Orbit.targetYaw[eid] -= input.mouse.deltaX * sensitivity;\n                Orbit.targetPitch[eid] = clamp(\n                    Orbit.targetPitch[eid] + input.mouse.deltaY * sensitivity,\n                    minPitch,\n                    maxPitch\n                );\n            }\n\n            if (input && input.mouse.scrollDelta !== 0) {\n                const currentDistance = Orbit.targetDistance[eid];\n                const distanceScale = Math.max(0.3, currentDistance * 0.08);\n                const zoomDelta = input.mouse.scrollDelta * zoomSpeed * distanceScale;\n                Orbit.targetDistance[eid] = clamp(\n                    currentDistance + zoomDelta,\n                    minDistance,\n                    maxDistance\n                );\n            }\n\n            const t = smoothLerp(smoothness, dt);\n            Orbit.yaw[eid] += angleDiff(Orbit.yaw[eid], Orbit.targetYaw[eid]) * t;\n            Orbit.pitch[eid] += (Orbit.targetPitch[eid] - Orbit.pitch[eid]) * t;\n            Orbit.distance[eid] += (Orbit.targetDistance[eid] - Orbit.distance[eid]) * t;\n\n            const yaw = Orbit.yaw[eid];\n            const pitch = Orbit.pitch[eid];\n            const distance = Orbit.distance[eid];\n\n            let targetX = 0,\n                targetY = 0,\n                targetZ = 0;\n            const targetEid = Orbit.target[eid];\n            if (targetEid && state.hasComponent(targetEid, Transform)) {\n                targetX = Transform.posX[targetEid];\n                targetY = Transform.posY[targetEid];\n                targetZ = Transform.posZ[targetEid];\n            }\n\n            const camX = targetX + distance * Math.cos(pitch) * Math.sin(yaw);\n            const camY = targetY + distance * Math.sin(pitch);\n            const camZ = targetZ + distance * Math.cos(pitch) * Math.cos(yaw);\n\n            Transform.posX[eid] = camX;\n            Transform.posY[eid] = camY;\n            Transform.posZ[eid] = camZ;\n\n            const rotation = lookAt(camX, camY, camZ, targetX, targetY, targetZ);\n            Transform.quatX[eid] = rotation.x;\n            Transform.quatY[eid] = rotation.y;\n            Transform.quatZ[eid] = rotation.z;\n            Transform.quatW[eid] = rotation.w;\n        }\n    },\n};\n\nexport const OrbitPlugin: Plugin = {\n    systems: [OrbitSystem],\n    components: { Orbit },\n    dependencies: [InputPlugin],\n};\n","import { MAX_ENTITIES, resource, type Plugin, type State, type System } from \"../../core\";\nimport { setTraits, type FieldAccessor } from \"../../core/component\";\nimport { Compute, ComputePlugin, createEntityIdBuffer } from \"../../standard/compute\";\nimport {\n    Render,\n    RenderPlugin,\n    DEPTH_FORMAT,\n    registerDrawContributor,\n    type DrawContributor,\n    type DrawContext,\n} from \"../../standard/render\";\nimport { Transform } from \"../../standard/transforms\";\n\nexport const LineData = {\n    data: new Float32Array(MAX_ENTITIES * 12),\n};\n\ninterface LineProxy extends Array<number>, FieldAccessor {}\n\nfunction lineProxy(offset: number): LineProxy {\n    const data = LineData.data;\n\n    function getValue(eid: number): number {\n        return data[eid * 12 + offset];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * 12 + offset] = value;\n    }\n\n    return new Proxy([] as unknown as LineProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nfunction colorProxy(): LineProxy {\n    const data = LineData.data;\n\n    function getValue(eid: number): number {\n        const offset = eid * 12 + 8;\n        const r = Math.round(data[offset] * 255);\n        const g = Math.round(data[offset + 1] * 255);\n        const b = Math.round(data[offset + 2] * 255);\n        return (r << 16) | (g << 8) | b;\n    }\n\n    function setValue(eid: number, value: number): void {\n        const offset = eid * 12 + 8;\n        data[offset] = ((value >> 16) & 0xff) / 255;\n        data[offset + 1] = ((value >> 8) & 0xff) / 255;\n        data[offset + 2] = (value & 0xff) / 255;\n        data[offset + 3] = 1;\n    }\n\n    return new Proxy([] as unknown as LineProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nfunction colorChannelProxy(channelIndex: number): LineProxy {\n    const data = LineData.data;\n\n    function getValue(eid: number): number {\n        return data[eid * 12 + 8 + channelIndex];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * 12 + 8 + channelIndex] = value;\n    }\n\n    return new Proxy([] as unknown as LineProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nexport const Line: {\n    offsetX: LineProxy;\n    offsetY: LineProxy;\n    offsetZ: LineProxy;\n    thickness: LineProxy;\n    visible: LineProxy;\n    opacity: LineProxy;\n    color: LineProxy;\n    colorR: LineProxy;\n    colorG: LineProxy;\n    colorB: LineProxy;\n} = {\n    offsetX: lineProxy(0),\n    offsetY: lineProxy(1),\n    offsetZ: lineProxy(2),\n    thickness: lineProxy(3),\n    visible: lineProxy(4),\n    opacity: lineProxy(7),\n    color: colorProxy(),\n    colorR: colorChannelProxy(0),\n    colorG: colorChannelProxy(1),\n    colorB: colorChannelProxy(2),\n};\n\nsetTraits(Line, {\n    defaults: () => ({\n        offsetX: 1,\n        offsetY: 0,\n        offsetZ: 0,\n        thickness: 2,\n        visible: 1,\n        opacity: 1,\n        color: 0xffffff,\n    }),\n    accessors: {\n        offsetX: Line.offsetX,\n        offsetY: Line.offsetY,\n        offsetZ: Line.offsetZ,\n        thickness: Line.thickness,\n        visible: Line.visible,\n        opacity: Line.opacity,\n        color: Line.color,\n        colorR: Line.colorR,\n        colorG: Line.colorG,\n        colorB: Line.colorB,\n    },\n});\n\nexport interface LinesConfig {\n    scene: GPUBuffer;\n    lines: GPUBuffer;\n    entityIds: GPUBuffer;\n    matrices: GPUBuffer;\n    getCount: () => number;\n}\n\nexport const lineShader = /* wgsl */ `\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) color: vec4<f32>,\n    @location(1) dist: f32,\n    @location(2) halfWidth: f32,\n}\n\nstruct Scene {\n    viewProj: mat4x4<f32>,\n    cameraWorld: mat4x4<f32>,\n    ambientColor: vec4<f32>,\n    sunDirection: vec4<f32>,\n    sunColor: vec4<f32>,\n    cameraMode: f32,\n    cameraSize: f32,\n    viewport: vec2<f32>,\n}\n\nstruct LineData {\n    offset: vec3<f32>,\n    thickness: f32,\n    visible: f32,\n    _pad1: f32,\n    _pad2: f32,\n    opacity: f32,\n    color: vec4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> scene: Scene;\n@group(0) @binding(1) var<storage, read> entityIds: array<u32>;\n@group(0) @binding(2) var<storage, read> lines: array<LineData>;\n@group(0) @binding(3) var<storage, read> matrices: array<mat4x4<f32>>;\n\n@vertex\nfn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VertexOutput {\n    let eid = entityIds[iid];\n    let line = lines[eid];\n    let transform = matrices[eid];\n\n    let start = transform[3].xyz;\n    let rotation = mat3x3<f32>(transform[0].xyz, transform[1].xyz, transform[2].xyz);\n    let end = start + rotation * line.offset;\n\n    let startClip = scene.viewProj * vec4(start, 1.0);\n    let endClip = scene.viewProj * vec4(end, 1.0);\n\n    let startNDC = startClip.xy / startClip.w;\n    let endNDC = endClip.xy / endClip.w;\n\n    let dir = endNDC - startNDC;\n    let len = length(dir);\n    let normDir = select(vec2(1.0, 0.0), dir / len, len > 0.0001);\n\n    // Convert thickness from pixels to NDC (2 pixels / viewport = NDC units)\n    let halfWidth = line.thickness * 0.5;\n    let aaPadding = 1.0;\n    let totalHalf = halfWidth + aaPadding;\n    let perpNDC = vec2(-normDir.y, normDir.x) * totalHalf * 2.0 / scene.viewport;\n\n    var pos: vec2<f32>;\n    var t: f32;\n    var edge: f32;\n    switch vid {\n        case 0u: { pos = startNDC - perpNDC; t = 0.0; edge = -1.0; }\n        case 1u: { pos = startNDC + perpNDC; t = 0.0; edge = 1.0; }\n        case 2u: { pos = endNDC + perpNDC; t = 1.0; edge = 1.0; }\n        case 3u: { pos = startNDC - perpNDC; t = 0.0; edge = -1.0; }\n        case 4u: { pos = endNDC + perpNDC; t = 1.0; edge = 1.0; }\n        case 5u: { pos = endNDC - perpNDC; t = 1.0; edge = -1.0; }\n        default: { pos = startNDC; t = 0.0; edge = 0.0; }\n    }\n\n    let depth = mix(startClip.z / startClip.w, endClip.z / endClip.w, t);\n\n    // edge is -1 to +1 across quad, convert to pixel distance from line center\n    let pixelDist = edge * totalHalf;\n\n    var out: VertexOutput;\n    out.position = vec4(pos, depth, 1.0);\n    out.color = vec4(line.color.rgb, line.color.a * line.opacity);\n    out.dist = pixelDist;\n    out.halfWidth = halfWidth;\n    return out;\n}\n\nstruct FragmentOutput {\n    @location(0) color: vec4<f32>,\n    @location(1) mask: f32,\n}\n\n@fragment\nfn fs(input: VertexOutput) -> FragmentOutput {\n    let dist = abs(input.dist);\n    let aa = 1.0 - smoothstep(input.halfWidth - 0.5, input.halfWidth + 0.5, dist);\n    var out: FragmentOutput;\n    out.color = vec4(input.color.rgb, input.color.a * aa);\n    out.mask = select(0.0, 1.0, aa > 0.01);\n    return out;\n}\n`;\n\nexport function createLinesPipeline(\n    device: GPUDevice,\n    format: GPUTextureFormat,\n    maskFormat: GPUTextureFormat\n): GPURenderPipeline {\n    const module = device.createShaderModule({ code: lineShader });\n\n    return device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n            module,\n            entryPoint: \"vs\",\n        },\n        fragment: {\n            module,\n            entryPoint: \"fs\",\n            targets: [\n                {\n                    format,\n                    blend: {\n                        color: {\n                            srcFactor: \"src-alpha\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                        alpha: {\n                            srcFactor: \"one\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                    },\n                },\n                {\n                    format: maskFormat,\n                    writeMask: GPUColorWrite.RED,\n                },\n            ],\n        },\n        primitive: {\n            topology: \"triangle-list\",\n        },\n        depthStencil: {\n            format: DEPTH_FORMAT,\n            depthCompare: \"less\",\n            depthWriteEnabled: false,\n        },\n    });\n}\n\nfunction createLinesContributor(config: LinesConfig): DrawContributor {\n    let pipeline: GPURenderPipeline | null = null;\n    let bindGroup: GPUBindGroup | null = null;\n\n    return {\n        id: \"lines\",\n        order: 0,\n\n        draw(pass: GPURenderPassEncoder, ctx: DrawContext) {\n            const count = config.getCount();\n            if (count === 0) return;\n\n            if (!pipeline) {\n                pipeline = createLinesPipeline(ctx.device, ctx.format, ctx.maskFormat);\n            }\n\n            if (!bindGroup) {\n                bindGroup = ctx.device.createBindGroup({\n                    layout: pipeline.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: { buffer: config.scene } },\n                        { binding: 1, resource: { buffer: config.entityIds } },\n                        { binding: 2, resource: { buffer: config.lines } },\n                        { binding: 3, resource: { buffer: config.matrices } },\n                    ],\n                });\n            }\n\n            pass.setPipeline(pipeline);\n            pass.setBindGroup(0, bindGroup);\n            pass.draw(6, count);\n        },\n    };\n}\n\nexport interface LinesState {\n    buffer: GPUBuffer;\n    entityIds: GPUBuffer;\n    count: number;\n}\n\nexport const Lines = resource<LinesState>(\"lines\");\n\nconst entityIdArray = new Uint32Array(MAX_ENTITIES);\n\nconst LinesSystem: System = {\n    group: \"draw\",\n\n    update(state: State) {\n        const compute = Compute.from(state);\n        const lines = Lines.from(state);\n        if (!compute || !lines) return;\n\n        const { device } = compute;\n\n        let count = 0;\n        for (const eid of state.query([Line, Transform])) {\n            if (!Line.visible[eid]) continue;\n            entityIdArray[count++] = eid;\n        }\n\n        device.queue.writeBuffer(lines.buffer, 0, LineData.data);\n        device.queue.writeBuffer(lines.entityIds, 0, entityIdArray, 0, count);\n        lines.count = count;\n    },\n};\n\nexport const LinesPlugin: Plugin = {\n    systems: [LinesSystem],\n    components: { Line },\n    dependencies: [ComputePlugin, RenderPlugin],\n\n    initialize(state: State) {\n        const compute = Compute.from(state);\n        const render = Render.from(state);\n        if (!compute || !render) return;\n\n        const { device } = compute;\n\n        const linesState: LinesState = {\n            buffer: device.createBuffer({\n                label: \"lines\",\n                size: MAX_ENTITIES * 12 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            }),\n            entityIds: createEntityIdBuffer(device, MAX_ENTITIES),\n            count: 0,\n        };\n\n        state.setResource(Lines, linesState);\n\n        registerDrawContributor(\n            state,\n            createLinesContributor({\n                scene: render.scene,\n                lines: linesState.buffer,\n                entityIds: linesState.entityIds,\n                matrices: render.matrices,\n                getCount: () => linesState.count,\n            })\n        );\n    },\n};\n","import { MAX_ENTITIES, resource, type Plugin, type State, type System } from \"../../core\";\nimport { setTraits, type FieldAccessor } from \"../../core/component\";\nimport { Compute, ComputePlugin, createEntityIdBuffer } from \"../../standard/compute\";\nimport {\n    Render,\n    RenderPlugin,\n    DEPTH_FORMAT,\n    registerDrawContributor,\n    type DrawContributor,\n    type DrawContext,\n} from \"../../standard/render\";\nimport { Transform } from \"../../standard/transforms\";\nimport { Line, Lines, LinesPlugin } from \"../lines\";\n\nexport const ArrowData = {\n    data: new Float32Array(MAX_ENTITIES * 4),\n};\n\ninterface ArrowProxy extends Array<number>, FieldAccessor {}\n\nfunction arrowProxy(offset: number): ArrowProxy {\n    const data = ArrowData.data;\n\n    function getValue(eid: number): number {\n        return data[eid * 4 + offset];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * 4 + offset] = value;\n    }\n\n    return new Proxy([] as unknown as ArrowProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nexport const Arrow: {\n    start: ArrowProxy;\n    end: ArrowProxy;\n    size: ArrowProxy;\n} = {\n    start: arrowProxy(0),\n    end: arrowProxy(1),\n    size: arrowProxy(2),\n};\n\nsetTraits(Arrow, {\n    defaults: () => ({\n        start: 0,\n        end: 1,\n        size: 1,\n    }),\n    accessors: {\n        start: Arrow.start,\n        end: Arrow.end,\n        size: Arrow.size,\n    },\n});\n\nexport interface ArrowsConfig {\n    scene: GPUBuffer;\n    arrows: GPUBuffer;\n    lines: GPUBuffer;\n    matrices: GPUBuffer;\n    entityIds: GPUBuffer;\n    getCount: () => number;\n}\n\nconst END_FLAG = 0x80000000;\n\nexport const arrowShader = /* wgsl */ `\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) color: vec4<f32>,\n}\n\nstruct Scene {\n    viewProj: mat4x4<f32>,\n    cameraWorld: mat4x4<f32>,\n    ambientColor: vec4<f32>,\n    sunDirection: vec4<f32>,\n    sunColor: vec4<f32>,\n    cameraMode: f32,\n    cameraSize: f32,\n    viewport: vec2<f32>,\n}\n\nstruct ArrowData {\n    start: f32,\n    end: f32,\n    size: f32,\n    _pad: f32,\n}\n\nstruct LineData {\n    offset: vec3<f32>,\n    thickness: f32,\n    visible: f32,\n    _pad1: f32,\n    _pad2: f32,\n    opacity: f32,\n    color: vec4<f32>,\n}\n\nconst END_FLAG: u32 = 0x80000000u;\n\n@group(0) @binding(0) var<uniform> scene: Scene;\n@group(0) @binding(1) var<storage, read> entityIds: array<u32>;\n@group(0) @binding(2) var<storage, read> arrows: array<ArrowData>;\n@group(0) @binding(3) var<storage, read> lines: array<LineData>;\n@group(0) @binding(4) var<storage, read> matrices: array<mat4x4<f32>>;\n\n@vertex\nfn vs(@builtin(vertex_index) vid: u32, @builtin(instance_index) iid: u32) -> VertexOutput {\n    let packed = entityIds[iid];\n    let isEnd = (packed & END_FLAG) != 0u;\n    let eid = packed & ~END_FLAG;\n\n    let arrow = arrows[eid];\n    let line = lines[eid];\n    let transform = matrices[eid];\n\n    // Extract scale from transform matrix (use X axis scale)\n    let scale = length(transform[0].xyz);\n\n    let start = transform[3].xyz;\n    let rotation = mat3x3<f32>(transform[0].xyz, transform[1].xyz, transform[2].xyz);\n    let end = start + rotation * line.offset;\n\n    // Project start and end to clip space\n    let startClip = scene.viewProj * vec4(start, 1.0);\n    let endClip = scene.viewProj * vec4(end, 1.0);\n\n    // Convert to screen space (pixels from center)\n    let startScreen = (startClip.xy / startClip.w) * scene.viewport * 0.5;\n    let endScreen = (endClip.xy / endClip.w) * scene.viewport * 0.5;\n\n    // Anchor point in screen space\n    let anchorScreen = select(startScreen, endScreen, isEnd);\n    let anchorDepth = select(startClip.z / startClip.w, endClip.z / endClip.w, isEnd);\n\n    // Line direction in screen space (correct for aspect ratio)\n    let dir = endScreen - startScreen;\n    let len = length(dir);\n    let normDir = select(vec2(1.0, 0.0), dir / len, len > 0.0001);\n    let perp = vec2(-normDir.y, normDir.x);\n\n    // Arrow direction (pointing away from line)\n    let arrowDir = select(-normDir, normDir, isEnd);\n\n    // Arrow dimensions in pixels\n    let arrowLengthPx = arrow.size * line.thickness * 4.0 * scale;\n    let arrowWidthPx = arrow.size * line.thickness * 2.0 * scale;\n\n    // Build triangle in screen space\n    var posScreen: vec2<f32>;\n    switch vid {\n        case 0u: { posScreen = anchorScreen; }  // Tip\n        case 1u: { posScreen = anchorScreen - arrowDir * arrowLengthPx + perp * arrowWidthPx; }\n        case 2u: { posScreen = anchorScreen - arrowDir * arrowLengthPx - perp * arrowWidthPx; }\n        default: { posScreen = anchorScreen; }\n    }\n\n    // Convert back to NDC\n    let pos = posScreen / (scene.viewport * 0.5);\n\n    var out: VertexOutput;\n    out.position = vec4(pos, anchorDepth, 1.0);\n    out.color = vec4(line.color.rgb, line.color.a * line.opacity);\n    return out;\n}\n\nstruct FragmentOutput {\n    @location(0) color: vec4<f32>,\n    @location(1) mask: f32,\n}\n\n@fragment\nfn fs(input: VertexOutput) -> FragmentOutput {\n    var out: FragmentOutput;\n    out.color = input.color;\n    out.mask = 1.0;\n    return out;\n}\n`;\n\nexport function createArrowsPipeline(\n    device: GPUDevice,\n    format: GPUTextureFormat,\n    maskFormat: GPUTextureFormat\n): GPURenderPipeline {\n    const module = device.createShaderModule({ code: arrowShader });\n\n    return device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n            module,\n            entryPoint: \"vs\",\n        },\n        fragment: {\n            module,\n            entryPoint: \"fs\",\n            targets: [\n                {\n                    format,\n                    blend: {\n                        color: {\n                            srcFactor: \"src-alpha\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                        alpha: {\n                            srcFactor: \"one\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                    },\n                },\n                {\n                    format: maskFormat,\n                    writeMask: GPUColorWrite.RED,\n                },\n            ],\n        },\n        primitive: {\n            topology: \"triangle-list\",\n        },\n        depthStencil: {\n            format: DEPTH_FORMAT,\n            depthCompare: \"less\",\n            depthWriteEnabled: false,\n        },\n    });\n}\n\nfunction createArrowsContributor(config: ArrowsConfig): DrawContributor {\n    let pipeline: GPURenderPipeline | null = null;\n    let bindGroup: GPUBindGroup | null = null;\n\n    return {\n        id: \"arrows\",\n        order: 1,\n\n        draw(pass: GPURenderPassEncoder, ctx: DrawContext) {\n            const count = config.getCount();\n            if (count === 0) return;\n\n            if (!pipeline) {\n                pipeline = createArrowsPipeline(ctx.device, ctx.format, ctx.maskFormat);\n            }\n\n            if (!bindGroup) {\n                bindGroup = ctx.device.createBindGroup({\n                    layout: pipeline.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: { buffer: config.scene } },\n                        { binding: 1, resource: { buffer: config.entityIds } },\n                        { binding: 2, resource: { buffer: config.arrows } },\n                        { binding: 3, resource: { buffer: config.lines } },\n                        { binding: 4, resource: { buffer: config.matrices } },\n                    ],\n                });\n            }\n\n            pass.setPipeline(pipeline);\n            pass.setBindGroup(0, bindGroup);\n            pass.draw(3, count);\n        },\n    };\n}\n\nexport interface ArrowsState {\n    buffer: GPUBuffer;\n    entityIds: GPUBuffer;\n    count: number;\n}\n\nexport const Arrows = resource<ArrowsState>(\"arrows\");\n\nconst arrowEntityIdArray = new Uint32Array(MAX_ENTITIES * 2);\n\nconst ArrowsSystem: System = {\n    group: \"draw\",\n\n    update(state: State) {\n        const compute = Compute.from(state);\n        const arrows = Arrows.from(state);\n        const lines = Lines.from(state);\n        if (!compute || !arrows || !lines) return;\n\n        const { device } = compute;\n\n        let count = 0;\n        for (const eid of state.query([Arrow, Line, Transform])) {\n            if (!Line.visible[eid]) continue;\n\n            if (Arrow.start[eid]) {\n                arrowEntityIdArray[count++] = eid;\n            }\n            if (Arrow.end[eid]) {\n                arrowEntityIdArray[count++] = eid | END_FLAG;\n            }\n        }\n\n        device.queue.writeBuffer(arrows.buffer, 0, ArrowData.data);\n        device.queue.writeBuffer(arrows.entityIds, 0, arrowEntityIdArray, 0, count);\n        arrows.count = count;\n    },\n};\n\nexport const ArrowsPlugin: Plugin = {\n    systems: [ArrowsSystem],\n    components: { Arrow },\n    dependencies: [ComputePlugin, RenderPlugin, LinesPlugin],\n\n    initialize(state: State) {\n        const compute = Compute.from(state);\n        const render = Render.from(state);\n        const lines = Lines.from(state);\n        if (!compute || !render || !lines) return;\n\n        const { device } = compute;\n\n        const arrowsState: ArrowsState = {\n            buffer: device.createBuffer({\n                label: \"arrows\",\n                size: MAX_ENTITIES * 4 * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            }),\n            entityIds: createEntityIdBuffer(device, MAX_ENTITIES * 2),\n            count: 0,\n        };\n\n        state.setResource(Arrows, arrowsState);\n\n        registerDrawContributor(\n            state,\n            createArrowsContributor({\n                scene: render.scene,\n                arrows: arrowsState.buffer,\n                lines: lines.buffer,\n                matrices: render.matrices,\n                entityIds: arrowsState.entityIds,\n                getCount: () => arrowsState.count,\n            })\n        );\n    },\n};\n","import TinySDF from \"@mapbox/tiny-sdf\";\nimport { MAX_ENTITIES, resource, type Plugin, type State, type System } from \"../../core\";\nimport { setTraits, type FieldAccessor } from \"../../core/component\";\nimport { Compute, ComputePlugin } from \"../../standard/compute\";\nimport {\n    Render,\n    RenderPlugin,\n    DEPTH_FORMAT,\n    registerDrawContributor,\n    type DrawContributor,\n    type DrawContext,\n} from \"../../standard/render\";\nimport { Transform } from \"../../standard/transforms\";\n\nconst MAX_GLYPHS = 50000;\nconst GLYPH_FLOATS = 16;\nconst SDF_EXPONENT = 9;\nconst SDF_CUTOFF = 0.5;\n\nlet customFontFamily: string | null = null;\nlet customFontWeight: string = \"normal\";\n\nfunction encodeExponentialSdf(linearData: Uint8Array): Uint8Array {\n    const encoded = new Uint8Array(linearData.length);\n    for (let i = 0; i < linearData.length; i++) {\n        // TinySDF outputs: 0=outside, 255=inside, cutoff*255=edge\n        // Convert to signed distance: positive=outside, negative=inside\n        const raw = linearData[i] / 255;\n        const signedDist = (SDF_CUTOFF - raw) / SDF_CUTOFF;\n\n        // Apply exponential encoding (Troika formula)\n        const absDist = Math.min(1, Math.abs(signedDist));\n        let alpha = Math.pow(1 - absDist, SDF_EXPONENT) / 2;\n        if (signedDist < 0) {\n            alpha = 1 - alpha;\n        }\n        encoded[i] = Math.round(Math.max(0, Math.min(255, alpha * 255)));\n    }\n    return encoded;\n}\n\nexport async function setTextFont(fontFamily: string, weight: number = 400): Promise<void> {\n    const fontSpec = `${weight} 128px \"${fontFamily}\"`;\n    await document.fonts.load(fontSpec);\n    customFontFamily = fontFamily;\n    customFontWeight = weight >= 600 ? \"bold\" : \"normal\";\n}\n\nexport const TextData = {\n    data: new Float32Array(MAX_ENTITIES * 12),\n};\n\ninterface TextProxy extends Array<number>, FieldAccessor {}\n\nfunction textProxy(offset: number): TextProxy {\n    const data = TextData.data;\n\n    function getValue(eid: number): number {\n        return data[eid * 12 + offset];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * 12 + offset] = value;\n    }\n\n    return new Proxy([] as unknown as TextProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nfunction colorProxy(): TextProxy {\n    const data = TextData.data;\n\n    function getValue(eid: number): number {\n        const offset = eid * 12 + 8;\n        const r = Math.round(data[offset] * 255);\n        const g = Math.round(data[offset + 1] * 255);\n        const b = Math.round(data[offset + 2] * 255);\n        return (r << 16) | (g << 8) | b;\n    }\n\n    function setValue(eid: number, value: number): void {\n        const offset = eid * 12 + 8;\n        data[offset] = ((value >> 16) & 0xff) / 255;\n        data[offset + 1] = ((value >> 8) & 0xff) / 255;\n        data[offset + 2] = (value & 0xff) / 255;\n        data[offset + 3] = 1;\n    }\n\n    return new Proxy([] as unknown as TextProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nfunction colorChannelProxy(channelIndex: number): TextProxy {\n    const data = TextData.data;\n\n    function getValue(eid: number): number {\n        return data[eid * 12 + 8 + channelIndex];\n    }\n\n    function setValue(eid: number, value: number): void {\n        data[eid * 12 + 8 + channelIndex] = value;\n    }\n\n    return new Proxy([] as unknown as TextProxy, {\n        get(_, prop) {\n            if (prop === \"get\") return getValue;\n            if (prop === \"set\") return setValue;\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return undefined;\n            return getValue(eid);\n        },\n        set(_, prop, value) {\n            const eid = Number(prop);\n            if (Number.isNaN(eid)) return false;\n            setValue(eid, value);\n            return true;\n        },\n    });\n}\n\nexport const Text: {\n    fontSize: TextProxy;\n    opacity: TextProxy;\n    visible: TextProxy;\n    anchorX: TextProxy;\n    anchorY: TextProxy;\n    color: TextProxy;\n    colorR: TextProxy;\n    colorG: TextProxy;\n    colorB: TextProxy;\n} = {\n    fontSize: textProxy(0),\n    opacity: textProxy(1),\n    visible: textProxy(2),\n    anchorX: textProxy(3),\n    anchorY: textProxy(4),\n    color: colorProxy(),\n    colorR: colorChannelProxy(0),\n    colorG: colorChannelProxy(1),\n    colorB: colorChannelProxy(2),\n};\n\nsetTraits(Text, {\n    defaults: () => ({\n        fontSize: 1,\n        opacity: 1,\n        visible: 1,\n        anchorX: 0,\n        anchorY: 0,\n        color: 0xffffff,\n    }),\n    accessors: {\n        fontSize: Text.fontSize,\n        opacity: Text.opacity,\n        visible: Text.visible,\n        anchorX: Text.anchorX,\n        anchorY: Text.anchorY,\n        color: Text.color,\n        colorR: Text.colorR,\n        colorG: Text.colorG,\n        colorB: Text.colorB,\n    },\n});\n\ninterface GlyphMetrics {\n    width: number;\n    height: number;\n    glyphWidth: number;\n    glyphHeight: number;\n    glyphTop: number;\n    glyphLeft: number;\n    advance: number;\n    u0: number;\n    v0: number;\n    u1: number;\n    v1: number;\n}\n\ninterface GlyphAtlas {\n    texture: GPUTexture;\n    textureView: GPUTextureView;\n    width: number;\n    height: number;\n    glyphs: Map<string, GlyphMetrics>;\n    rowHeight: number;\n    cursorX: number;\n    cursorY: number;\n    sdf: TinySDF;\n    sdfFontSize: number;\n}\n\nfunction createGlyphAtlas(device: GPUDevice): GlyphAtlas {\n    const width = 2048;\n    const height = 2048;\n    const fontSize = 128;\n\n    const texture = device.createTexture({\n        size: { width, height },\n        format: \"r8unorm\",\n        usage: GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST,\n        label: \"glyphAtlas\",\n    });\n\n    const sdf = new TinySDF({\n        fontSize,\n        fontFamily: customFontFamily ?? \"system-ui, sans-serif\",\n        fontWeight: customFontWeight,\n        fontStyle: \"normal\",\n        buffer: 16,\n        radius: 48,\n        cutoff: 0.5,\n    });\n\n    return {\n        texture,\n        textureView: texture.createView(),\n        width,\n        height,\n        glyphs: new Map(),\n        rowHeight: 0,\n        cursorX: 0,\n        cursorY: 0,\n        sdf,\n        sdfFontSize: fontSize,\n    };\n}\n\nfunction ensureGlyph(device: GPUDevice, atlas: GlyphAtlas, char: string): GlyphMetrics {\n    const existing = atlas.glyphs.get(char);\n    if (existing) return existing;\n\n    const glyph = atlas.sdf.draw(char);\n\n    if (atlas.cursorX + glyph.width > atlas.width) {\n        atlas.cursorX = 0;\n        atlas.cursorY += atlas.rowHeight;\n        atlas.rowHeight = 0;\n    }\n\n    if (atlas.cursorY + glyph.height > atlas.height) {\n        throw new Error(\"Glyph atlas full\");\n    }\n\n    const glyphData = encodeExponentialSdf(new Uint8Array(glyph.data));\n\n    device.queue.writeTexture(\n        {\n            texture: atlas.texture,\n            origin: { x: atlas.cursorX, y: atlas.cursorY },\n        },\n        glyphData as Uint8Array<ArrayBuffer>,\n        { bytesPerRow: glyph.width },\n        { width: glyph.width, height: glyph.height }\n    );\n\n    const metrics: GlyphMetrics = {\n        width: glyph.width,\n        height: glyph.height,\n        glyphWidth: glyph.glyphWidth,\n        glyphHeight: glyph.glyphHeight,\n        glyphTop: glyph.glyphTop,\n        glyphLeft: glyph.glyphLeft,\n        advance: glyph.glyphAdvance,\n        u0: atlas.cursorX / atlas.width,\n        v0: atlas.cursorY / atlas.height,\n        u1: (atlas.cursorX + glyph.width) / atlas.width,\n        v1: (atlas.cursorY + glyph.height) / atlas.height,\n    };\n\n    atlas.glyphs.set(char, metrics);\n    atlas.cursorX += glyph.width;\n    atlas.rowHeight = Math.max(atlas.rowHeight, glyph.height);\n\n    return metrics;\n}\n\nfunction ensureString(device: GPUDevice, atlas: GlyphAtlas, text: string): void {\n    for (const char of text) {\n        ensureGlyph(device, atlas, char);\n    }\n}\n\ninterface LayoutGlyph {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    texelWidth: number;\n    texelHeight: number;\n    u0: number;\n    v0: number;\n    u1: number;\n    v1: number;\n}\n\ninterface LayoutResult {\n    glyphs: LayoutGlyph[];\n    width: number;\n    height: number;\n}\n\nfunction layoutText(text: string, atlas: GlyphAtlas, fontSize: number): LayoutResult {\n    const glyphs: LayoutGlyph[] = [];\n    const scale = fontSize / atlas.sdfFontSize;\n\n    let cursorX = 0;\n    let maxHeight = 0;\n\n    for (const char of text) {\n        const metrics = atlas.glyphs.get(char);\n        if (!metrics) continue;\n\n        const glyphW = metrics.glyphWidth * scale;\n        const glyphH = metrics.glyphHeight * scale;\n        const advance = metrics.advance * scale;\n\n        const x = cursorX + metrics.glyphLeft * scale;\n        const y = (metrics.glyphTop - metrics.glyphHeight) * scale;\n\n        glyphs.push({\n            x,\n            y,\n            width: glyphW,\n            height: glyphH,\n            texelWidth: metrics.width,\n            texelHeight: metrics.height,\n            u0: metrics.u0,\n            v0: metrics.v0,\n            u1: metrics.u1,\n            v1: metrics.v1,\n        });\n\n        cursorX += advance;\n        maxHeight = Math.max(maxHeight, glyphH);\n    }\n\n    return {\n        glyphs,\n        width: cursorX,\n        height: maxHeight,\n    };\n}\n\nconst textShader = /* wgsl */ `\nstruct Scene {\n    viewProj: mat4x4<f32>,\n    cameraWorld: mat4x4<f32>,\n    ambientColor: vec4<f32>,\n    sunDirection: vec4<f32>,\n    sunColor: vec4<f32>,\n    cameraMode: f32,\n    cameraSize: f32,\n    viewport: vec2<f32>,\n}\n\nstruct GlyphInstance {\n    posX: f32,\n    posY: f32,\n    posZ: f32,\n    entityId: u32,\n    width: f32,\n    height: f32,\n    texelWidth: f32,\n    texelHeight: f32,\n    u0: f32,\n    v0: f32,\n    u1: f32,\n    v1: f32,\n    color: vec4<f32>,\n}\n\n@group(0) @binding(0) var<uniform> scene: Scene;\n@group(0) @binding(1) var<storage, read> glyphs: array<GlyphInstance>;\n@group(0) @binding(2) var atlasTexture: texture_2d<f32>;\n@group(0) @binding(3) var atlasSampler: sampler;\n@group(0) @binding(4) var<storage, read> matrices: array<mat4x4<f32>>;\n\nstruct VertexOutput {\n    @builtin(position) position: vec4<f32>,\n    @location(0) uv: vec2<f32>,\n    @location(1) color: vec4<f32>,\n    @location(2) localUV: vec2<f32>,\n    @location(3) texelSize: vec2<f32>,\n}\n\n@vertex\nfn vs(@builtin(vertex_index) vid: u32) -> VertexOutput {\n    let glyphIdx = vid / 6u;\n    let cornerIdx = vid % 6u;\n\n    let glyph = glyphs[glyphIdx];\n\n    var localPos: vec2<f32>;\n    var uv: vec2<f32>;\n\n    switch cornerIdx {\n        case 0u: {\n            localPos = vec2(0.0, 0.0);\n            uv = vec2(glyph.u0, glyph.v1);\n        }\n        case 1u: {\n            localPos = vec2(1.0, 0.0);\n            uv = vec2(glyph.u1, glyph.v1);\n        }\n        case 2u: {\n            localPos = vec2(1.0, 1.0);\n            uv = vec2(glyph.u1, glyph.v0);\n        }\n        case 3u: {\n            localPos = vec2(0.0, 0.0);\n            uv = vec2(glyph.u0, glyph.v1);\n        }\n        case 4u: {\n            localPos = vec2(1.0, 1.0);\n            uv = vec2(glyph.u1, glyph.v0);\n        }\n        case 5u: {\n            localPos = vec2(0.0, 1.0);\n            uv = vec2(glyph.u0, glyph.v0);\n        }\n        default: {\n            localPos = vec2(0.0);\n            uv = vec2(0.0);\n        }\n    }\n\n    let localPos3 = vec3(\n        glyph.posX + localPos.x * glyph.width,\n        glyph.posY + localPos.y * glyph.height,\n        glyph.posZ\n    );\n\n    let transform = matrices[glyph.entityId];\n    let worldPos = transform * vec4(localPos3, 1.0);\n\n    var out: VertexOutput;\n    out.position = scene.viewProj * worldPos;\n    out.uv = uv;\n    out.color = glyph.color;\n    out.localUV = localPos;\n    out.texelSize = vec2(glyph.texelWidth, glyph.texelHeight);\n    return out;\n}\n\nstruct FragmentOutput {\n    @location(0) color: vec4<f32>,\n    @location(1) mask: f32,\n}\n\n@fragment\nfn fs(input: VertexOutput) -> FragmentOutput {\n    let sdfValue = textureSample(atlasTexture, atlasSampler, input.uv).r;\n\n    // Decode exponential SDF (inverse of Troika-style encoding)\n    let sdfExponent = 9.0;\n    let isOutside = sdfValue < 0.5;\n    let processedAlpha = select(1.0 - sdfValue, sdfValue, isOutside);\n    let normalizedDist = 1.0 - pow(2.0 * processedAlpha, 1.0 / sdfExponent);\n    let signedDist = select(-normalizedDist, normalizedDist, isOutside);\n\n    // Troika-style AA using screen-space derivatives\n    let texelFootprint = fwidth(input.localUV * input.texelSize);\n    let aaRadius = length(texelFootprint) * 0.5;\n    let smoothing = clamp(aaRadius * 0.5, 0.01, 0.25);\n\n    // Edge at signedDist = 0, positive offset = thicker text\n    let edgeOffset = 0.02;\n    let alpha = smoothstep(edgeOffset + smoothing, edgeOffset - smoothing, signedDist);\n\n    if alpha < 0.01 {\n        discard;\n    }\n\n    var out: FragmentOutput;\n    out.color = vec4(input.color.rgb, input.color.a * alpha);\n    out.mask = select(0.0, 1.0, alpha > 0.01);\n    return out;\n}\n`;\n\nfunction createTextPipeline(\n    device: GPUDevice,\n    format: GPUTextureFormat,\n    maskFormat: GPUTextureFormat\n): GPURenderPipeline {\n    const module = device.createShaderModule({ code: textShader });\n\n    return device.createRenderPipeline({\n        layout: \"auto\",\n        vertex: {\n            module,\n            entryPoint: \"vs\",\n        },\n        fragment: {\n            module,\n            entryPoint: \"fs\",\n            targets: [\n                {\n                    format,\n                    blend: {\n                        color: {\n                            srcFactor: \"src-alpha\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                        alpha: {\n                            srcFactor: \"one\",\n                            dstFactor: \"one-minus-src-alpha\",\n                            operation: \"add\",\n                        },\n                    },\n                },\n                {\n                    format: maskFormat,\n                    writeMask: GPUColorWrite.RED,\n                },\n            ],\n        },\n        primitive: {\n            topology: \"triangle-list\",\n            cullMode: \"none\",\n        },\n        depthStencil: {\n            format: DEPTH_FORMAT,\n            depthCompare: \"less\",\n            depthWriteEnabled: false,\n        },\n    });\n}\n\nexport interface TextConfig {\n    scene: GPUBuffer;\n    glyphs: GPUBuffer;\n    atlas: GPUTextureView;\n    sampler: GPUSampler;\n    matrices: GPUBuffer;\n    getCount: () => number;\n}\n\nfunction createTextContributor(config: TextConfig): DrawContributor {\n    let pipeline: GPURenderPipeline | null = null;\n    let bindGroup: GPUBindGroup | null = null;\n\n    return {\n        id: \"text\",\n        order: 2,\n\n        draw(pass: GPURenderPassEncoder, ctx: DrawContext) {\n            const count = config.getCount();\n            if (count === 0) return;\n\n            if (!pipeline) {\n                pipeline = createTextPipeline(ctx.device, ctx.format, ctx.maskFormat);\n            }\n\n            if (!bindGroup) {\n                bindGroup = ctx.device.createBindGroup({\n                    layout: pipeline.getBindGroupLayout(0),\n                    entries: [\n                        { binding: 0, resource: { buffer: config.scene } },\n                        { binding: 1, resource: { buffer: config.glyphs } },\n                        { binding: 2, resource: config.atlas },\n                        { binding: 3, resource: config.sampler },\n                        { binding: 4, resource: { buffer: config.matrices } },\n                    ],\n                });\n            }\n\n            pass.setPipeline(pipeline);\n            pass.setBindGroup(0, bindGroup);\n            pass.draw(count * 6);\n        },\n    };\n}\n\nexport interface TextState {\n    content: Map<number, string>;\n    atlas: GlyphAtlas;\n    sampler: GPUSampler;\n    buffer: GPUBuffer;\n    staging: Float32Array;\n    count: number;\n}\n\nexport const TextResource = resource<TextState>(\"text\");\n\nexport function setTextContent(state: State, eid: number, content: string): void {\n    const text = TextResource.from(state);\n    if (!text) return;\n    text.content.set(eid, content);\n}\n\nexport function getTextContent(state: State, eid: number): string | undefined {\n    const text = TextResource.from(state);\n    return text?.content.get(eid);\n}\n\nconst TextSystem: System = {\n    group: \"draw\",\n\n    update(state: State) {\n        const compute = Compute.from(state);\n        const text = TextResource.from(state);\n        if (!compute || !text) return;\n\n        const { device } = compute;\n        const { atlas, staging, content } = text;\n        const stagingU32 = new Uint32Array(staging.buffer);\n\n        let glyphCount = 0;\n\n        for (const eid of state.query([Text, Transform])) {\n            if (!Text.visible[eid]) continue;\n\n            const textContent = content.get(eid);\n            if (!textContent) continue;\n\n            ensureString(device, atlas, textContent);\n\n            const fontSize = Text.fontSize[eid];\n            const layout = layoutText(textContent, atlas, fontSize);\n\n            const anchorX = Text.anchorX[eid];\n            const anchorY = Text.anchorY[eid];\n            const offsetX = -layout.width * anchorX;\n            const offsetY = -layout.height * anchorY;\n\n            const color = Text.color[eid];\n            const r = ((color >> 16) & 0xff) / 255;\n            const g = ((color >> 8) & 0xff) / 255;\n            const b = (color & 0xff) / 255;\n            const a = Text.opacity[eid];\n\n            for (const glyph of layout.glyphs) {\n                if (glyphCount >= MAX_GLYPHS) break;\n\n                const offset = glyphCount * GLYPH_FLOATS;\n\n                staging[offset + 0] = offsetX + glyph.x;\n                staging[offset + 1] = offsetY + glyph.y;\n                staging[offset + 2] = 0;\n                stagingU32[offset + 3] = eid;\n\n                staging[offset + 4] = glyph.width;\n                staging[offset + 5] = glyph.height;\n                staging[offset + 6] = glyph.texelWidth;\n                staging[offset + 7] = glyph.texelHeight;\n\n                staging[offset + 8] = glyph.u0;\n                staging[offset + 9] = glyph.v0;\n                staging[offset + 10] = glyph.u1;\n                staging[offset + 11] = glyph.v1;\n\n                staging[offset + 12] = r;\n                staging[offset + 13] = g;\n                staging[offset + 14] = b;\n                staging[offset + 15] = a;\n\n                glyphCount++;\n            }\n        }\n\n        text.count = glyphCount;\n\n        if (glyphCount > 0) {\n            device.queue.writeBuffer(\n                text.buffer,\n                0,\n                staging.buffer,\n                0,\n                glyphCount * GLYPH_FLOATS * 4\n            );\n        }\n    },\n};\n\nexport const TextPlugin: Plugin = {\n    systems: [TextSystem],\n    components: { Text },\n    dependencies: [ComputePlugin, RenderPlugin],\n\n    initialize(state: State) {\n        const compute = Compute.from(state);\n        const render = Render.from(state);\n        if (!compute || !render) return;\n\n        const { device } = compute;\n\n        const atlas = createGlyphAtlas(device);\n        const sampler = device.createSampler({\n            magFilter: \"linear\",\n            minFilter: \"linear\",\n        });\n\n        const textState: TextState = {\n            content: new Map(),\n            atlas,\n            sampler,\n            buffer: device.createBuffer({\n                label: \"glyphs\",\n                size: MAX_GLYPHS * GLYPH_FLOATS * 4,\n                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n            }),\n            staging: new Float32Array(MAX_GLYPHS * GLYPH_FLOATS),\n            count: 0,\n        };\n\n        state.setResource(TextResource, textState);\n\n        registerDrawContributor(\n            state,\n            createTextContributor({\n                scene: render.scene,\n                glyphs: textState.buffer,\n                atlas: atlas.textureView,\n                sampler,\n                matrices: render.matrices,\n                getCount: () => textState.count,\n            })\n        );\n    },\n};\n","import { Pair } from 'bitecs';\r\nimport {\r\n  setTraits,\r\n  registerPostLoadHook,\r\n  Sequence,\r\n  SequenceState,\r\n  Tween,\r\n  TweenState,\r\n  ChildOf,\r\n  type State,\r\n  type System,\r\n  type Plugin,\r\n  type ParseContext,\r\n} from '@multiplekex/shallot';\r\n\r\nexport type SequenceMap = Record<string, string>;\r\n\r\nexport const StepController = {\r\n  step: [] as number[],\r\n  target: [] as number[],\r\n  max: [] as number[],\r\n};\r\n\r\nsetTraits(StepController, {\r\n  defaults: () => ({ step: 0, target: 0, max: 0 }),\r\n});\r\n\r\ntype EntityLookup = (name: string) => number | null;\r\nlet entityLookup: EntityLookup | null = null;\r\n\r\nfunction captureEntityLookup(_state: State, context: ParseContext): void {\r\n  entityLookup = (name: string) => context.getEntityByName(name);\r\n}\r\n\r\nregisterPostLoadHook(captureEntityLookup);\r\n\r\nexport function getEntityByName(name: string): number | null {\r\n  return entityLookup?.(name) ?? null;\r\n}\r\n\r\nfunction createStepControllerSystem(sequenceMap: SequenceMap): System {\r\n  let isTransitioning = false;\r\n\r\n  return {\r\n    group: 'simulation',\r\n    update(state: State) {\r\n      if (isTransitioning) return;\r\n\r\n      for (const eid of state.query([StepController])) {\r\n        const current = StepController.step[eid];\r\n        const target = StepController.target[eid];\r\n\r\n        if (current !== target) {\r\n          isTransitioning = true;\r\n\r\n          const seqName = sequenceMap[`${current}-${target}`];\r\n          const targetSeqEid = seqName ? getEntityByName(seqName) : null;\r\n\r\n          for (const name of Object.values(sequenceMap)) {\r\n            const seqEid = getEntityByName(name);\r\n            if (seqEid !== null && state.hasComponent(seqEid, Sequence)) {\r\n              if (Sequence.state[seqEid] === SequenceState.PLAYING) {\r\n                Sequence.state[seqEid] = SequenceState.COMPLETE;\r\n              }\r\n            }\r\n          }\r\n\r\n          state.step(0);\r\n\r\n          for (const name of Object.values(sequenceMap)) {\r\n            const seqEid = getEntityByName(name);\r\n            if (seqEid !== null && state.hasComponent(seqEid, Sequence)) {\r\n              Sequence.state[seqEid] = SequenceState.IDLE;\r\n              Sequence.elapsed[seqEid] = 0;\r\n              for (const childEid of state.query([Pair(ChildOf.relation, seqEid), Tween])) {\r\n                Tween.state[childEid] = TweenState.IDLE;\r\n                Tween.elapsed[childEid] = 0;\r\n              }\r\n            }\r\n          }\r\n\r\n          if (targetSeqEid !== null && state.hasComponent(targetSeqEid, Sequence)) {\r\n            Sequence.state[targetSeqEid] = SequenceState.PLAYING;\r\n          }\r\n\r\n          StepController.step[eid] = target;\r\n          isTransitioning = false;\r\n        }\r\n      }\r\n    },\r\n  };\r\n}\r\n\r\nexport function createStepPlugin(sequenceMap: SequenceMap): Plugin {\r\n  return {\r\n    components: { StepController },\r\n    systems: [createStepControllerSystem(sequenceMap)],\r\n  };\r\n}\r\n"],"file":"step-plugin-Cqgj3jUS.js"}